var Bb = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
};
var jm = (e, t, n) => (Bb(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Lb = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, $b = (e, t, n, i) => (Bb(e, t, "write to private field"), i ? i.call(e, n) : t.set(e, n), n);
import { shallowRef as pe, Fragment as De, reactive as ti, computed as b, watchEffect as Wt, toRefs as lh, capitalize as Rl, isVNode as LE, Comment as $E, readonly as Fl, unref as Ct, warn as Ec, ref as X, provide as Tt, inject as tt, defineComponent as Bl, camelize as J_, h as oa, getCurrentInstance as ep, TransitionGroup as tp, Transition as na, createVNode as v, mergeProps as ie, withDirectives as Rt, vShow as Tr, watch as fe, isRef as ia, toRef as G, Text as WE, onScopeDispose as jn, effectScope as np, toRaw as si, onBeforeUnmount as ai, markRaw as jE, onBeforeMount as ip, onMounted as En, nextTick as He, resolveDirective as Ei, cloneVNode as HE, onDeactivated as zE, onActivated as UE, resolveComponent as tn, openBlock as vl, createBlock as cf, toHandlers as qE, withCtx as dn, createTextVNode as _r, createCommentVNode as GE, toDisplayString as uh, getCurrentScope as YE, createSlots as ZE, renderList as KE, renderSlot as or, normalizeProps as os, guardReactiveProps as ls, createElementBlock as Q_, toValue as Nn, onUnmounted as eS, withModifiers as Av, createElementVNode as XE, Suspense as tS, onUpdated as JE, resolveDynamicComponent as QE, Teleport as eP, onBeforeUpdate as tP, vModelText as nP, render as nS } from "vue";
const ft = typeof window < "u", rp = ft && "IntersectionObserver" in window, iP = ft && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0), Wb = ft && "EyeDropper" in window;
function jb(e, t, n) {
  rP(e, t), t.set(e, n);
}
function rP(e, t) {
  if (t.has(e))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function sP(e, t, n) {
  return e.set(iS(e, t), n), n;
}
function pa(e, t) {
  return e.get(iS(e, t));
}
function iS(e, t, n) {
  if (typeof e == "function" ? e === t : e.has(t))
    return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
function rS(e, t, n) {
  const i = t.length - 1;
  if (i < 0)
    return e === void 0 ? n : e;
  for (let r = 0; r < i; r++) {
    if (e == null)
      return n;
    e = e[t[r]];
  }
  return e == null || e[t[i]] === void 0 ? n : e[t[i]];
}
function Yr(e, t) {
  if (e === t)
    return !0;
  if (e instanceof Date && t instanceof Date && e.getTime() !== t.getTime() || e !== Object(e) || t !== Object(t))
    return !1;
  const n = Object.keys(e);
  return n.length !== Object.keys(t).length ? !1 : n.every((i) => Yr(e[i], t[i]));
}
function Hu(e, t, n) {
  return e == null || !t || typeof t != "string" ? n : e[t] !== void 0 ? e[t] : (t = t.replace(/\[(\w+)\]/g, ".$1"), t = t.replace(/^\./, ""), rS(e, t.split("."), n));
}
function hn(e, t, n) {
  if (t === !0)
    return e === void 0 ? n : e;
  if (t == null || typeof t == "boolean")
    return n;
  if (e !== Object(e)) {
    if (typeof t != "function")
      return n;
    const r = t(e, n);
    return typeof r > "u" ? n : r;
  }
  if (typeof t == "string")
    return Hu(e, t, n);
  if (Array.isArray(t))
    return rS(e, t, n);
  if (typeof t != "function")
    return n;
  const i = t(e, n);
  return typeof i > "u" ? n : i;
}
function Hr(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return Array.from({
    length: e
  }, (n, i) => t + i);
}
function _e(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
  if (!(e == null || e === ""))
    return isNaN(+e) ? String(e) : isFinite(+e) ? `${Number(e)}${t}` : void 0;
}
function zu(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function sp(e) {
  if (e && "$el" in e) {
    const t = e.$el;
    return (t == null ? void 0 : t.nodeType) === Node.TEXT_NODE ? t.nextElementSibling : t;
  }
  return e;
}
const Hb = Object.freeze({
  enter: 13,
  tab: 9,
  delete: 46,
  esc: 27,
  space: 32,
  up: 38,
  down: 40,
  left: 37,
  right: 39,
  end: 35,
  home: 36,
  del: 46,
  backspace: 8,
  insert: 45,
  pageup: 33,
  pagedown: 34,
  shift: 16
}), Iv = Object.freeze({
  enter: "Enter",
  tab: "Tab",
  delete: "Delete",
  esc: "Escape",
  space: "Space",
  up: "ArrowUp",
  down: "ArrowDown",
  left: "ArrowLeft",
  right: "ArrowRight",
  end: "End",
  home: "Home",
  del: "Delete",
  backspace: "Backspace",
  insert: "Insert",
  pageup: "PageUp",
  pagedown: "PageDown",
  shift: "Shift"
});
function sS(e) {
  return Object.keys(e);
}
function Da(e, t) {
  return t.every((n) => e.hasOwnProperty(n));
}
function aS(e, t) {
  const n = {}, i = new Set(Object.keys(e));
  for (const r of t)
    i.has(r) && (n[r] = e[r]);
  return n;
}
function Ev(e, t, n) {
  const i = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  for (const s in e)
    t.some((a) => a instanceof RegExp ? a.test(s) : a === s) && !(n != null && n.some((a) => a === s)) ? i[s] = e[s] : r[s] = e[s];
  return [i, r];
}
function an(e, t) {
  const n = {
    ...e
  };
  return t.forEach((i) => delete n[i]), n;
}
function ch(e, t) {
  const n = {};
  return t.forEach((i) => n[i] = e[i]), n;
}
const oS = /^on[^a-z]/, dh = (e) => oS.test(e), aP = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"], oP = ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Escape", "Tab", " "];
function lP(e) {
  return e.isComposing && oP.includes(e.key);
}
function la(e) {
  const [t, n] = Ev(e, [oS]), i = an(t, aP), [r, s] = Ev(n, ["class", "style", "id", /^data-/]);
  return Object.assign(r, t), Object.assign(s, i), [r, s];
}
function Nt(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function uP(e, t) {
  let n = 0;
  const i = function() {
    for (var r = arguments.length, s = new Array(r), a = 0; a < r; a++)
      s[a] = arguments[a];
    clearTimeout(n), n = setTimeout(() => e(...s), Ct(t));
  };
  return i.clear = () => {
    clearTimeout(n);
  }, i.immediate = e, i;
}
function Xt(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.max(t, Math.min(n, e));
}
function zb(e) {
  const t = e.toString().trim();
  return t.includes(".") ? t.length - t.indexOf(".") - 1 : 0;
}
function Ub(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  return e + n.repeat(Math.max(0, t - e.length));
}
function qb(e, t) {
  return (arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0").repeat(Math.max(0, t - e.length)) + e;
}
function cP(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  const n = [];
  let i = 0;
  for (; i < e.length; )
    n.push(e.substr(i, t)), i += t;
  return n;
}
function Gb(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
  if (e < t)
    return `${e} B`;
  const n = t === 1024 ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"];
  let i = -1;
  for (; Math.abs(e) >= t && i < n.length - 1; )
    e /= t, ++i;
  return `${e.toFixed(1)} ${n[i]}B`;
}
function qn() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;
  const i = {};
  for (const r in e)
    i[r] = e[r];
  for (const r in t) {
    const s = e[r], a = t[r];
    if (zu(s) && zu(a)) {
      i[r] = qn(s, a, n);
      continue;
    }
    if (Array.isArray(s) && Array.isArray(a) && n) {
      i[r] = n(s, a);
      continue;
    }
    i[r] = a;
  }
  return i;
}
function lS(e) {
  return e.map((t) => t.type === De ? lS(t.children) : t).flat();
}
function $a() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  if ($a.cache.has(e))
    return $a.cache.get(e);
  const t = e.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
  return $a.cache.set(e, t), t;
}
$a.cache = /* @__PURE__ */ new Map();
function Ko(e, t) {
  if (!t || typeof t != "object")
    return [];
  if (Array.isArray(t))
    return t.map((n) => Ko(e, n)).flat(1);
  if (t.suspense)
    return Ko(e, t.ssContent);
  if (Array.isArray(t.children))
    return t.children.map((n) => Ko(e, n)).flat(1);
  if (t.component) {
    if (Object.getOwnPropertySymbols(t.component.provides).includes(e))
      return [t.component];
    if (t.component.subTree)
      return Ko(e, t.component.subTree).flat(1);
  }
  return [];
}
var gd = /* @__PURE__ */ new WeakMap(), Mo = /* @__PURE__ */ new WeakMap();
class dP {
  constructor(t) {
    jb(this, gd, []), jb(this, Mo, 0), this.size = t;
  }
  push(t) {
    pa(gd, this)[pa(Mo, this)] = t, sP(Mo, this, (pa(Mo, this) + 1) % this.size);
  }
  values() {
    return pa(gd, this).slice(pa(Mo, this)).concat(pa(gd, this).slice(0, pa(Mo, this)));
  }
}
function fP(e) {
  return "touches" in e ? {
    clientX: e.touches[0].clientX,
    clientY: e.touches[0].clientY
  } : {
    clientX: e.clientX,
    clientY: e.clientY
  };
}
function ap(e) {
  const t = ti({}), n = b(e);
  return Wt(() => {
    for (const i in n.value)
      t[i] = n.value[i];
  }, {
    flush: "sync"
  }), lh(t);
}
function df(e, t) {
  return e.includes(t);
}
function uS(e) {
  return e[2].toLowerCase() + e.slice(3);
}
const ri = () => [Function, Array];
function Yb(e, t) {
  return t = "on" + Rl(t), !!(e[t] || e[`${t}Once`] || e[`${t}Capture`] || e[`${t}OnceCapture`] || e[`${t}CaptureOnce`]);
}
function op(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  if (Array.isArray(e))
    for (const r of e)
      r(...n);
  else
    typeof e == "function" && e(...n);
}
function Uu(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  const n = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map((i) => `${i}${t ? ':not([tabindex="-1"])' : ""}:not([disabled])`).join(", ");
  return [...e.querySelectorAll(n)];
}
function cS(e, t, n) {
  let i, r = e.indexOf(document.activeElement);
  const s = t === "next" ? 1 : -1;
  do
    r += s, i = e[r];
  while ((!i || i.offsetParent == null || !((n == null ? void 0 : n(i)) ?? !0)) && r < e.length && r >= 0);
  return i;
}
function gl(e, t) {
  var i, r, s, a;
  const n = Uu(e);
  if (!t)
    (e === document.activeElement || !e.contains(document.activeElement)) && ((i = n[0]) == null || i.focus());
  else if (t === "first")
    (r = n[0]) == null || r.focus();
  else if (t === "last")
    (s = n.at(-1)) == null || s.focus();
  else if (typeof t == "number")
    (a = n[t]) == null || a.focus();
  else {
    const o = cS(n, t);
    o ? o.focus() : gl(e, t === "next" ? "first" : "last");
  }
}
function pd(e) {
  return e == null || typeof e == "string" && e.trim() === "";
}
function dS() {
}
function pl(e, t) {
  if (!(ft && typeof CSS < "u" && typeof CSS.supports < "u" && CSS.supports(`selector(${t})`)))
    return null;
  try {
    return !!e && e.matches(t);
  } catch {
    return null;
  }
}
function fh(e) {
  return e.some((t) => LE(t) ? t.type === $E ? !1 : t.type !== De || fh(t.children) : !0) ? e : null;
}
function hP(e, t) {
  if (!ft || e === 0)
    return t(), () => {
    };
  const n = window.setTimeout(t, e);
  return () => window.clearTimeout(n);
}
function Zb(e, t) {
  const n = pe();
  return Wt(() => {
    n.value = e();
  }, {
    flush: "sync",
    ...t
  }), Fl(n);
}
function mP(e, t) {
  const n = e.clientX, i = e.clientY, r = t.getBoundingClientRect(), s = r.left, a = r.top, o = r.right, l = r.bottom;
  return n >= s && n <= o && i >= a && i <= l;
}
function ff() {
  const e = pe(), t = (n) => {
    e.value = n;
  };
  return Object.defineProperty(t, "value", {
    enumerable: !0,
    get: () => e.value,
    set: (n) => e.value = n
  }), Object.defineProperty(t, "el", {
    enumerable: !0,
    get: () => sp(e.value)
  }), t;
}
const fS = ["top", "bottom"], vP = ["start", "end", "left", "right"];
function Pv(e, t) {
  let [n, i] = e.split(" ");
  return i || (i = df(fS, n) ? "start" : df(vP, n) ? "top" : "center"), {
    side: Ov(n, t),
    align: Ov(i, t)
  };
}
function Ov(e, t) {
  return e === "start" ? t ? "right" : "left" : e === "end" ? t ? "left" : "right" : e;
}
function Hm(e) {
  return {
    side: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[e.side],
    align: e.align
  };
}
function zm(e) {
  return {
    side: e.side,
    align: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[e.align]
  };
}
function Kb(e) {
  return {
    side: e.align,
    align: e.side
  };
}
function Xb(e) {
  return df(fS, e.side) ? "y" : "x";
}
class Wa {
  constructor(t) {
    let {
      x: n,
      y: i,
      width: r,
      height: s
    } = t;
    this.x = n, this.y = i, this.width = r, this.height = s;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
}
function Jb(e, t) {
  return {
    x: {
      before: Math.max(0, t.left - e.left),
      after: Math.max(0, e.right - t.right)
    },
    y: {
      before: Math.max(0, t.top - e.top),
      after: Math.max(0, e.bottom - t.bottom)
    }
  };
}
function hS(e) {
  return Array.isArray(e) ? new Wa({
    x: e[0],
    y: e[1],
    width: 0,
    height: 0
  }) : e.getBoundingClientRect();
}
function lp(e) {
  const t = e.getBoundingClientRect(), n = getComputedStyle(e), i = n.transform;
  if (i) {
    let r, s, a, o, l;
    if (i.startsWith("matrix3d("))
      r = i.slice(9, -1).split(/, /), s = +r[0], a = +r[5], o = +r[12], l = +r[13];
    else if (i.startsWith("matrix("))
      r = i.slice(7, -1).split(/, /), s = +r[0], a = +r[3], o = +r[4], l = +r[5];
    else
      return new Wa(t);
    const u = n.transformOrigin, c = t.x - o - (1 - s) * parseFloat(u), d = t.y - l - (1 - a) * parseFloat(u.slice(u.indexOf(" ") + 1)), f = s ? t.width / s : e.offsetWidth + 1, h = a ? t.height / a : e.offsetHeight + 1;
    return new Wa({
      x: c,
      y: d,
      width: f,
      height: h
    });
  } else
    return new Wa(t);
}
function Na(e, t, n) {
  if (typeof e.animate > "u")
    return {
      finished: Promise.resolve()
    };
  let i;
  try {
    i = e.animate(t, n);
  } catch {
    return {
      finished: Promise.resolve()
    };
  }
  return typeof i.finished > "u" && (i.finished = new Promise((r) => {
    i.onfinish = () => {
      r(i);
    };
  })), i;
}
const Fd = /* @__PURE__ */ new WeakMap();
function gP(e, t) {
  Object.keys(t).forEach((n) => {
    if (dh(n)) {
      const i = uS(n), r = Fd.get(e);
      if (t[n] == null)
        r == null || r.forEach((s) => {
          const [a, o] = s;
          a === i && (e.removeEventListener(i, o), r.delete(s));
        });
      else if (!r || ![...r].some((s) => s[0] === i && s[1] === t[n])) {
        e.addEventListener(i, t[n]);
        const s = r || /* @__PURE__ */ new Set();
        s.add([i, t[n]]), Fd.has(e) || Fd.set(e, s);
      }
    } else
      t[n] == null ? e.removeAttribute(n) : e.setAttribute(n, t[n]);
  });
}
function pP(e, t) {
  Object.keys(t).forEach((n) => {
    if (dh(n)) {
      const i = uS(n), r = Fd.get(e);
      r == null || r.forEach((s) => {
        const [a, o] = s;
        a === i && (e.removeEventListener(i, o), r.delete(s));
      });
    } else
      e.removeAttribute(n);
  });
}
const Ro = 2.4, Qb = 0.2126729, ew = 0.7151522, tw = 0.072175, yP = 0.55, bP = 0.58, wP = 0.57, _P = 0.62, yd = 0.03, nw = 1.45, SP = 5e-4, kP = 1.25, CP = 1.25, iw = 0.078, rw = 12.82051282051282, bd = 0.06, sw = 1e-3;
function aw(e, t) {
  const n = (e.r / 255) ** Ro, i = (e.g / 255) ** Ro, r = (e.b / 255) ** Ro, s = (t.r / 255) ** Ro, a = (t.g / 255) ** Ro, o = (t.b / 255) ** Ro;
  let l = n * Qb + i * ew + r * tw, u = s * Qb + a * ew + o * tw;
  if (l <= yd && (l += (yd - l) ** nw), u <= yd && (u += (yd - u) ** nw), Math.abs(u - l) < SP)
    return 0;
  let c;
  if (u > l) {
    const d = (u ** yP - l ** bP) * kP;
    c = d < sw ? 0 : d < iw ? d - d * rw * bd : d - bd;
  } else {
    const d = (u ** _P - l ** wP) * CP;
    c = d > -sw ? 0 : d > -iw ? d - d * rw * bd : d + bd;
  }
  return c * 100;
}
function pr(e) {
  Ec(`Vuetify: ${e}`);
}
function hf(e) {
  Ec(`Vuetify error: ${e}`);
}
function TP(e, t) {
  t = Array.isArray(t) ? t.slice(0, -1).map((n) => `'${n}'`).join(", ") + ` or '${t.at(-1)}'` : `'${t}'`, Ec(`[Vuetify UPGRADE] '${e}' is deprecated, use ${t} instead.`);
}
const mf = 0.20689655172413793, xP = (e) => e > mf ** 3 ? Math.cbrt(e) : e / (3 * mf ** 2) + 4 / 29, AP = (e) => e > mf ? e ** 3 : 3 * mf ** 2 * (e - 4 / 29);
function mS(e) {
  const t = xP, n = t(e[1]);
  return [116 * n - 16, 500 * (t(e[0] / 0.95047) - n), 200 * (n - t(e[2] / 1.08883))];
}
function vS(e) {
  const t = AP, n = (e[0] + 16) / 116;
  return [t(n + e[1] / 500) * 0.95047, t(n), t(n - e[2] / 200) * 1.08883];
}
const IP = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]], EP = (e) => e <= 31308e-7 ? e * 12.92 : 1.055 * e ** (1 / 2.4) - 0.055, PP = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]], OP = (e) => e <= 0.04045 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4;
function gS(e) {
  const t = Array(3), n = EP, i = IP;
  for (let r = 0; r < 3; ++r)
    t[r] = Math.round(Xt(n(i[r][0] * e[0] + i[r][1] * e[1] + i[r][2] * e[2])) * 255);
  return {
    r: t[0],
    g: t[1],
    b: t[2]
  };
}
function up(e) {
  let {
    r: t,
    g: n,
    b: i
  } = e;
  const r = [0, 0, 0], s = OP, a = PP;
  t = s(t / 255), n = s(n / 255), i = s(i / 255);
  for (let o = 0; o < 3; ++o)
    r[o] = a[o][0] * t + a[o][1] * n + a[o][2] * i;
  return r;
}
function Vv(e) {
  return !!e && /^(#|var\(--|(rgb|hsl)a?\()/.test(e);
}
function VP(e) {
  return Vv(e) && !/^((rgb|hsl)a?\()?var\(--/.test(e);
}
const ow = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/, DP = {
  rgb: (e, t, n, i) => ({
    r: e,
    g: t,
    b: n,
    a: i
  }),
  rgba: (e, t, n, i) => ({
    r: e,
    g: t,
    b: n,
    a: i
  }),
  hsl: (e, t, n, i) => lw({
    h: e,
    s: t,
    l: n,
    a: i
  }),
  hsla: (e, t, n, i) => lw({
    h: e,
    s: t,
    l: n,
    a: i
  }),
  hsv: (e, t, n, i) => bs({
    h: e,
    s: t,
    v: n,
    a: i
  }),
  hsva: (e, t, n, i) => bs({
    h: e,
    s: t,
    v: n,
    a: i
  })
};
function Hi(e) {
  if (typeof e == "number")
    return (isNaN(e) || e < 0 || e > 16777215) && pr(`'${e}' is not a valid hex color`), {
      r: (e & 16711680) >> 16,
      g: (e & 65280) >> 8,
      b: e & 255
    };
  if (typeof e == "string" && ow.test(e)) {
    const {
      groups: t
    } = e.match(ow), {
      fn: n,
      values: i
    } = t, r = i.split(/,\s*/).map((s) => s.endsWith("%") && ["hsl", "hsla", "hsv", "hsva"].includes(n) ? parseFloat(s) / 100 : parseFloat(s));
    return DP[n](...r);
  } else if (typeof e == "string") {
    let t = e.startsWith("#") ? e.slice(1) : e;
    [3, 4].includes(t.length) ? t = t.split("").map((i) => i + i).join("") : [6, 8].includes(t.length) || pr(`'${e}' is not a valid hex(a) color`);
    const n = parseInt(t, 16);
    return (isNaN(n) || n < 0 || n > 4294967295) && pr(`'${e}' is not a valid hex(a) color`), _S(t);
  } else if (typeof e == "object") {
    if (Da(e, ["r", "g", "b"]))
      return e;
    if (Da(e, ["h", "s", "l"]))
      return bs(cp(e));
    if (Da(e, ["h", "s", "v"]))
      return bs(e);
  }
  throw new TypeError(`Invalid color: ${e == null ? e : String(e) || e.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
}
function bs(e) {
  const {
    h: t,
    s: n,
    v: i,
    a: r
  } = e, s = (o) => {
    const l = (o + t / 60) % 6;
    return i - i * n * Math.max(Math.min(l, 4 - l, 1), 0);
  }, a = [s(5), s(3), s(1)].map((o) => Math.round(o * 255));
  return {
    r: a[0],
    g: a[1],
    b: a[2],
    a: r
  };
}
function lw(e) {
  return bs(cp(e));
}
function hh(e) {
  if (!e)
    return {
      h: 0,
      s: 1,
      v: 1,
      a: 1
    };
  const t = e.r / 255, n = e.g / 255, i = e.b / 255, r = Math.max(t, n, i), s = Math.min(t, n, i);
  let a = 0;
  r !== s && (r === t ? a = 60 * (0 + (n - i) / (r - s)) : r === n ? a = 60 * (2 + (i - t) / (r - s)) : r === i && (a = 60 * (4 + (t - n) / (r - s)))), a < 0 && (a = a + 360);
  const o = r === 0 ? 0 : (r - s) / r, l = [a, o, r];
  return {
    h: l[0],
    s: l[1],
    v: l[2],
    a: e.a
  };
}
function pS(e) {
  const {
    h: t,
    s: n,
    v: i,
    a: r
  } = e, s = i - i * n / 2, a = s === 1 || s === 0 ? 0 : (i - s) / Math.min(s, 1 - s);
  return {
    h: t,
    s: a,
    l: s,
    a: r
  };
}
function cp(e) {
  const {
    h: t,
    s: n,
    l: i,
    a: r
  } = e, s = i + n * Math.min(i, 1 - i), a = s === 0 ? 0 : 2 - 2 * i / s;
  return {
    h: t,
    s: a,
    v: s,
    a: r
  };
}
function yS(e) {
  let {
    r: t,
    g: n,
    b: i,
    a: r
  } = e;
  return r === void 0 ? `rgb(${t}, ${n}, ${i})` : `rgba(${t}, ${n}, ${i}, ${r})`;
}
function bS(e) {
  return yS(bs(e));
}
function wd(e) {
  const t = Math.round(e).toString(16);
  return ("00".substr(0, 2 - t.length) + t).toUpperCase();
}
function wS(e) {
  let {
    r: t,
    g: n,
    b: i,
    a: r
  } = e;
  return `#${[wd(t), wd(n), wd(i), r !== void 0 ? wd(Math.round(r * 255)) : ""].join("")}`;
}
function _S(e) {
  e = NP(e);
  let [t, n, i, r] = cP(e, 2).map((s) => parseInt(s, 16));
  return r = r === void 0 ? r : r / 255, {
    r: t,
    g: n,
    b: i,
    a: r
  };
}
function SS(e) {
  const t = _S(e);
  return hh(t);
}
function kS(e) {
  return wS(bs(e));
}
function NP(e) {
  return e.startsWith("#") && (e = e.slice(1)), e = e.replace(/([^0-9a-f])/gi, "F"), (e.length === 3 || e.length === 4) && (e = e.split("").map((t) => t + t).join("")), e.length !== 6 && (e = Ub(Ub(e, 6), 8, "F")), e;
}
function MP(e, t) {
  const n = mS(up(e));
  return n[0] = n[0] + t * 10, gS(vS(n));
}
function RP(e, t) {
  const n = mS(up(e));
  return n[0] = n[0] - t * 10, gS(vS(n));
}
function Dv(e) {
  const t = Hi(e);
  return up(t)[1];
}
function FP(e, t) {
  const n = Dv(e), i = Dv(t), r = Math.max(n, i), s = Math.min(n, i);
  return (r + 0.05) / (s + 0.05);
}
function CS(e) {
  const t = Math.abs(aw(Hi(0), Hi(e)));
  return Math.abs(aw(Hi(16777215), Hi(e))) > Math.min(t, 50) ? "#fff" : "#000";
}
function B(e, t) {
  return (n) => Object.keys(e).reduce((i, r) => {
    const a = typeof e[r] == "object" && e[r] != null && !Array.isArray(e[r]) ? e[r] : {
      type: e[r]
    };
    return n && r in n ? i[r] = {
      ...a,
      default: n[r]
    } : i[r] = a, t && !i[r].source && (i[r].source = t), i;
  }, {});
}
const ke = B({
  class: [String, Array, Object],
  style: {
    type: [String, Array, Object],
    default: null
  }
}, "component"), yl = Symbol.for("vuetify:defaults");
function BP(e) {
  return X(e);
}
function dp() {
  const e = tt(yl);
  if (!e)
    throw new Error("[Vuetify] Could not find defaults instance");
  return e;
}
function jt(e, t) {
  const n = dp(), i = X(e), r = b(() => {
    if (Ct(t == null ? void 0 : t.disabled))
      return n.value;
    const a = Ct(t == null ? void 0 : t.scoped), o = Ct(t == null ? void 0 : t.reset), l = Ct(t == null ? void 0 : t.root);
    if (i.value == null && !(a || o || l))
      return n.value;
    let u = qn(i.value, {
      prev: n.value
    });
    if (a)
      return u;
    if (o || l) {
      const c = Number(o || 1 / 0);
      for (let d = 0; d <= c && !(!u || !("prev" in u)); d++)
        u = u.prev;
      return u && typeof l == "string" && l in u && (u = qn(qn(u, {
        prev: u
      }), u[l])), u;
    }
    return u.prev ? qn(u.prev, u) : u;
  });
  return Tt(yl, r), r;
}
function LP(e, t) {
  var n, i;
  return typeof ((n = e.props) == null ? void 0 : n[t]) < "u" || typeof ((i = e.props) == null ? void 0 : i[$a(t)]) < "u";
}
function TS() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : dp();
  const i = Ut("useDefaults");
  if (t = t ?? i.type.name ?? i.type.__name, !t)
    throw new Error("[Vuetify] Could not determine component name");
  const r = b(() => {
    var l;
    return (l = n.value) == null ? void 0 : l[e._as ?? t];
  }), s = new Proxy(e, {
    get(l, u) {
      var d, f, h, m, g, p, y;
      const c = Reflect.get(l, u);
      return u === "class" || u === "style" ? [(d = r.value) == null ? void 0 : d[u], c].filter((k) => k != null) : typeof u == "string" && !LP(i.vnode, u) ? ((f = r.value) == null ? void 0 : f[u]) !== void 0 ? (h = r.value) == null ? void 0 : h[u] : ((g = (m = n.value) == null ? void 0 : m.global) == null ? void 0 : g[u]) !== void 0 ? (y = (p = n.value) == null ? void 0 : p.global) == null ? void 0 : y[u] : c : c;
    }
  }), a = pe();
  Wt(() => {
    if (r.value) {
      const l = Object.entries(r.value).filter((u) => {
        let [c] = u;
        return c.startsWith(c[0].toUpperCase());
      });
      a.value = l.length ? Object.fromEntries(l) : void 0;
    } else
      a.value = void 0;
  });
  function o() {
    const l = zP(yl, i);
    Tt(yl, b(() => a.value ? qn((l == null ? void 0 : l.value) ?? {}, a.value) : l == null ? void 0 : l.value));
  }
  return {
    props: s,
    provideSubDefaults: o
  };
}
function ja() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
  const {
    props: n,
    provideSubDefaults: i
  } = TS(e, t);
  return i(), n;
}
function Pi(e) {
  if (e._setup = e._setup ?? e.setup, !e.name)
    return pr("The component is missing an explicit name, unable to generate default prop value"), e;
  if (e._setup) {
    e.props = B(e.props ?? {}, e.name)();
    const t = Object.keys(e.props).filter((n) => n !== "class" && n !== "style");
    e.filterProps = function(i) {
      return aS(i, t);
    }, e.props._as = String, e.setup = function(i, r) {
      const s = dp();
      if (!s.value)
        return e._setup(i, r);
      const {
        props: a,
        provideSubDefaults: o
      } = TS(i, i._as ?? e.name, s), l = e._setup(a, r);
      return o(), l;
    };
  }
  return e;
}
function J() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
  return (t) => (e ? Pi : Bl)(t);
}
function $P(e, t) {
  return t.props = e, t;
}
function Zr(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div", n = arguments.length > 2 ? arguments[2] : void 0;
  return J()({
    name: n ?? Rl(J_(e.replace(/__/g, "-"))),
    props: {
      tag: {
        type: String,
        default: t
      },
      ...ke()
    },
    setup(i, r) {
      let {
        slots: s
      } = r;
      return () => {
        var a;
        return oa(i.tag, {
          class: [e, i.class],
          style: i.style
        }, (a = s.default) == null ? void 0 : a.call(s));
      };
    }
  });
}
function xS(e) {
  if (typeof e.getRootNode != "function") {
    for (; e.parentNode; )
      e = e.parentNode;
    return e !== document ? null : document;
  }
  const t = e.getRootNode();
  return t !== document && t.getRootNode({
    composed: !0
  }) !== document ? null : t;
}
const qu = "cubic-bezier(0.4, 0, 0.2, 1)", WP = "cubic-bezier(0.0, 0, 0.2, 1)", jP = "cubic-bezier(0.4, 0, 1, 1)";
function uw(e, t, n) {
  return Object.keys(e).filter((i) => dh(i) && i.endsWith(t)).reduce((i, r) => (i[r.slice(0, -t.length)] = (s) => e[r](s, n(s)), i), {});
}
function Ut(e, t) {
  const n = ep();
  if (!n)
    throw new Error(`[Vuetify] ${e} ${t || "must be called from inside a setup function"}`);
  return n;
}
function Kr() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
  const t = Ut(e).type;
  return $a((t == null ? void 0 : t.aliasName) || (t == null ? void 0 : t.name));
}
let AS = 0, Bd = /* @__PURE__ */ new WeakMap();
function Pn() {
  const e = Ut("getUid");
  if (Bd.has(e))
    return Bd.get(e);
  {
    const t = AS++;
    return Bd.set(e, t), t;
  }
}
Pn.reset = () => {
  AS = 0, Bd = /* @__PURE__ */ new WeakMap();
};
function fp(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  for (; e; ) {
    if (t ? HP(e) : hp(e))
      return e;
    e = e.parentElement;
  }
  return document.scrollingElement;
}
function vf(e, t) {
  const n = [];
  if (t && e && !t.contains(e))
    return n;
  for (; e && (hp(e) && n.push(e), e !== t); )
    e = e.parentElement;
  return n;
}
function hp(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE)
    return !1;
  const t = window.getComputedStyle(e);
  return t.overflowY === "scroll" || t.overflowY === "auto" && e.scrollHeight > e.clientHeight;
}
function HP(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE)
    return !1;
  const t = window.getComputedStyle(e);
  return ["scroll", "auto"].includes(t.overflowY);
}
function zP(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ut("injectSelf");
  const {
    provides: n
  } = t;
  if (n && e in n)
    return n[e];
}
function UP(e) {
  for (; e; ) {
    if (window.getComputedStyle(e).position === "fixed")
      return !0;
    e = e.offsetParent;
  }
  return !1;
}
function re(e) {
  const t = Ut("useRender");
  t.render = e;
}
const qP = B({
  disabled: Boolean,
  group: Boolean,
  hideOnLeave: Boolean,
  leaveAbsolute: Boolean,
  mode: String,
  origin: String
}, "transition");
function Oi(e, t, n) {
  return J()({
    name: e,
    props: qP({
      mode: n,
      origin: t
    }),
    setup(i, r) {
      let {
        slots: s
      } = r;
      const a = {
        onBeforeEnter(o) {
          i.origin && (o.style.transformOrigin = i.origin);
        },
        onLeave(o) {
          if (i.leaveAbsolute) {
            const {
              offsetTop: l,
              offsetLeft: u,
              offsetWidth: c,
              offsetHeight: d
            } = o;
            o._transitionInitialStyles = {
              position: o.style.position,
              top: o.style.top,
              left: o.style.left,
              width: o.style.width,
              height: o.style.height
            }, o.style.position = "absolute", o.style.top = `${l}px`, o.style.left = `${u}px`, o.style.width = `${c}px`, o.style.height = `${d}px`;
          }
          i.hideOnLeave && o.style.setProperty("display", "none", "important");
        },
        onAfterLeave(o) {
          if (i.leaveAbsolute && (o != null && o._transitionInitialStyles)) {
            const {
              position: l,
              top: u,
              left: c,
              width: d,
              height: f
            } = o._transitionInitialStyles;
            delete o._transitionInitialStyles, o.style.position = l || "", o.style.top = u || "", o.style.left = c || "", o.style.width = d || "", o.style.height = f || "";
          }
        }
      };
      return () => {
        const o = i.group ? tp : na;
        return oa(o, {
          name: i.disabled ? "" : e,
          css: !i.disabled,
          ...i.group ? void 0 : {
            mode: i.mode
          },
          ...i.disabled ? {} : a
        }, s.default);
      };
    }
  });
}
function IS(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
  return J()({
    name: e,
    props: {
      mode: {
        type: String,
        default: n
      },
      disabled: Boolean,
      group: Boolean
    },
    setup(i, r) {
      let {
        slots: s
      } = r;
      const a = i.group ? tp : na;
      return () => oa(a, {
        name: i.disabled ? "" : e,
        css: !i.disabled,
        // mode: props.mode, // TODO: vuejs/vue-next#3104
        ...i.disabled ? {} : t
      }, s.default);
    }
  });
}
function ES() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) ? "width" : "height", i = J_(`offset-${n}`);
  return {
    onBeforeEnter(a) {
      a._parent = a.parentNode, a._initialStyle = {
        transition: a.style.transition,
        overflow: a.style.overflow,
        [n]: a.style[n]
      };
    },
    onEnter(a) {
      const o = a._initialStyle;
      a.style.setProperty("transition", "none", "important"), a.style.overflow = "hidden";
      const l = `${a[i]}px`;
      a.style[n] = "0", a.offsetHeight, a.style.transition = o.transition, e && a._parent && a._parent.classList.add(e), requestAnimationFrame(() => {
        a.style[n] = l;
      });
    },
    onAfterEnter: s,
    onEnterCancelled: s,
    onLeave(a) {
      a._initialStyle = {
        transition: "",
        overflow: a.style.overflow,
        [n]: a.style[n]
      }, a.style.overflow = "hidden", a.style[n] = `${a[i]}px`, a.offsetHeight, requestAnimationFrame(() => a.style[n] = "0");
    },
    onAfterLeave: r,
    onLeaveCancelled: r
  };
  function r(a) {
    e && a._parent && a._parent.classList.remove(e), s(a);
  }
  function s(a) {
    const o = a._initialStyle[n];
    a.style.overflow = a._initialStyle.overflow, o != null && (a.style[n] = o), delete a._initialStyle;
  }
}
const GP = B({
  target: [Object, Array]
}, "v-dialog-transition"), mh = J()({
  name: "VDialogTransition",
  props: GP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = {
      onBeforeEnter(r) {
        r.style.pointerEvents = "none", r.style.visibility = "hidden";
      },
      async onEnter(r, s) {
        var f;
        await new Promise((h) => requestAnimationFrame(h)), await new Promise((h) => requestAnimationFrame(h)), r.style.visibility = "";
        const {
          x: a,
          y: o,
          sx: l,
          sy: u,
          speed: c
        } = dw(e.target, r), d = Na(r, [{
          transform: `translate(${a}px, ${o}px) scale(${l}, ${u})`,
          opacity: 0
        }, {}], {
          duration: 225 * c,
          easing: WP
        });
        (f = cw(r)) == null || f.forEach((h) => {
          Na(h, [{
            opacity: 0
          }, {
            opacity: 0,
            offset: 0.33
          }, {}], {
            duration: 225 * 2 * c,
            easing: qu
          });
        }), d.finished.then(() => s());
      },
      onAfterEnter(r) {
        r.style.removeProperty("pointer-events");
      },
      onBeforeLeave(r) {
        r.style.pointerEvents = "none";
      },
      async onLeave(r, s) {
        var f;
        await new Promise((h) => requestAnimationFrame(h));
        const {
          x: a,
          y: o,
          sx: l,
          sy: u,
          speed: c
        } = dw(e.target, r);
        Na(r, [{}, {
          transform: `translate(${a}px, ${o}px) scale(${l}, ${u})`,
          opacity: 0
        }], {
          duration: 125 * c,
          easing: jP
        }).finished.then(() => s()), (f = cw(r)) == null || f.forEach((h) => {
          Na(h, [{}, {
            opacity: 0,
            offset: 0.2
          }, {
            opacity: 0
          }], {
            duration: 125 * 2 * c,
            easing: qu
          });
        });
      },
      onAfterLeave(r) {
        r.style.removeProperty("pointer-events");
      }
    };
    return () => e.target ? v(na, ie({
      name: "dialog-transition"
    }, i, {
      css: !1
    }), n) : v(na, {
      name: "dialog-transition"
    }, n);
  }
});
function cw(e) {
  var n;
  const t = (n = e.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) == null ? void 0 : n.children;
  return t && [...t];
}
function dw(e, t) {
  const n = hS(e), i = lp(t), [r, s] = getComputedStyle(t).transformOrigin.split(" ").map((y) => parseFloat(y)), [a, o] = getComputedStyle(t).getPropertyValue("--v-overlay-anchor-origin").split(" ");
  let l = n.left + n.width / 2;
  a === "left" || o === "left" ? l -= n.width / 2 : (a === "right" || o === "right") && (l += n.width / 2);
  let u = n.top + n.height / 2;
  a === "top" || o === "top" ? u -= n.height / 2 : (a === "bottom" || o === "bottom") && (u += n.height / 2);
  const c = n.width / i.width, d = n.height / i.height, f = Math.max(1, c, d), h = c / f || 0, m = d / f || 0, g = i.width * i.height / (window.innerWidth * window.innerHeight), p = g > 0.12 ? Math.min(1.5, (g - 0.12) * 10 + 1) : 1;
  return {
    x: l - (r + i.left),
    y: u - (s + i.top),
    sx: h,
    sy: m,
    speed: p
  };
}
const YP = Oi("fab-transition", "center center", "out-in"), ZP = Oi("dialog-bottom-transition"), KP = Oi("dialog-top-transition"), Gu = Oi("fade-transition"), mp = Oi("scale-transition"), XP = Oi("scroll-x-transition"), JP = Oi("scroll-x-reverse-transition"), QP = Oi("scroll-y-transition"), eO = Oi("scroll-y-reverse-transition"), tO = Oi("slide-x-transition"), nO = Oi("slide-x-reverse-transition"), vp = Oi("slide-y-transition"), iO = Oi("slide-y-reverse-transition"), vh = IS("expand-transition", ES()), gp = IS("expand-x-transition", ES("", !0)), xr = B({
  transition: {
    type: [Boolean, String, Object],
    default: "fade-transition",
    validator: (e) => e !== !0
  }
}, "transition"), Gn = (e, t) => {
  let {
    slots: n
  } = t;
  const {
    transition: i,
    disabled: r,
    group: s,
    ...a
  } = e, {
    component: o = s ? tp : na,
    ...l
  } = typeof i == "object" ? i : {};
  return oa(o, ie(typeof i == "string" ? {
    name: r ? "" : i
  } : l, typeof i == "string" ? {} : Object.fromEntries(Object.entries({
    disabled: r,
    group: s
  }).filter((u) => {
    let [c, d] = u;
    return d !== void 0;
  })), a), n);
}, rO = B({
  active: Boolean,
  disabled: Boolean,
  max: [Number, String],
  value: {
    type: [Number, String],
    default: 0
  },
  ...ke(),
  ...xr({
    transition: {
      component: vp
    }
  })
}, "VCounter"), gh = J()({
  name: "VCounter",
  functional: !0,
  props: rO(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = b(() => e.max ? `${e.value} / ${e.max}` : String(e.value));
    return re(() => v(Gn, {
      transition: e.transition
    }, {
      default: () => [Rt(v("div", {
        class: ["v-counter", {
          "text-error": e.max && !e.disabled && parseFloat(e.value) > parseFloat(e.max)
        }, e.class],
        style: e.style
      }, [n.default ? n.default({
        counter: i.value,
        max: e.max,
        value: e.value
      }) : i.value]), [[Tr, e.active]])]
    })), {};
  }
});
const Yu = Symbol.for("vuetify:theme"), Qe = B({
  theme: String
}, "theme");
function fw() {
  return {
    defaultTheme: "light",
    variations: {
      colors: [],
      lighten: 0,
      darken: 0
    },
    themes: {
      light: {
        dark: !1,
        colors: {
          background: "#FFFFFF",
          surface: "#FFFFFF",
          "surface-bright": "#FFFFFF",
          "surface-light": "#EEEEEE",
          "surface-variant": "#424242",
          "on-surface-variant": "#EEEEEE",
          primary: "#1867C0",
          "primary-darken-1": "#1F5592",
          secondary: "#48A9A6",
          "secondary-darken-1": "#018786",
          error: "#B00020",
          info: "#2196F3",
          success: "#4CAF50",
          warning: "#FB8C00"
        },
        variables: {
          "border-color": "#000000",
          "border-opacity": 0.12,
          "high-emphasis-opacity": 0.87,
          "medium-emphasis-opacity": 0.6,
          "disabled-opacity": 0.38,
          "idle-opacity": 0.04,
          "hover-opacity": 0.04,
          "focus-opacity": 0.12,
          "selected-opacity": 0.08,
          "activated-opacity": 0.12,
          "pressed-opacity": 0.12,
          "dragged-opacity": 0.08,
          "theme-kbd": "#212529",
          "theme-on-kbd": "#FFFFFF",
          "theme-code": "#F5F5F5",
          "theme-on-code": "#000000"
        }
      },
      dark: {
        dark: !0,
        colors: {
          background: "#121212",
          surface: "#212121",
          "surface-bright": "#ccbfd6",
          "surface-light": "#424242",
          "surface-variant": "#a3a3a3",
          "on-surface-variant": "#424242",
          primary: "#2196F3",
          "primary-darken-1": "#277CC1",
          secondary: "#54B6B2",
          "secondary-darken-1": "#48A9A6",
          error: "#CF6679",
          info: "#2196F3",
          success: "#4CAF50",
          warning: "#FB8C00"
        },
        variables: {
          "border-color": "#FFFFFF",
          "border-opacity": 0.12,
          "high-emphasis-opacity": 1,
          "medium-emphasis-opacity": 0.7,
          "disabled-opacity": 0.5,
          "idle-opacity": 0.1,
          "hover-opacity": 0.04,
          "focus-opacity": 0.12,
          "selected-opacity": 0.08,
          "activated-opacity": 0.12,
          "pressed-opacity": 0.16,
          "dragged-opacity": 0.08,
          "theme-kbd": "#212529",
          "theme-on-kbd": "#FFFFFF",
          "theme-code": "#343434",
          "theme-on-code": "#CCCCCC"
        }
      }
    }
  };
}
function sO() {
  var i, r;
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : fw();
  const t = fw();
  if (!e)
    return {
      ...t,
      isDisabled: !0
    };
  const n = {};
  for (const [s, a] of Object.entries(e.themes ?? {})) {
    const o = a.dark || s === "dark" ? (i = t.themes) == null ? void 0 : i.dark : (r = t.themes) == null ? void 0 : r.light;
    n[s] = qn(o, a);
  }
  return qn(t, {
    ...e,
    themes: n
  });
}
function aO(e) {
  const t = sO(e), n = X(t.defaultTheme), i = X(t.themes), r = b(() => {
    const c = {};
    for (const [d, f] of Object.entries(i.value)) {
      const h = c[d] = {
        ...f,
        colors: {
          ...f.colors
        }
      };
      if (t.variations)
        for (const m of t.variations.colors) {
          const g = h.colors[m];
          if (g)
            for (const p of ["lighten", "darken"]) {
              const y = p === "lighten" ? MP : RP;
              for (const k of Hr(t.variations[p], 1))
                h.colors[`${m}-${p}-${k}`] = wS(y(Hi(g), k));
            }
        }
      for (const m of Object.keys(h.colors)) {
        if (/^on-[a-z]/.test(m) || h.colors[`on-${m}`])
          continue;
        const g = `on-${m}`, p = Hi(h.colors[m]);
        h.colors[g] = CS(p);
      }
    }
    return c;
  }), s = b(() => r.value[n.value]), a = b(() => {
    var m;
    const c = [];
    (m = s.value) != null && m.dark && ya(c, ":root", ["color-scheme: dark"]), ya(c, ":root", hw(s.value));
    for (const [g, p] of Object.entries(r.value))
      ya(c, `.v-theme--${g}`, [`color-scheme: ${p.dark ? "dark" : "normal"}`, ...hw(p)]);
    const d = [], f = [], h = new Set(Object.values(r.value).flatMap((g) => Object.keys(g.colors)));
    for (const g of h)
      /^on-[a-z]/.test(g) ? ya(f, `.${g}`, [`color: rgb(var(--v-theme-${g})) !important`]) : (ya(d, `.bg-${g}`, [`--v-theme-overlay-multiplier: var(--v-theme-${g}-overlay-multiplier)`, `background-color: rgb(var(--v-theme-${g})) !important`, `color: rgb(var(--v-theme-on-${g})) !important`]), ya(f, `.text-${g}`, [`color: rgb(var(--v-theme-${g})) !important`]), ya(f, `.border-${g}`, [`--v-border-color: var(--v-theme-${g})`]));
    return c.push(...d, ...f), c.map((g, p) => p === 0 ? g : `    ${g}`).join("");
  });
  function o() {
    return {
      style: [{
        children: a.value,
        id: "vuetify-theme-stylesheet",
        nonce: t.cspNonce || !1
      }]
    };
  }
  function l(c) {
    if (t.isDisabled)
      return;
    const d = c._context.provides.usehead;
    if (d)
      if (d.push) {
        const f = d.push(o);
        ft && fe(a, () => {
          f.patch(o);
        });
      } else
        ft ? (d.addHeadObjs(b(o)), Wt(() => d.updateDOM())) : d.addHeadObjs(o());
    else {
      let h = function() {
        if (typeof document < "u" && !f) {
          const m = document.createElement("style");
          m.type = "text/css", m.id = "vuetify-theme-stylesheet", t.cspNonce && m.setAttribute("nonce", t.cspNonce), f = m, document.head.appendChild(f);
        }
        f && (f.innerHTML = a.value);
      }, f = ft ? document.getElementById("vuetify-theme-stylesheet") : null;
      ft ? fe(a, h, {
        immediate: !0
      }) : h();
    }
  }
  const u = b(() => t.isDisabled ? void 0 : `v-theme--${n.value}`);
  return {
    install: l,
    isDisabled: t.isDisabled,
    name: n,
    themes: i,
    current: s,
    computedThemes: r,
    themeClasses: u,
    styles: a,
    global: {
      name: n,
      current: s
    }
  };
}
function lt(e) {
  Ut("provideTheme");
  const t = tt(Yu, null);
  if (!t)
    throw new Error("Could not find Vuetify theme injection");
  const n = b(() => e.theme ?? t.name.value), i = b(() => t.themes.value[n.value]), r = b(() => t.isDisabled ? void 0 : `v-theme--${n.value}`), s = {
    ...t,
    name: n,
    current: i,
    themeClasses: r
  };
  return Tt(Yu, s), s;
}
function PS() {
  Ut("useTheme");
  const e = tt(Yu, null);
  if (!e)
    throw new Error("Could not find Vuetify theme injection");
  return e;
}
function ya(e, t, n) {
  e.push(`${t} {
`, ...n.map((i) => `  ${i};
`), `}
`);
}
function hw(e) {
  const t = e.dark ? 2 : 1, n = e.dark ? 1 : 2, i = [];
  for (const [r, s] of Object.entries(e.colors)) {
    const a = Hi(s);
    i.push(`--v-theme-${r}: ${a.r},${a.g},${a.b}`), r.startsWith("on-") || i.push(`--v-theme-${r}-overlay-multiplier: ${Dv(s) > 0.18 ? t : n}`);
  }
  for (const [r, s] of Object.entries(e.variables)) {
    const a = typeof s == "string" && s.startsWith("#") ? Hi(s) : void 0, o = a ? `${a.r}, ${a.g}, ${a.b}` : void 0;
    i.push(`--v-${r}: ${o ?? s}`);
  }
  return i;
}
const oO = B({
  text: String,
  onClick: ri(),
  ...ke(),
  ...Qe()
}, "VLabel"), Ll = J()({
  name: "VLabel",
  props: oO(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => {
      var i;
      return v("label", {
        class: ["v-label", {
          "v-label--clickable": !!e.onClick
        }, e.class],
        style: e.style,
        onClick: e.onClick
      }, [e.text, (i = n.default) == null ? void 0 : i.call(n)]);
    }), {};
  }
}), lO = B({
  floating: Boolean,
  ...ke()
}, "VFieldLabel"), vu = J()({
  name: "VFieldLabel",
  props: lO(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => v(Ll, {
      class: ["v-field-label", {
        "v-field-label--floating": e.floating
      }, e.class],
      style: e.style,
      "aria-hidden": e.floating || void 0
    }, n)), {};
  }
}), uO = B({
  defaults: Object,
  disabled: Boolean,
  reset: [Number, String],
  root: [Boolean, String],
  scoped: Boolean
}, "VDefaultsProvider"), Ze = J(!1)({
  name: "VDefaultsProvider",
  props: uO(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      defaults: i,
      disabled: r,
      reset: s,
      root: a,
      scoped: o
    } = lh(e);
    return jt(i, {
      reset: s,
      root: a,
      scoped: o,
      disabled: r
    }), () => {
      var l;
      return (l = n.default) == null ? void 0 : l.call(n);
    };
  }
});
function pp(e) {
  return ap(() => {
    const t = [], n = {};
    if (e.value.background)
      if (Vv(e.value.background)) {
        if (n.backgroundColor = e.value.background, !e.value.text && VP(e.value.background)) {
          const i = Hi(e.value.background);
          if (i.a == null || i.a === 1) {
            const r = CS(i);
            n.color = r, n.caretColor = r;
          }
        }
      } else
        t.push(`bg-${e.value.background}`);
    return e.value.text && (Vv(e.value.text) ? (n.color = e.value.text, n.caretColor = e.value.text) : t.push(`text-${e.value.text}`)), {
      colorClasses: t,
      colorStyles: n
    };
  });
}
function $n(e, t) {
  const n = b(() => ({
    text: ia(e) ? e.value : t ? e[t] : null
  })), {
    colorClasses: i,
    colorStyles: r
  } = pp(n);
  return {
    textColorClasses: i,
    textColorStyles: r
  };
}
function gt(e, t) {
  const n = b(() => ({
    background: ia(e) ? e.value : t ? e[t] : null
  })), {
    colorClasses: i,
    colorStyles: r
  } = pp(n);
  return {
    backgroundColorClasses: i,
    backgroundColorStyles: r
  };
}
const cO = {
  collapse: "mdi-chevron-up",
  complete: "mdi-check",
  cancel: "mdi-close-circle",
  close: "mdi-close",
  delete: "mdi-close-circle",
  // delete (e.g. v-chip close)
  clear: "mdi-close-circle",
  success: "mdi-check-circle",
  info: "mdi-information",
  warning: "mdi-alert-circle",
  error: "mdi-close-circle",
  prev: "mdi-chevron-left",
  next: "mdi-chevron-right",
  checkboxOn: "mdi-checkbox-marked",
  checkboxOff: "mdi-checkbox-blank-outline",
  checkboxIndeterminate: "mdi-minus-box",
  delimiter: "mdi-circle",
  // for carousel
  sortAsc: "mdi-arrow-up",
  sortDesc: "mdi-arrow-down",
  expand: "mdi-chevron-down",
  menu: "mdi-menu",
  subgroup: "mdi-menu-down",
  dropdown: "mdi-menu-down",
  radioOn: "mdi-radiobox-marked",
  radioOff: "mdi-radiobox-blank",
  edit: "mdi-pencil",
  ratingEmpty: "mdi-star-outline",
  ratingFull: "mdi-star",
  ratingHalf: "mdi-star-half-full",
  loading: "mdi-cached",
  first: "mdi-page-first",
  last: "mdi-page-last",
  unfold: "mdi-unfold-more-horizontal",
  file: "mdi-paperclip",
  plus: "mdi-plus",
  minus: "mdi-minus",
  calendar: "mdi-calendar",
  treeviewCollapse: "mdi-menu-down",
  treeviewExpand: "mdi-menu-right",
  eyeDropper: "mdi-eyedropper"
}, dO = {
  // Not using mergeProps here, functional components merge props by default (?)
  component: (e) => oa(bp, {
    ...e,
    class: "mdi"
  })
}, We = [String, Function, Object, Array], Nv = Symbol.for("vuetify:icons"), ph = B({
  icon: {
    type: We
  },
  // Could not remove this and use makeTagProps, types complained because it is not required
  tag: {
    type: String,
    required: !0
  }
}, "icon"), Mv = J()({
  name: "VComponentIcon",
  props: ph(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      const i = e.icon;
      return v(e.tag, null, {
        default: () => {
          var r;
          return [e.icon ? v(i, null, null) : (r = n.default) == null ? void 0 : r.call(n)];
        }
      });
    };
  }
}), yp = Pi({
  name: "VSvgIcon",
  inheritAttrs: !1,
  props: ph(),
  setup(e, t) {
    let {
      attrs: n
    } = t;
    return () => v(e.tag, ie(n, {
      style: null
    }), {
      default: () => [v("svg", {
        class: "v-icon__svg",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        role: "img",
        "aria-hidden": "true"
      }, [Array.isArray(e.icon) ? e.icon.map((i) => Array.isArray(i) ? v("path", {
        d: i[0],
        "fill-opacity": i[1]
      }, null) : v("path", {
        d: i
      }, null)) : v("path", {
        d: e.icon
      }, null)])]
    });
  }
}), fO = Pi({
  name: "VLigatureIcon",
  props: ph(),
  setup(e) {
    return () => v(e.tag, null, {
      default: () => [e.icon]
    });
  }
}), bp = Pi({
  name: "VClassIcon",
  props: ph(),
  setup(e) {
    return () => v(e.tag, {
      class: e.icon
    }, null);
  }
});
function hO() {
  return {
    svg: {
      component: yp
    },
    class: {
      component: bp
    }
  };
}
function mO(e) {
  const t = hO(), n = (e == null ? void 0 : e.defaultSet) ?? "mdi";
  return n === "mdi" && !t.mdi && (t.mdi = dO), qn({
    defaultSet: n,
    sets: t,
    aliases: {
      ...cO,
      /* eslint-disable max-len */
      vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", 0.6]],
      "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z",
      "vuetify-play": ["m6.376 13.184-4.11-7.192C1.505 4.66 2.467 3 4.003 3h8.532l-.953 1.576-.006.01-.396.677c-.429.732-.214 1.507.194 2.015.404.503 1.092.878 1.869.806a3.72 3.72 0 0 1 1.005.022c.276.053.434.143.523.237.138.146.38.635-.25 2.09-.893 1.63-1.553 1.722-1.847 1.677-.213-.033-.468-.158-.756-.406a4.95 4.95 0 0 1-.8-.927c-.39-.564-1.04-.84-1.66-.846-.625-.006-1.316.27-1.693.921l-.478.826-.911 1.506Z", ["M9.093 11.552c.046-.079.144-.15.32-.148a.53.53 0 0 1 .43.207c.285.414.636.847 1.046 1.2.405.35.914.662 1.516.754 1.334.205 2.502-.698 3.48-2.495l.014-.028.013-.03c.687-1.574.774-2.852-.005-3.675-.37-.391-.861-.586-1.333-.676a5.243 5.243 0 0 0-1.447-.044c-.173.016-.393-.073-.54-.257-.145-.18-.127-.316-.082-.392l.393-.672L14.287 3h5.71c1.536 0 2.499 1.659 1.737 2.992l-7.997 13.996c-.768 1.344-2.706 1.344-3.473 0l-3.037-5.314 1.377-2.278.004-.006.004-.007.481-.831Z", 0.6]]
      /* eslint-enable max-len */
    }
  }, e);
}
const vO = (e) => {
  const t = tt(Nv);
  if (!t)
    throw new Error("Missing Vuetify Icons provide!");
  return {
    iconData: b(() => {
      var l;
      const i = Ct(e);
      if (!i)
        return {
          component: Mv
        };
      let r = i;
      if (typeof r == "string" && (r = r.trim(), r.startsWith("$") && (r = (l = t.aliases) == null ? void 0 : l[r.slice(1)])), r || pr(`Could not find aliased icon "${i}"`), Array.isArray(r))
        return {
          component: yp,
          icon: r
        };
      if (typeof r != "string")
        return {
          component: Mv,
          icon: r
        };
      const s = Object.keys(t.sets).find((u) => typeof r == "string" && r.startsWith(`${u}:`)), a = s ? r.slice(s.length + 1) : r;
      return {
        component: t.sets[s ?? t.defaultSet].component,
        icon: a
      };
    })
  };
}, gO = ["x-small", "small", "default", "large", "x-large"], Xr = B({
  size: {
    type: [String, Number],
    default: "default"
  }
}, "size");
function $l(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Kr();
  return ap(() => {
    let n, i;
    return df(gO, e.size) ? n = `${t}--size-${e.size}` : e.size && (i = {
      width: _e(e.size),
      height: _e(e.size)
    }), {
      sizeClasses: n,
      sizeStyles: i
    };
  });
}
const je = B({
  tag: {
    type: String,
    default: "div"
  }
}, "tag"), pO = B({
  color: String,
  disabled: Boolean,
  start: Boolean,
  end: Boolean,
  icon: We,
  ...ke(),
  ...Xr(),
  ...je({
    tag: "i"
  }),
  ...Qe()
}, "VIcon"), at = J()({
  name: "VIcon",
  props: pO(),
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const r = X(), {
      themeClasses: s
    } = lt(e), {
      iconData: a
    } = vO(b(() => r.value || e.icon)), {
      sizeClasses: o
    } = $l(e), {
      textColorClasses: l,
      textColorStyles: u
    } = $n(G(e, "color"));
    return re(() => {
      var f, h;
      const c = (f = i.default) == null ? void 0 : f.call(i);
      c && (r.value = (h = lS(c).filter((m) => m.type === WE && m.children && typeof m.children == "string")[0]) == null ? void 0 : h.children);
      const d = !!(n.onClick || n.onClickOnce);
      return v(a.value.component, {
        tag: e.tag,
        icon: a.value.icon,
        class: ["v-icon", "notranslate", s.value, o.value, l.value, {
          "v-icon--clickable": d,
          "v-icon--disabled": e.disabled,
          "v-icon--start": e.start,
          "v-icon--end": e.end
        }, e.class],
        style: [o.value ? void 0 : {
          fontSize: _e(e.size),
          height: _e(e.size),
          width: _e(e.size)
        }, u.value, e.style],
        role: d ? "button" : void 0,
        "aria-hidden": !d,
        tabindex: d ? e.disabled ? -1 : 0 : void 0
      }, {
        default: () => [c]
      });
    }), {};
  }
});
function vi(e, t) {
  let n;
  function i() {
    n = np(), n.run(() => t.length ? t(() => {
      n == null || n.stop(), i();
    }) : t());
  }
  fe(e, (r) => {
    r && !n ? i() : r || (n == null || n.stop(), n = void 0);
  }, {
    immediate: !0
  }), jn(() => {
    n == null || n.stop();
  });
}
function Ee(e, t, n) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (d) => d, r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (d) => d;
  const s = Ut("useProxiedModel"), a = X(e[t] !== void 0 ? e[t] : n), o = $a(t), u = o !== t ? b(() => {
    var d, f, h, m;
    return e[t], !!(((d = s.vnode.props) != null && d.hasOwnProperty(t) || (f = s.vnode.props) != null && f.hasOwnProperty(o)) && ((h = s.vnode.props) != null && h.hasOwnProperty(`onUpdate:${t}`) || (m = s.vnode.props) != null && m.hasOwnProperty(`onUpdate:${o}`)));
  }) : b(() => {
    var d, f;
    return e[t], !!((d = s.vnode.props) != null && d.hasOwnProperty(t) && ((f = s.vnode.props) != null && f.hasOwnProperty(`onUpdate:${t}`)));
  });
  vi(() => !u.value, () => {
    fe(() => e[t], (d) => {
      a.value = d;
    });
  });
  const c = b({
    get() {
      const d = e[t];
      return i(u.value ? d : a.value);
    },
    set(d) {
      const f = r(d), h = si(u.value ? e[t] : a.value);
      h === f || i(h) === d || (a.value = f, s == null || s.emit(`update:${t}`, f));
    }
  });
  return Object.defineProperty(c, "externalValue", {
    get: () => u.value ? e[t] : a.value
  }), c;
}
const yO = {
  badge: "Badge",
  open: "Open",
  close: "Close",
  dismiss: "Dismiss",
  confirmEdit: {
    ok: "OK",
    cancel: "Cancel"
  },
  dataIterator: {
    noResultsText: "No matching records found",
    loadingText: "Loading items..."
  },
  dataTable: {
    itemsPerPageText: "Rows per page:",
    ariaLabel: {
      sortDescending: "Sorted descending.",
      sortAscending: "Sorted ascending.",
      sortNone: "Not sorted.",
      activateNone: "Activate to remove sorting.",
      activateDescending: "Activate to sort descending.",
      activateAscending: "Activate to sort ascending."
    },
    sortBy: "Sort by"
  },
  dataFooter: {
    itemsPerPageText: "Items per page:",
    itemsPerPageAll: "All",
    nextPage: "Next page",
    prevPage: "Previous page",
    firstPage: "First page",
    lastPage: "Last page",
    pageText: "{0}-{1} of {2}"
  },
  dateRangeInput: {
    divider: "to"
  },
  datePicker: {
    itemsSelected: "{0} selected",
    range: {
      title: "Select dates",
      header: "Enter dates"
    },
    title: "Select date",
    header: "Enter date",
    input: {
      placeholder: "Enter date"
    }
  },
  noDataText: "No data available",
  carousel: {
    prev: "Previous visual",
    next: "Next visual",
    ariaLabel: {
      delimiter: "Carousel slide {0} of {1}"
    }
  },
  calendar: {
    moreEvents: "{0} more",
    today: "Today"
  },
  input: {
    clear: "Clear {0}",
    prependAction: "{0} prepended action",
    appendAction: "{0} appended action",
    otp: "Please enter OTP character {0}"
  },
  fileInput: {
    counter: "{0} files",
    counterSize: "{0} files ({1} in total)"
  },
  timePicker: {
    am: "AM",
    pm: "PM",
    title: "Select Time"
  },
  pagination: {
    ariaLabel: {
      root: "Pagination Navigation",
      next: "Next page",
      previous: "Previous page",
      page: "Go to page {0}",
      currentPage: "Page {0}, Current page",
      first: "First page",
      last: "Last page"
    }
  },
  stepper: {
    next: "Next",
    prev: "Previous"
  },
  rating: {
    ariaLabel: {
      item: "Rating {0} of {1}"
    }
  },
  loading: "Loading...",
  infiniteScroll: {
    loadMore: "Load more",
    empty: "No more"
  }
}, mw = "$vuetify.", vw = (e, t) => e.replace(/\{(\d+)\}/g, (n, i) => String(t[+i])), OS = (e, t, n) => function(i) {
  for (var r = arguments.length, s = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)
    s[a - 1] = arguments[a];
  if (!i.startsWith(mw))
    return vw(i, s);
  const o = i.replace(mw, ""), l = e.value && n.value[e.value], u = t.value && n.value[t.value];
  let c = Hu(l, o, null);
  return c || (pr(`Translation key "${i}" not found in "${e.value}", trying fallback locale`), c = Hu(u, o, null)), c || (hf(`Translation key "${i}" not found in fallback`), c = i), typeof c != "string" && (hf(`Translation key "${i}" has a non-string value`), c = i), vw(c, s);
};
function VS(e, t) {
  return (n, i) => new Intl.NumberFormat([e.value, t.value], i).format(n);
}
function Um(e, t, n) {
  const i = Ee(e, t, e[t] ?? n.value);
  return i.value = e[t] ?? n.value, fe(n, (r) => {
    e[t] == null && (i.value = n.value);
  }), i;
}
function DS(e) {
  return (t) => {
    const n = Um(t, "locale", e.current), i = Um(t, "fallback", e.fallback), r = Um(t, "messages", e.messages);
    return {
      name: "vuetify",
      current: n,
      fallback: i,
      messages: r,
      t: OS(n, i, r),
      n: VS(n, i),
      provide: DS({
        current: n,
        fallback: i,
        messages: r
      })
    };
  };
}
function bO(e) {
  const t = pe((e == null ? void 0 : e.locale) ?? "en"), n = pe((e == null ? void 0 : e.fallback) ?? "en"), i = X({
    en: yO,
    ...e == null ? void 0 : e.messages
  });
  return {
    name: "vuetify",
    current: t,
    fallback: n,
    messages: i,
    t: OS(t, n, i),
    n: VS(t, n),
    provide: DS({
      current: t,
      fallback: n,
      messages: i
    })
  };
}
const bl = Symbol.for("vuetify:locale");
function wO(e) {
  return e.name != null;
}
function _O(e) {
  const t = e != null && e.adapter && wO(e == null ? void 0 : e.adapter) ? e == null ? void 0 : e.adapter : bO(e), n = CO(t, e);
  return {
    ...t,
    ...n
  };
}
function qt() {
  const e = tt(bl);
  if (!e)
    throw new Error("[Vuetify] Could not find injected locale instance");
  return e;
}
function SO(e) {
  const t = tt(bl);
  if (!t)
    throw new Error("[Vuetify] Could not find injected locale instance");
  const n = t.provide(e), i = TO(n, t.rtl, e), r = {
    ...n,
    ...i
  };
  return Tt(bl, r), r;
}
function kO() {
  return {
    af: !1,
    ar: !0,
    bg: !1,
    ca: !1,
    ckb: !1,
    cs: !1,
    de: !1,
    el: !1,
    en: !1,
    es: !1,
    et: !1,
    fa: !0,
    fi: !1,
    fr: !1,
    hr: !1,
    hu: !1,
    he: !0,
    id: !1,
    it: !1,
    ja: !1,
    km: !1,
    ko: !1,
    lv: !1,
    lt: !1,
    nl: !1,
    no: !1,
    pl: !1,
    pt: !1,
    ro: !1,
    ru: !1,
    sk: !1,
    sl: !1,
    srCyrl: !1,
    srLatn: !1,
    sv: !1,
    th: !1,
    tr: !1,
    az: !1,
    uk: !1,
    vi: !1,
    zhHans: !1,
    zhHant: !1
  };
}
function CO(e, t) {
  const n = X((t == null ? void 0 : t.rtl) ?? kO()), i = b(() => n.value[e.current.value] ?? !1);
  return {
    isRtl: i,
    rtl: n,
    rtlClasses: b(() => `v-locale--is-${i.value ? "rtl" : "ltr"}`)
  };
}
function TO(e, t, n) {
  const i = b(() => n.rtl ?? t.value[e.current.value] ?? !1);
  return {
    isRtl: i,
    rtl: t,
    rtlClasses: b(() => `v-locale--is-${i.value ? "rtl" : "ltr"}`)
  };
}
function wn() {
  const e = tt(bl);
  if (!e)
    throw new Error("[Vuetify] Could not find injected rtl instance");
  return {
    isRtl: e.isRtl,
    rtlClasses: e.rtlClasses
  };
}
function NS(e) {
  const {
    t
  } = qt();
  function n(i) {
    let {
      name: r
    } = i;
    const s = {
      prepend: "prependAction",
      prependInner: "prependAction",
      append: "appendAction",
      appendInner: "appendAction",
      clear: "clear"
    }[r], a = e[`onClick:${r}`], o = a && s ? t(`$vuetify.input.${s}`, e.label ?? "") : void 0;
    return v(at, {
      icon: e[`${r}Icon`],
      "aria-label": o,
      onClick: a
    }, null);
  }
  return {
    InputIcon: n
  };
}
const Pc = B({
  focused: Boolean,
  "onUpdate:focused": ri()
}, "focus");
function xs(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Kr();
  const n = Ee(e, "focused"), i = b(() => ({
    [`${t}--focused`]: n.value
  }));
  function r() {
    n.value = !0;
  }
  function s() {
    n.value = !1;
  }
  return {
    focusClasses: i,
    isFocused: n,
    focus: r,
    blur: s
  };
}
function yh(e, t) {
  const n = X(), i = pe(!1);
  if (rp) {
    const r = new IntersectionObserver((s) => {
      e == null || e(s, r), i.value = !!s.find((a) => a.isIntersecting);
    }, t);
    ai(() => {
      r.disconnect();
    }), fe(n, (s, a) => {
      a && (r.unobserve(a), i.value = !1), s && r.observe(s);
    }, {
      flush: "post"
    });
  }
  return {
    intersectionRef: n,
    isIntersecting: i
  };
}
const gw = {
  center: "center",
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
}, ua = B({
  location: String
}, "location");
function yo(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 ? arguments[2] : void 0;
  const {
    isRtl: i
  } = wn();
  return {
    locationStyles: b(() => {
      if (!e.location)
        return {};
      const {
        side: s,
        align: a
      } = Pv(e.location.split(" ").length > 1 ? e.location : `${e.location} center`, i.value);
      function o(u) {
        return n ? n(u) : 0;
      }
      const l = {};
      return s !== "center" && (t ? l[gw[s]] = `calc(100% - ${o(s)}px)` : l[s] = 0), a !== "center" ? t ? l[gw[a]] = `calc(100% - ${o(a)}px)` : l[a] = 0 : (s === "center" ? l.top = l.left = "50%" : l[{
        top: "left",
        bottom: "left",
        left: "top",
        right: "top"
      }[s]] = "50%", l.transform = {
        top: "translateX(-50%)",
        bottom: "translateX(-50%)",
        left: "translateY(-50%)",
        right: "translateY(-50%)",
        center: "translate(-50%, -50%)"
      }[s]), l;
    })
  };
}
const It = B({
  rounded: {
    type: [Boolean, Number, String],
    default: void 0
  },
  tile: Boolean
}, "rounded");
function Ht(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Kr();
  return {
    roundedClasses: b(() => {
      const i = ia(e) ? e.value : e.rounded, r = ia(e) ? e.value : e.tile, s = [];
      if (i === !0 || i === "")
        s.push(`${t}--rounded`);
      else if (typeof i == "string" || i === 0)
        for (const a of String(i).split(" "))
          s.push(`rounded-${a}`);
      else
        (r || i === !1) && s.push("rounded-0");
      return s;
    })
  };
}
const xO = B({
  absolute: Boolean,
  active: {
    type: Boolean,
    default: !0
  },
  bgColor: String,
  bgOpacity: [Number, String],
  bufferValue: {
    type: [Number, String],
    default: 0
  },
  bufferColor: String,
  bufferOpacity: [Number, String],
  clickable: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: 4
  },
  indeterminate: Boolean,
  max: {
    type: [Number, String],
    default: 100
  },
  modelValue: {
    type: [Number, String],
    default: 0
  },
  opacity: [Number, String],
  reverse: Boolean,
  stream: Boolean,
  striped: Boolean,
  roundedBar: Boolean,
  ...ke(),
  ...ua({
    location: "top"
  }),
  ...It(),
  ...je(),
  ...Qe()
}, "VProgressLinear"), bh = J()({
  name: "VProgressLinear",
  props: xO(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), {
      isRtl: r,
      rtlClasses: s
    } = wn(), {
      themeClasses: a
    } = lt(e), {
      locationStyles: o
    } = yo(e), {
      textColorClasses: l,
      textColorStyles: u
    } = $n(e, "color"), {
      backgroundColorClasses: c,
      backgroundColorStyles: d
    } = gt(b(() => e.bgColor || e.color)), {
      backgroundColorClasses: f,
      backgroundColorStyles: h
    } = gt(b(() => e.bufferColor || e.bgColor || e.color)), {
      backgroundColorClasses: m,
      backgroundColorStyles: g
    } = gt(e, "color"), {
      roundedClasses: p
    } = Ht(e), {
      intersectionRef: y,
      isIntersecting: k
    } = yh(), T = b(() => parseFloat(e.max)), _ = b(() => parseFloat(e.height)), w = b(() => Xt(parseFloat(e.bufferValue) / T.value * 100, 0, 100)), S = b(() => Xt(parseFloat(i.value) / T.value * 100, 0, 100)), C = b(() => r.value !== e.reverse), x = b(() => e.indeterminate ? "fade-transition" : "slide-x-transition");
    function A(I) {
      if (!y.value)
        return;
      const {
        left: E,
        right: P,
        width: V
      } = y.value.getBoundingClientRect(), N = C.value ? V - I.clientX + (P - V) : I.clientX - E;
      i.value = Math.round(N / V * T.value);
    }
    return re(() => v(e.tag, {
      ref: y,
      class: ["v-progress-linear", {
        "v-progress-linear--absolute": e.absolute,
        "v-progress-linear--active": e.active && k.value,
        "v-progress-linear--reverse": C.value,
        "v-progress-linear--rounded": e.rounded,
        "v-progress-linear--rounded-bar": e.roundedBar,
        "v-progress-linear--striped": e.striped
      }, p.value, a.value, s.value, e.class],
      style: [{
        bottom: e.location === "bottom" ? 0 : void 0,
        top: e.location === "top" ? 0 : void 0,
        height: e.active ? _e(_.value) : 0,
        "--v-progress-linear-height": _e(_.value),
        ...e.absolute ? o.value : {}
      }, e.style],
      role: "progressbar",
      "aria-hidden": e.active ? "false" : "true",
      "aria-valuemin": "0",
      "aria-valuemax": e.max,
      "aria-valuenow": e.indeterminate ? void 0 : S.value,
      onClick: e.clickable && A
    }, {
      default: () => [e.stream && v("div", {
        key: "stream",
        class: ["v-progress-linear__stream", l.value],
        style: {
          ...u.value,
          [C.value ? "left" : "right"]: _e(-_.value),
          borderTop: `${_e(_.value / 2)} dotted`,
          opacity: parseFloat(e.bufferOpacity),
          top: `calc(50% - ${_e(_.value / 4)})`,
          width: _e(100 - w.value, "%"),
          "--v-progress-linear-stream-to": _e(_.value * (C.value ? 1 : -1))
        }
      }, null), v("div", {
        class: ["v-progress-linear__background", c.value],
        style: [d.value, {
          opacity: parseFloat(e.bgOpacity),
          width: e.stream ? 0 : void 0
        }]
      }, null), v("div", {
        class: ["v-progress-linear__buffer", f.value],
        style: [h.value, {
          opacity: parseFloat(e.bufferOpacity),
          width: _e(w.value, "%")
        }]
      }, null), v(na, {
        name: x.value
      }, {
        default: () => [e.indeterminate ? v("div", {
          class: "v-progress-linear__indeterminate"
        }, [["long", "short"].map((I) => v("div", {
          key: I,
          class: ["v-progress-linear__indeterminate", I, m.value],
          style: g.value
        }, null))]) : v("div", {
          class: ["v-progress-linear__determinate", m.value],
          style: [g.value, {
            width: _e(S.value, "%")
          }]
        }, null)]
      }), n.default && v("div", {
        class: "v-progress-linear__content"
      }, [n.default({
        value: S.value,
        buffer: w.value
      })])]
    })), {};
  }
}), wh = B({
  loading: [Boolean, String]
}, "loader");
function Oc(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Kr();
  return {
    loaderClasses: b(() => ({
      [`${t}--loading`]: e.loading
    }))
  };
}
function Vc(e, t) {
  var i;
  let {
    slots: n
  } = t;
  return v("div", {
    class: `${e.name}__loader`
  }, [((i = n.default) == null ? void 0 : i.call(n, {
    color: e.color,
    isActive: e.active
  })) || v(bh, {
    absolute: e.absolute,
    active: e.active,
    color: e.color,
    height: "2",
    indeterminate: !0
  }, null)]);
}
const AO = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"], Dc = B({
  appendInnerIcon: We,
  bgColor: String,
  clearable: Boolean,
  clearIcon: {
    type: We,
    default: "$clear"
  },
  active: Boolean,
  centerAffix: {
    type: Boolean,
    default: void 0
  },
  color: String,
  baseColor: String,
  dirty: Boolean,
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  flat: Boolean,
  label: String,
  persistentClear: Boolean,
  prependInnerIcon: We,
  reverse: Boolean,
  singleLine: Boolean,
  variant: {
    type: String,
    default: "filled",
    validator: (e) => AO.includes(e)
  },
  "onClick:clear": ri(),
  "onClick:appendInner": ri(),
  "onClick:prependInner": ri(),
  ...ke(),
  ...wh(),
  ...It(),
  ...Qe()
}, "VField"), Wl = J()({
  name: "VField",
  inheritAttrs: !1,
  props: {
    id: String,
    ...Pc(),
    ...Dc()
  },
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const {
      themeClasses: s
    } = lt(e), {
      loaderClasses: a
    } = Oc(e), {
      focusClasses: o,
      isFocused: l,
      focus: u,
      blur: c
    } = xs(e), {
      InputIcon: d
    } = NS(e), {
      roundedClasses: f
    } = Ht(e), {
      rtlClasses: h
    } = wn(), m = b(() => e.dirty || e.active), g = b(() => !e.singleLine && !!(e.label || r.label)), p = Pn(), y = b(() => e.id || `input-${p}`), k = b(() => `${y.value}-messages`), T = X(), _ = X(), w = X(), S = b(() => ["plain", "underlined"].includes(e.variant)), {
      backgroundColorClasses: C,
      backgroundColorStyles: x
    } = gt(G(e, "bgColor")), {
      textColorClasses: A,
      textColorStyles: I
    } = $n(b(() => e.error || e.disabled ? void 0 : m.value && l.value ? e.color : e.baseColor));
    fe(m, (N) => {
      if (g.value) {
        const F = T.value.$el, $ = _.value.$el;
        requestAnimationFrame(() => {
          const Z = lp(F), j = $.getBoundingClientRect(), H = j.x - Z.x, R = j.y - Z.y - (Z.height / 2 - j.height / 2), L = j.width / 0.75, ne = Math.abs(L - Z.width) > 1 ? {
            maxWidth: _e(L)
          } : void 0, oe = getComputedStyle(F), we = getComputedStyle($), ee = parseFloat(oe.transitionDuration) * 1e3 || 150, K = parseFloat(we.getPropertyValue("--v-field-label-scale")), ue = we.getPropertyValue("color");
          F.style.visibility = "visible", $.style.visibility = "hidden", Na(F, {
            transform: `translate(${H}px, ${R}px) scale(${K})`,
            color: ue,
            ...ne
          }, {
            duration: ee,
            easing: qu,
            direction: N ? "normal" : "reverse"
          }).finished.then(() => {
            F.style.removeProperty("visibility"), $.style.removeProperty("visibility");
          });
        });
      }
    }, {
      flush: "post"
    });
    const E = b(() => ({
      isActive: m,
      isFocused: l,
      controlRef: w,
      blur: c,
      focus: u
    }));
    function P(N) {
      N.target !== document.activeElement && N.preventDefault();
    }
    function V(N) {
      var F;
      N.key !== "Enter" && N.key !== " " || (N.preventDefault(), N.stopPropagation(), (F = e["onClick:clear"]) == null || F.call(e, new MouseEvent("click")));
    }
    return re(() => {
      var H, R, L;
      const N = e.variant === "outlined", F = !!(r["prepend-inner"] || e.prependInnerIcon), $ = !!(e.clearable || r.clear), Z = !!(r["append-inner"] || e.appendInnerIcon || $), j = () => r.label ? r.label({
        ...E.value,
        label: e.label,
        props: {
          for: y.value
        }
      }) : e.label;
      return v("div", ie({
        class: ["v-field", {
          "v-field--active": m.value,
          "v-field--appended": Z,
          "v-field--center-affix": e.centerAffix ?? !S.value,
          "v-field--disabled": e.disabled,
          "v-field--dirty": e.dirty,
          "v-field--error": e.error,
          "v-field--flat": e.flat,
          "v-field--has-background": !!e.bgColor,
          "v-field--persistent-clear": e.persistentClear,
          "v-field--prepended": F,
          "v-field--reverse": e.reverse,
          "v-field--single-line": e.singleLine,
          "v-field--no-label": !j(),
          [`v-field--variant-${e.variant}`]: !0
        }, s.value, C.value, o.value, a.value, f.value, h.value, e.class],
        style: [x.value, e.style],
        onClick: P
      }, n), [v("div", {
        class: "v-field__overlay"
      }, null), v(Vc, {
        name: "v-field",
        active: !!e.loading,
        color: e.error ? "error" : typeof e.loading == "string" ? e.loading : e.color
      }, {
        default: r.loader
      }), F && v("div", {
        key: "prepend",
        class: "v-field__prepend-inner"
      }, [e.prependInnerIcon && v(d, {
        key: "prepend-icon",
        name: "prependInner"
      }, null), (H = r["prepend-inner"]) == null ? void 0 : H.call(r, E.value)]), v("div", {
        class: "v-field__field",
        "data-no-activator": ""
      }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(e.variant) && g.value && v(vu, {
        key: "floating-label",
        ref: _,
        class: [A.value],
        floating: !0,
        for: y.value,
        style: I.value
      }, {
        default: () => [j()]
      }), v(vu, {
        ref: T,
        for: y.value
      }, {
        default: () => [j()]
      }), (R = r.default) == null ? void 0 : R.call(r, {
        ...E.value,
        props: {
          id: y.value,
          class: "v-field__input",
          "aria-describedby": k.value
        },
        focus: u,
        blur: c
      })]), $ && v(gp, {
        key: "clear"
      }, {
        default: () => [Rt(v("div", {
          class: "v-field__clearable",
          onMousedown: (ne) => {
            ne.preventDefault(), ne.stopPropagation();
          }
        }, [v(Ze, {
          defaults: {
            VIcon: {
              icon: e.clearIcon
            }
          }
        }, {
          default: () => [r.clear ? r.clear({
            ...E.value,
            props: {
              onKeydown: V,
              onFocus: u,
              onBlur: c,
              onClick: e["onClick:clear"]
            }
          }) : v(d, {
            name: "clear",
            onKeydown: V,
            onFocus: u,
            onBlur: c
          }, null)]
        })]), [[Tr, e.dirty]])]
      }), Z && v("div", {
        key: "append",
        class: "v-field__append-inner"
      }, [(L = r["append-inner"]) == null ? void 0 : L.call(r, E.value), e.appendInnerIcon && v(d, {
        key: "append-icon",
        name: "appendInner"
      }, null)]), v("div", {
        class: ["v-field__outline", A.value],
        style: I.value
      }, [N && v(De, null, [v("div", {
        class: "v-field__outline__start"
      }, null), g.value && v("div", {
        class: "v-field__outline__notch"
      }, [v(vu, {
        ref: _,
        floating: !0,
        for: y.value
      }, {
        default: () => [j()]
      })]), v("div", {
        class: "v-field__outline__end"
      }, null)]), S.value && g.value && v(vu, {
        ref: _,
        floating: !0,
        for: y.value
      }, {
        default: () => [j()]
      })])]);
    }), {
      controlRef: w
    };
  }
});
function wp(e) {
  const t = Object.keys(Wl.props).filter((n) => !dh(n) && n !== "class" && n !== "style");
  return aS(e, t);
}
const IO = B({
  active: Boolean,
  color: String,
  messages: {
    type: [Array, String],
    default: () => []
  },
  ...ke(),
  ...xr({
    transition: {
      component: vp,
      leaveAbsolute: !0,
      group: !0
    }
  })
}, "VMessages"), MS = J()({
  name: "VMessages",
  props: IO(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = b(() => Nt(e.messages)), {
      textColorClasses: r,
      textColorStyles: s
    } = $n(b(() => e.color));
    return re(() => v(Gn, {
      transition: e.transition,
      tag: "div",
      class: ["v-messages", r.value, e.class],
      style: [s.value, e.style],
      role: "alert",
      "aria-live": "polite"
    }, {
      default: () => [e.active && i.value.map((a, o) => v("div", {
        class: "v-messages__message",
        key: `${o}-${i.value}`
      }, [n.message ? n.message({
        message: a
      }) : a]))]
    })), {};
  }
}), EO = [null, "default", "comfortable", "compact"], _n = B({
  density: {
    type: String,
    default: "default",
    validator: (e) => EO.includes(e)
  }
}, "density");
function Kn(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Kr();
  return {
    densityClasses: b(() => `${t}--density-${e.density}`)
  };
}
const Sn = B({
  height: [Number, String],
  maxHeight: [Number, String],
  maxWidth: [Number, String],
  minHeight: [Number, String],
  minWidth: [Number, String],
  width: [Number, String]
}, "dimension");
function kn(e) {
  return {
    dimensionStyles: b(() => {
      const n = {}, i = _e(e.height), r = _e(e.maxHeight), s = _e(e.maxWidth), a = _e(e.minHeight), o = _e(e.minWidth), l = _e(e.width);
      return i != null && (n.height = i), r != null && (n.maxHeight = r), s != null && (n.maxWidth = s), a != null && (n.minHeight = a), o != null && (n.minWidth = o), l != null && (n.width = l), n;
    })
  };
}
const RS = Symbol.for("vuetify:form"), PO = B({
  disabled: Boolean,
  fastFail: Boolean,
  readonly: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  validateOn: {
    type: String,
    default: "input"
  }
}, "form");
function OO(e) {
  const t = Ee(e, "modelValue"), n = b(() => e.disabled), i = b(() => e.readonly), r = pe(!1), s = X([]), a = X([]);
  async function o() {
    const c = [];
    let d = !0;
    a.value = [], r.value = !0;
    for (const f of s.value) {
      const h = await f.validate();
      if (h.length > 0 && (d = !1, c.push({
        id: f.id,
        errorMessages: h
      })), !d && e.fastFail)
        break;
    }
    return a.value = c, r.value = !1, {
      valid: d,
      errors: a.value
    };
  }
  function l() {
    s.value.forEach((c) => c.reset());
  }
  function u() {
    s.value.forEach((c) => c.resetValidation());
  }
  return fe(s, () => {
    let c = 0, d = 0;
    const f = [];
    for (const h of s.value)
      h.isValid === !1 ? (d++, f.push({
        id: h.id,
        errorMessages: h.errorMessages
      })) : h.isValid === !0 && c++;
    a.value = f, t.value = d > 0 ? !1 : c === s.value.length ? !0 : null;
  }, {
    deep: !0,
    flush: "post"
  }), Tt(RS, {
    register: (c) => {
      let {
        id: d,
        vm: f,
        validate: h,
        reset: m,
        resetValidation: g
      } = c;
      s.value.some((p) => p.id === d) && pr(`Duplicate input name "${d}"`), s.value.push({
        id: d,
        validate: h,
        reset: m,
        resetValidation: g,
        vm: jE(f),
        isValid: null,
        errorMessages: []
      });
    },
    unregister: (c) => {
      s.value = s.value.filter((d) => d.id !== c);
    },
    update: (c, d, f) => {
      const h = s.value.find((m) => m.id === c);
      h && (h.isValid = d, h.errorMessages = f);
    },
    isDisabled: n,
    isReadonly: i,
    isValidating: r,
    isValid: t,
    items: s,
    validateOn: G(e, "validateOn")
  }), {
    errors: a,
    isDisabled: n,
    isReadonly: i,
    isValidating: r,
    isValid: t,
    items: s,
    validate: o,
    reset: l,
    resetValidation: u
  };
}
function _h() {
  return tt(RS, null);
}
const FS = B({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  errorMessages: {
    type: [Array, String],
    default: () => []
  },
  maxErrors: {
    type: [Number, String],
    default: 1
  },
  name: String,
  label: String,
  readonly: {
    type: Boolean,
    default: null
  },
  rules: {
    type: Array,
    default: () => []
  },
  modelValue: null,
  validateOn: String,
  validationValue: null,
  ...Pc()
}, "validation");
function BS(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Kr(), n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Pn();
  const i = Ee(e, "modelValue"), r = b(() => e.validationValue === void 0 ? i.value : e.validationValue), s = _h(), a = X([]), o = pe(!0), l = b(() => !!(Nt(i.value === "" ? null : i.value).length || Nt(r.value === "" ? null : r.value).length)), u = b(() => !!(e.disabled ?? (s == null ? void 0 : s.isDisabled.value))), c = b(() => !!(e.readonly ?? (s == null ? void 0 : s.isReadonly.value))), d = b(() => {
    var w;
    return (w = e.errorMessages) != null && w.length ? Nt(e.errorMessages).concat(a.value).slice(0, Math.max(0, +e.maxErrors)) : a.value;
  }), f = b(() => {
    let w = (e.validateOn ?? (s == null ? void 0 : s.validateOn.value)) || "input";
    w === "lazy" && (w = "input lazy");
    const S = new Set((w == null ? void 0 : w.split(" ")) ?? []);
    return {
      blur: S.has("blur") || S.has("input"),
      input: S.has("input"),
      submit: S.has("submit"),
      lazy: S.has("lazy")
    };
  }), h = b(() => {
    var w;
    return e.error || (w = e.errorMessages) != null && w.length ? !1 : e.rules.length ? o.value ? a.value.length || f.value.lazy ? null : !0 : !a.value.length : !0;
  }), m = pe(!1), g = b(() => ({
    [`${t}--error`]: h.value === !1,
    [`${t}--dirty`]: l.value,
    [`${t}--disabled`]: u.value,
    [`${t}--readonly`]: c.value
  })), p = Ut("validation"), y = b(() => e.name ?? Ct(n));
  ip(() => {
    s == null || s.register({
      id: y.value,
      vm: p,
      validate: _,
      reset: k,
      resetValidation: T
    });
  }), ai(() => {
    s == null || s.unregister(y.value);
  }), En(async () => {
    f.value.lazy || await _(!0), s == null || s.update(y.value, h.value, d.value);
  }), vi(() => f.value.input, () => {
    fe(r, () => {
      if (r.value != null)
        _();
      else if (e.focused) {
        const w = fe(() => e.focused, (S) => {
          S || _(), w();
        });
      }
    });
  }), vi(() => f.value.blur, () => {
    fe(() => e.focused, (w) => {
      w || _();
    });
  }), fe([h, d], () => {
    s == null || s.update(y.value, h.value, d.value);
  });
  async function k() {
    i.value = null, await He(), await T();
  }
  async function T() {
    o.value = !0, f.value.lazy ? a.value = [] : await _(!0);
  }
  async function _() {
    let w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const S = [];
    m.value = !0;
    for (const C of e.rules) {
      if (S.length >= +(e.maxErrors ?? 1))
        break;
      const A = await (typeof C == "function" ? C : () => C)(r.value);
      if (A !== !0) {
        if (A !== !1 && typeof A != "string") {
          console.warn(`${A} is not a valid value. Rule functions must return boolean true or a string.`);
          continue;
        }
        S.push(A || "");
      }
    }
    return a.value = S, m.value = !1, o.value = w, a.value;
  }
  return {
    errorMessages: d,
    isDirty: l,
    isDisabled: u,
    isReadonly: c,
    isPristine: o,
    isValid: h,
    isValidating: m,
    reset: k,
    resetValidation: T,
    validate: _,
    validationClasses: g
  };
}
const As = B({
  id: String,
  appendIcon: We,
  centerAffix: {
    type: Boolean,
    default: !0
  },
  prependIcon: We,
  hideDetails: [Boolean, String],
  hideSpinButtons: Boolean,
  hint: String,
  persistentHint: Boolean,
  messages: {
    type: [Array, String],
    default: () => []
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (e) => ["horizontal", "vertical"].includes(e)
  },
  "onClick:prepend": ri(),
  "onClick:append": ri(),
  ...ke(),
  ..._n(),
  ...ch(Sn(), ["maxWidth", "minWidth", "width"]),
  ...Qe(),
  ...FS()
}, "VInput"), Wn = J()({
  name: "VInput",
  props: {
    ...As()
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i,
      emit: r
    } = t;
    const {
      densityClasses: s
    } = Kn(e), {
      dimensionStyles: a
    } = kn(e), {
      themeClasses: o
    } = lt(e), {
      rtlClasses: l
    } = wn(), {
      InputIcon: u
    } = NS(e), c = Pn(), d = b(() => e.id || `input-${c}`), f = b(() => `${d.value}-messages`), {
      errorMessages: h,
      isDirty: m,
      isDisabled: g,
      isReadonly: p,
      isPristine: y,
      isValid: k,
      isValidating: T,
      reset: _,
      resetValidation: w,
      validate: S,
      validationClasses: C
    } = BS(e, "v-input", d), x = b(() => ({
      id: d,
      messagesId: f,
      isDirty: m,
      isDisabled: g,
      isReadonly: p,
      isPristine: y,
      isValid: k,
      isValidating: T,
      reset: _,
      resetValidation: w,
      validate: S
    })), A = b(() => {
      var I;
      return (I = e.errorMessages) != null && I.length || !y.value && h.value.length ? h.value : e.hint && (e.persistentHint || e.focused) ? e.hint : e.messages;
    });
    return re(() => {
      var N, F, $, Z;
      const I = !!(i.prepend || e.prependIcon), E = !!(i.append || e.appendIcon), P = A.value.length > 0, V = !e.hideDetails || e.hideDetails === "auto" && (P || !!i.details);
      return v("div", {
        class: ["v-input", `v-input--${e.direction}`, {
          "v-input--center-affix": e.centerAffix,
          "v-input--hide-spin-buttons": e.hideSpinButtons
        }, s.value, o.value, l.value, C.value, e.class],
        style: [a.value, e.style]
      }, [I && v("div", {
        key: "prepend",
        class: "v-input__prepend"
      }, [(N = i.prepend) == null ? void 0 : N.call(i, x.value), e.prependIcon && v(u, {
        key: "prepend-icon",
        name: "prepend"
      }, null)]), i.default && v("div", {
        class: "v-input__control"
      }, [(F = i.default) == null ? void 0 : F.call(i, x.value)]), E && v("div", {
        key: "append",
        class: "v-input__append"
      }, [e.appendIcon && v(u, {
        key: "append-icon",
        name: "append"
      }, null), ($ = i.append) == null ? void 0 : $.call(i, x.value)]), V && v("div", {
        class: "v-input__details"
      }, [v(MS, {
        id: f.value,
        active: P,
        messages: A.value
      }, {
        message: i.message
      }), (Z = i.details) == null ? void 0 : Z.call(i, x.value)])]);
    }), {
      reset: _,
      resetValidation: w,
      validate: S,
      isValid: k,
      errorMessages: h
    };
  }
}), qm = Symbol("Forwarded refs");
function Gm(e, t) {
  let n = e;
  for (; n; ) {
    const i = Reflect.getOwnPropertyDescriptor(n, t);
    if (i)
      return i;
    n = Object.getPrototypeOf(n);
  }
}
function Qi(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return e[qm] = n, new Proxy(e, {
    get(r, s) {
      if (Reflect.has(r, s))
        return Reflect.get(r, s);
      if (!(typeof s == "symbol" || s.startsWith("$") || s.startsWith("__"))) {
        for (const a of n)
          if (a.value && Reflect.has(a.value, s)) {
            const o = Reflect.get(a.value, s);
            return typeof o == "function" ? o.bind(a.value) : o;
          }
      }
    },
    has(r, s) {
      if (Reflect.has(r, s))
        return !0;
      if (typeof s == "symbol" || s.startsWith("$") || s.startsWith("__"))
        return !1;
      for (const a of n)
        if (a.value && Reflect.has(a.value, s))
          return !0;
      return !1;
    },
    set(r, s, a) {
      if (Reflect.has(r, s))
        return Reflect.set(r, s, a);
      if (typeof s == "symbol" || s.startsWith("$") || s.startsWith("__"))
        return !1;
      for (const o of n)
        if (o.value && Reflect.has(o.value, s))
          return Reflect.set(o.value, s, a);
      return !1;
    },
    getOwnPropertyDescriptor(r, s) {
      var o;
      const a = Reflect.getOwnPropertyDescriptor(r, s);
      if (a)
        return a;
      if (!(typeof s == "symbol" || s.startsWith("$") || s.startsWith("__"))) {
        for (const l of n) {
          if (!l.value)
            continue;
          const u = Gm(l.value, s) ?? ("_" in l.value ? Gm((o = l.value._) == null ? void 0 : o.setupState, s) : void 0);
          if (u)
            return u;
        }
        for (const l of n) {
          const u = l.value && l.value[qm];
          if (!u)
            continue;
          const c = u.slice();
          for (; c.length; ) {
            const d = c.shift(), f = Gm(d.value, s);
            if (f)
              return f;
            const h = d.value && d.value[qm];
            h && c.push(...h);
          }
        }
      }
    }
  });
}
function VO(e, t) {
  if (!rp)
    return;
  const n = t.modifiers || {}, i = t.value, {
    handler: r,
    options: s
  } = typeof i == "object" ? i : {
    handler: i,
    options: {}
  }, a = new IntersectionObserver(function() {
    var d;
    let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], l = arguments.length > 1 ? arguments[1] : void 0;
    const u = (d = e._observe) == null ? void 0 : d[t.instance.$.uid];
    if (!u)
      return;
    const c = o.some((f) => f.isIntersecting);
    r && (!n.quiet || u.init) && (!n.once || c || u.init) && r(c, o, l), c && n.once ? LS(e, t) : u.init = !0;
  }, s);
  e._observe = Object(e._observe), e._observe[t.instance.$.uid] = {
    init: !1,
    observer: a
  }, a.observe(e);
}
function LS(e, t) {
  var i;
  const n = (i = e._observe) == null ? void 0 : i[t.instance.$.uid];
  n && (n.observer.unobserve(e), delete e._observe[t.instance.$.uid]);
}
const Nc = {
  mounted: VO,
  unmounted: LS
}, DO = ["color", "file", "time", "date", "datetime-local", "week", "month"], Sh = B({
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: [Number, Function],
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  suffix: String,
  role: String,
  type: {
    type: String,
    default: "text"
  },
  modelModifiers: Object,
  ...As(),
  ...Dc()
}, "VTextField"), gi = J()({
  name: "VTextField",
  directives: {
    Intersect: Nc
  },
  inheritAttrs: !1,
  props: Sh(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const s = Ee(e, "modelValue"), {
      isFocused: a,
      focus: o,
      blur: l
    } = xs(e), u = b(() => typeof e.counterValue == "function" ? e.counterValue(s.value) : typeof e.counterValue == "number" ? e.counterValue : (s.value ?? "").toString().length), c = b(() => {
      if (n.maxlength)
        return n.maxlength;
      if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string"))
        return e.counter;
    }), d = b(() => ["plain", "underlined"].includes(e.variant));
    function f(S, C) {
      var x, A;
      !e.autofocus || !S || (A = (x = C[0].target) == null ? void 0 : x.focus) == null || A.call(x);
    }
    const h = X(), m = X(), g = X(), p = b(() => DO.includes(e.type) || e.persistentPlaceholder || a.value || e.active);
    function y() {
      var S;
      g.value !== document.activeElement && ((S = g.value) == null || S.focus()), a.value || o();
    }
    function k(S) {
      i("mousedown:control", S), S.target !== g.value && (y(), S.preventDefault());
    }
    function T(S) {
      y(), i("click:control", S);
    }
    function _(S) {
      S.stopPropagation(), y(), He(() => {
        s.value = null, op(e["onClick:clear"], S);
      });
    }
    function w(S) {
      var x;
      const C = S.target;
      if (s.value = C.value, (x = e.modelModifiers) != null && x.trim && ["text", "search", "password", "tel", "url"].includes(e.type)) {
        const A = [C.selectionStart, C.selectionEnd];
        He(() => {
          C.selectionStart = A[0], C.selectionEnd = A[1];
        });
      }
    }
    return re(() => {
      const S = !!(r.counter || e.counter !== !1 && e.counter != null), C = !!(S || r.details), [x, A] = la(n), {
        modelValue: I,
        ...E
      } = Wn.filterProps(e), P = wp(e);
      return v(Wn, ie({
        ref: h,
        modelValue: s.value,
        "onUpdate:modelValue": (V) => s.value = V,
        class: ["v-text-field", {
          "v-text-field--prefixed": e.prefix,
          "v-text-field--suffixed": e.suffix,
          "v-input--plain-underlined": d.value
        }, e.class],
        style: e.style
      }, x, E, {
        centerAffix: !d.value,
        focused: a.value
      }), {
        ...r,
        default: (V) => {
          let {
            id: N,
            isDisabled: F,
            isDirty: $,
            isReadonly: Z,
            isValid: j
          } = V;
          return v(Wl, ie({
            ref: m,
            onMousedown: k,
            onClick: T,
            "onClick:clear": _,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"],
            role: e.role
          }, P, {
            id: N.value,
            active: p.value || $.value,
            dirty: $.value || e.dirty,
            disabled: F.value,
            focused: a.value,
            error: j.value === !1
          }), {
            ...r,
            default: (H) => {
              let {
                props: {
                  class: R,
                  ...L
                }
              } = H;
              const ne = Rt(v("input", ie({
                ref: g,
                value: s.value,
                onInput: w,
                autofocus: e.autofocus,
                readonly: Z.value,
                disabled: F.value,
                name: e.name,
                placeholder: e.placeholder,
                size: 1,
                type: e.type,
                onFocus: y,
                onBlur: l
              }, L, A), null), [[Ei("intersect"), {
                handler: f
              }, null, {
                once: !0
              }]]);
              return v(De, null, [e.prefix && v("span", {
                class: "v-text-field__prefix"
              }, [v("span", {
                class: "v-text-field__prefix__text"
              }, [e.prefix])]), r.default ? v("div", {
                class: R,
                "data-no-activator": ""
              }, [r.default(), ne]) : HE(ne, {
                class: R
              }), e.suffix && v("span", {
                class: "v-text-field__suffix"
              }, [v("span", {
                class: "v-text-field__suffix__text"
              }, [e.suffix])])]);
            }
          });
        },
        details: C ? (V) => {
          var N;
          return v(De, null, [(N = r.details) == null ? void 0 : N.call(r, V), S && v(De, null, [v("span", null, null), v(gh, {
            active: e.persistentCounter || a.value,
            value: u.value,
            max: c.value,
            disabled: e.disabled
          }, r.counter)])]);
        } : void 0
      });
    }), Qi({}, h, m, g);
  }
}), Zu = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AG: 0,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AS: 0,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BD: 0,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BR: 0,
  BS: 0,
  BT: 0,
  BW: 0,
  BY: 1,
  BZ: 0,
  CA: 0,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CO: 0,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DM: 0,
  DO: 0,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  ET: 0,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  "GB-alt-variant": 0,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  GT: 0,
  GU: 0,
  HK: 0,
  HN: 0,
  HR: 1,
  HU: 1,
  ID: 0,
  IE: 1,
  IL: 0,
  IN: 0,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JM: 0,
  JO: 6,
  JP: 0,
  KE: 0,
  KG: 1,
  KH: 0,
  KR: 0,
  KW: 6,
  KZ: 1,
  LA: 0,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MH: 0,
  MK: 1,
  MM: 0,
  MN: 1,
  MO: 0,
  MQ: 1,
  MT: 0,
  MV: 5,
  MX: 0,
  MY: 1,
  MZ: 0,
  NI: 0,
  NL: 1,
  NO: 1,
  NP: 0,
  NZ: 1,
  OM: 6,
  PA: 0,
  PE: 0,
  PH: 0,
  PK: 0,
  PL: 1,
  PR: 0,
  PT: 0,
  PY: 0,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SA: 0,
  SD: 6,
  SE: 1,
  SG: 0,
  SI: 1,
  SK: 1,
  SM: 1,
  SV: 0,
  SY: 6,
  TH: 0,
  TJ: 1,
  TM: 1,
  TR: 1,
  TT: 0,
  TW: 0,
  UA: 1,
  UM: 0,
  US: 0,
  UY: 1,
  UZ: 1,
  VA: 1,
  VE: 0,
  VI: 0,
  VN: 1,
  WS: 0,
  XK: 1,
  YE: 0,
  ZA: 0,
  ZW: 0
};
function NO(e, t) {
  const n = [];
  let i = [];
  const r = $S(e), s = WS(e), a = (r.getDay() - Zu[t.slice(-2).toUpperCase()] + 7) % 7, o = (s.getDay() - Zu[t.slice(-2).toUpperCase()] + 7) % 7;
  for (let l = 0; l < a; l++) {
    const u = new Date(r);
    u.setDate(u.getDate() - (a - l)), i.push(u);
  }
  for (let l = 1; l <= s.getDate(); l++) {
    const u = new Date(e.getFullYear(), e.getMonth(), l);
    i.push(u), i.length === 7 && (n.push(i), i = []);
  }
  for (let l = 1; l < 7 - o; l++) {
    const u = new Date(s);
    u.setDate(u.getDate() + l), i.push(u);
  }
  return i.length > 0 && n.push(i), n;
}
function MO(e, t) {
  const n = new Date(e);
  for (; n.getDay() !== (Zu[t.slice(-2).toUpperCase()] ?? 0); )
    n.setDate(n.getDate() - 1);
  return n;
}
function RO(e, t) {
  const n = new Date(e), i = ((Zu[t.slice(-2).toUpperCase()] ?? 0) + 6) % 7;
  for (; n.getDay() !== i; )
    n.setDate(n.getDate() + 1);
  return n;
}
function $S(e) {
  return new Date(e.getFullYear(), e.getMonth(), 1);
}
function WS(e) {
  return new Date(e.getFullYear(), e.getMonth() + 1, 0);
}
function FO(e) {
  const t = e.split("-").map(Number);
  return new Date(t[0], t[1] - 1, t[2]);
}
const BO = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/;
function jS(e) {
  if (e == null)
    return /* @__PURE__ */ new Date();
  if (e instanceof Date)
    return e;
  if (typeof e == "string") {
    let t;
    if (BO.test(e))
      return FO(e);
    if (t = Date.parse(e), !isNaN(t))
      return new Date(t);
  }
  return null;
}
const pw = new Date(2e3, 0, 2);
function LO(e) {
  const t = Zu[e.slice(-2).toUpperCase()];
  return Hr(7).map((n) => {
    const i = new Date(pw);
    return i.setDate(pw.getDate() + t + n), new Intl.DateTimeFormat(e, {
      weekday: "narrow"
    }).format(i);
  });
}
function $O(e, t, n, i) {
  const r = jS(e) ?? /* @__PURE__ */ new Date(), s = i == null ? void 0 : i[t];
  if (typeof s == "function")
    return s(r, t, n);
  let a = {};
  switch (t) {
    case "fullDate":
      a = {
        year: "numeric",
        month: "long",
        day: "numeric"
      };
      break;
    case "fullDateWithWeekday":
      a = {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      };
      break;
    case "normalDate":
      const o = r.getDate(), l = new Intl.DateTimeFormat(n, {
        month: "long"
      }).format(r);
      return `${o} ${l}`;
    case "normalDateWithWeekday":
      a = {
        weekday: "short",
        day: "numeric",
        month: "short"
      };
      break;
    case "shortDate":
      a = {
        month: "short",
        day: "numeric"
      };
      break;
    case "year":
      a = {
        year: "numeric"
      };
      break;
    case "month":
      a = {
        month: "long"
      };
      break;
    case "monthShort":
      a = {
        month: "short"
      };
      break;
    case "monthAndYear":
      a = {
        month: "long",
        year: "numeric"
      };
      break;
    case "monthAndDate":
      a = {
        month: "long",
        day: "numeric"
      };
      break;
    case "weekday":
      a = {
        weekday: "long"
      };
      break;
    case "weekdayShort":
      a = {
        weekday: "short"
      };
      break;
    case "dayOfMonth":
      return new Intl.NumberFormat(n).format(r.getDate());
    case "hours12h":
      a = {
        hour: "numeric",
        hour12: !0
      };
      break;
    case "hours24h":
      a = {
        hour: "numeric",
        hour12: !1
      };
      break;
    case "minutes":
      a = {
        minute: "numeric"
      };
      break;
    case "seconds":
      a = {
        second: "numeric"
      };
      break;
    case "fullTime":
      a = {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullTime12h":
      a = {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullTime24h":
      a = {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    case "fullDateTime":
      a = {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullDateTime12h":
      a = {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullDateTime24h":
      a = {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    case "keyboardDate":
      a = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit"
      };
      break;
    case "keyboardDateTime":
      a = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    case "keyboardDateTime12h":
      a = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "keyboardDateTime24h":
      a = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    default:
      a = s ?? {
        timeZone: "UTC",
        timeZoneName: "short"
      };
  }
  return new Intl.DateTimeFormat(n, a).format(r);
}
function WO(e, t) {
  const n = e.toJsDate(t), i = n.getFullYear(), r = qb(String(n.getMonth() + 1), 2, "0"), s = qb(String(n.getDate()), 2, "0");
  return `${i}-${r}-${s}`;
}
function jO(e) {
  const [t, n, i] = e.split("-").map(Number);
  return new Date(t, n - 1, i);
}
function HO(e, t) {
  const n = new Date(e);
  return n.setMinutes(n.getMinutes() + t), n;
}
function zO(e, t) {
  const n = new Date(e);
  return n.setHours(n.getHours() + t), n;
}
function UO(e, t) {
  const n = new Date(e);
  return n.setDate(n.getDate() + t), n;
}
function qO(e, t) {
  const n = new Date(e);
  return n.setDate(n.getDate() + t * 7), n;
}
function GO(e, t) {
  const n = new Date(e);
  return n.setDate(1), n.setMonth(n.getMonth() + t), n;
}
function YO(e) {
  return e.getFullYear();
}
function ZO(e) {
  return e.getMonth();
}
function KO(e) {
  return e.getDate();
}
function XO(e) {
  return new Date(e.getFullYear(), e.getMonth() + 1, 1);
}
function JO(e) {
  return new Date(e.getFullYear(), e.getMonth() - 1, 1);
}
function QO(e) {
  return e.getHours();
}
function eV(e) {
  return e.getMinutes();
}
function tV(e) {
  return new Date(e.getFullYear(), 0, 1);
}
function nV(e) {
  return new Date(e.getFullYear(), 11, 31);
}
function iV(e, t) {
  return gf(e, t[0]) && aV(e, t[1]);
}
function rV(e) {
  const t = new Date(e);
  return t instanceof Date && !isNaN(t.getTime());
}
function gf(e, t) {
  return e.getTime() > t.getTime();
}
function sV(e, t) {
  return gf(Rv(e), Rv(t));
}
function aV(e, t) {
  return e.getTime() < t.getTime();
}
function yw(e, t) {
  return e.getTime() === t.getTime();
}
function oV(e, t) {
  return e.getDate() === t.getDate() && e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear();
}
function lV(e, t) {
  return e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear();
}
function uV(e, t) {
  return e.getFullYear() === t.getFullYear();
}
function cV(e, t, n) {
  const i = new Date(e), r = new Date(t);
  switch (n) {
    case "years":
      return i.getFullYear() - r.getFullYear();
    case "quarters":
      return Math.floor((i.getMonth() - r.getMonth() + (i.getFullYear() - r.getFullYear()) * 12) / 4);
    case "months":
      return i.getMonth() - r.getMonth() + (i.getFullYear() - r.getFullYear()) * 12;
    case "weeks":
      return Math.floor((i.getTime() - r.getTime()) / (1e3 * 60 * 60 * 24 * 7));
    case "days":
      return Math.floor((i.getTime() - r.getTime()) / (1e3 * 60 * 60 * 24));
    case "hours":
      return Math.floor((i.getTime() - r.getTime()) / (1e3 * 60 * 60));
    case "minutes":
      return Math.floor((i.getTime() - r.getTime()) / (1e3 * 60));
    case "seconds":
      return Math.floor((i.getTime() - r.getTime()) / 1e3);
    default:
      return i.getTime() - r.getTime();
  }
}
function dV(e, t) {
  const n = new Date(e);
  return n.setHours(t), n;
}
function fV(e, t) {
  const n = new Date(e);
  return n.setMinutes(t), n;
}
function hV(e, t) {
  const n = new Date(e);
  return n.setMonth(t), n;
}
function mV(e, t) {
  const n = new Date(e);
  return n.setDate(t), n;
}
function vV(e, t) {
  const n = new Date(e);
  return n.setFullYear(t), n;
}
function Rv(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 0, 0, 0, 0);
}
function gV(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 23, 59, 59, 999);
}
class pV {
  constructor(t) {
    this.locale = t.locale, this.formats = t.formats;
  }
  date(t) {
    return jS(t);
  }
  toJsDate(t) {
    return t;
  }
  toISO(t) {
    return WO(this, t);
  }
  parseISO(t) {
    return jO(t);
  }
  addMinutes(t, n) {
    return HO(t, n);
  }
  addHours(t, n) {
    return zO(t, n);
  }
  addDays(t, n) {
    return UO(t, n);
  }
  addWeeks(t, n) {
    return qO(t, n);
  }
  addMonths(t, n) {
    return GO(t, n);
  }
  getWeekArray(t) {
    return NO(t, this.locale);
  }
  startOfWeek(t) {
    return MO(t, this.locale);
  }
  endOfWeek(t) {
    return RO(t, this.locale);
  }
  startOfMonth(t) {
    return $S(t);
  }
  endOfMonth(t) {
    return WS(t);
  }
  format(t, n) {
    return $O(t, n, this.locale, this.formats);
  }
  isEqual(t, n) {
    return yw(t, n);
  }
  isValid(t) {
    return rV(t);
  }
  isWithinRange(t, n) {
    return iV(t, n);
  }
  isAfter(t, n) {
    return gf(t, n);
  }
  isAfterDay(t, n) {
    return sV(t, n);
  }
  isBefore(t, n) {
    return !gf(t, n) && !yw(t, n);
  }
  isSameDay(t, n) {
    return oV(t, n);
  }
  isSameMonth(t, n) {
    return lV(t, n);
  }
  isSameYear(t, n) {
    return uV(t, n);
  }
  setMinutes(t, n) {
    return fV(t, n);
  }
  setHours(t, n) {
    return dV(t, n);
  }
  setMonth(t, n) {
    return hV(t, n);
  }
  setDate(t, n) {
    return mV(t, n);
  }
  setYear(t, n) {
    return vV(t, n);
  }
  getDiff(t, n, i) {
    return cV(t, n, i);
  }
  getWeekdays() {
    return LO(this.locale);
  }
  getYear(t) {
    return YO(t);
  }
  getMonth(t) {
    return ZO(t);
  }
  getDate(t) {
    return KO(t);
  }
  getNextMonth(t) {
    return XO(t);
  }
  getPreviousMonth(t) {
    return JO(t);
  }
  getHours(t) {
    return QO(t);
  }
  getMinutes(t) {
    return eV(t);
  }
  startOfDay(t) {
    return Rv(t);
  }
  endOfDay(t) {
    return gV(t);
  }
  startOfYear(t) {
    return tV(t);
  }
  endOfYear(t) {
    return nV(t);
  }
}
const HS = Symbol.for("vuetify:date-options"), bw = Symbol.for("vuetify:date-adapter");
function yV(e, t) {
  const n = qn({
    adapter: pV,
    locale: {
      af: "af-ZA",
      // ar: '', # not the same value for all variants
      bg: "bg-BG",
      ca: "ca-ES",
      ckb: "",
      cs: "cs-CZ",
      de: "de-DE",
      el: "el-GR",
      en: "en-US",
      // es: '', # not the same value for all variants
      et: "et-EE",
      fa: "fa-IR",
      fi: "fi-FI",
      // fr: '', #not the same value for all variants
      hr: "hr-HR",
      hu: "hu-HU",
      he: "he-IL",
      id: "id-ID",
      it: "it-IT",
      ja: "ja-JP",
      ko: "ko-KR",
      lv: "lv-LV",
      lt: "lt-LT",
      nl: "nl-NL",
      no: "no-NO",
      pl: "pl-PL",
      pt: "pt-PT",
      ro: "ro-RO",
      ru: "ru-RU",
      sk: "sk-SK",
      sl: "sl-SI",
      srCyrl: "sr-SP",
      srLatn: "sr-SP",
      sv: "sv-SE",
      th: "th-TH",
      tr: "tr-TR",
      az: "az-AZ",
      uk: "uk-UA",
      vi: "vi-VN",
      zhHans: "zh-CN",
      zhHant: "zh-TW"
    }
  }, e);
  return {
    options: n,
    instance: zS(n, t)
  };
}
function zS(e, t) {
  const n = ti(typeof e.adapter == "function" ? new e.adapter({
    locale: e.locale[t.current.value] ?? t.current.value,
    formats: e.formats
  }) : e.adapter);
  return fe(t.current, (i) => {
    n.locale = e.locale[i] ?? i ?? n.locale;
  }), n;
}
function Mc() {
  const e = tt(HS);
  if (!e)
    throw new Error("[Vuetify] Could not find injected date options");
  const t = qt();
  return zS(e, t);
}
function bV(e, t) {
  const n = e.toJsDate(t);
  let i = n.getFullYear(), r = new Date(i, 0, 1);
  if (n < r)
    i = i - 1, r = new Date(i, 0, 1);
  else {
    const o = new Date(i + 1, 0, 1);
    n >= o && (i = i + 1, r = o);
  }
  const s = Math.abs(n.getTime() - r.getTime()), a = Math.ceil(s / (1e3 * 60 * 60 * 24));
  return Math.floor(a / 7) + 1;
}
const kh = ["sm", "md", "lg", "xl", "xxl"], Fv = Symbol.for("vuetify:display"), ww = {
  mobileBreakpoint: "lg",
  thresholds: {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920,
    xxl: 2560
  }
}, wV = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ww;
  return qn(ww, e);
};
function _w(e) {
  return ft && !e ? window.innerWidth : typeof e == "object" && e.clientWidth || 0;
}
function Sw(e) {
  return ft && !e ? window.innerHeight : typeof e == "object" && e.clientHeight || 0;
}
function kw(e) {
  const t = ft && !e ? window.navigator.userAgent : "ssr";
  function n(m) {
    return !!t.match(m);
  }
  const i = n(/android/i), r = n(/iphone|ipad|ipod/i), s = n(/cordova/i), a = n(/electron/i), o = n(/chrome/i), l = n(/edge/i), u = n(/firefox/i), c = n(/opera/i), d = n(/win/i), f = n(/mac/i), h = n(/linux/i);
  return {
    android: i,
    ios: r,
    cordova: s,
    electron: a,
    chrome: o,
    edge: l,
    firefox: u,
    opera: c,
    win: d,
    mac: f,
    linux: h,
    touch: iP,
    ssr: t === "ssr"
  };
}
function _V(e, t) {
  const {
    thresholds: n,
    mobileBreakpoint: i
  } = wV(e), r = pe(Sw(t)), s = pe(kw(t)), a = ti({}), o = pe(_w(t));
  function l() {
    r.value = Sw(), o.value = _w();
  }
  function u() {
    l(), s.value = kw();
  }
  return Wt(() => {
    const c = o.value < n.sm, d = o.value < n.md && !c, f = o.value < n.lg && !(d || c), h = o.value < n.xl && !(f || d || c), m = o.value < n.xxl && !(h || f || d || c), g = o.value >= n.xxl, p = c ? "xs" : d ? "sm" : f ? "md" : h ? "lg" : m ? "xl" : "xxl", y = typeof i == "number" ? i : n[i], k = o.value < y;
    a.xs = c, a.sm = d, a.md = f, a.lg = h, a.xl = m, a.xxl = g, a.smAndUp = !c, a.mdAndUp = !(c || d), a.lgAndUp = !(c || d || f), a.xlAndUp = !(c || d || f || h), a.smAndDown = !(f || h || m || g), a.mdAndDown = !(h || m || g), a.lgAndDown = !(m || g), a.xlAndDown = !g, a.name = p, a.height = r.value, a.width = o.value, a.mobile = k, a.mobileBreakpoint = i, a.platform = s.value, a.thresholds = n;
  }), ft && window.addEventListener("resize", l, {
    passive: !0
  }), {
    ...lh(a),
    update: u,
    ssr: !!t
  };
}
const jl = B({
  mobile: {
    type: Boolean,
    default: !1
  },
  mobileBreakpoint: [Number, String]
}, "display");
function Ar() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Kr();
  const n = tt(Fv);
  if (!n)
    throw new Error("Could not find Vuetify display injection");
  const i = b(() => {
    if (e.mobile != null)
      return e.mobile;
    if (!e.mobileBreakpoint)
      return n.mobile.value;
    const s = typeof e.mobileBreakpoint == "number" ? e.mobileBreakpoint : n.thresholds.value[e.mobileBreakpoint];
    return n.width.value < s;
  }), r = b(() => t ? {
    [`${t}--mobile`]: i.value
  } : {});
  return {
    ...n,
    displayClasses: r,
    mobile: i
  };
}
const US = Symbol.for("vuetify:goto");
function qS() {
  return {
    container: void 0,
    duration: 300,
    layout: !1,
    offset: 0,
    easing: "easeInOutCubic",
    patterns: {
      linear: (e) => e,
      easeInQuad: (e) => e ** 2,
      easeOutQuad: (e) => e * (2 - e),
      easeInOutQuad: (e) => e < 0.5 ? 2 * e ** 2 : -1 + (4 - 2 * e) * e,
      easeInCubic: (e) => e ** 3,
      easeOutCubic: (e) => --e ** 3 + 1,
      easeInOutCubic: (e) => e < 0.5 ? 4 * e ** 3 : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1,
      easeInQuart: (e) => e ** 4,
      easeOutQuart: (e) => 1 - --e ** 4,
      easeInOutQuart: (e) => e < 0.5 ? 8 * e ** 4 : 1 - 8 * --e ** 4,
      easeInQuint: (e) => e ** 5,
      easeOutQuint: (e) => 1 + --e ** 5,
      easeInOutQuint: (e) => e < 0.5 ? 16 * e ** 5 : 1 + 16 * --e ** 5
    }
  };
}
function SV(e) {
  return _p(e) ?? (document.scrollingElement || document.body);
}
function _p(e) {
  return typeof e == "string" ? document.querySelector(e) : sp(e);
}
function Ym(e, t, n) {
  if (typeof e == "number")
    return t && n ? -e : e;
  let i = _p(e), r = 0;
  for (; i; )
    r += t ? i.offsetLeft : i.offsetTop, i = i.offsetParent;
  return r;
}
function kV(e, t) {
  return {
    rtl: t.isRtl,
    options: qn(qS(), e)
  };
}
async function Cw(e, t, n, i) {
  const r = n ? "scrollLeft" : "scrollTop", s = qn((i == null ? void 0 : i.options) ?? qS(), t), a = i == null ? void 0 : i.rtl.value, o = (typeof e == "number" ? e : _p(e)) ?? 0, l = s.container === "parent" && o instanceof HTMLElement ? o.parentElement : SV(s.container), u = typeof s.easing == "function" ? s.easing : s.patterns[s.easing];
  if (!u)
    throw new TypeError(`Easing function "${s.easing}" not found.`);
  let c;
  if (typeof o == "number")
    c = Ym(o, n, a);
  else if (c = Ym(o, n, a) - Ym(l, n, a), s.layout) {
    const m = window.getComputedStyle(o).getPropertyValue("--v-layout-top");
    m && (c -= parseInt(m, 10));
  }
  c += s.offset, c = TV(l, c, !!a, !!n);
  const d = l[r] ?? 0;
  if (c === d)
    return Promise.resolve(c);
  const f = performance.now();
  return new Promise((h) => requestAnimationFrame(function m(g) {
    const y = (g - f) / s.duration, k = Math.floor(d + (c - d) * u(Xt(y, 0, 1)));
    if (l[r] = k, y >= 1 && Math.abs(k - l[r]) < 10)
      return h(c);
    if (y > 2)
      return pr("Scroll target is not reachable"), h(l[r]);
    requestAnimationFrame(m);
  }));
}
function CV() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const t = tt(US), {
    isRtl: n
  } = wn();
  if (!t)
    throw new Error("[Vuetify] Could not find injected goto instance");
  const i = {
    ...t,
    // can be set via VLocaleProvider
    rtl: b(() => t.rtl.value || n.value)
  };
  async function r(s, a) {
    return Cw(s, qn(e, a), !1, i);
  }
  return r.horizontal = async (s, a) => Cw(s, qn(e, a), !0, i), r;
}
function TV(e, t, n, i) {
  const {
    scrollWidth: r,
    scrollHeight: s
  } = e, [a, o] = e === document.scrollingElement ? [window.innerWidth, window.innerHeight] : [e.offsetWidth, e.offsetHeight];
  let l, u;
  return i ? n ? (l = -(r - a), u = 0) : (l = 0, u = r - a) : (l = 0, u = s + -o), Math.max(Math.min(t, u), l);
}
function Sr(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
  const n = ff(), i = X();
  if (ft) {
    const r = new ResizeObserver((s) => {
      e == null || e(s, r), s.length && (t === "content" ? i.value = s[0].contentRect : i.value = s[0].target.getBoundingClientRect());
    });
    ai(() => {
      r.disconnect();
    }), fe(() => n.el, (s, a) => {
      a && (r.unobserve(a), i.value = void 0), s && r.observe(s);
    }, {
      flush: "post"
    });
  }
  return {
    resizeRef: n,
    contentRect: Fl(i)
  };
}
const Ku = Symbol.for("vuetify:layout"), GS = Symbol.for("vuetify:layout-item"), Tw = 1e3, YS = B({
  overlaps: {
    type: Array,
    default: () => []
  },
  fullHeight: Boolean
}, "layout"), bo = B({
  name: {
    type: String
  },
  order: {
    type: [Number, String],
    default: 0
  },
  absolute: Boolean
}, "layout-item");
function ZS() {
  const e = tt(Ku);
  if (!e)
    throw new Error("[Vuetify] Could not find injected layout");
  return {
    layoutIsReady: He(),
    getLayoutItem: e.getLayoutItem,
    mainRect: e.mainRect,
    mainStyles: e.mainStyles
  };
}
function wo(e) {
  const t = tt(Ku);
  if (!t)
    throw new Error("[Vuetify] Could not find injected layout");
  const n = e.id ?? `layout-item-${Pn()}`, i = Ut("useLayoutItem");
  Tt(GS, {
    id: n
  });
  const r = pe(!1);
  zE(() => r.value = !0), UE(() => r.value = !1);
  const s = He(), {
    layoutItemStyles: a,
    layoutItemScrimStyles: o
  } = t.register(i, {
    ...e,
    active: b(() => r.value ? !1 : e.active.value),
    id: n
  });
  return ai(() => t.unregister(n)), {
    layoutItemStyles: a,
    layoutRect: t.layoutRect,
    layoutItemScrimStyles: o,
    layoutIsReady: s
  };
}
const xV = (e, t, n, i) => {
  let r = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  };
  const s = [{
    id: "",
    layer: {
      ...r
    }
  }];
  for (const a of e) {
    const o = t.get(a), l = n.get(a), u = i.get(a);
    if (!o || !l || !u)
      continue;
    const c = {
      ...r,
      [o.value]: parseInt(r[o.value], 10) + (u.value ? parseInt(l.value, 10) : 0)
    };
    s.push({
      id: a,
      layer: c
    }), r = c;
  }
  return s;
};
function KS(e) {
  const t = tt(Ku, null), n = b(() => t ? t.rootZIndex.value - 100 : Tw), i = X([]), r = ti(/* @__PURE__ */ new Map()), s = ti(/* @__PURE__ */ new Map()), a = ti(/* @__PURE__ */ new Map()), o = ti(/* @__PURE__ */ new Map()), l = ti(/* @__PURE__ */ new Map()), {
    resizeRef: u,
    contentRect: c
  } = Sr(), d = Zb(() => {
    const w = [...new Set([...a.values()].map((C) => C.value))].sort((C, x) => C - x), S = [];
    for (const C of w) {
      const x = i.value.filter((A) => {
        var I;
        return ((I = a.get(A)) == null ? void 0 : I.value) === C;
      });
      S.push(...x);
    }
    return xV(S, r, s, o);
  }), f = b(() => !Array.from(l.values()).some((w) => w.value)), h = b(() => d.value[d.value.length - 1].layer), m = b(() => ({
    "--v-layout-left": _e(h.value.left),
    "--v-layout-right": _e(h.value.right),
    "--v-layout-top": _e(h.value.top),
    "--v-layout-bottom": _e(h.value.bottom),
    ...f.value ? void 0 : {
      transition: "none"
    }
  })), g = Zb(() => d.value.slice(1).map((w, S) => {
    let {
      id: C
    } = w;
    const {
      layer: x
    } = d.value[S], A = s.get(C), I = r.get(C);
    return {
      id: C,
      ...x,
      size: Number(A.value),
      position: I.value
    };
  })), p = (w) => g.value.find((S) => S.id === w), y = Ut("createLayout"), k = He();
  Tt(Ku, {
    register: (w, S) => {
      let {
        id: C,
        order: x,
        position: A,
        layoutSize: I,
        elementSize: E,
        active: P,
        disableTransitions: V,
        absolute: N
      } = S;
      a.set(C, x), r.set(C, A), s.set(C, I), o.set(C, P), V && l.set(C, V);
      const $ = Ko(GS, y == null ? void 0 : y.vnode).indexOf(w);
      $ > -1 ? i.value.splice($, 0, C) : i.value.push(C);
      const Z = b(() => g.value.findIndex((L) => L.id === C)), j = b(() => n.value + d.value.length * 2 - Z.value * 2), H = b(() => {
        const L = A.value === "left" || A.value === "right", ne = A.value === "right", oe = A.value === "bottom", we = E.value ?? I.value, ee = we === 0 ? "%" : "px", K = {
          [A.value]: 0,
          zIndex: j.value,
          transform: `translate${L ? "X" : "Y"}(${(P.value ? 0 : -(we === 0 ? 100 : we)) * (ne || oe ? -1 : 1)}${ee})`,
          position: N.value || n.value !== Tw ? "absolute" : "fixed",
          ...f.value ? void 0 : {
            transition: "none"
          }
        };
        if (Z.value < 0)
          throw new Error(`Layout item "${C}" is missing`);
        const ue = g.value[Z.value];
        if (!ue)
          throw new Error(`[Vuetify] Could not find layout item "${C}"`);
        return {
          ...K,
          height: L ? `calc(100% - ${ue.top}px - ${ue.bottom}px)` : E.value ? `${E.value}px` : void 0,
          left: ne ? void 0 : `${ue.left}px`,
          right: ne ? `${ue.right}px` : void 0,
          top: A.value !== "bottom" ? `${ue.top}px` : void 0,
          bottom: A.value !== "top" ? `${ue.bottom}px` : void 0,
          width: L ? E.value ? `${E.value}px` : void 0 : `calc(100% - ${ue.left}px - ${ue.right}px)`
        };
      }), R = b(() => ({
        zIndex: j.value - 1
      }));
      return {
        layoutItemStyles: H,
        layoutItemScrimStyles: R,
        zIndex: j
      };
    },
    unregister: (w) => {
      a.delete(w), r.delete(w), s.delete(w), o.delete(w), l.delete(w), i.value = i.value.filter((S) => S !== w);
    },
    mainRect: h,
    mainStyles: m,
    getLayoutItem: p,
    items: g,
    layoutRect: c,
    rootZIndex: n,
    layoutIsReady: k
  });
  const T = b(() => ["v-layout", {
    "v-layout--full-height": e.fullHeight
  }]), _ = b(() => ({
    zIndex: t ? n.value : void 0,
    position: t ? "relative" : void 0,
    overflow: t ? "hidden" : void 0
  }));
  return {
    layoutClasses: T,
    layoutStyles: _,
    getLayoutItem: p,
    items: g,
    layoutRect: c,
    layoutIsReady: k,
    layoutRef: u
  };
}
function XS() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    blueprint: t,
    ...n
  } = e, i = qn(t, n), {
    aliases: r = {},
    components: s = {},
    directives: a = {}
  } = i, o = BP(i.defaults), l = _V(i.display, i.ssr), u = aO(i.theme), c = mO(i.icons), d = _O(i.locale), f = yV(i.date, d), h = kV(i.goTo, d);
  return {
    install: (g) => {
      for (const p in a)
        g.directive(p, a[p]);
      for (const p in s)
        g.component(p, s[p]);
      for (const p in r)
        g.component(p, Pi({
          ...r[p],
          name: p,
          aliasName: r[p].name
        }));
      if (u.install(g), g.provide(yl, o), g.provide(Fv, l), g.provide(Yu, u), g.provide(Nv, c), g.provide(bl, d), g.provide(HS, f.options), g.provide(bw, f.instance), g.provide(US, h), ft && i.ssr)
        if (g.$nuxt)
          g.$nuxt.hook("app:suspense:resolve", () => {
            l.update();
          });
        else {
          const {
            mount: p
          } = g;
          g.mount = function() {
            const y = p(...arguments);
            return He(() => l.update()), g.mount = p, y;
          };
        }
      Pn.reset(), g.mixin({
        computed: {
          $vuetify() {
            return ti({
              defaults: Fo.call(this, yl),
              display: Fo.call(this, Fv),
              theme: Fo.call(this, Yu),
              icons: Fo.call(this, Nv),
              locale: Fo.call(this, bl),
              date: Fo.call(this, bw)
            });
          }
        }
      });
    },
    defaults: o,
    display: l,
    theme: u,
    icons: c,
    locale: d,
    date: f,
    goTo: h
  };
}
const AV = "3.6.7";
XS.version = AV;
function Fo(e) {
  var i, r;
  const t = this.$, n = ((i = t.parent) == null ? void 0 : i.provides) ?? ((r = t.vnode.appContext) == null ? void 0 : r.provides);
  if (n && e in n)
    return n[e];
}
var fi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function IV(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function EV(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function i() {
      return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(e, i);
    Object.defineProperty(n, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return e[i];
      }
    });
  }), n;
}
var JS = {}, QS = {}, ek = {}, tk = {}, hr = {};
const PV = {}, OV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PV
}, Symbol.toStringTag, { value: "Module" })), VV = /* @__PURE__ */ EV(OV);
Object.defineProperty(hr, "__esModule", { value: !0 });
hr.getCrypto = hr.getRootWebCrypto = hr.getWebCrypto = hr.getNodeCrypto = void 0;
var Sp = function() {
  if (!(typeof window < "u" && window.crypto))
    return typeof window > "u" && typeof crypto < "u" ? void 0 : VV;
};
hr.getNodeCrypto = Sp;
var kp = function() {
  if (typeof window < "u" && window.crypto)
    return window.crypto.subtle;
  if (typeof window > "u" && typeof crypto < "u")
    return crypto.subtle;
};
hr.getWebCrypto = kp;
var nk = function() {
  if (typeof window < "u" && window.crypto)
    return window.crypto;
  if (typeof window > "u" && typeof crypto < "u")
    return crypto;
};
hr.getRootWebCrypto = nk;
var ik = function() {
  var e = kp(), t = Sp();
  return typeof t < "u" ? { name: "nodeCrypto", crypto: t } : typeof e < "u" ? { name: "webCrypto", crypto: e } : { name: void 0 };
};
hr.getCrypto = ik;
hr.default = { getNodeCrypto: Sp, getWebCrypto: kp, getRootWebCrypto: nk, getCrypto: ik };
(function(e) {
  var t = fi && fi.__createBinding || (Object.create ? function(u, c, d, f) {
    f === void 0 && (f = d), Object.defineProperty(u, f, { enumerable: !0, get: function() {
      return c[d];
    } });
  } : function(u, c, d, f) {
    f === void 0 && (f = d), u[f] = c[d];
  }), n = fi && fi.__setModuleDefault || (Object.create ? function(u, c) {
    Object.defineProperty(u, "default", { enumerable: !0, value: c });
  } : function(u, c) {
    u.default = c;
  }), i = fi && fi.__importStar || function(u) {
    if (u && u.__esModule)
      return u;
    var c = {};
    if (u != null)
      for (var d in u)
        d !== "default" && Object.prototype.hasOwnProperty.call(u, d) && t(c, u, d);
    return n(c, u), c;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getRandomBytes = e.getRandomSampledString = e.getRandomAsciiString = e.getRandomString = void 0;
  var r = i(hr), s = function(u) {
    for (var c = (0, e.getRandomBytes)(u), d = (0, e.getRandomBytes)(u), f = "", h = 0; h < u; h++)
      d[h] = d[h] % 3, c[h] = d[h] === 0 ? c[h] % 10 + 48 : c[h] % 26 + (d[h] === 1 ? 65 : 97), f += String.fromCharCode(c[h]);
    return f;
  };
  e.getRandomString = s;
  var a = function(u) {
    for (var c = (0, e.getRandomBytes)(u), d = "", f = 0; f < u; f++)
      c[f] = c[f] % 94 + 32, d += String.fromCharCode(c[f]);
    return d;
  };
  e.getRandomAsciiString = a;
  var o = function(u, c) {
    var d = c.length;
    if (d === 0)
      return "";
    for (var f = (0, e.getRandomBytes)(u), h = "", m = 0; m < u; m++)
      h += c[f[m] % d];
    return h;
  };
  e.getRandomSampledString = o;
  var l = function(u) {
    var c = r.getRootWebCrypto(), d = r.getNodeCrypto();
    if (typeof c < "u" && typeof c.getRandomValues == "function") {
      var f = new Uint8Array(u);
      return c.getRandomValues(f), f;
    } else {
      if (typeof d < "u")
        return new Uint8Array(d.randomBytes(u));
      throw new Error("UnsupportedEnvironment");
    }
  };
  e.getRandomBytes = l;
})(tk);
(function(e) {
  var t = fi && fi.__createBinding || (Object.create ? function(s, a, o, l) {
    l === void 0 && (l = o), Object.defineProperty(s, l, { enumerable: !0, get: function() {
      return a[o];
    } });
  } : function(s, a, o, l) {
    l === void 0 && (l = o), s[l] = a[o];
  }), n = fi && fi.__setModuleDefault || (Object.create ? function(s, a) {
    Object.defineProperty(s, "default", { enumerable: !0, value: a });
  } : function(s, a) {
    s.default = a;
  }), i = fi && fi.__importStar || function(s) {
    if (s && s.__esModule)
      return s;
    var a = {};
    if (s != null)
      for (var o in s)
        o !== "default" && Object.prototype.hasOwnProperty.call(s, o) && t(a, s, o);
    return n(a, s), a;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getRandomSampledString = e.getRandomString = e.getRandomAsciiString = e.getRandomBytes = void 0;
  var r = i(tk);
  e.getRandomBytes = r.getRandomBytes, e.getRandomAsciiString = r.getRandomAsciiString, e.getRandomString = r.getRandomString, e.getRandomSampledString = r.getRandomSampledString, e.default = { getRandomBytes: e.getRandomBytes, getRandomAsciiString: e.getRandomAsciiString, getRandomString: e.getRandomString, getRandomSampledString: e.getRandomSampledString };
})(ek);
(function(e) {
  var t = fi && fi.__importDefault || function(y) {
    return y && y.__esModule ? y : { default: y };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.generateMultiple = e.generate = void 0;
  var n = t(ek), i = 256, r = void 0, s = new Uint8Array(), a = function() {
    (r === void 0 || r >= s.length) && (r = 0, s = n.default.getRandomBytes(i));
    var y = s[r];
    return r += 1, y;
  }, o = function(y) {
    for (var k = a(); k >= 256 - 256 % y; )
      k = a();
    return k % y;
  }, l = "abcdefghijklmnopqrstuvwxyz", u = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", c = "0123456789", d = "\\!@#$%^&*()+_-=}{[]|:;\"/?.><,`~'", f = /[ilLI|`oO0]/g, h = [
    { name: "lowercase", rule: /[a-z]/ },
    { name: "uppercase", rule: /[A-Z]/ },
    { name: "numbers", rule: /[0-9]/ },
    { name: "symbols", rule: /[\\!@#$%^&*()+_\-=}{[\]|:;"/?.><,`~']/ }
  ], m = function(y, k) {
    for (var T = "", _ = y.length, w = k.length, S = 0; S < _; S++)
      T += k[o(w)];
    if (y.strict) {
      var C = h.every(function(x) {
        if (y[x.name || "uppercase"] == !1)
          return !0;
        if (x.name === "symbols" && typeof y[x.name] == "string") {
          var A = new RegExp("[".concat(y[x.name], "]"));
          return A.test(T);
        }
        return x.rule.test(T);
      });
      if (!C)
        return m(y, k);
    }
    return T;
  }, g = function(y) {
    if (y = y || {}, Object.prototype.hasOwnProperty.call(y, "length") || (y.length = 10), Object.prototype.hasOwnProperty.call(y, "numbers") || (y.numbers = !1), Object.prototype.hasOwnProperty.call(y, "symbols") || (y.symbols = !1), Object.prototype.hasOwnProperty.call(y, "exclude") || (y.exclude = ""), Object.prototype.hasOwnProperty.call(y, "uppercase") || (y.uppercase = !0), Object.prototype.hasOwnProperty.call(y, "lowercase") || (y.lowercase = !0), Object.prototype.hasOwnProperty.call(y, "excludeSimilarCharacters") || (y.excludeSimilarCharacters = !1), Object.prototype.hasOwnProperty.call(y, "strict") || (y.strict = !1), y.strict) {
      var k = 1 + (y.numbers ? 1 : 0) + (y.symbols ? 1 : 0) + (y.uppercase ? 1 : 0);
      if (k > y.length)
        throw new TypeError("Length must correlate with strict guidelines");
    }
    var T = "";
    if (y.lowercase && (T += l), y.uppercase && (T += u), y.numbers && (T += c), y.symbols && (typeof y.symbols == "string" ? T += y.symbols : T += d), !T)
      throw new TypeError("At least one rule for pools must be true");
    y.excludeSimilarCharacters && (T = T.replace(f, ""));
    for (var _ = y.exclude.length; _--; )
      T = T.replace(y.exclude[_], "");
    return m(y, T);
  };
  e.generate = g;
  var p = function(y, k) {
    for (var T = [], _ = 0; _ < y; _++)
      T.push((0, e.generate)(k));
    return T;
  };
  e.generateMultiple = p;
})(QS);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.generateMultiple = e.generate = void 0;
  var t = QS;
  Object.defineProperty(e, "generate", { enumerable: !0, get: function() {
    return t.generate;
  } }), Object.defineProperty(e, "generateMultiple", { enumerable: !0, get: function() {
    return t.generateMultiple;
  } }), e.default = { generate: t.generate, generateMultiple: t.generateMultiple };
})(JS);
const DV = /* @__PURE__ */ IV(JS), NV = Bl({
  name: "VPPasswordField",
  props: {
    ...gi.props,
    /**
     * Whether to show the password generator button
     */
    showGenerator: {
      type: Boolean,
      default: !1
    },
    /**
     * The length of the password to generate
     */
    generatePasswordLength: {
      type: Number,
      default: 12
    },
    /**
     * Whether to include numbers in the generated password
     */
    generatePasswordWithNumbers: {
      type: Boolean,
      default: !0
    },
    /**
     * Whether to include symbols in the generated password
     */
    generatePasswordWithSymbols: {
      type: Boolean,
      default: !0
    },
    /**
     * Whether to include uppercase characters in the generated password
     */
    generatePasswordWithUppercase: {
      type: Boolean,
      default: !0
    },
    /**
     * Whether to exclude similar characters in the generated password
     */
    generatePasswordExcludingSimilarCharacters: {
      type: Boolean,
      default: !0
    }
  },
  emits: [
    ...Object.keys({ ...gi.emits }),
    /**
     * Emitted when the password generator button is clicked
     */
    "generate-password"
  ],
  setup(e, { emit: t }) {
    const n = X("password"), i = b(() => e.generatePasswordLength), r = b(
      () => e.generatePasswordWithNumbers
    ), s = b(
      () => e.generatePasswordWithSymbols
    ), a = b(
      () => e.generatePasswordWithUppercase
    ), o = b(
      () => e.generatePasswordExcludingSimilarCharacters
    ), l = b(
      () => n.value === "password" ? "mdi-eye-lock-open-outline" : "mdi-eye-off-outline"
    ), u = () => {
      n.value = n.value === "password" ? "text" : "password";
    }, c = () => {
      const p = DV.generate({
        length: i.value,
        numbers: r.value,
        symbols: s.value,
        uppercase: a.value,
        excludeSimilarCharacters: o.value
      });
      n.value = "text", t("generate-password", p), t("update:modelValue", p);
    }, d = b(() => e), f = ja(d.value, "VTextField"), h = b(() => ({
      ...f,
      type: n.value,
      "append-inner-icon": void 0
    })), m = b(() => {
      const p = {};
      return Object.keys({ ...gi.emits }).forEach((y) => {
        p[y] = (k) => t(y, k);
      }), p;
    }), g = X(void 0);
    return {
      updatedProps: h,
      updatedEmitters: m,
      field: g,
      onGeneratePassword: c,
      passwordFieldTypeIcon: l,
      togglePasswordFieldType: u
    };
  }
});
const Rc = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [i, r] of t)
    n[i] = r;
  return n;
};
function MV(e, t, n, i, r, s) {
  const a = tn("v-icon"), o = tn("v-btn"), l = tn("v-text-field");
  return vl(), cf(l, ie({ ref: "field" }, e.updatedProps, { class: "vp-password-field" }, qE(e.updatedEmitters)), {
    "append-inner": dn(() => [
      e.showGenerator ? (vl(), cf(o, {
        key: 0,
        icon: "",
        onClick: e.onGeneratePassword,
        variant: "plain",
        density: "compact"
      }, {
        default: dn(() => [
          v(a, null, {
            default: dn(() => [
              _r("mdi-form-textbox-password")
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["onClick"])) : GE("", !0),
      v(o, {
        icon: "",
        onClick: e.togglePasswordFieldType,
        variant: "plain",
        density: "compact"
      }, {
        default: dn(() => [
          v(a, null, {
            default: dn(() => [
              _r(uh(e.passwordFieldTypeIcon), 1)
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["onClick"])
    ]),
    _: 1
  }, 16);
}
const rk = /* @__PURE__ */ Rc(NV, [["render", MV]]);
function sk(e) {
  return YE() ? (jn(e), !0) : !1;
}
function Ch(e) {
  return typeof e == "function" ? e() : Ct(e);
}
const Cp = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const RV = Object.prototype.toString, FV = (e) => RV.call(e) === "[object Object]", BV = () => {
};
function LV(e) {
  let t;
  function n() {
    return t || (t = e()), t;
  }
  return n.reset = async () => {
    const i = t;
    t = void 0, i && await i;
  }, n;
}
function $V(e, t, n = {}) {
  const {
    immediate: i = !0
  } = n, r = X(!1);
  let s = null;
  function a() {
    s && (clearTimeout(s), s = null);
  }
  function o() {
    r.value = !1, a();
  }
  function l(...u) {
    a(), r.value = !0, s = setTimeout(() => {
      r.value = !1, s = null, e(...u);
    }, Ch(t));
  }
  return i && (r.value = !0, Cp && l()), sk(o), {
    isPending: Fl(r),
    start: l,
    stop: o
  };
}
function WV(e) {
  var t;
  const n = Ch(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
const jV = Cp ? window : void 0, ak = Cp ? window.navigator : void 0;
function ok(...e) {
  let t, n, i, r;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([n, i, r] = e, t = jV) : [t, n, i, r] = e, !t)
    return BV;
  Array.isArray(n) || (n = [n]), Array.isArray(i) || (i = [i]);
  const s = [], a = () => {
    s.forEach((c) => c()), s.length = 0;
  }, o = (c, d, f, h) => (c.addEventListener(d, f, h), () => c.removeEventListener(d, f, h)), l = fe(
    () => [WV(t), Ch(r)],
    ([c, d]) => {
      if (a(), !c)
        return;
      const f = FV(d) ? { ...d } : d;
      s.push(
        ...n.flatMap((h) => i.map((m) => o(c, h, m, f)))
      );
    },
    { immediate: !0, flush: "post" }
  ), u = () => {
    l(), a();
  };
  return sk(u), u;
}
function HV() {
  const e = X(!1), t = ep();
  return t && En(() => {
    e.value = !0;
  }, t), e;
}
function lk(e) {
  const t = HV();
  return b(() => (t.value, !!e()));
}
function xw(e, t = {}) {
  const {
    controls: n = !1,
    navigator: i = ak
  } = t, r = lk(() => i && "permissions" in i);
  let s;
  const a = typeof e == "string" ? { name: e } : e, o = X(), l = () => {
    s && (o.value = s.state);
  }, u = LV(async () => {
    if (r.value) {
      if (!s)
        try {
          s = await i.permissions.query(a), ok(s, "change", l), l();
        } catch {
          o.value = "prompt";
        }
      return s;
    }
  });
  return u(), n ? {
    state: o,
    isSupported: r,
    query: u
  } : o;
}
function zV(e = {}) {
  const {
    navigator: t = ak,
    read: n = !1,
    source: i,
    copiedDuring: r = 1500,
    legacy: s = !1
  } = e, a = lk(() => t && "clipboard" in t), o = xw("clipboard-read"), l = xw("clipboard-write"), u = b(() => a.value || s), c = X(""), d = X(!1), f = $V(() => d.value = !1, r);
  function h() {
    a.value && y(o.value) ? t.clipboard.readText().then((k) => {
      c.value = k;
    }) : c.value = p();
  }
  u.value && n && ok(["copy", "cut"], h);
  async function m(k = Ch(i)) {
    u.value && k != null && (a.value && y(l.value) ? await t.clipboard.writeText(k) : g(k), c.value = k, d.value = !0, f.start());
  }
  function g(k) {
    const T = document.createElement("textarea");
    T.value = k ?? "", T.style.position = "absolute", T.style.opacity = "0", document.body.appendChild(T), T.select(), document.execCommand("copy"), T.remove();
  }
  function p() {
    var k, T, _;
    return (_ = (T = (k = document == null ? void 0 : document.getSelection) == null ? void 0 : k.call(document)) == null ? void 0 : T.toString()) != null ? _ : "";
  }
  function y(k) {
    return k === "granted" || k === "prompt";
  }
  return {
    isSupported: u,
    text: c,
    copied: d,
    copy: m
  };
}
const Is = (e, t = "#34495E", n = "#41B883") => (...i) => {
  if (typeof window > "u" && (typeof ServiceWorkerGlobalScope > "u" || !(self instanceof ServiceWorkerGlobalScope))) {
    console.log(`[${e}]`, ...i);
    return;
  }
  if (typeof ServiceWorkerGlobalScope < "u" && self instanceof ServiceWorkerGlobalScope && !e.startsWith("[") && !e.endsWith("]")) {
    e = `[${e}]`;
    const r = t;
    t = n, n = r;
  }
  console.groupCollapsed(
    `%c${e}`,
    `background-color: ${n}; color: ${t}; padding: 2px 4px;`,
    ...i
  ), console.debug(new Error("stack").stack.split(`
`).slice(2).join(`
`)), console.groupEnd();
}, Aw = Is("VPTextFieldCopyable"), uk = [
  "readonly",
  "value",
  "model-value",
  "modelValue",
  "hide-details",
  "append-inner-icon",
  "hideDetails",
  "appendInnerIcon",
  "onClick:prependInner"
], UV = (e = {}) => {
  const t = {};
  for (const n in gi.props)
    uk.includes(n) || (t[n] = gi.props[n]);
  return {
    ...t,
    ...e
  };
}, qV = Bl({
  name: "VPTextFieldCopyable",
  props: UV({
    /**
     * The value to be copied to the clipboard
     * @model
     */
    value: {
      type: String,
      default: ""
    }
  }),
  emits: [
    /**
     * Emitted when the value is successfully copied to the clipboard
     * 
     * @property {string} value - The value that was copied
     */
    "copied",
    /**
     * Emitted when the value fails to be copied to the clipboard
     */
    "copy-failed",
    ...Object.keys({ ...gi.emits })
  ],
  setup(e, { emit: t }) {
    const n = b(() => e.value), { copy: i, copied: r, isSupported: s, text: a } = zV(), o = async () => {
      await i(n.value), r.value && a.value === n.value ? (t("copied", r.value), Aw(`Copied: ${r.value}`)) : (t("copy-failed"), Aw(`Failed to copy: ${n.value}`));
    }, l = ja(e, "VTextField"), u = b(() => {
      const c = {};
      for (const d in gi.props)
        uk.includes(d) || (c[d] = l[d]);
      return c;
    });
    return {
      copy: o,
      isSupported: s,
      bound: u
    };
  }
});
function GV(e, t, n, i, r, s) {
  const a = tn("v-text-field");
  return vl(), cf(a, ie({
    readonly: "",
    "model-value": e.value,
    "hide-details": "",
    "append-inner-icon": "mdi-content-copy"
  }, e.bound, { "onClick:appendInner": e.copy }), ZE({ _: 2 }, [
    KE(e.$slots, (o, l) => ({
      name: l,
      fn: dn((u) => [
        or(e.$slots, l, os(ls(u)))
      ])
    }))
  ]), 1040, ["model-value", "onClick:appendInner"]);
}
const YV = /* @__PURE__ */ Rc(qV, [["render", GV]]);
class _o extends Error {
}
class ZV extends _o {
  constructor(t) {
    super(`Invalid DateTime: ${t.toMessage()}`);
  }
}
class KV extends _o {
  constructor(t) {
    super(`Invalid Interval: ${t.toMessage()}`);
  }
}
class XV extends _o {
  constructor(t) {
    super(`Invalid Duration: ${t.toMessage()}`);
  }
}
class Xo extends _o {
}
class ck extends _o {
  constructor(t) {
    super(`Invalid unit ${t}`);
  }
}
class hi extends _o {
}
class Ns extends _o {
  constructor() {
    super("Zone is an abstract class");
  }
}
const Ce = "numeric", kr = "short", xi = "long", pf = {
  year: Ce,
  month: Ce,
  day: Ce
}, dk = {
  year: Ce,
  month: kr,
  day: Ce
}, JV = {
  year: Ce,
  month: kr,
  day: Ce,
  weekday: kr
}, fk = {
  year: Ce,
  month: xi,
  day: Ce
}, hk = {
  year: Ce,
  month: xi,
  day: Ce,
  weekday: xi
}, mk = {
  hour: Ce,
  minute: Ce
}, vk = {
  hour: Ce,
  minute: Ce,
  second: Ce
}, gk = {
  hour: Ce,
  minute: Ce,
  second: Ce,
  timeZoneName: kr
}, pk = {
  hour: Ce,
  minute: Ce,
  second: Ce,
  timeZoneName: xi
}, yk = {
  hour: Ce,
  minute: Ce,
  hourCycle: "h23"
}, bk = {
  hour: Ce,
  minute: Ce,
  second: Ce,
  hourCycle: "h23"
}, wk = {
  hour: Ce,
  minute: Ce,
  second: Ce,
  hourCycle: "h23",
  timeZoneName: kr
}, _k = {
  hour: Ce,
  minute: Ce,
  second: Ce,
  hourCycle: "h23",
  timeZoneName: xi
}, Sk = {
  year: Ce,
  month: Ce,
  day: Ce,
  hour: Ce,
  minute: Ce
}, kk = {
  year: Ce,
  month: Ce,
  day: Ce,
  hour: Ce,
  minute: Ce,
  second: Ce
}, Ck = {
  year: Ce,
  month: kr,
  day: Ce,
  hour: Ce,
  minute: Ce
}, Tk = {
  year: Ce,
  month: kr,
  day: Ce,
  hour: Ce,
  minute: Ce,
  second: Ce
}, QV = {
  year: Ce,
  month: kr,
  day: Ce,
  weekday: kr,
  hour: Ce,
  minute: Ce
}, xk = {
  year: Ce,
  month: xi,
  day: Ce,
  hour: Ce,
  minute: Ce,
  timeZoneName: kr
}, Ak = {
  year: Ce,
  month: xi,
  day: Ce,
  hour: Ce,
  minute: Ce,
  second: Ce,
  timeZoneName: kr
}, Ik = {
  year: Ce,
  month: xi,
  day: Ce,
  weekday: xi,
  hour: Ce,
  minute: Ce,
  timeZoneName: xi
}, Ek = {
  year: Ce,
  month: xi,
  day: Ce,
  weekday: xi,
  hour: Ce,
  minute: Ce,
  second: Ce,
  timeZoneName: xi
};
class Fc {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new Ns();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new Ns();
  }
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new Ns();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(t, n) {
    throw new Ns();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(t, n) {
    throw new Ns();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(t) {
    throw new Ns();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(t) {
    throw new Ns();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new Ns();
  }
}
let Zm = null;
class Th extends Fc {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    return Zm === null && (Zm = new Th()), Zm;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(t, { format: n, locale: i }) {
    return Bk(t, n, i);
  }
  /** @override **/
  formatOffset(t, n) {
    return Ru(this.offset(t), n);
  }
  /** @override **/
  offset(t) {
    return -new Date(t).getTimezoneOffset();
  }
  /** @override **/
  equals(t) {
    return t.type === "system";
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
let Ld = {};
function eD(e) {
  return Ld[e] || (Ld[e] = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: e,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  })), Ld[e];
}
const tD = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function nD(e, t) {
  const n = e.format(t).replace(/\u200E/g, ""), i = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(n), [, r, s, a, o, l, u, c] = i;
  return [a, r, s, o, l, u, c];
}
function iD(e, t) {
  const n = e.formatToParts(t), i = [];
  for (let r = 0; r < n.length; r++) {
    const { type: s, value: a } = n[r], o = tD[s];
    s === "era" ? i[o] = a : Ue(o) || (i[o] = parseInt(a, 10));
  }
  return i;
}
let _d = {};
class ws extends Fc {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(t) {
    return _d[t] || (_d[t] = new ws(t)), _d[t];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    _d = {}, Ld = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(t) {
    return this.isValidZone(t);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(t) {
    if (!t)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: t }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(t) {
    super(), this.zoneName = t, this.valid = ws.isValidZone(t);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(t, { format: n, locale: i }) {
    return Bk(t, n, i, this.name);
  }
  /** @override **/
  formatOffset(t, n) {
    return Ru(this.offset(t), n);
  }
  /** @override **/
  offset(t) {
    const n = new Date(t);
    if (isNaN(n))
      return NaN;
    const i = eD(this.name);
    let [r, s, a, o, l, u, c] = i.formatToParts ? iD(i, n) : nD(i, n);
    o === "BC" && (r = -Math.abs(r) + 1);
    const f = Ah({
      year: r,
      month: s,
      day: a,
      hour: l === 24 ? 0 : l,
      minute: u,
      second: c,
      millisecond: 0
    });
    let h = +n;
    const m = h % 1e3;
    return h -= m >= 0 ? m : 1e3 + m, (f - h) / (60 * 1e3);
  }
  /** @override **/
  equals(t) {
    return t.type === "iana" && t.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
}
let Iw = {};
function rD(e, t = {}) {
  const n = JSON.stringify([e, t]);
  let i = Iw[n];
  return i || (i = new Intl.ListFormat(e, t), Iw[n] = i), i;
}
let Bv = {};
function Lv(e, t = {}) {
  const n = JSON.stringify([e, t]);
  let i = Bv[n];
  return i || (i = new Intl.DateTimeFormat(e, t), Bv[n] = i), i;
}
let $v = {};
function sD(e, t = {}) {
  const n = JSON.stringify([e, t]);
  let i = $v[n];
  return i || (i = new Intl.NumberFormat(e, t), $v[n] = i), i;
}
let Wv = {};
function aD(e, t = {}) {
  const { base: n, ...i } = t, r = JSON.stringify([e, i]);
  let s = Wv[r];
  return s || (s = new Intl.RelativeTimeFormat(e, t), Wv[r] = s), s;
}
let gu = null;
function oD() {
  return gu || (gu = new Intl.DateTimeFormat().resolvedOptions().locale, gu);
}
let Ew = {};
function lD(e) {
  let t = Ew[e];
  if (!t) {
    const n = new Intl.Locale(e);
    t = "getWeekInfo" in n ? n.getWeekInfo() : n.weekInfo, Ew[e] = t;
  }
  return t;
}
function uD(e) {
  const t = e.indexOf("-x-");
  t !== -1 && (e = e.substring(0, t));
  const n = e.indexOf("-u-");
  if (n === -1)
    return [e];
  {
    let i, r;
    try {
      i = Lv(e).resolvedOptions(), r = e;
    } catch {
      const l = e.substring(0, n);
      i = Lv(l).resolvedOptions(), r = l;
    }
    const { numberingSystem: s, calendar: a } = i;
    return [r, s, a];
  }
}
function cD(e, t, n) {
  return (n || t) && (e.includes("-u-") || (e += "-u"), n && (e += `-ca-${n}`), t && (e += `-nu-${t}`)), e;
}
function dD(e) {
  const t = [];
  for (let n = 1; n <= 12; n++) {
    const i = Re.utc(2009, n, 1);
    t.push(e(i));
  }
  return t;
}
function fD(e) {
  const t = [];
  for (let n = 1; n <= 7; n++) {
    const i = Re.utc(2016, 11, 13 + n);
    t.push(e(i));
  }
  return t;
}
function Sd(e, t, n, i) {
  const r = e.listingMode();
  return r === "error" ? null : r === "en" ? n(t) : i(t);
}
function hD(e) {
  return e.numberingSystem && e.numberingSystem !== "latn" ? !1 : e.numberingSystem === "latn" || !e.locale || e.locale.startsWith("en") || new Intl.DateTimeFormat(e.intl).resolvedOptions().numberingSystem === "latn";
}
class mD {
  constructor(t, n, i) {
    this.padTo = i.padTo || 0, this.floor = i.floor || !1;
    const { padTo: r, floor: s, ...a } = i;
    if (!n || Object.keys(a).length > 0) {
      const o = { useGrouping: !1, ...i };
      i.padTo > 0 && (o.minimumIntegerDigits = i.padTo), this.inf = sD(t, o);
    }
  }
  format(t) {
    if (this.inf) {
      const n = this.floor ? Math.floor(t) : t;
      return this.inf.format(n);
    } else {
      const n = this.floor ? Math.floor(t) : Ip(t, 3);
      return fn(n, this.padTo);
    }
  }
}
class vD {
  constructor(t, n, i) {
    this.opts = i, this.originalZone = void 0;
    let r;
    if (this.opts.timeZone)
      this.dt = t;
    else if (t.zone.type === "fixed") {
      const a = -1 * (t.offset / 60), o = a >= 0 ? `Etc/GMT+${a}` : `Etc/GMT${a}`;
      t.offset !== 0 && ws.create(o).valid ? (r = o, this.dt = t) : (r = "UTC", this.dt = t.offset === 0 ? t : t.setZone("UTC").plus({ minutes: t.offset }), this.originalZone = t.zone);
    } else
      t.zone.type === "system" ? this.dt = t : t.zone.type === "iana" ? (this.dt = t, r = t.zone.name) : (r = "UTC", this.dt = t.setZone("UTC").plus({ minutes: t.offset }), this.originalZone = t.zone);
    const s = { ...this.opts };
    s.timeZone = s.timeZone || r, this.dtf = Lv(n, s);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: t }) => t).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const t = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? t.map((n) => {
      if (n.type === "timeZoneName") {
        const i = this.originalZone.offsetName(this.dt.ts, {
          locale: this.dt.locale,
          format: this.opts.timeZoneName
        });
        return {
          ...n,
          value: i
        };
      } else
        return n;
    }) : t;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class gD {
  constructor(t, n, i) {
    this.opts = { style: "long", ...i }, !n && Rk() && (this.rtf = aD(t, i));
  }
  format(t, n) {
    return this.rtf ? this.rtf.format(t, n) : RD(n, t, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(t, n) {
    return this.rtf ? this.rtf.formatToParts(t, n) : [];
  }
}
const pD = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
class bt {
  static fromOpts(t) {
    return bt.create(
      t.locale,
      t.numberingSystem,
      t.outputCalendar,
      t.weekSettings,
      t.defaultToEN
    );
  }
  static create(t, n, i, r, s = !1) {
    const a = t || rn.defaultLocale, o = a || (s ? "en-US" : oD()), l = n || rn.defaultNumberingSystem, u = i || rn.defaultOutputCalendar, c = jv(r) || rn.defaultWeekSettings;
    return new bt(o, l, u, c, a);
  }
  static resetCache() {
    gu = null, Bv = {}, $v = {}, Wv = {};
  }
  static fromObject({ locale: t, numberingSystem: n, outputCalendar: i, weekSettings: r } = {}) {
    return bt.create(t, n, i, r);
  }
  constructor(t, n, i, r, s) {
    const [a, o, l] = uD(t);
    this.locale = a, this.numberingSystem = n || o || null, this.outputCalendar = i || l || null, this.weekSettings = r, this.intl = cD(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = s, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = hD(this)), this.fastNumbersCached;
  }
  listingMode() {
    const t = this.isEnglish(), n = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return t && n ? "en" : "intl";
  }
  clone(t) {
    return !t || Object.getOwnPropertyNames(t).length === 0 ? this : bt.create(
      t.locale || this.specifiedLocale,
      t.numberingSystem || this.numberingSystem,
      t.outputCalendar || this.outputCalendar,
      jv(t.weekSettings) || this.weekSettings,
      t.defaultToEN || !1
    );
  }
  redefaultToEN(t = {}) {
    return this.clone({ ...t, defaultToEN: !0 });
  }
  redefaultToSystem(t = {}) {
    return this.clone({ ...t, defaultToEN: !1 });
  }
  months(t, n = !1) {
    return Sd(this, t, Wk, () => {
      const i = n ? { month: t, day: "numeric" } : { month: t }, r = n ? "format" : "standalone";
      return this.monthsCache[r][t] || (this.monthsCache[r][t] = dD((s) => this.extract(s, i, "month"))), this.monthsCache[r][t];
    });
  }
  weekdays(t, n = !1) {
    return Sd(this, t, zk, () => {
      const i = n ? { weekday: t, year: "numeric", month: "long", day: "numeric" } : { weekday: t }, r = n ? "format" : "standalone";
      return this.weekdaysCache[r][t] || (this.weekdaysCache[r][t] = fD(
        (s) => this.extract(s, i, "weekday")
      )), this.weekdaysCache[r][t];
    });
  }
  meridiems() {
    return Sd(
      this,
      void 0,
      () => Uk,
      () => {
        if (!this.meridiemCache) {
          const t = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [Re.utc(2016, 11, 13, 9), Re.utc(2016, 11, 13, 19)].map(
            (n) => this.extract(n, t, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(t) {
    return Sd(this, t, qk, () => {
      const n = { era: t };
      return this.eraCache[t] || (this.eraCache[t] = [Re.utc(-40, 1, 1), Re.utc(2017, 1, 1)].map(
        (i) => this.extract(i, n, "era")
      )), this.eraCache[t];
    });
  }
  extract(t, n, i) {
    const r = this.dtFormatter(t, n), s = r.formatToParts(), a = s.find((o) => o.type.toLowerCase() === i);
    return a ? a.value : null;
  }
  numberFormatter(t = {}) {
    return new mD(this.intl, t.forceSimple || this.fastNumbers, t);
  }
  dtFormatter(t, n = {}) {
    return new vD(t, this.intl, n);
  }
  relFormatter(t = {}) {
    return new gD(this.intl, this.isEnglish(), t);
  }
  listFormatter(t = {}) {
    return rD(this.intl, t);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    return this.weekSettings ? this.weekSettings : Fk() ? lD(this.locale) : pD;
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(t) {
    return this.locale === t.locale && this.numberingSystem === t.numberingSystem && this.outputCalendar === t.outputCalendar;
  }
}
let Km = null;
class ni extends Fc {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    return Km === null && (Km = new ni(0)), Km;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(t) {
    return t === 0 ? ni.utcInstance : new ni(t);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(t) {
    if (t) {
      const n = t.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (n)
        return new ni(Ih(n[1], n[2]));
    }
    return null;
  }
  constructor(t) {
    super(), this.fixed = t;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${Ru(this.fixed, "narrow")}`;
  }
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${Ru(-this.fixed, "narrow")}`;
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(t, n) {
    return Ru(this.fixed, n);
  }
  /** @override **/
  get isUniversal() {
    return !0;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(t) {
    return t.type === "fixed" && t.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
class yD extends Fc {
  constructor(t) {
    super(), this.zoneName = t;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return !1;
  }
  /** @override **/
  get isValid() {
    return !1;
  }
}
function Us(e, t) {
  if (Ue(e) || e === null)
    return t;
  if (e instanceof Fc)
    return e;
  if (_D(e)) {
    const n = e.toLowerCase();
    return n === "default" ? t : n === "local" || n === "system" ? Th.instance : n === "utc" || n === "gmt" ? ni.utcInstance : ni.parseSpecifier(n) || ws.create(e);
  } else
    return Ha(e) ? ni.instance(e) : typeof e == "object" && "offset" in e && typeof e.offset == "function" ? e : new yD(e);
}
let Pw = () => Date.now(), Ow = "system", Vw = null, Dw = null, Nw = null, Mw = 60, Rw, Fw = null;
class rn {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return Pw;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(t) {
    Pw = t;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(t) {
    Ow = t;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return Us(Ow, Th.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return Vw;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(t) {
    Vw = t;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return Dw;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(t) {
    Dw = t;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return Nw;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(t) {
    Nw = t;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return Fw;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(t) {
    Fw = jv(t);
  }
  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return Mw;
  }
  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(t) {
    Mw = t % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return Rw;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    Rw = t;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    bt.resetCache(), ws.resetCache();
  }
}
class mr {
  constructor(t, n) {
    this.reason = t, this.explanation = n;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
const Pk = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Ok = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function zi(e, t) {
  return new mr(
    "unit out of range",
    `you specified ${t} (of type ${typeof t}) as a ${e}, which is invalid`
  );
}
function Tp(e, t, n) {
  const i = new Date(Date.UTC(e, t - 1, n));
  e < 100 && e >= 0 && i.setUTCFullYear(i.getUTCFullYear() - 1900);
  const r = i.getUTCDay();
  return r === 0 ? 7 : r;
}
function Vk(e, t, n) {
  return n + (Bc(e) ? Ok : Pk)[t - 1];
}
function Dk(e, t) {
  const n = Bc(e) ? Ok : Pk, i = n.findIndex((s) => s < t), r = t - n[i];
  return { month: i + 1, day: r };
}
function xp(e, t) {
  return (e - t + 7) % 7 + 1;
}
function yf(e, t = 4, n = 1) {
  const { year: i, month: r, day: s } = e, a = Vk(i, r, s), o = xp(Tp(i, r, s), n);
  let l = Math.floor((a - o + 14 - t) / 7), u;
  return l < 1 ? (u = i - 1, l = Xu(u, t, n)) : l > Xu(i, t, n) ? (u = i + 1, l = 1) : u = i, { weekYear: u, weekNumber: l, weekday: o, ...Eh(e) };
}
function Bw(e, t = 4, n = 1) {
  const { weekYear: i, weekNumber: r, weekday: s } = e, a = xp(Tp(i, 1, t), n), o = ol(i);
  let l = r * 7 + s - a - 7 + t, u;
  l < 1 ? (u = i - 1, l += ol(u)) : l > o ? (u = i + 1, l -= ol(i)) : u = i;
  const { month: c, day: d } = Dk(u, l);
  return { year: u, month: c, day: d, ...Eh(e) };
}
function Xm(e) {
  const { year: t, month: n, day: i } = e, r = Vk(t, n, i);
  return { year: t, ordinal: r, ...Eh(e) };
}
function Lw(e) {
  const { year: t, ordinal: n } = e, { month: i, day: r } = Dk(t, n);
  return { year: t, month: i, day: r, ...Eh(e) };
}
function $w(e, t) {
  if (!Ue(e.localWeekday) || !Ue(e.localWeekNumber) || !Ue(e.localWeekYear)) {
    if (!Ue(e.weekday) || !Ue(e.weekNumber) || !Ue(e.weekYear))
      throw new Xo(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    return Ue(e.localWeekday) || (e.weekday = e.localWeekday), Ue(e.localWeekNumber) || (e.weekNumber = e.localWeekNumber), Ue(e.localWeekYear) || (e.weekYear = e.localWeekYear), delete e.localWeekday, delete e.localWeekNumber, delete e.localWeekYear, {
      minDaysInFirstWeek: t.getMinDaysInFirstWeek(),
      startOfWeek: t.getStartOfWeek()
    };
  } else
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
}
function bD(e, t = 4, n = 1) {
  const i = xh(e.weekYear), r = Ui(
    e.weekNumber,
    1,
    Xu(e.weekYear, t, n)
  ), s = Ui(e.weekday, 1, 7);
  return i ? r ? s ? !1 : zi("weekday", e.weekday) : zi("week", e.weekNumber) : zi("weekYear", e.weekYear);
}
function wD(e) {
  const t = xh(e.year), n = Ui(e.ordinal, 1, ol(e.year));
  return t ? n ? !1 : zi("ordinal", e.ordinal) : zi("year", e.year);
}
function Nk(e) {
  const t = xh(e.year), n = Ui(e.month, 1, 12), i = Ui(e.day, 1, bf(e.year, e.month));
  return t ? n ? i ? !1 : zi("day", e.day) : zi("month", e.month) : zi("year", e.year);
}
function Mk(e) {
  const { hour: t, minute: n, second: i, millisecond: r } = e, s = Ui(t, 0, 23) || t === 24 && n === 0 && i === 0 && r === 0, a = Ui(n, 0, 59), o = Ui(i, 0, 59), l = Ui(r, 0, 999);
  return s ? a ? o ? l ? !1 : zi("millisecond", r) : zi("second", i) : zi("minute", n) : zi("hour", t);
}
function Ue(e) {
  return typeof e > "u";
}
function Ha(e) {
  return typeof e == "number";
}
function xh(e) {
  return typeof e == "number" && e % 1 === 0;
}
function _D(e) {
  return typeof e == "string";
}
function SD(e) {
  return Object.prototype.toString.call(e) === "[object Date]";
}
function Rk() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function Fk() {
  try {
    return typeof Intl < "u" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch {
    return !1;
  }
}
function kD(e) {
  return Array.isArray(e) ? e : [e];
}
function Ww(e, t, n) {
  if (e.length !== 0)
    return e.reduce((i, r) => {
      const s = [t(r), r];
      return i && n(i[0], s[0]) === i[0] ? i : s;
    }, null)[1];
}
function CD(e, t) {
  return t.reduce((n, i) => (n[i] = e[i], n), {});
}
function wl(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function jv(e) {
  if (e == null)
    return null;
  if (typeof e != "object")
    throw new hi("Week settings must be an object");
  if (!Ui(e.firstDay, 1, 7) || !Ui(e.minimalDays, 1, 7) || !Array.isArray(e.weekend) || e.weekend.some((t) => !Ui(t, 1, 7)))
    throw new hi("Invalid week settings");
  return {
    firstDay: e.firstDay,
    minimalDays: e.minimalDays,
    weekend: Array.from(e.weekend)
  };
}
function Ui(e, t, n) {
  return xh(e) && e >= t && e <= n;
}
function TD(e, t) {
  return e - t * Math.floor(e / t);
}
function fn(e, t = 2) {
  const n = e < 0;
  let i;
  return n ? i = "-" + ("" + -e).padStart(t, "0") : i = ("" + e).padStart(t, "0"), i;
}
function Ws(e) {
  if (!(Ue(e) || e === null || e === ""))
    return parseInt(e, 10);
}
function ba(e) {
  if (!(Ue(e) || e === null || e === ""))
    return parseFloat(e);
}
function Ap(e) {
  if (!(Ue(e) || e === null || e === "")) {
    const t = parseFloat("0." + e) * 1e3;
    return Math.floor(t);
  }
}
function Ip(e, t, n = !1) {
  const i = 10 ** t;
  return (n ? Math.trunc : Math.round)(e * i) / i;
}
function Bc(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function ol(e) {
  return Bc(e) ? 366 : 365;
}
function bf(e, t) {
  const n = TD(t - 1, 12) + 1, i = e + (t - n) / 12;
  return n === 2 ? Bc(i) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][n - 1];
}
function Ah(e) {
  let t = Date.UTC(
    e.year,
    e.month - 1,
    e.day,
    e.hour,
    e.minute,
    e.second,
    e.millisecond
  );
  return e.year < 100 && e.year >= 0 && (t = new Date(t), t.setUTCFullYear(e.year, e.month - 1, e.day)), +t;
}
function jw(e, t, n) {
  return -xp(Tp(e, 1, t), n) + t - 1;
}
function Xu(e, t = 4, n = 1) {
  const i = jw(e, t, n), r = jw(e + 1, t, n);
  return (ol(e) - i + r) / 7;
}
function Hv(e) {
  return e > 99 ? e : e > rn.twoDigitCutoffYear ? 1900 + e : 2e3 + e;
}
function Bk(e, t, n, i = null) {
  const r = new Date(e), s = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  i && (s.timeZone = i);
  const a = { timeZoneName: t, ...s }, o = new Intl.DateTimeFormat(n, a).formatToParts(r).find((l) => l.type.toLowerCase() === "timezonename");
  return o ? o.value : null;
}
function Ih(e, t) {
  let n = parseInt(e, 10);
  Number.isNaN(n) && (n = 0);
  const i = parseInt(t, 10) || 0, r = n < 0 || Object.is(n, -0) ? -i : i;
  return n * 60 + r;
}
function Lk(e) {
  const t = Number(e);
  if (typeof e == "boolean" || e === "" || Number.isNaN(t))
    throw new hi(`Invalid unit value ${e}`);
  return t;
}
function wf(e, t) {
  const n = {};
  for (const i in e)
    if (wl(e, i)) {
      const r = e[i];
      if (r == null)
        continue;
      n[t(i)] = Lk(r);
    }
  return n;
}
function Ru(e, t) {
  const n = Math.trunc(Math.abs(e / 60)), i = Math.trunc(Math.abs(e % 60)), r = e >= 0 ? "+" : "-";
  switch (t) {
    case "short":
      return `${r}${fn(n, 2)}:${fn(i, 2)}`;
    case "narrow":
      return `${r}${n}${i > 0 ? `:${i}` : ""}`;
    case "techie":
      return `${r}${fn(n, 2)}${fn(i, 2)}`;
    default:
      throw new RangeError(`Value format ${t} is out of range for property format`);
  }
}
function Eh(e) {
  return CD(e, ["hour", "minute", "second", "millisecond"]);
}
const xD = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], $k = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], AD = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function Wk(e) {
  switch (e) {
    case "narrow":
      return [...AD];
    case "short":
      return [...$k];
    case "long":
      return [...xD];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const jk = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], Hk = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], ID = ["M", "T", "W", "T", "F", "S", "S"];
function zk(e) {
  switch (e) {
    case "narrow":
      return [...ID];
    case "short":
      return [...Hk];
    case "long":
      return [...jk];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const Uk = ["AM", "PM"], ED = ["Before Christ", "Anno Domini"], PD = ["BC", "AD"], OD = ["B", "A"];
function qk(e) {
  switch (e) {
    case "narrow":
      return [...OD];
    case "short":
      return [...PD];
    case "long":
      return [...ED];
    default:
      return null;
  }
}
function VD(e) {
  return Uk[e.hour < 12 ? 0 : 1];
}
function DD(e, t) {
  return zk(t)[e.weekday - 1];
}
function ND(e, t) {
  return Wk(t)[e.month - 1];
}
function MD(e, t) {
  return qk(t)[e.year < 0 ? 0 : 1];
}
function RD(e, t, n = "always", i = !1) {
  const r = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, s = ["hours", "minutes", "seconds"].indexOf(e) === -1;
  if (n === "auto" && s) {
    const d = e === "days";
    switch (t) {
      case 1:
        return d ? "tomorrow" : `next ${r[e][0]}`;
      case -1:
        return d ? "yesterday" : `last ${r[e][0]}`;
      case 0:
        return d ? "today" : `this ${r[e][0]}`;
    }
  }
  const a = Object.is(t, -0) || t < 0, o = Math.abs(t), l = o === 1, u = r[e], c = i ? l ? u[1] : u[2] || u[1] : l ? r[e][0] : e;
  return a ? `${o} ${c} ago` : `in ${o} ${c}`;
}
function Hw(e, t) {
  let n = "";
  for (const i of e)
    i.literal ? n += i.val : n += t(i.val);
  return n;
}
const FD = {
  D: pf,
  DD: dk,
  DDD: fk,
  DDDD: hk,
  t: mk,
  tt: vk,
  ttt: gk,
  tttt: pk,
  T: yk,
  TT: bk,
  TTT: wk,
  TTTT: _k,
  f: Sk,
  ff: Ck,
  fff: xk,
  ffff: Ik,
  F: kk,
  FF: Tk,
  FFF: Ak,
  FFFF: Ek
};
class Un {
  static create(t, n = {}) {
    return new Un(t, n);
  }
  static parseFormat(t) {
    let n = null, i = "", r = !1;
    const s = [];
    for (let a = 0; a < t.length; a++) {
      const o = t.charAt(a);
      o === "'" ? (i.length > 0 && s.push({ literal: r || /^\s+$/.test(i), val: i }), n = null, i = "", r = !r) : r || o === n ? i += o : (i.length > 0 && s.push({ literal: /^\s+$/.test(i), val: i }), i = o, n = o);
    }
    return i.length > 0 && s.push({ literal: r || /^\s+$/.test(i), val: i }), s;
  }
  static macroTokenToFormatOpts(t) {
    return FD[t];
  }
  constructor(t, n) {
    this.opts = n, this.loc = t, this.systemLoc = null;
  }
  formatWithSystemDefault(t, n) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(t, { ...this.opts, ...n }).format();
  }
  dtFormatter(t, n = {}) {
    return this.loc.dtFormatter(t, { ...this.opts, ...n });
  }
  formatDateTime(t, n) {
    return this.dtFormatter(t, n).format();
  }
  formatDateTimeParts(t, n) {
    return this.dtFormatter(t, n).formatToParts();
  }
  formatInterval(t, n) {
    return this.dtFormatter(t.start, n).dtf.formatRange(t.start.toJSDate(), t.end.toJSDate());
  }
  resolvedOptions(t, n) {
    return this.dtFormatter(t, n).resolvedOptions();
  }
  num(t, n = 0) {
    if (this.opts.forceSimple)
      return fn(t, n);
    const i = { ...this.opts };
    return n > 0 && (i.padTo = n), this.loc.numberFormatter(i).format(t);
  }
  formatDateTimeFromString(t, n) {
    const i = this.loc.listingMode() === "en", r = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", s = (h, m) => this.loc.extract(t, h, m), a = (h) => t.isOffsetFixed && t.offset === 0 && h.allowZ ? "Z" : t.isValid ? t.zone.formatOffset(t.ts, h.format) : "", o = () => i ? VD(t) : s({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), l = (h, m) => i ? ND(t, h) : s(m ? { month: h } : { month: h, day: "numeric" }, "month"), u = (h, m) => i ? DD(t, h) : s(
      m ? { weekday: h } : { weekday: h, month: "long", day: "numeric" },
      "weekday"
    ), c = (h) => {
      const m = Un.macroTokenToFormatOpts(h);
      return m ? this.formatWithSystemDefault(t, m) : h;
    }, d = (h) => i ? MD(t, h) : s({ era: h }, "era"), f = (h) => {
      switch (h) {
        case "S":
          return this.num(t.millisecond);
        case "u":
        case "SSS":
          return this.num(t.millisecond, 3);
        case "s":
          return this.num(t.second);
        case "ss":
          return this.num(t.second, 2);
        case "uu":
          return this.num(Math.floor(t.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(t.millisecond / 100));
        case "m":
          return this.num(t.minute);
        case "mm":
          return this.num(t.minute, 2);
        case "h":
          return this.num(t.hour % 12 === 0 ? 12 : t.hour % 12);
        case "hh":
          return this.num(t.hour % 12 === 0 ? 12 : t.hour % 12, 2);
        case "H":
          return this.num(t.hour);
        case "HH":
          return this.num(t.hour, 2);
        case "Z":
          return a({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return a({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return a({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return t.zone.offsetName(t.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return t.zone.offsetName(t.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return t.zoneName;
        case "a":
          return o();
        case "d":
          return r ? s({ day: "numeric" }, "day") : this.num(t.day);
        case "dd":
          return r ? s({ day: "2-digit" }, "day") : this.num(t.day, 2);
        case "c":
          return this.num(t.weekday);
        case "ccc":
          return u("short", !0);
        case "cccc":
          return u("long", !0);
        case "ccccc":
          return u("narrow", !0);
        case "E":
          return this.num(t.weekday);
        case "EEE":
          return u("short", !1);
        case "EEEE":
          return u("long", !1);
        case "EEEEE":
          return u("narrow", !1);
        case "L":
          return r ? s({ month: "numeric", day: "numeric" }, "month") : this.num(t.month);
        case "LL":
          return r ? s({ month: "2-digit", day: "numeric" }, "month") : this.num(t.month, 2);
        case "LLL":
          return l("short", !0);
        case "LLLL":
          return l("long", !0);
        case "LLLLL":
          return l("narrow", !0);
        case "M":
          return r ? s({ month: "numeric" }, "month") : this.num(t.month);
        case "MM":
          return r ? s({ month: "2-digit" }, "month") : this.num(t.month, 2);
        case "MMM":
          return l("short", !1);
        case "MMMM":
          return l("long", !1);
        case "MMMMM":
          return l("narrow", !1);
        case "y":
          return r ? s({ year: "numeric" }, "year") : this.num(t.year);
        case "yy":
          return r ? s({ year: "2-digit" }, "year") : this.num(t.year.toString().slice(-2), 2);
        case "yyyy":
          return r ? s({ year: "numeric" }, "year") : this.num(t.year, 4);
        case "yyyyyy":
          return r ? s({ year: "numeric" }, "year") : this.num(t.year, 6);
        case "G":
          return d("short");
        case "GG":
          return d("long");
        case "GGGGG":
          return d("narrow");
        case "kk":
          return this.num(t.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(t.weekYear, 4);
        case "W":
          return this.num(t.weekNumber);
        case "WW":
          return this.num(t.weekNumber, 2);
        case "n":
          return this.num(t.localWeekNumber);
        case "nn":
          return this.num(t.localWeekNumber, 2);
        case "ii":
          return this.num(t.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(t.localWeekYear, 4);
        case "o":
          return this.num(t.ordinal);
        case "ooo":
          return this.num(t.ordinal, 3);
        case "q":
          return this.num(t.quarter);
        case "qq":
          return this.num(t.quarter, 2);
        case "X":
          return this.num(Math.floor(t.ts / 1e3));
        case "x":
          return this.num(t.ts);
        default:
          return c(h);
      }
    };
    return Hw(Un.parseFormat(n), f);
  }
  formatDurationFromString(t, n) {
    const i = (l) => {
      switch (l[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, r = (l) => (u) => {
      const c = i(u);
      return c ? this.num(l.get(c), u.length) : u;
    }, s = Un.parseFormat(n), a = s.reduce(
      (l, { literal: u, val: c }) => u ? l : l.concat(c),
      []
    ), o = t.shiftTo(...a.map(i).filter((l) => l));
    return Hw(s, r(o));
  }
}
const Gk = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function Hl(...e) {
  const t = e.reduce((n, i) => n + i.source, "");
  return RegExp(`^${t}$`);
}
function zl(...e) {
  return (t) => e.reduce(
    ([n, i, r], s) => {
      const [a, o, l] = s(t, r);
      return [{ ...n, ...a }, o || i, l];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function Ul(e, ...t) {
  if (e == null)
    return [null, null];
  for (const [n, i] of t) {
    const r = n.exec(e);
    if (r)
      return i(r);
  }
  return [null, null];
}
function Yk(...e) {
  return (t, n) => {
    const i = {};
    let r;
    for (r = 0; r < e.length; r++)
      i[e[r]] = Ws(t[n + r]);
    return [i, null, n + r];
  };
}
const Zk = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, BD = `(?:${Zk.source}?(?:\\[(${Gk.source})\\])?)?`, Ep = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, Kk = RegExp(`${Ep.source}${BD}`), Pp = RegExp(`(?:T${Kk.source})?`), LD = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, $D = /(\d{4})-?W(\d\d)(?:-?(\d))?/, WD = /(\d{4})-?(\d{3})/, jD = Yk("weekYear", "weekNumber", "weekDay"), HD = Yk("year", "ordinal"), zD = /(\d{4})-(\d\d)-(\d\d)/, Xk = RegExp(
  `${Ep.source} ?(?:${Zk.source}|(${Gk.source}))?`
), UD = RegExp(`(?: ${Xk.source})?`);
function ll(e, t, n) {
  const i = e[t];
  return Ue(i) ? n : Ws(i);
}
function qD(e, t) {
  return [{
    year: ll(e, t),
    month: ll(e, t + 1, 1),
    day: ll(e, t + 2, 1)
  }, null, t + 3];
}
function ql(e, t) {
  return [{
    hours: ll(e, t, 0),
    minutes: ll(e, t + 1, 0),
    seconds: ll(e, t + 2, 0),
    milliseconds: Ap(e[t + 3])
  }, null, t + 4];
}
function Lc(e, t) {
  const n = !e[t] && !e[t + 1], i = Ih(e[t + 1], e[t + 2]), r = n ? null : ni.instance(i);
  return [{}, r, t + 3];
}
function $c(e, t) {
  const n = e[t] ? ws.create(e[t]) : null;
  return [{}, n, t + 1];
}
const GD = RegExp(`^T?${Ep.source}$`), YD = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function ZD(e) {
  const [t, n, i, r, s, a, o, l, u] = e, c = t[0] === "-", d = l && l[0] === "-", f = (h, m = !1) => h !== void 0 && (m || h && c) ? -h : h;
  return [
    {
      years: f(ba(n)),
      months: f(ba(i)),
      weeks: f(ba(r)),
      days: f(ba(s)),
      hours: f(ba(a)),
      minutes: f(ba(o)),
      seconds: f(ba(l), l === "-0"),
      milliseconds: f(Ap(u), d)
    }
  ];
}
const KD = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function Op(e, t, n, i, r, s, a) {
  const o = {
    year: t.length === 2 ? Hv(Ws(t)) : Ws(t),
    month: $k.indexOf(n) + 1,
    day: Ws(i),
    hour: Ws(r),
    minute: Ws(s)
  };
  return a && (o.second = Ws(a)), e && (o.weekday = e.length > 3 ? jk.indexOf(e) + 1 : Hk.indexOf(e) + 1), o;
}
const XD = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function JD(e) {
  const [
    ,
    t,
    n,
    i,
    r,
    s,
    a,
    o,
    l,
    u,
    c,
    d
  ] = e, f = Op(t, r, i, n, s, a, o);
  let h;
  return l ? h = KD[l] : u ? h = 0 : h = Ih(c, d), [f, new ni(h)];
}
function QD(e) {
  return e.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const eN = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, tN = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, nN = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function zw(e) {
  const [, t, n, i, r, s, a, o] = e;
  return [Op(t, r, i, n, s, a, o), ni.utcInstance];
}
function iN(e) {
  const [, t, n, i, r, s, a, o] = e;
  return [Op(t, o, n, i, r, s, a), ni.utcInstance];
}
const rN = Hl(LD, Pp), sN = Hl($D, Pp), aN = Hl(WD, Pp), oN = Hl(Kk), Jk = zl(
  qD,
  ql,
  Lc,
  $c
), lN = zl(
  jD,
  ql,
  Lc,
  $c
), uN = zl(
  HD,
  ql,
  Lc,
  $c
), cN = zl(
  ql,
  Lc,
  $c
);
function dN(e) {
  return Ul(
    e,
    [rN, Jk],
    [sN, lN],
    [aN, uN],
    [oN, cN]
  );
}
function fN(e) {
  return Ul(QD(e), [XD, JD]);
}
function hN(e) {
  return Ul(
    e,
    [eN, zw],
    [tN, zw],
    [nN, iN]
  );
}
function mN(e) {
  return Ul(e, [YD, ZD]);
}
const vN = zl(ql);
function gN(e) {
  return Ul(e, [GD, vN]);
}
const pN = Hl(zD, UD), yN = Hl(Xk), bN = zl(
  ql,
  Lc,
  $c
);
function wN(e) {
  return Ul(
    e,
    [pN, Jk],
    [yN, bN]
  );
}
const Uw = "Invalid Duration", Qk = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, _N = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...Qk
}, Ri = 146097 / 400, Bo = 146097 / 4800, SN = {
  years: {
    quarters: 4,
    months: 12,
    weeks: Ri / 7,
    days: Ri,
    hours: Ri * 24,
    minutes: Ri * 24 * 60,
    seconds: Ri * 24 * 60 * 60,
    milliseconds: Ri * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: Ri / 28,
    days: Ri / 4,
    hours: Ri * 24 / 4,
    minutes: Ri * 24 * 60 / 4,
    seconds: Ri * 24 * 60 * 60 / 4,
    milliseconds: Ri * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: Bo / 7,
    days: Bo,
    hours: Bo * 24,
    minutes: Bo * 24 * 60,
    seconds: Bo * 24 * 60 * 60,
    milliseconds: Bo * 24 * 60 * 60 * 1e3
  },
  ...Qk
}, Ma = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], kN = Ma.slice(0).reverse();
function Ms(e, t, n = !1) {
  const i = {
    values: n ? t.values : { ...e.values, ...t.values || {} },
    loc: e.loc.clone(t.loc),
    conversionAccuracy: t.conversionAccuracy || e.conversionAccuracy,
    matrix: t.matrix || e.matrix
  };
  return new ct(i);
}
function eC(e, t) {
  let n = t.milliseconds ?? 0;
  for (const i of kN.slice(1))
    t[i] && (n += t[i] * e[i].milliseconds);
  return n;
}
function qw(e, t) {
  const n = eC(e, t) < 0 ? -1 : 1;
  Ma.reduceRight((i, r) => {
    if (Ue(t[r]))
      return i;
    if (i) {
      const s = t[i] * n, a = e[r][i], o = Math.floor(s / a);
      t[r] += o * n, t[i] -= o * a * n;
    }
    return r;
  }, null), Ma.reduce((i, r) => {
    if (Ue(t[r]))
      return i;
    if (i) {
      const s = t[i] % 1;
      t[i] -= s, t[r] += s * e[i][r];
    }
    return r;
  }, null);
}
function CN(e) {
  const t = {};
  for (const [n, i] of Object.entries(e))
    i !== 0 && (t[n] = i);
  return t;
}
class ct {
  /**
   * @private
   */
  constructor(t) {
    const n = t.conversionAccuracy === "longterm" || !1;
    let i = n ? SN : _N;
    t.matrix && (i = t.matrix), this.values = t.values, this.loc = t.loc || bt.create(), this.conversionAccuracy = n ? "longterm" : "casual", this.invalid = t.invalid || null, this.matrix = i, this.isLuxonDuration = !0;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(t, n) {
    return ct.fromObject({ milliseconds: t }, n);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(t, n = {}) {
    if (t == null || typeof t != "object")
      throw new hi(
        `Duration.fromObject: argument expected to be an object, got ${t === null ? "null" : typeof t}`
      );
    return new ct({
      values: wf(t, ct.normalizeUnit),
      loc: bt.fromObject(n),
      conversionAccuracy: n.conversionAccuracy,
      matrix: n.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(t) {
    if (Ha(t))
      return ct.fromMillis(t);
    if (ct.isDuration(t))
      return t;
    if (typeof t == "object")
      return ct.fromObject(t);
    throw new hi(
      `Unknown duration argument ${t} of type ${typeof t}`
    );
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(t, n) {
    const [i] = mN(t);
    return i ? ct.fromObject(i, n) : ct.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`);
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(t, n) {
    const [i] = gN(t);
    return i ? ct.fromObject(i, n) : ct.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`);
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(t, n = null) {
    if (!t)
      throw new hi("need to specify a reason the Duration is invalid");
    const i = t instanceof mr ? t : new mr(t, n);
    if (rn.throwOnInvalid)
      throw new XV(i);
    return new ct({ invalid: i });
  }
  /**
   * @private
   */
  static normalizeUnit(t) {
    const n = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[t && t.toLowerCase()];
    if (!n)
      throw new ck(t);
    return n;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(t) {
    return t && t.isLuxonDuration || !1;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(t, n = {}) {
    const i = {
      ...n,
      floor: n.round !== !1 && n.floor !== !1
    };
    return this.isValid ? Un.create(this.loc, i).formatDurationFromString(this, t) : Uw;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(t = {}) {
    if (!this.isValid)
      return Uw;
    const n = Ma.map((i) => {
      const r = this.values[i];
      return Ue(r) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...t, unit: i.slice(0, -1) }).format(r);
    }).filter((i) => i);
    return this.loc.listFormatter({ type: "conjunction", style: t.listStyle || "narrow", ...t }).format(n);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let t = "P";
    return this.years !== 0 && (t += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (t += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (t += this.weeks + "W"), this.days !== 0 && (t += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (t += "T"), this.hours !== 0 && (t += this.hours + "H"), this.minutes !== 0 && (t += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (t += Ip(this.seconds + this.milliseconds / 1e3, 3) + "S"), t === "P" && (t += "T0S"), t;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(t = {}) {
    if (!this.isValid)
      return null;
    const n = this.toMillis();
    return n < 0 || n >= 864e5 ? null : (t = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...t,
      includeOffset: !1
    }, Re.fromMillis(n, { zone: "UTC" }).toISOTime(t));
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Duration { values: ${JSON.stringify(this.values)} }` : `Duration { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? eC(this.matrix, this.values) : NaN;
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(t) {
    if (!this.isValid)
      return this;
    const n = ct.fromDurationLike(t), i = {};
    for (const r of Ma)
      (wl(n.values, r) || wl(this.values, r)) && (i[r] = n.get(r) + this.get(r));
    return Ms(this, { values: i }, !0);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(t) {
    if (!this.isValid)
      return this;
    const n = ct.fromDurationLike(t);
    return this.plus(n.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(t) {
    if (!this.isValid)
      return this;
    const n = {};
    for (const i of Object.keys(this.values))
      n[i] = Lk(t(this.values[i], i));
    return Ms(this, { values: n }, !0);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(t) {
    return this[ct.normalizeUnit(t)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(t) {
    if (!this.isValid)
      return this;
    const n = { ...this.values, ...wf(t, ct.normalizeUnit) };
    return Ms(this, { values: n });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale: t, numberingSystem: n, conversionAccuracy: i, matrix: r } = {}) {
    const a = { loc: this.loc.clone({ locale: t, numberingSystem: n }), matrix: r, conversionAccuracy: i };
    return Ms(this, a);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(t) {
    return this.isValid ? this.shiftTo(t).get(t) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const t = this.toObject();
    return qw(this.matrix, t), Ms(this, { values: t }, !0);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid)
      return this;
    const t = CN(this.normalize().shiftToAll().toObject());
    return Ms(this, { values: t }, !0);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...t) {
    if (!this.isValid)
      return this;
    if (t.length === 0)
      return this;
    t = t.map((a) => ct.normalizeUnit(a));
    const n = {}, i = {}, r = this.toObject();
    let s;
    for (const a of Ma)
      if (t.indexOf(a) >= 0) {
        s = a;
        let o = 0;
        for (const u in i)
          o += this.matrix[u][a] * i[u], i[u] = 0;
        Ha(r[a]) && (o += r[a]);
        const l = Math.trunc(o);
        n[a] = l, i[a] = (o * 1e3 - l * 1e3) / 1e3;
      } else
        Ha(r[a]) && (i[a] = r[a]);
    for (const a in i)
      i[a] !== 0 && (n[s] += a === s ? i[a] : i[a] / this.matrix[s][a]);
    return qw(this.matrix, n), Ms(this, { values: n }, !0);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    return this.isValid ? this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ) : this;
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const t = {};
    for (const n of Object.keys(this.values))
      t[n] = this.values[n] === 0 ? 0 : -this.values[n];
    return Ms(this, { values: t }, !0);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(t) {
    if (!this.isValid || !t.isValid || !this.loc.equals(t.loc))
      return !1;
    function n(i, r) {
      return i === void 0 || i === 0 ? r === void 0 || r === 0 : i === r;
    }
    for (const i of Ma)
      if (!n(this.values[i], t.values[i]))
        return !1;
    return !0;
  }
}
const Lo = "Invalid Interval";
function TN(e, t) {
  return !e || !e.isValid ? Yt.invalid("missing or invalid start") : !t || !t.isValid ? Yt.invalid("missing or invalid end") : t < e ? Yt.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${e.toISO()} and end=${t.toISO()}`
  ) : null;
}
class Yt {
  /**
   * @private
   */
  constructor(t) {
    this.s = t.start, this.e = t.end, this.invalid = t.invalid || null, this.isLuxonInterval = !0;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(t, n = null) {
    if (!t)
      throw new hi("need to specify a reason the Interval is invalid");
    const i = t instanceof mr ? t : new mr(t, n);
    if (rn.throwOnInvalid)
      throw new KV(i);
    return new Yt({ invalid: i });
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(t, n) {
    const i = du(t), r = du(n), s = TN(i, r);
    return s ?? new Yt({
      start: i,
      end: r
    });
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(t, n) {
    const i = ct.fromDurationLike(n), r = du(t);
    return Yt.fromDateTimes(r, r.plus(i));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(t, n) {
    const i = ct.fromDurationLike(n), r = du(t);
    return Yt.fromDateTimes(r.minus(i), r);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(t, n) {
    const [i, r] = (t || "").split("/", 2);
    if (i && r) {
      let s, a;
      try {
        s = Re.fromISO(i, n), a = s.isValid;
      } catch {
        a = !1;
      }
      let o, l;
      try {
        o = Re.fromISO(r, n), l = o.isValid;
      } catch {
        l = !1;
      }
      if (a && l)
        return Yt.fromDateTimes(s, o);
      if (a) {
        const u = ct.fromISO(r, n);
        if (u.isValid)
          return Yt.after(s, u);
      } else if (l) {
        const u = ct.fromISO(i, n);
        if (u.isValid)
          return Yt.before(o, u);
      }
    }
    return Yt.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(t) {
    return t && t.isLuxonInterval || !1;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(t = "milliseconds") {
    return this.isValid ? this.toDuration(t).get(t) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(t = "milliseconds", n) {
    if (!this.isValid)
      return NaN;
    const i = this.start.startOf(t, n);
    let r;
    return n != null && n.useLocaleWeeks ? r = this.end.reconfigure({ locale: i.locale }) : r = this.end, r = r.startOf(t, n), Math.floor(r.diff(i, t).get(t)) + (r.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(t) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, t) : !1;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(t) {
    return this.isValid ? this.s > t : !1;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(t) {
    return this.isValid ? this.e <= t : !1;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(t) {
    return this.isValid ? this.s <= t && this.e > t : !1;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start: t, end: n } = {}) {
    return this.isValid ? Yt.fromDateTimes(t || this.s, n || this.e) : this;
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...t) {
    if (!this.isValid)
      return [];
    const n = t.map(du).filter((a) => this.contains(a)).sort((a, o) => a.toMillis() - o.toMillis()), i = [];
    let { s: r } = this, s = 0;
    for (; r < this.e; ) {
      const a = n[s] || this.e, o = +a > +this.e ? this.e : a;
      i.push(Yt.fromDateTimes(r, o)), r = o, s += 1;
    }
    return i;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(t) {
    const n = ct.fromDurationLike(t);
    if (!this.isValid || !n.isValid || n.as("milliseconds") === 0)
      return [];
    let { s: i } = this, r = 1, s;
    const a = [];
    for (; i < this.e; ) {
      const o = this.start.plus(n.mapUnits((l) => l * r));
      s = +o > +this.e ? this.e : o, a.push(Yt.fromDateTimes(i, s)), i = s, r += 1;
    }
    return a;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(t) {
    return this.isValid ? this.splitBy(this.length() / t).slice(0, t) : [];
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(t) {
    return this.e > t.s && this.s < t.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(t) {
    return this.isValid ? +this.e == +t.s : !1;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(t) {
    return this.isValid ? +t.e == +this.s : !1;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(t) {
    return this.isValid ? this.s <= t.s && this.e >= t.e : !1;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(t) {
    return !this.isValid || !t.isValid ? !1 : this.s.equals(t.s) && this.e.equals(t.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(t) {
    if (!this.isValid)
      return this;
    const n = this.s > t.s ? this.s : t.s, i = this.e < t.e ? this.e : t.e;
    return n >= i ? null : Yt.fromDateTimes(n, i);
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(t) {
    if (!this.isValid)
      return this;
    const n = this.s < t.s ? this.s : t.s, i = this.e > t.e ? this.e : t.e;
    return Yt.fromDateTimes(n, i);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(t) {
    const [n, i] = t.sort((r, s) => r.s - s.s).reduce(
      ([r, s], a) => s ? s.overlaps(a) || s.abutsStart(a) ? [r, s.union(a)] : [r.concat([s]), a] : [r, a],
      [[], null]
    );
    return i && n.push(i), n;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(t) {
    let n = null, i = 0;
    const r = [], s = t.map((l) => [
      { time: l.s, type: "s" },
      { time: l.e, type: "e" }
    ]), a = Array.prototype.concat(...s), o = a.sort((l, u) => l.time - u.time);
    for (const l of o)
      i += l.type === "s" ? 1 : -1, i === 1 ? n = l.time : (n && +n != +l.time && r.push(Yt.fromDateTimes(n, l.time)), n = null);
    return Yt.merge(r);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...t) {
    return Yt.xor([this].concat(t)).map((n) => this.intersection(n)).filter((n) => n && !n.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    return this.isValid ? `[${this.s.toISO()}  ${this.e.toISO()})` : Lo;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }` : `Interval { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
   * @return {string}
   */
  toLocaleString(t = pf, n = {}) {
    return this.isValid ? Un.create(this.s.loc.clone(n), t).formatInterval(this) : Lo;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(t) {
    return this.isValid ? `${this.s.toISO(t)}/${this.e.toISO(t)}` : Lo;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : Lo;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(t) {
    return this.isValid ? `${this.s.toISOTime(t)}/${this.e.toISOTime(t)}` : Lo;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(t, { separator: n = "  " } = {}) {
    return this.isValid ? `${this.s.toFormat(t)}${n}${this.e.toFormat(t)}` : Lo;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(t, n) {
    return this.isValid ? this.e.diff(this.s, t, n) : ct.invalid(this.invalidReason);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(t) {
    return Yt.fromDateTimes(t(this.s), t(this.e));
  }
}
class kd {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(t = rn.defaultZone) {
    const n = Re.now().setZone(t).set({ month: 12 });
    return !t.isUniversal && n.offset !== n.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(t) {
    return ws.isValidZone(t);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(t) {
    return Us(t, rn.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale: t = null, locObj: n = null } = {}) {
    return (n || bt.create(t)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale: t = null, locObj: n = null } = {}) {
    return (n || bt.create(t)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale: t = null, locObj: n = null } = {}) {
    return (n || bt.create(t)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
   * @return {Array}
   */
  static months(t = "long", { locale: n = null, numberingSystem: i = null, locObj: r = null, outputCalendar: s = "gregory" } = {}) {
    return (r || bt.create(n, i, s)).months(t);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(t = "long", { locale: n = null, numberingSystem: i = null, locObj: r = null, outputCalendar: s = "gregory" } = {}) {
    return (r || bt.create(n, i, s)).months(t, !0);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
   * @return {Array}
   */
  static weekdays(t = "long", { locale: n = null, numberingSystem: i = null, locObj: r = null } = {}) {
    return (r || bt.create(n, i, null)).weekdays(t);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(t = "long", { locale: n = null, numberingSystem: i = null, locObj: r = null } = {}) {
    return (r || bt.create(n, i, null)).weekdays(t, !0);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
   * @return {Array}
   */
  static meridiems({ locale: t = null } = {}) {
    return bt.create(t).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
   * @return {Array}
   */
  static eras(t = "short", { locale: n = null } = {}) {
    return bt.create(n, null, "gregory").eras(t);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: Rk(), localeWeek: Fk() };
  }
}
function Gw(e, t) {
  const n = (r) => r.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), i = n(t) - n(e);
  return Math.floor(ct.fromMillis(i).as("days"));
}
function xN(e, t, n) {
  const i = [
    ["years", (l, u) => u.year - l.year],
    ["quarters", (l, u) => u.quarter - l.quarter + (u.year - l.year) * 4],
    ["months", (l, u) => u.month - l.month + (u.year - l.year) * 12],
    [
      "weeks",
      (l, u) => {
        const c = Gw(l, u);
        return (c - c % 7) / 7;
      }
    ],
    ["days", Gw]
  ], r = {}, s = e;
  let a, o;
  for (const [l, u] of i)
    n.indexOf(l) >= 0 && (a = l, r[l] = u(e, t), o = s.plus(r), o > t ? (r[l]--, e = s.plus(r), e > t && (o = e, r[l]--, e = s.plus(r))) : e = o);
  return [e, r, o, a];
}
function AN(e, t, n, i) {
  let [r, s, a, o] = xN(e, t, n);
  const l = t - r, u = n.filter(
    (d) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(d) >= 0
  );
  u.length === 0 && (a < t && (a = r.plus({ [o]: 1 })), a !== r && (s[o] = (s[o] || 0) + l / (a - r)));
  const c = ct.fromObject(s, i);
  return u.length > 0 ? ct.fromMillis(l, i).shiftTo(...u).plus(c) : c;
}
const Vp = {
  arab: "[-]",
  arabext: "[-]",
  bali: "[-]",
  beng: "[-]",
  deva: "[-]",
  fullwide: "[-]",
  gujr: "[-]",
  hanidec: "[|||||||||]",
  khmr: "[-]",
  knda: "[-]",
  laoo: "[-]",
  limb: "[-]",
  mlym: "[-]",
  mong: "[-]",
  mymr: "[-]",
  orya: "[-]",
  tamldec: "[-]",
  telu: "[-]",
  thai: "[-]",
  tibt: "[-]",
  latn: "\\d"
}, Yw = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, IN = Vp.hanidec.replace(/[\[|\]]/g, "").split("");
function EN(e) {
  let t = parseInt(e, 10);
  if (isNaN(t)) {
    t = "";
    for (let n = 0; n < e.length; n++) {
      const i = e.charCodeAt(n);
      if (e[n].search(Vp.hanidec) !== -1)
        t += IN.indexOf(e[n]);
      else
        for (const r in Yw) {
          const [s, a] = Yw[r];
          i >= s && i <= a && (t += i - s);
        }
    }
    return parseInt(t, 10);
  } else
    return t;
}
function ir({ numberingSystem: e }, t = "") {
  return new RegExp(`${Vp[e || "latn"]}${t}`);
}
const PN = "missing Intl.DateTimeFormat.formatToParts support";
function ht(e, t = (n) => n) {
  return { regex: e, deser: ([n]) => t(EN(n)) };
}
const ON = String.fromCharCode(160), tC = `[ ${ON}]`, nC = new RegExp(tC, "g");
function VN(e) {
  return e.replace(/\./g, "\\.?").replace(nC, tC);
}
function Zw(e) {
  return e.replace(/\./g, "").replace(nC, " ").toLowerCase();
}
function rr(e, t) {
  return e === null ? null : {
    regex: RegExp(e.map(VN).join("|")),
    deser: ([n]) => e.findIndex((i) => Zw(n) === Zw(i)) + t
  };
}
function Kw(e, t) {
  return { regex: e, deser: ([, n, i]) => Ih(n, i), groups: t };
}
function Cd(e) {
  return { regex: e, deser: ([t]) => t };
}
function DN(e) {
  return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function NN(e, t) {
  const n = ir(t), i = ir(t, "{2}"), r = ir(t, "{3}"), s = ir(t, "{4}"), a = ir(t, "{6}"), o = ir(t, "{1,2}"), l = ir(t, "{1,3}"), u = ir(t, "{1,6}"), c = ir(t, "{1,9}"), d = ir(t, "{2,4}"), f = ir(t, "{4,6}"), h = (p) => ({ regex: RegExp(DN(p.val)), deser: ([y]) => y, literal: !0 }), g = ((p) => {
    if (e.literal)
      return h(p);
    switch (p.val) {
      case "G":
        return rr(t.eras("short"), 0);
      case "GG":
        return rr(t.eras("long"), 0);
      case "y":
        return ht(u);
      case "yy":
        return ht(d, Hv);
      case "yyyy":
        return ht(s);
      case "yyyyy":
        return ht(f);
      case "yyyyyy":
        return ht(a);
      case "M":
        return ht(o);
      case "MM":
        return ht(i);
      case "MMM":
        return rr(t.months("short", !0), 1);
      case "MMMM":
        return rr(t.months("long", !0), 1);
      case "L":
        return ht(o);
      case "LL":
        return ht(i);
      case "LLL":
        return rr(t.months("short", !1), 1);
      case "LLLL":
        return rr(t.months("long", !1), 1);
      case "d":
        return ht(o);
      case "dd":
        return ht(i);
      case "o":
        return ht(l);
      case "ooo":
        return ht(r);
      case "HH":
        return ht(i);
      case "H":
        return ht(o);
      case "hh":
        return ht(i);
      case "h":
        return ht(o);
      case "mm":
        return ht(i);
      case "m":
        return ht(o);
      case "q":
        return ht(o);
      case "qq":
        return ht(i);
      case "s":
        return ht(o);
      case "ss":
        return ht(i);
      case "S":
        return ht(l);
      case "SSS":
        return ht(r);
      case "u":
        return Cd(c);
      case "uu":
        return Cd(o);
      case "uuu":
        return ht(n);
      case "a":
        return rr(t.meridiems(), 0);
      case "kkkk":
        return ht(s);
      case "kk":
        return ht(d, Hv);
      case "W":
        return ht(o);
      case "WW":
        return ht(i);
      case "E":
      case "c":
        return ht(n);
      case "EEE":
        return rr(t.weekdays("short", !1), 1);
      case "EEEE":
        return rr(t.weekdays("long", !1), 1);
      case "ccc":
        return rr(t.weekdays("short", !0), 1);
      case "cccc":
        return rr(t.weekdays("long", !0), 1);
      case "Z":
      case "ZZ":
        return Kw(new RegExp(`([+-]${o.source})(?::(${i.source}))?`), 2);
      case "ZZZ":
        return Kw(new RegExp(`([+-]${o.source})(${i.source})?`), 2);
      case "z":
        return Cd(/[a-z_+-/]{1,256}?/i);
      case " ":
        return Cd(/[^\S\n\r]/);
      default:
        return h(p);
    }
  })(e) || {
    invalidReason: PN
  };
  return g.token = e, g;
}
const MN = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function RN(e, t, n) {
  const { type: i, value: r } = e;
  if (i === "literal") {
    const l = /^\s+$/.test(r);
    return {
      literal: !l,
      val: l ? " " : r
    };
  }
  const s = t[i];
  let a = i;
  i === "hour" && (t.hour12 != null ? a = t.hour12 ? "hour12" : "hour24" : t.hourCycle != null ? t.hourCycle === "h11" || t.hourCycle === "h12" ? a = "hour12" : a = "hour24" : a = n.hour12 ? "hour12" : "hour24");
  let o = MN[a];
  if (typeof o == "object" && (o = o[s]), o)
    return {
      literal: !1,
      val: o
    };
}
function FN(e) {
  return [`^${e.map((n) => n.regex).reduce((n, i) => `${n}(${i.source})`, "")}$`, e];
}
function BN(e, t, n) {
  const i = e.match(t);
  if (i) {
    const r = {};
    let s = 1;
    for (const a in n)
      if (wl(n, a)) {
        const o = n[a], l = o.groups ? o.groups + 1 : 1;
        !o.literal && o.token && (r[o.token.val[0]] = o.deser(i.slice(s, s + l))), s += l;
      }
    return [i, r];
  } else
    return [i, {}];
}
function LN(e) {
  const t = (s) => {
    switch (s) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let n = null, i;
  return Ue(e.z) || (n = ws.create(e.z)), Ue(e.Z) || (n || (n = new ni(e.Z)), i = e.Z), Ue(e.q) || (e.M = (e.q - 1) * 3 + 1), Ue(e.h) || (e.h < 12 && e.a === 1 ? e.h += 12 : e.h === 12 && e.a === 0 && (e.h = 0)), e.G === 0 && e.y && (e.y = -e.y), Ue(e.u) || (e.S = Ap(e.u)), [Object.keys(e).reduce((s, a) => {
    const o = t(a);
    return o && (s[o] = e[a]), s;
  }, {}), n, i];
}
let Jm = null;
function $N() {
  return Jm || (Jm = Re.fromMillis(1555555555555)), Jm;
}
function WN(e, t) {
  if (e.literal)
    return e;
  const n = Un.macroTokenToFormatOpts(e.val), i = sC(n, t);
  return i == null || i.includes(void 0) ? e : i;
}
function iC(e, t) {
  return Array.prototype.concat(...e.map((n) => WN(n, t)));
}
function rC(e, t, n) {
  const i = iC(Un.parseFormat(n), e), r = i.map((a) => NN(a, e)), s = r.find((a) => a.invalidReason);
  if (s)
    return { input: t, tokens: i, invalidReason: s.invalidReason };
  {
    const [a, o] = FN(r), l = RegExp(a, "i"), [u, c] = BN(t, l, o), [d, f, h] = c ? LN(c) : [null, null, void 0];
    if (wl(c, "a") && wl(c, "H"))
      throw new Xo(
        "Can't include meridiem when specifying 24-hour format"
      );
    return { input: t, tokens: i, regex: l, rawMatches: u, matches: c, result: d, zone: f, specificOffset: h };
  }
}
function jN(e, t, n) {
  const { result: i, zone: r, specificOffset: s, invalidReason: a } = rC(e, t, n);
  return [i, r, s, a];
}
function sC(e, t) {
  if (!e)
    return null;
  const i = Un.create(t, e).dtFormatter($N()), r = i.formatToParts(), s = i.resolvedOptions();
  return r.map((a) => RN(a, e, s));
}
const Qm = "Invalid DateTime", Xw = 864e13;
function Td(e) {
  return new mr("unsupported zone", `the zone "${e.name}" is not supported`);
}
function ev(e) {
  return e.weekData === null && (e.weekData = yf(e.c)), e.weekData;
}
function tv(e) {
  return e.localWeekData === null && (e.localWeekData = yf(
    e.c,
    e.loc.getMinDaysInFirstWeek(),
    e.loc.getStartOfWeek()
  )), e.localWeekData;
}
function wa(e, t) {
  const n = {
    ts: e.ts,
    zone: e.zone,
    c: e.c,
    o: e.o,
    loc: e.loc,
    invalid: e.invalid
  };
  return new Re({ ...n, ...t, old: n });
}
function aC(e, t, n) {
  let i = e - t * 60 * 1e3;
  const r = n.offset(i);
  if (t === r)
    return [i, t];
  i -= (r - t) * 60 * 1e3;
  const s = n.offset(i);
  return r === s ? [i, r] : [e - Math.min(r, s) * 60 * 1e3, Math.max(r, s)];
}
function xd(e, t) {
  e += t * 60 * 1e3;
  const n = new Date(e);
  return {
    year: n.getUTCFullYear(),
    month: n.getUTCMonth() + 1,
    day: n.getUTCDate(),
    hour: n.getUTCHours(),
    minute: n.getUTCMinutes(),
    second: n.getUTCSeconds(),
    millisecond: n.getUTCMilliseconds()
  };
}
function $d(e, t, n) {
  return aC(Ah(e), t, n);
}
function Jw(e, t) {
  const n = e.o, i = e.c.year + Math.trunc(t.years), r = e.c.month + Math.trunc(t.months) + Math.trunc(t.quarters) * 3, s = {
    ...e.c,
    year: i,
    month: r,
    day: Math.min(e.c.day, bf(i, r)) + Math.trunc(t.days) + Math.trunc(t.weeks) * 7
  }, a = ct.fromObject({
    years: t.years - Math.trunc(t.years),
    quarters: t.quarters - Math.trunc(t.quarters),
    months: t.months - Math.trunc(t.months),
    weeks: t.weeks - Math.trunc(t.weeks),
    days: t.days - Math.trunc(t.days),
    hours: t.hours,
    minutes: t.minutes,
    seconds: t.seconds,
    milliseconds: t.milliseconds
  }).as("milliseconds"), o = Ah(s);
  let [l, u] = aC(o, n, e.zone);
  return a !== 0 && (l += a, u = e.zone.offset(l)), { ts: l, o: u };
}
function cu(e, t, n, i, r, s) {
  const { setZone: a, zone: o } = n;
  if (e && Object.keys(e).length !== 0 || t) {
    const l = t || o, u = Re.fromObject(e, {
      ...n,
      zone: l,
      specificOffset: s
    });
    return a ? u : u.setZone(o);
  } else
    return Re.invalid(
      new mr("unparsable", `the input "${r}" can't be parsed as ${i}`)
    );
}
function Ad(e, t, n = !0) {
  return e.isValid ? Un.create(bt.create("en-US"), {
    allowZ: n,
    forceSimple: !0
  }).formatDateTimeFromString(e, t) : null;
}
function nv(e, t) {
  const n = e.c.year > 9999 || e.c.year < 0;
  let i = "";
  return n && e.c.year >= 0 && (i += "+"), i += fn(e.c.year, n ? 6 : 4), t ? (i += "-", i += fn(e.c.month), i += "-", i += fn(e.c.day)) : (i += fn(e.c.month), i += fn(e.c.day)), i;
}
function Qw(e, t, n, i, r, s) {
  let a = fn(e.c.hour);
  return t ? (a += ":", a += fn(e.c.minute), (e.c.millisecond !== 0 || e.c.second !== 0 || !n) && (a += ":")) : a += fn(e.c.minute), (e.c.millisecond !== 0 || e.c.second !== 0 || !n) && (a += fn(e.c.second), (e.c.millisecond !== 0 || !i) && (a += ".", a += fn(e.c.millisecond, 3))), r && (e.isOffsetFixed && e.offset === 0 && !s ? a += "Z" : e.o < 0 ? (a += "-", a += fn(Math.trunc(-e.o / 60)), a += ":", a += fn(Math.trunc(-e.o % 60))) : (a += "+", a += fn(Math.trunc(e.o / 60)), a += ":", a += fn(Math.trunc(e.o % 60)))), s && (a += "[" + e.zone.ianaName + "]"), a;
}
const oC = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, HN = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, zN = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, lC = ["year", "month", "day", "hour", "minute", "second", "millisecond"], UN = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], qN = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function GN(e) {
  const t = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[e.toLowerCase()];
  if (!t)
    throw new ck(e);
  return t;
}
function e0(e) {
  switch (e.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return GN(e);
  }
}
function t0(e, t) {
  const n = Us(t.zone, rn.defaultZone), i = bt.fromObject(t), r = rn.now();
  let s, a;
  if (Ue(e.year))
    s = r;
  else {
    for (const u of lC)
      Ue(e[u]) && (e[u] = oC[u]);
    const o = Nk(e) || Mk(e);
    if (o)
      return Re.invalid(o);
    const l = n.offset(r);
    [s, a] = $d(e, l, n);
  }
  return new Re({ ts: s, zone: n, loc: i, o: a });
}
function n0(e, t, n) {
  const i = Ue(n.round) ? !0 : n.round, r = (a, o) => (a = Ip(a, i || n.calendary ? 0 : 2, !0), t.loc.clone(n).relFormatter(n).format(a, o)), s = (a) => n.calendary ? t.hasSame(e, a) ? 0 : t.startOf(a).diff(e.startOf(a), a).get(a) : t.diff(e, a).get(a);
  if (n.unit)
    return r(s(n.unit), n.unit);
  for (const a of n.units) {
    const o = s(a);
    if (Math.abs(o) >= 1)
      return r(o, a);
  }
  return r(e > t ? -0 : 0, n.units[n.units.length - 1]);
}
function i0(e) {
  let t = {}, n;
  return e.length > 0 && typeof e[e.length - 1] == "object" ? (t = e[e.length - 1], n = Array.from(e).slice(0, e.length - 1)) : n = Array.from(e), [t, n];
}
class Re {
  /**
   * @access private
   */
  constructor(t) {
    const n = t.zone || rn.defaultZone;
    let i = t.invalid || (Number.isNaN(t.ts) ? new mr("invalid input") : null) || (n.isValid ? null : Td(n));
    this.ts = Ue(t.ts) ? rn.now() : t.ts;
    let r = null, s = null;
    if (!i)
      if (t.old && t.old.ts === this.ts && t.old.zone.equals(n))
        [r, s] = [t.old.c, t.old.o];
      else {
        const o = n.offset(this.ts);
        r = xd(this.ts, o), i = Number.isNaN(r.year) ? new mr("invalid input") : null, r = i ? null : r, s = i ? null : o;
      }
    this._zone = n, this.loc = t.loc || bt.create(), this.invalid = i, this.weekData = null, this.localWeekData = null, this.c = r, this.o = s, this.isLuxonDateTime = !0;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new Re({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [t, n] = i0(arguments), [i, r, s, a, o, l, u] = n;
    return t0({ year: i, month: r, day: s, hour: a, minute: o, second: l, millisecond: u }, t);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [t, n] = i0(arguments), [i, r, s, a, o, l, u] = n;
    return t.zone = ni.utcInstance, t0({ year: i, month: r, day: s, hour: a, minute: o, second: l, millisecond: u }, t);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(t, n = {}) {
    const i = SD(t) ? t.valueOf() : NaN;
    if (Number.isNaN(i))
      return Re.invalid("invalid input");
    const r = Us(n.zone, rn.defaultZone);
    return r.isValid ? new Re({
      ts: i,
      zone: r,
      loc: bt.fromObject(n)
    }) : Re.invalid(Td(r));
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(t, n = {}) {
    if (Ha(t))
      return t < -Xw || t > Xw ? Re.invalid("Timestamp out of range") : new Re({
        ts: t,
        zone: Us(n.zone, rn.defaultZone),
        loc: bt.fromObject(n)
      });
    throw new hi(
      `fromMillis requires a numerical input, but received a ${typeof t} with value ${t}`
    );
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(t, n = {}) {
    if (Ha(t))
      return new Re({
        ts: t * 1e3,
        zone: Us(n.zone, rn.defaultZone),
        loc: bt.fromObject(n)
      });
    throw new hi("fromSeconds requires a numerical input");
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(t, n = {}) {
    t = t || {};
    const i = Us(n.zone, rn.defaultZone);
    if (!i.isValid)
      return Re.invalid(Td(i));
    const r = bt.fromObject(n), s = wf(t, e0), { minDaysInFirstWeek: a, startOfWeek: o } = $w(s, r), l = rn.now(), u = Ue(n.specificOffset) ? i.offset(l) : n.specificOffset, c = !Ue(s.ordinal), d = !Ue(s.year), f = !Ue(s.month) || !Ue(s.day), h = d || f, m = s.weekYear || s.weekNumber;
    if ((h || c) && m)
      throw new Xo(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (f && c)
      throw new Xo("Can't mix ordinal dates with month/day");
    const g = m || s.weekday && !h;
    let p, y, k = xd(l, u);
    g ? (p = UN, y = HN, k = yf(k, a, o)) : c ? (p = qN, y = zN, k = Xm(k)) : (p = lC, y = oC);
    let T = !1;
    for (const I of p) {
      const E = s[I];
      Ue(E) ? T ? s[I] = y[I] : s[I] = k[I] : T = !0;
    }
    const _ = g ? bD(s, a, o) : c ? wD(s) : Nk(s), w = _ || Mk(s);
    if (w)
      return Re.invalid(w);
    const S = g ? Bw(s, a, o) : c ? Lw(s) : s, [C, x] = $d(S, u, i), A = new Re({
      ts: C,
      zone: i,
      o: x,
      loc: r
    });
    return s.weekday && h && t.weekday !== A.weekday ? Re.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${s.weekday} and a date of ${A.toISO()}`
    ) : A;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(t, n = {}) {
    const [i, r] = dN(t);
    return cu(i, r, n, "ISO 8601", t);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(t, n = {}) {
    const [i, r] = fN(t);
    return cu(i, r, n, "RFC 2822", t);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(t, n = {}) {
    const [i, r] = hN(t);
    return cu(i, r, n, "HTTP", n);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(t, n, i = {}) {
    if (Ue(t) || Ue(n))
      throw new hi("fromFormat requires an input string and a format");
    const { locale: r = null, numberingSystem: s = null } = i, a = bt.fromOpts({
      locale: r,
      numberingSystem: s,
      defaultToEN: !0
    }), [o, l, u, c] = jN(a, t, n);
    return c ? Re.invalid(c) : cu(o, l, i, `format ${n}`, t, u);
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(t, n, i = {}) {
    return Re.fromFormat(t, n, i);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(t, n = {}) {
    const [i, r] = wN(t);
    return cu(i, r, n, "SQL", t);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(t, n = null) {
    if (!t)
      throw new hi("need to specify a reason the DateTime is invalid");
    const i = t instanceof mr ? t : new mr(t, n);
    if (rn.throwOnInvalid)
      throw new ZV(i);
    return new Re({ invalid: i });
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(t) {
    return t && t.isLuxonDateTime || !1;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(t, n = {}) {
    const i = sC(t, bt.fromObject(n));
    return i ? i.map((r) => r ? r.val : null).join("") : null;
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(t, n = {}) {
    return iC(Un.parseFormat(t), bt.fromObject(n)).map((r) => r.val).join("");
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(t) {
    return this[t];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? ev(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? ev(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? ev(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? tv(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? tv(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? tv(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? Xm(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? kd.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? kd.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? kd.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? kd.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed)
      return [this];
    const t = 864e5, n = 6e4, i = Ah(this.c), r = this.zone.offset(i - t), s = this.zone.offset(i + t), a = this.zone.offset(i - r * n), o = this.zone.offset(i - s * n);
    if (a === o)
      return [this];
    const l = i - a * n, u = i - o * n, c = xd(l, a), d = xd(u, o);
    return c.hour === d.hour && c.minute === d.minute && c.second === d.second && c.millisecond === d.millisecond ? [wa(this, { ts: l }), wa(this, { ts: u })] : [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return Bc(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return bf(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? ol(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? Xu(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? Xu(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(t = {}) {
    const { locale: n, numberingSystem: i, calendar: r } = Un.create(
      this.loc.clone(t),
      t
    ).resolvedOptions(this);
    return { locale: n, numberingSystem: i, outputCalendar: r };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(t = 0, n = {}) {
    return this.setZone(ni.instance(t), n);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(rn.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(t, { keepLocalTime: n = !1, keepCalendarTime: i = !1 } = {}) {
    if (t = Us(t, rn.defaultZone), t.equals(this.zone))
      return this;
    if (t.isValid) {
      let r = this.ts;
      if (n || i) {
        const s = t.offset(this.ts), a = this.toObject();
        [r] = $d(a, s, t);
      }
      return wa(this, { ts: r, zone: t });
    } else
      return Re.invalid(Td(t));
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale: t, numberingSystem: n, outputCalendar: i } = {}) {
    const r = this.loc.clone({ locale: t, numberingSystem: n, outputCalendar: i });
    return wa(this, { loc: r });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(t) {
    return this.reconfigure({ locale: t });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(t) {
    if (!this.isValid)
      return this;
    const n = wf(t, e0), { minDaysInFirstWeek: i, startOfWeek: r } = $w(n, this.loc), s = !Ue(n.weekYear) || !Ue(n.weekNumber) || !Ue(n.weekday), a = !Ue(n.ordinal), o = !Ue(n.year), l = !Ue(n.month) || !Ue(n.day), u = o || l, c = n.weekYear || n.weekNumber;
    if ((u || a) && c)
      throw new Xo(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (l && a)
      throw new Xo("Can't mix ordinal dates with month/day");
    let d;
    s ? d = Bw(
      { ...yf(this.c, i, r), ...n },
      i,
      r
    ) : Ue(n.ordinal) ? (d = { ...this.toObject(), ...n }, Ue(n.day) && (d.day = Math.min(bf(d.year, d.month), d.day))) : d = Lw({ ...Xm(this.c), ...n });
    const [f, h] = $d(d, this.o, this.zone);
    return wa(this, { ts: f, o: h });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(t) {
    if (!this.isValid)
      return this;
    const n = ct.fromDurationLike(t);
    return wa(this, Jw(this, n));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(t) {
    if (!this.isValid)
      return this;
    const n = ct.fromDurationLike(t).negate();
    return wa(this, Jw(this, n));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(t, { useLocaleWeeks: n = !1 } = {}) {
    if (!this.isValid)
      return this;
    const i = {}, r = ct.normalizeUnit(t);
    switch (r) {
      case "years":
        i.month = 1;
      case "quarters":
      case "months":
        i.day = 1;
      case "weeks":
      case "days":
        i.hour = 0;
      case "hours":
        i.minute = 0;
      case "minutes":
        i.second = 0;
      case "seconds":
        i.millisecond = 0;
        break;
    }
    if (r === "weeks")
      if (n) {
        const s = this.loc.getStartOfWeek(), { weekday: a } = this;
        a < s && (i.weekNumber = this.weekNumber - 1), i.weekday = s;
      } else
        i.weekday = 1;
    if (r === "quarters") {
      const s = Math.ceil(this.month / 3);
      i.month = (s - 1) * 3 + 1;
    }
    return this.set(i);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(t, n) {
    return this.isValid ? this.plus({ [t]: 1 }).startOf(t, n).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(t, n = {}) {
    return this.isValid ? Un.create(this.loc.redefaultToEN(n)).formatDateTimeFromString(this, t) : Qm;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(t = pf, n = {}) {
    return this.isValid ? Un.create(this.loc.clone(n), t).formatDateTime(this) : Qm;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(t = {}) {
    return this.isValid ? Un.create(this.loc.clone(t), t).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format: t = "extended",
    suppressSeconds: n = !1,
    suppressMilliseconds: i = !1,
    includeOffset: r = !0,
    extendedZone: s = !1
  } = {}) {
    if (!this.isValid)
      return null;
    const a = t === "extended";
    let o = nv(this, a);
    return o += "T", o += Qw(this, a, n, i, r, s), o;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format: t = "extended" } = {}) {
    return this.isValid ? nv(this, t === "extended") : null;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return Ad(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds: t = !1,
    suppressSeconds: n = !1,
    includeOffset: i = !0,
    includePrefix: r = !1,
    extendedZone: s = !1,
    format: a = "extended"
  } = {}) {
    return this.isValid ? (r ? "T" : "") + Qw(
      this,
      a === "extended",
      n,
      t,
      i,
      s
    ) : null;
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return Ad(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return Ad(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    return this.isValid ? nv(this, !0) : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset: t = !0, includeZone: n = !1, includeOffsetSpace: i = !0 } = {}) {
    let r = "HH:mm:ss.SSS";
    return (n || t) && (i && (r += " "), n ? r += "z" : t && (r += "ZZ")), Ad(this, r, !0);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(t = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(t)}` : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : Qm;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }` : `DateTime { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(t = {}) {
    if (!this.isValid)
      return {};
    const n = { ...this.c };
    return t.includeConfig && (n.outputCalendar = this.outputCalendar, n.numberingSystem = this.loc.numberingSystem, n.locale = this.loc.locale), n;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(t, n = "milliseconds", i = {}) {
    if (!this.isValid || !t.isValid)
      return ct.invalid("created by diffing an invalid DateTime");
    const r = { locale: this.locale, numberingSystem: this.numberingSystem, ...i }, s = kD(n).map(ct.normalizeUnit), a = t.valueOf() > this.valueOf(), o = a ? this : t, l = a ? t : this, u = AN(o, l, s, r);
    return a ? u.negate() : u;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(t = "milliseconds", n = {}) {
    return this.diff(Re.now(), t, n);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(t) {
    return this.isValid ? Yt.fromDateTimes(this, t) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(t, n, i) {
    if (!this.isValid)
      return !1;
    const r = t.valueOf(), s = this.setZone(t.zone, { keepLocalTime: !0 });
    return s.startOf(n, i) <= r && r <= s.endOf(n, i);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(t) {
    return this.isValid && t.isValid && this.valueOf() === t.valueOf() && this.zone.equals(t.zone) && this.loc.equals(t.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(t = {}) {
    if (!this.isValid)
      return null;
    const n = t.base || Re.fromObject({}, { zone: this.zone }), i = t.padding ? this < n ? -t.padding : t.padding : 0;
    let r = ["years", "months", "days", "hours", "minutes", "seconds"], s = t.unit;
    return Array.isArray(t.unit) && (r = t.unit, s = void 0), n0(n, this.plus(i), {
      ...t,
      numeric: "always",
      units: r,
      unit: s
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(t = {}) {
    return this.isValid ? n0(t.base || Re.fromObject({}, { zone: this.zone }), this, {
      ...t,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...t) {
    if (!t.every(Re.isDateTime))
      throw new hi("min requires all arguments be DateTimes");
    return Ww(t, (n) => n.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...t) {
    if (!t.every(Re.isDateTime))
      throw new hi("max requires all arguments be DateTimes");
    return Ww(t, (n) => n.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(t, n, i = {}) {
    const { locale: r = null, numberingSystem: s = null } = i, a = bt.fromOpts({
      locale: r,
      numberingSystem: s,
      defaultToEN: !0
    });
    return rC(a, t, n);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(t, n, i = {}) {
    return Re.fromFormatExplain(t, n, i);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return pf;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return dk;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return JV;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return fk;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return hk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return mk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return vk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return gk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return pk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return yk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return bk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return wk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return _k;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return Sk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return kk;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return Ck;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return Tk;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return QV;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return xk;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return Ak;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return Ik;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return Ek;
  }
}
function du(e) {
  if (Re.isDateTime(e))
    return e;
  if (e && e.valueOf && Ha(e.valueOf()))
    return Re.fromJSDate(e);
  if (e && typeof e == "object")
    return Re.fromObject(e);
  throw new hi(
    `Unknown datetime argument: ${e}, of type ${typeof e}`
  );
}
const YN = Bl({
  name: "VPDateTime",
  props: {
    /**
     * The input date string to be formatted.
     */
    input: {
      type: String,
      default: void 0
    },
    /**
     * The format of the input date string.
     */
    inputFormat: {
      type: String,
      default: "yyyy-MM-ddTHH:mm:ss.ZZZZ"
    },
    /**
     * The time zone of the input date string.
     */
    inputZone: {
      type: [String, Object],
      default: "local"
    },
    /**
     * Whether to set the time zone of the input date string.
     */
    inputSetZone: {
      type: Boolean,
      default: !1
    },
    /**
     * The locale of the input date string.
     */
    inputLocale: {
      type: String,
      default: "en-US"
    },
    /**
     * The numbering system of the input date string.
     */
    inputNumberingSystem: {
      type: String,
      default: "latn"
    },
    /**
     * The output calendar of the input date string.
     */
    inputOutputCalendar: {
      type: String,
      default: "gregory"
    },
    /**
     * The format of the output date string.
     */
    outputFormat: {
      type: [Object],
      default: Re.DATETIME_FULL
    },
    /**
     * The time zone of the output date string.
     */
    outputTimeZone: {
      type: [String, Object],
      default: "local"
    },
    /**
     * The locale of the output date string.
     */
    outputLocale: {
      type: String,
      default: "en-US"
    },
    /**
     * The numbering system of the output date string.
     */
    outputNumberingSystem: {
      type: String,
      default: "latn"
    },
    /**
     * The output calendar of the output date string.
     */
    outputOutputCalendar: {
      type: String,
      default: "gregory"
    }
  },
  setup(e) {
    const t = b(() => e.input), n = ja(e, "VPDateTime"), i = b(
      () => n.inputFormat || "yyyy-MM-ddTHH:mm:ss.ZZZZ"
    ), r = b(() => n.inputZone), s = b(() => n.inputSetZone), a = b(() => n.inputLocale), o = b(() => n.inputNumberingSystem), l = b(() => n.inputOutputCalendar), u = X(void 0), c = b(() => t.value !== void 0 ? Re.fromFormat(t.value, i.value, {
      zone: r.value,
      setZone: s.value,
      locale: a.value,
      numberingSystem: o.value,
      outputCalendar: l.value
    }) : u.value !== void 0 ? u.value : Re.now()), d = () => {
      t.value === void 0 && (u.value = Re.now());
    };
    let f;
    En(() => {
      d(), f = setInterval(d, 10);
    }), ip(() => {
      f !== void 0 && clearInterval(f);
    });
    const h = b(() => n.outputFormat), m = b(() => n.outputTimeZone), g = b(() => n.outputLocale), p = b(() => n.outputNumberingSystem), y = b(() => n.outputOutputCalendar);
    return {
      output: b(() => c.value.setZone(m.value).toLocaleString(h.value, {
        locale: g.value,
        numberingSystem: p.value,
        outputCalendar: y.value
      }))
    };
  }
}), ZN = ["textContent"];
function KN(e, t, n, i, r, s) {
  return vl(), Q_("span", {
    textContent: uh(e.output)
  }, null, 8, ZN);
}
const XN = /* @__PURE__ */ Rc(YN, [["render", KN]]);
function JN() {
  return uC().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function uC() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
}
const QN = typeof Proxy == "function", eM = "devtools-plugin:setup", tM = "plugin:settings:set";
let $o, zv;
function nM() {
  var e;
  return $o !== void 0 || (typeof window < "u" && window.performance ? ($o = !0, zv = window.performance) : typeof globalThis < "u" && (!((e = globalThis.perf_hooks) === null || e === void 0) && e.performance) ? ($o = !0, zv = globalThis.perf_hooks.performance) : $o = !1), $o;
}
function iM() {
  return nM() ? zv.now() : Date.now();
}
class rM {
  constructor(t, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = t, this.hook = n;
    const i = {};
    if (t.settings)
      for (const a in t.settings) {
        const o = t.settings[a];
        i[a] = o.defaultValue;
      }
    const r = `__vue-devtools-plugin-settings__${t.id}`;
    let s = Object.assign({}, i);
    try {
      const a = localStorage.getItem(r), o = JSON.parse(a);
      Object.assign(s, o);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return s;
      },
      setSettings(a) {
        try {
          localStorage.setItem(r, JSON.stringify(a));
        } catch {
        }
        s = a;
      },
      now() {
        return iM();
      }
    }, n && n.on(tM, (a, o) => {
      a === this.plugin.id && this.fallbacks.setSettings(o);
    }), this.proxiedOn = new Proxy({}, {
      get: (a, o) => this.target ? this.target.on[o] : (...l) => {
        this.onQueue.push({
          method: o,
          args: l
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (a, o) => this.target ? this.target[o] : o === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(o) ? (...l) => (this.targetQueue.push({
        method: o,
        args: l,
        resolve: () => {
        }
      }), this.fallbacks[o](...l)) : (...l) => new Promise((u) => {
        this.targetQueue.push({
          method: o,
          args: l,
          resolve: u
        });
      })
    });
  }
  async setRealTarget(t) {
    this.target = t;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function sM(e, t) {
  const n = e, i = uC(), r = JN(), s = QN && n.enableEarlyProxy;
  if (r && (i.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !s))
    r.emit(eM, e, t);
  else {
    const a = s ? new rM(n, r) : null;
    (i.__VUE_DEVTOOLS_PLUGINS__ = i.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: t,
      proxy: a
    }), a && t(a.proxiedTarget);
  }
}
/**
  * vee-validate v4.12.8
  * (c) 2024 Abdelrahman Awad
  * @license MIT
  */
function dr(e) {
  return typeof e == "function";
}
function cC(e) {
  return e == null;
}
const Ya = (e) => e !== null && !!e && typeof e == "object" && !Array.isArray(e);
function Dp(e) {
  return Number(e) >= 0;
}
function aM(e) {
  return typeof e == "object" && e !== null;
}
function oM(e) {
  return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e);
}
function r0(e) {
  if (!aM(e) || oM(e) !== "[object Object]")
    return !1;
  if (Object.getPrototypeOf(e) === null)
    return !0;
  let t = e;
  for (; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t;
}
function Ju(e, t) {
  return Object.keys(t).forEach((n) => {
    if (r0(t[n]) && r0(e[n])) {
      e[n] || (e[n] = {}), Ju(e[n], t[n]);
      return;
    }
    e[n] = t[n];
  }), e;
}
function Id(e) {
  const t = e.split(".");
  if (!t.length)
    return "";
  let n = String(t[0]);
  for (let i = 1; i < t.length; i++) {
    if (Dp(t[i])) {
      n += `[${t[i]}]`;
      continue;
    }
    n += `.${t[i]}`;
  }
  return n;
}
const lM = {};
function uM(e) {
  return lM[e];
}
function s0(e, t, n) {
  typeof n.value == "object" && (n.value = zt(n.value)), !n.enumerable || n.get || n.set || !n.configurable || !n.writable || t === "__proto__" ? Object.defineProperty(e, t, n) : e[t] = n.value;
}
function zt(e) {
  if (typeof e != "object")
    return e;
  var t = 0, n, i, r, s = Object.prototype.toString.call(e);
  if (s === "[object Object]" ? r = Object.create(e.__proto__ || null) : s === "[object Array]" ? r = Array(e.length) : s === "[object Set]" ? (r = /* @__PURE__ */ new Set(), e.forEach(function(a) {
    r.add(zt(a));
  })) : s === "[object Map]" ? (r = /* @__PURE__ */ new Map(), e.forEach(function(a, o) {
    r.set(zt(o), zt(a));
  })) : s === "[object Date]" ? r = /* @__PURE__ */ new Date(+e) : s === "[object RegExp]" ? r = new RegExp(e.source, e.flags) : s === "[object DataView]" ? r = new e.constructor(zt(e.buffer)) : s === "[object ArrayBuffer]" ? r = e.slice(0) : s.slice(-6) === "Array]" && (r = new e.constructor(e)), r) {
    for (i = Object.getOwnPropertySymbols(e); t < i.length; t++)
      s0(r, i[t], Object.getOwnPropertyDescriptor(e, i[t]));
    for (t = 0, i = Object.getOwnPropertyNames(e); t < i.length; t++)
      Object.hasOwnProperty.call(r, n = i[t]) && r[n] === e[n] || s0(r, n, Object.getOwnPropertyDescriptor(e, n));
  }
  return r || e;
}
const cM = Symbol("vee-validate-form"), dM = typeof window < "u";
function fM(e) {
  return dr(e) && !!e.__locatorRef;
}
function Ys(e) {
  return !!e && dr(e.parse) && e.__type === "VVTypedSchema";
}
function dC(e) {
  return !!e && dr(e.validate);
}
function hM(e) {
  return e === "checkbox" || e === "radio";
}
function mM(e) {
  return Ya(e) || Array.isArray(e);
}
function vM(e) {
  return Array.isArray(e) ? e.length === 0 : Ya(e) && Object.keys(e).length === 0;
}
function Ph(e) {
  return /^\[.+\]$/i.test(e);
}
function gM(e) {
  return fC(e) && e.multiple;
}
function fC(e) {
  return e.tagName === "SELECT";
}
function pM(e) {
  return hC(e) && e.target && "submit" in e.target;
}
function hC(e) {
  return e ? !!(typeof Event < "u" && dr(Event) && e instanceof Event || e && e.srcElement) : !1;
}
function Fu(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    var n, i, r;
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (i = n; i-- !== 0; )
        if (!Fu(e[i], t[i]))
          return !1;
      return !0;
    }
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
        return !1;
      for (i of e.entries())
        if (!t.has(i[0]))
          return !1;
      for (i of e.entries())
        if (!Fu(i[1], t.get(i[0])))
          return !1;
      return !0;
    }
    if (a0(e) && a0(t))
      return !(e.size !== t.size || e.name !== t.name || e.lastModified !== t.lastModified || e.type !== t.type);
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
        return !1;
      for (i of e.entries())
        if (!t.has(i[0]))
          return !1;
      return !0;
    }
    if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
      if (n = e.length, n != t.length)
        return !1;
      for (i = n; i-- !== 0; )
        if (e[i] !== t[i])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    for (r = Object.keys(e), n = r.length, i = n; i-- !== 0; ) {
      var s = r[i];
      if (!Fu(e[s], t[s]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function a0(e) {
  return dM ? e instanceof File : !1;
}
function Np(e) {
  return Ph(e) ? e.replace(/\[|\]/gi, "") : e;
}
function ms(e, t, n) {
  return e ? Ph(t) ? e[Np(t)] : (t || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((r, s) => mM(r) && s in r ? r[s] : n, e) : n;
}
function us(e, t, n) {
  if (Ph(t)) {
    e[Np(t)] = n;
    return;
  }
  const i = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let r = e;
  for (let s = 0; s < i.length; s++) {
    if (s === i.length - 1) {
      r[i[s]] = n;
      return;
    }
    (!(i[s] in r) || cC(r[i[s]])) && (r[i[s]] = Dp(i[s + 1]) ? [] : {}), r = r[i[s]];
  }
}
function iv(e, t) {
  if (Array.isArray(e) && Dp(t)) {
    e.splice(Number(t), 1);
    return;
  }
  Ya(e) && delete e[t];
}
function o0(e, t) {
  if (Ph(t)) {
    delete e[Np(t)];
    return;
  }
  const n = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let i = e;
  for (let s = 0; s < n.length; s++) {
    if (s === n.length - 1) {
      iv(i, n[s]);
      break;
    }
    if (!(n[s] in i) || cC(i[n[s]]))
      break;
    i = i[n[s]];
  }
  const r = n.map((s, a) => ms(e, n.slice(0, a).join(".")));
  for (let s = r.length - 1; s >= 0; s--)
    if (vM(r[s])) {
      if (s === 0) {
        iv(e, n[0]);
        continue;
      }
      iv(r[s - 1], n[s - 1]);
    }
}
function ki(e) {
  return Object.keys(e);
}
function yM(e, t) {
  let n, i;
  return function(...r) {
    const s = this;
    return n || (n = !0, setTimeout(() => n = !1, t), i = e.apply(s, r)), i;
  };
}
function l0(e, t = 0) {
  let n = null, i = [];
  return function(...r) {
    return n && clearTimeout(n), n = setTimeout(() => {
      const s = e(...r);
      i.forEach((a) => a(s)), i = [];
    }, t), new Promise((s) => i.push(s));
  };
}
function bM(e, t) {
  let n;
  return async function(...r) {
    const s = e(...r);
    n = s;
    const a = await s;
    return s !== n ? a : (n = void 0, t(a, r));
  };
}
function u0(e) {
  return Array.isArray(e) ? e : e ? [e] : [];
}
function Ed(e, t) {
  const n = {};
  for (const i in e)
    t.includes(i) || (n[i] = e[i]);
  return n;
}
function wM(e) {
  let t = null, n = [];
  return function(...i) {
    const r = He(() => {
      if (t !== r)
        return;
      const s = e(...i);
      n.forEach((a) => a(s)), n = [], t = null;
    });
    return t = r, new Promise((s) => n.push(s));
  };
}
function rv(e) {
  if (mC(e))
    return e._value;
}
function mC(e) {
  return "_value" in e;
}
function _M(e) {
  return e.type === "number" || e.type === "range" ? Number.isNaN(e.valueAsNumber) ? e.value : e.valueAsNumber : e.value;
}
function c0(e) {
  if (!hC(e))
    return e;
  const t = e.target;
  if (hM(t.type) && mC(t))
    return rv(t);
  if (t.type === "file" && t.files) {
    const n = Array.from(t.files);
    return t.multiple ? n : n[0];
  }
  if (gM(t))
    return Array.from(t.options).filter((n) => n.selected && !n.disabled).map(rv);
  if (fC(t)) {
    const n = Array.from(t.options).find((i) => i.selected);
    return n ? rv(n) : t.value;
  }
  return _M(t);
}
function SM(e) {
  const t = {};
  return Object.defineProperty(t, "_$$isNormalized", {
    value: !0,
    writable: !1,
    enumerable: !1,
    configurable: !1
  }), e ? Ya(e) && e._$$isNormalized ? e : Ya(e) ? Object.keys(e).reduce((n, i) => {
    const r = kM(e[i]);
    return e[i] !== !1 && (n[i] = d0(r)), n;
  }, t) : typeof e != "string" ? t : e.split("|").reduce((n, i) => {
    const r = CM(i);
    return r.name && (n[r.name] = d0(r.params)), n;
  }, t) : t;
}
function kM(e) {
  return e === !0 ? [] : Array.isArray(e) || Ya(e) ? e : [e];
}
function d0(e) {
  const t = (n) => typeof n == "string" && n[0] === "@" ? TM(n.slice(1)) : n;
  return Array.isArray(e) ? e.map(t) : e instanceof RegExp ? [e] : Object.keys(e).reduce((n, i) => (n[i] = t(e[i]), n), {});
}
const CM = (e) => {
  let t = [];
  const n = e.split(":")[0];
  return e.includes(":") && (t = e.split(":").slice(1).join(":").split(",")), { name: n, params: t };
};
function TM(e) {
  const t = (n) => ms(n, e) || n[e];
  return t.__locatorRef = e, t;
}
const xM = {
  generateMessage: ({ field: e }) => `${e} is not valid.`,
  bails: !0,
  validateOnBlur: !0,
  validateOnChange: !0,
  validateOnInput: !1,
  validateOnModelUpdate: !0
};
let AM = Object.assign({}, xM);
const pu = () => AM;
async function IM(e, t, n = {}) {
  const i = n == null ? void 0 : n.bails, r = {
    name: (n == null ? void 0 : n.name) || "{field}",
    rules: t,
    label: n == null ? void 0 : n.label,
    bails: i ?? !0,
    formData: (n == null ? void 0 : n.values) || {}
  }, a = (await EM(r, e)).errors;
  return {
    errors: a,
    valid: !a.length
  };
}
async function EM(e, t) {
  if (Ys(e.rules) || dC(e.rules))
    return OM(t, e.rules);
  if (dr(e.rules) || Array.isArray(e.rules)) {
    const a = {
      field: e.label || e.name,
      name: e.name,
      label: e.label,
      form: e.formData,
      value: t
    }, o = Array.isArray(e.rules) ? e.rules : [e.rules], l = o.length, u = [];
    for (let c = 0; c < l; c++) {
      const d = o[c], f = await d(t, a);
      if (!(typeof f != "string" && !Array.isArray(f) && f)) {
        if (Array.isArray(f))
          u.push(...f);
        else {
          const m = typeof f == "string" ? f : gC(a);
          u.push(m);
        }
        if (e.bails)
          return {
            errors: u
          };
      }
    }
    return {
      errors: u
    };
  }
  const n = Object.assign(Object.assign({}, e), { rules: SM(e.rules) }), i = [], r = Object.keys(n.rules), s = r.length;
  for (let a = 0; a < s; a++) {
    const o = r[a], l = await VM(n, t, {
      name: o,
      params: n.rules[o]
    });
    if (l.error && (i.push(l.error), e.bails))
      return {
        errors: i
      };
  }
  return {
    errors: i
  };
}
function PM(e) {
  return !!e && e.name === "ValidationError";
}
function vC(e) {
  return {
    __type: "VVTypedSchema",
    async parse(n) {
      var i;
      try {
        return {
          output: await e.validate(n, { abortEarly: !1 }),
          errors: []
        };
      } catch (r) {
        if (!PM(r))
          throw r;
        if (!(!((i = r.inner) === null || i === void 0) && i.length) && r.errors.length)
          return { errors: [{ path: r.path, errors: r.errors }] };
        const s = r.inner.reduce((a, o) => {
          const l = o.path || "";
          return a[l] || (a[l] = { errors: [], path: l }), a[l].errors.push(...o.errors), a;
        }, {});
        return { errors: Object.values(s) };
      }
    }
  };
}
async function OM(e, t) {
  const i = await (Ys(t) ? t : vC(t)).parse(e), r = [];
  for (const s of i.errors)
    s.errors.length && r.push(...s.errors);
  return {
    errors: r
  };
}
async function VM(e, t, n) {
  const i = uM(n.name);
  if (!i)
    throw new Error(`No such validator '${n.name}' exists.`);
  const r = DM(n.params, e.formData), s = {
    field: e.label || e.name,
    name: e.name,
    label: e.label,
    value: t,
    form: e.formData,
    rule: Object.assign(Object.assign({}, n), { params: r })
  }, a = await i(t, r, s);
  return typeof a == "string" ? {
    error: a
  } : {
    error: a ? void 0 : gC(s)
  };
}
function gC(e) {
  const t = pu().generateMessage;
  return t ? t(e) : "Field is invalid";
}
function DM(e, t) {
  const n = (i) => fM(i) ? i(t) : i;
  return Array.isArray(e) ? e.map(n) : Object.keys(e).reduce((i, r) => (i[r] = n(e[r]), i), {});
}
async function NM(e, t) {
  const i = await (Ys(e) ? e : vC(e)).parse(zt(t)), r = {}, s = {};
  for (const a of i.errors) {
    const o = a.errors, l = (a.path || "").replace(/\["(\d+)"\]/g, (u, c) => `[${c}]`);
    r[l] = { valid: !o.length, errors: o }, o.length && (s[l] = o[0]);
  }
  return {
    valid: !i.errors.length,
    results: r,
    errors: s,
    values: i.value
  };
}
async function MM(e, t, n) {
  const r = ki(e).map(async (u) => {
    var c, d, f;
    const h = (c = n == null ? void 0 : n.names) === null || c === void 0 ? void 0 : c[u], m = await IM(ms(t, u), e[u], {
      name: (h == null ? void 0 : h.name) || u,
      label: h == null ? void 0 : h.label,
      values: t,
      bails: (f = (d = n == null ? void 0 : n.bailsMap) === null || d === void 0 ? void 0 : d[u]) !== null && f !== void 0 ? f : !0
    });
    return Object.assign(Object.assign({}, m), { path: u });
  });
  let s = !0;
  const a = await Promise.all(r), o = {}, l = {};
  for (const u of a)
    o[u.path] = {
      valid: u.valid,
      errors: u.errors
    }, u.valid || (s = !1, l[u.path] = u.errors[0]);
  return {
    valid: s,
    results: o,
    errors: l
  };
}
function RM(e) {
  process.env.NODE_ENV !== "production" && sM({
    id: "vee-validate-devtools-plugin",
    label: "VeeValidate Plugin",
    packageName: "vee-validate",
    homepage: "https://vee-validate.logaretm.com/v4",
    app: e,
    logo: "https://vee-validate.logaretm.com/v4/logo.png"
  }, BM);
}
const Bu = {}, pC = {};
let js;
const Uv = yM(() => {
  setTimeout(async () => {
    await He(), js == null || js.sendInspectorState(Jo), js == null || js.sendInspectorTree(Jo);
  }, 100);
}, 100);
function FM(e) {
  const t = ep();
  if (!js) {
    const n = t == null ? void 0 : t.appContext.app;
    if (!n)
      return;
    RM(n);
  }
  Bu[e.formId] = Object.assign({}, e), Bu[e.formId]._vm = t, eS(() => {
    delete Bu[e.formId], Uv();
  }), Uv();
}
const Jo = "vee-validate-inspector", di = {
  error: 12405579,
  success: 448379,
  unknown: 5522283,
  white: 16777215,
  black: 0,
  blue: 218007,
  purple: 12157168,
  orange: 16099682,
  gray: 12304330
};
let un = null;
function BM(e) {
  js = e, e.addInspector({
    id: Jo,
    icon: "rule",
    label: "vee-validate",
    noSelectionText: "Select a vee-validate node to inspect",
    actions: [
      {
        icon: "done_outline",
        tooltip: "Validate selected item",
        action: async () => {
          if (!un) {
            console.error("There is not a valid selected vee-validate node or component");
            return;
          }
          if (un.type === "field") {
            await un.field.validate();
            return;
          }
          if (un.type === "form") {
            await un.form.validate();
            return;
          }
          un.type === "pathState" && await un.form.validateField(un.state.path);
        }
      },
      {
        icon: "delete_sweep",
        tooltip: "Clear validation state of the selected item",
        action: () => {
          if (!un) {
            console.error("There is not a valid selected vee-validate node or component");
            return;
          }
          if (un.type === "field") {
            un.field.resetField();
            return;
          }
          un.type === "form" && un.form.resetForm(), un.type === "pathState" && un.form.resetField(un.state.path);
        }
      }
    ]
  }), e.on.getInspectorTree((t) => {
    if (t.inspectorId !== Jo)
      return;
    const n = Object.values(Bu), i = Object.values(pC);
    t.rootNodes = [
      ...n.map(LM),
      ...i.map((r) => WM(r))
    ];
  }), e.on.getInspectorState((t, n) => {
    if (t.inspectorId !== Jo || n.currentTab !== `custom-inspector:${Jo}`)
      return;
    const { form: i, field: r, state: s, type: a } = jM(t.nodeId);
    if (i && a === "form") {
      t.state = HM(i), un = { type: "form", form: i };
      return;
    }
    if (s && a === "pathState" && i) {
      t.state = f0(s), un = { type: "pathState", state: s, form: i };
      return;
    }
    if (r && a === "field") {
      t.state = f0({
        errors: r.errors.value,
        dirty: r.meta.dirty,
        valid: r.meta.valid,
        touched: r.meta.touched,
        value: r.value.value,
        initialValue: r.meta.initialValue
      }), un = { field: r, type: "field" };
      return;
    }
    un = null;
  });
}
function LM(e) {
  const { textColor: t, bgColor: n } = bC(e.meta.value.valid), i = {};
  Object.values(e.getAllPathStates()).forEach((a) => {
    us(i, Ct(a.path), $M(a, e));
  });
  function r(a, o = []) {
    const l = [...o].pop();
    return "id" in a ? Object.assign(Object.assign({}, a), { label: l || a.label }) : Ya(a) ? {
      id: `${o.join(".")}`,
      label: l || "",
      children: Object.keys(a).map((u) => r(a[u], [...o, u]))
    } : Array.isArray(a) ? {
      id: `${o.join(".")}`,
      label: `${l}[]`,
      children: a.map((u, c) => r(u, [...o, String(c)]))
    } : { id: "", label: "", children: [] };
  }
  const { children: s } = r(i);
  return {
    id: Mp(e),
    label: "Form",
    children: s,
    tags: [
      {
        label: "Form",
        textColor: t,
        backgroundColor: n
      },
      {
        label: `${e.getAllPathStates().length} fields`,
        textColor: di.white,
        backgroundColor: di.unknown
      }
    ]
  };
}
function $M(e, t) {
  return {
    id: Mp(t, e),
    label: Ct(e.path),
    tags: yC(e.multiple, e.fieldsCount, e.type, e.valid, t)
  };
}
function WM(e, t) {
  return {
    id: Mp(t, e),
    label: Ct(e.name),
    tags: yC(!1, 1, e.type, e.meta.valid, t)
  };
}
function yC(e, t, n, i, r) {
  const { textColor: s, bgColor: a } = bC(i);
  return [
    e ? void 0 : {
      label: "Field",
      textColor: s,
      backgroundColor: a
    },
    r ? void 0 : {
      label: "Standalone",
      textColor: di.black,
      backgroundColor: di.gray
    },
    n === "checkbox" ? {
      label: "Checkbox",
      textColor: di.white,
      backgroundColor: di.blue
    } : void 0,
    n === "radio" ? {
      label: "Radio",
      textColor: di.white,
      backgroundColor: di.purple
    } : void 0,
    e ? {
      label: "Multiple",
      textColor: di.black,
      backgroundColor: di.orange
    } : void 0
  ].filter(Boolean);
}
function Mp(e, t) {
  const n = t ? "path" in t ? "pathState" : "field" : "form", i = t ? "path" in t ? t == null ? void 0 : t.path : Ct(t == null ? void 0 : t.name) : "", r = { f: e == null ? void 0 : e.formId, ff: i, type: n };
  return btoa(encodeURIComponent(JSON.stringify(r)));
}
function jM(e) {
  try {
    const t = JSON.parse(decodeURIComponent(atob(e))), n = Bu[t.f];
    if (!n && t.ff) {
      const r = pC[t.ff];
      return r ? {
        type: t.type,
        field: r
      } : {};
    }
    if (!n)
      return {};
    const i = n.getPathState(t.ff);
    return {
      type: t.type,
      form: n,
      state: i
    };
  } catch {
  }
  return {};
}
function f0(e) {
  return {
    "Field state": [
      { key: "errors", value: e.errors },
      {
        key: "initialValue",
        value: e.initialValue
      },
      {
        key: "currentValue",
        value: e.value
      },
      {
        key: "touched",
        value: e.touched
      },
      {
        key: "dirty",
        value: e.dirty
      },
      {
        key: "valid",
        value: e.valid
      }
    ]
  };
}
function HM(e) {
  const { errorBag: t, meta: n, values: i, isSubmitting: r, isValidating: s, submitCount: a } = e;
  return {
    "Form state": [
      {
        key: "submitCount",
        value: a.value
      },
      {
        key: "isSubmitting",
        value: r.value
      },
      {
        key: "isValidating",
        value: s.value
      },
      {
        key: "touched",
        value: n.value.touched
      },
      {
        key: "dirty",
        value: n.value.dirty
      },
      {
        key: "valid",
        value: n.value.valid
      },
      {
        key: "initialValues",
        value: n.value.initialValues
      },
      {
        key: "currentValues",
        value: i
      },
      {
        key: "errors",
        value: ki(t.value).reduce((o, l) => {
          var u;
          const c = (u = t.value[l]) === null || u === void 0 ? void 0 : u[0];
          return c && (o[l] = c), o;
        }, {})
      }
    ]
  };
}
function bC(e) {
  return {
    bgColor: e ? di.success : di.error,
    textColor: e ? di.black : di.white
  };
}
let zM = 0;
const Pd = ["bails", "fieldsCount", "id", "multiple", "type", "validate"];
function wC(e) {
  const t = (e == null ? void 0 : e.initialValues) || {}, n = Object.assign({}, Nn(t)), i = Ct(e == null ? void 0 : e.validationSchema);
  return i && Ys(i) && dr(i.cast) ? zt(i.cast(n) || {}) : zt(n);
}
function UM(e) {
  var t;
  const n = zM++;
  let i = 0;
  const r = X(!1), s = X(!1), a = X(0), o = [], l = ti(wC(e)), u = X([]), c = X({}), d = X({}), f = wM(() => {
    d.value = u.value.reduce((q, z) => (q[Id(Nn(z.path))] = z, q), {});
  });
  function h(q, z) {
    const de = $(q);
    if (!de) {
      typeof q == "string" && (c.value[Id(q)] = u0(z));
      return;
    }
    if (typeof q == "string") {
      const O = Id(q);
      c.value[O] && delete c.value[O];
    }
    de.errors = u0(z), de.valid = !de.errors.length;
  }
  function m(q) {
    ki(q).forEach((z) => {
      h(z, q[z]);
    });
  }
  e != null && e.initialErrors && m(e.initialErrors);
  const g = b(() => {
    const q = u.value.reduce((z, de) => (de.errors.length && (z[de.path] = de.errors), z), {});
    return Object.assign(Object.assign({}, c.value), q);
  }), p = b(() => ki(g.value).reduce((q, z) => {
    const de = g.value[z];
    return de != null && de.length && (q[z] = de[0]), q;
  }, {})), y = b(() => u.value.reduce((q, z) => (q[z.path] = { name: z.path || "", label: z.label || "" }, q), {})), k = b(() => u.value.reduce((q, z) => {
    var de;
    return q[z.path] = (de = z.bails) !== null && de !== void 0 ? de : !0, q;
  }, {})), T = Object.assign({}, (e == null ? void 0 : e.initialErrors) || {}), _ = (t = e == null ? void 0 : e.keepValuesOnUnmount) !== null && t !== void 0 ? t : !1, { initialValues: w, originalInitialValues: S, setInitialValues: C } = GM(u, l, e), x = qM(u, l, S, p), A = b(() => u.value.reduce((q, z) => {
    const de = ms(l, z.path);
    return us(q, z.path, de), q;
  }, {})), I = e == null ? void 0 : e.validationSchema;
  function E(q, z) {
    var de, O;
    const M = b(() => ms(w.value, Nn(q))), U = d.value[Nn(q)], Y = (z == null ? void 0 : z.type) === "checkbox" || (z == null ? void 0 : z.type) === "radio";
    if (U && Y) {
      U.multiple = !0;
      const qe = i++;
      return Array.isArray(U.id) ? U.id.push(qe) : U.id = [U.id, qe], U.fieldsCount++, U.__flags.pendingUnmount[qe] = !1, U;
    }
    const ce = b(() => ms(l, Nn(q))), Se = Nn(q), Ie = j.findIndex((qe) => qe === Se);
    Ie !== -1 && j.splice(Ie, 1);
    const Ne = b(() => {
      var qe, Et, Pt, ui;
      const ts = Nn(I);
      if (Ys(ts))
        return (Et = (qe = ts.describe) === null || qe === void 0 ? void 0 : qe.call(ts, Nn(q)).required) !== null && Et !== void 0 ? Et : !1;
      const va = Nn(z == null ? void 0 : z.schema);
      return Ys(va) && (ui = (Pt = va.describe) === null || Pt === void 0 ? void 0 : Pt.call(va).required) !== null && ui !== void 0 ? ui : !1;
    }), Le = i++, Ge = ti({
      id: Le,
      path: q,
      touched: !1,
      pending: !1,
      valid: !0,
      validated: !!(!((de = T[Se]) === null || de === void 0) && de.length),
      required: Ne,
      initialValue: M,
      errors: pe([]),
      bails: (O = z == null ? void 0 : z.bails) !== null && O !== void 0 ? O : !1,
      label: z == null ? void 0 : z.label,
      type: (z == null ? void 0 : z.type) || "default",
      value: ce,
      multiple: !1,
      __flags: {
        pendingUnmount: { [Le]: !1 },
        pendingReset: !1
      },
      fieldsCount: 1,
      validate: z == null ? void 0 : z.validate,
      dirty: b(() => !Fu(Ct(ce), Ct(M)))
    });
    return u.value.push(Ge), d.value[Se] = Ge, f(), p.value[Se] && !T[Se] && He(() => {
      xe(Se, { mode: "silent" });
    }), ia(q) && fe(q, (qe) => {
      f();
      const Et = zt(ce.value);
      d.value[qe] = Ge, He(() => {
        us(l, qe, Et);
      });
    }), Ge;
  }
  const P = l0(vt, 5), V = l0(vt, 5), N = bM(async (q) => await (q === "silent" ? P() : V()), (q, [z]) => {
    const de = ki(K.errorBag.value), M = [
      .../* @__PURE__ */ new Set([...ki(q.results), ...u.value.map((U) => U.path), ...de])
    ].sort().reduce((U, Y) => {
      var ce;
      const Se = Y, Ie = $(Se) || Z(Se), Ne = ((ce = q.results[Se]) === null || ce === void 0 ? void 0 : ce.errors) || [], Le = Nn(Ie == null ? void 0 : Ie.path) || Se, Ge = YM({ errors: Ne, valid: !Ne.length }, U.results[Le]);
      return U.results[Le] = Ge, Ge.valid || (U.errors[Le] = Ge.errors[0]), Ie && c.value[Le] && delete c.value[Le], Ie ? (Ie.valid = Ge.valid, z === "silent" || z === "validated-only" && !Ie.validated || h(Ie, Ge.errors), U) : (h(Le, Ne), U);
    }, { valid: q.valid, results: {}, errors: {} });
    return q.values && (M.values = q.values), ki(M.results).forEach((U) => {
      var Y;
      const ce = $(U);
      ce && z !== "silent" && (z === "validated-only" && !ce.validated || h(ce, (Y = M.results[U]) === null || Y === void 0 ? void 0 : Y.errors));
    }), M;
  });
  function F(q) {
    u.value.forEach(q);
  }
  function $(q) {
    const z = typeof q == "string" ? Id(q) : q;
    return typeof z == "string" ? d.value[z] : z;
  }
  function Z(q) {
    return u.value.filter((de) => q.startsWith(de.path)).reduce((de, O) => de ? O.path.length > de.path.length ? O : de : O, void 0);
  }
  let j = [], H;
  function R(q) {
    return j.push(q), H || (H = He(() => {
      [...j].sort().reverse().forEach((de) => {
        o0(l, de);
      }), j = [], H = null;
    })), H;
  }
  function L(q) {
    return function(de, O) {
      return function(U) {
        return U instanceof Event && (U.preventDefault(), U.stopPropagation()), F((Y) => Y.touched = !0), r.value = !0, a.value++, Be().then((Y) => {
          const ce = zt(l);
          if (Y.valid && typeof de == "function") {
            const Se = zt(A.value);
            let Ie = q ? Se : ce;
            return Y.values && (Ie = Y.values), de(Ie, {
              evt: U,
              controlledValues: Se,
              setErrors: m,
              setFieldError: h,
              setTouched: te,
              setFieldTouched: Oe,
              setValues: Fe,
              setFieldValue: ue,
              resetForm: Me,
              resetField: me
            });
          }
          !Y.valid && typeof O == "function" && O({
            values: ce,
            evt: U,
            errors: Y.errors,
            results: Y.results
          });
        }).then((Y) => (r.value = !1, Y), (Y) => {
          throw r.value = !1, Y;
        });
      };
    };
  }
  const oe = L(!1);
  oe.withControlled = L(!0);
  function we(q, z) {
    const de = u.value.findIndex((M) => M.path === q && (Array.isArray(M.id) ? M.id.includes(z) : M.id === z)), O = u.value[de];
    if (!(de === -1 || !O)) {
      if (He(() => {
        xe(q, { mode: "silent", warn: !1 });
      }), O.multiple && O.fieldsCount && O.fieldsCount--, Array.isArray(O.id)) {
        const M = O.id.indexOf(z);
        M >= 0 && O.id.splice(M, 1), delete O.__flags.pendingUnmount[z];
      }
      (!O.multiple || O.fieldsCount <= 0) && (u.value.splice(de, 1), ze(q), f(), delete d.value[q]);
    }
  }
  function ee(q) {
    ki(d.value).forEach((z) => {
      z.startsWith(q) && delete d.value[z];
    }), u.value = u.value.filter((z) => !z.path.startsWith(q)), He(() => {
      f();
    });
  }
  const K = {
    formId: n,
    values: l,
    controlledValues: A,
    errorBag: g,
    errors: p,
    schema: I,
    submitCount: a,
    meta: x,
    isSubmitting: r,
    isValidating: s,
    fieldArrays: o,
    keepValuesOnUnmount: _,
    validateSchema: Ct(I) ? N : void 0,
    validate: Be,
    setFieldError: h,
    validateField: xe,
    setFieldValue: ue,
    setValues: Fe,
    setErrors: m,
    setFieldTouched: Oe,
    setTouched: te,
    resetForm: Me,
    resetField: me,
    handleSubmit: oe,
    useFieldModel: Dr,
    defineInputBinds: ma,
    defineComponentBinds: li,
    defineField: Dn,
    stageInitialValue: Ke,
    unsetInitialValue: ze,
    setFieldInitialValue: ut,
    createPathState: E,
    getPathState: $,
    unsetPathValue: R,
    removePathState: we,
    initialValues: w,
    getAllPathStates: () => u.value,
    destroyPath: ee,
    isFieldTouched: le,
    isFieldDirty: be,
    isFieldValid: Pe
  };
  function ue(q, z, de = !0) {
    const O = zt(z), M = typeof q == "string" ? q : q.path;
    $(M) || E(M), us(l, M, O), de && xe(M);
  }
  function ve(q, z = !0) {
    ki(l).forEach((de) => {
      delete l[de];
    }), ki(q).forEach((de) => {
      ue(de, q[de], !1);
    }), z && Be();
  }
  function Fe(q, z = !0) {
    Ju(l, q), o.forEach((de) => de && de.reset()), z && Be();
  }
  function he(q, z) {
    const de = $(Nn(q)) || E(q);
    return b({
      get() {
        return de.value;
      },
      set(O) {
        var M;
        const U = Nn(q);
        ue(U, O, (M = Nn(z)) !== null && M !== void 0 ? M : !1);
      }
    });
  }
  function Oe(q, z) {
    const de = $(q);
    de && (de.touched = z);
  }
  function le(q) {
    const z = $(q);
    return z ? z.touched : u.value.filter((de) => de.path.startsWith(q)).some((de) => de.touched);
  }
  function be(q) {
    const z = $(q);
    return z ? z.dirty : u.value.filter((de) => de.path.startsWith(q)).some((de) => de.dirty);
  }
  function Pe(q) {
    const z = $(q);
    return z ? z.valid : u.value.filter((de) => de.path.startsWith(q)).every((de) => de.valid);
  }
  function te(q) {
    if (typeof q == "boolean") {
      F((z) => {
        z.touched = q;
      });
      return;
    }
    ki(q).forEach((z) => {
      Oe(z, !!q[z]);
    });
  }
  function me(q, z) {
    var de;
    const O = z && "value" in z ? z.value : ms(w.value, q), M = $(q);
    M && (M.__flags.pendingReset = !0), ut(q, zt(O), !0), ue(q, O, !1), Oe(q, (de = z == null ? void 0 : z.touched) !== null && de !== void 0 ? de : !1), h(q, (z == null ? void 0 : z.errors) || []), He(() => {
      M && (M.__flags.pendingReset = !1);
    });
  }
  function Me(q, z) {
    let de = zt(q != null && q.values ? q.values : S.value);
    de = z != null && z.force ? de : Ju(S.value, de), de = Ys(I) && dr(I.cast) ? I.cast(de) : de, C(de), F((O) => {
      var M;
      O.__flags.pendingReset = !0, O.validated = !1, O.touched = ((M = q == null ? void 0 : q.touched) === null || M === void 0 ? void 0 : M[O.path]) || !1, ue(O.path, ms(de, O.path), !1), h(O.path, void 0);
    }), z != null && z.force ? ve(de, !1) : Fe(de, !1), m((q == null ? void 0 : q.errors) || {}), a.value = (q == null ? void 0 : q.submitCount) || 0, He(() => {
      Be({ mode: "silent" }), F((O) => {
        O.__flags.pendingReset = !1;
      });
    });
  }
  async function Be(q) {
    const z = (q == null ? void 0 : q.mode) || "force";
    if (z === "force" && F((U) => U.validated = !0), K.validateSchema)
      return K.validateSchema(z);
    s.value = !0;
    const de = await Promise.all(u.value.map((U) => U.validate ? U.validate(q).then((Y) => ({
      key: U.path,
      valid: Y.valid,
      errors: Y.errors
    })) : Promise.resolve({
      key: U.path,
      valid: !0,
      errors: []
    })));
    s.value = !1;
    const O = {}, M = {};
    for (const U of de)
      O[U.key] = {
        valid: U.valid,
        errors: U.errors
      }, U.errors.length && (M[U.key] = U.errors[0]);
    return {
      valid: de.every((U) => U.valid),
      results: O,
      errors: M
    };
  }
  async function xe(q, z) {
    var de;
    const O = $(q);
    if (O && (z == null ? void 0 : z.mode) !== "silent" && (O.validated = !0), I) {
      const { results: U } = await N((z == null ? void 0 : z.mode) || "validated-only");
      return U[q] || { errors: [], valid: !0 };
    }
    return O != null && O.validate ? O.validate(z) : (!O && ((de = z == null ? void 0 : z.warn) !== null && de !== void 0 ? de : !0) && process.env.NODE_ENV !== "production" && Ec(`field with path ${q} was not found`), Promise.resolve({ errors: [], valid: !0 }));
  }
  function ze(q) {
    o0(w.value, q);
  }
  function Ke(q, z, de = !1) {
    ut(q, z), us(l, q, z), de && !(e != null && e.initialValues) && us(S.value, q, zt(z));
  }
  function ut(q, z, de = !1) {
    us(w.value, q, zt(z)), de && us(S.value, q, zt(z));
  }
  async function vt() {
    const q = Ct(I);
    if (!q)
      return { valid: !0, results: {}, errors: {} };
    s.value = !0;
    const z = dC(q) || Ys(q) ? await NM(q, l) : await MM(q, l, {
      names: y.value,
      bailsMap: k.value
    });
    return s.value = !1, z;
  }
  const Vn = oe((q, { evt: z }) => {
    pM(z) && z.target.submit();
  });
  En(() => {
    if (e != null && e.initialErrors && m(e.initialErrors), e != null && e.initialTouched && te(e.initialTouched), e != null && e.validateOnMount) {
      Be();
      return;
    }
    K.validateSchema && K.validateSchema("silent");
  }), ia(I) && fe(I, () => {
    var q;
    (q = K.validateSchema) === null || q === void 0 || q.call(K, "validated-only");
  }), Tt(cM, K), process.env.NODE_ENV !== "production" && (FM(K), fe(() => Object.assign(Object.assign({ errors: g.value }, x.value), { values: l, isSubmitting: r.value, isValidating: s.value, submitCount: a.value }), Uv, {
    deep: !0
  }));
  function Dn(q, z) {
    const de = dr(z) || z == null ? void 0 : z.label, O = $(Nn(q)) || E(q, { label: de }), M = () => dr(z) ? z(Ed(O, Pd)) : z || {};
    function U() {
      var Ne;
      O.touched = !0, ((Ne = M().validateOnBlur) !== null && Ne !== void 0 ? Ne : pu().validateOnBlur) && xe(O.path);
    }
    function Y() {
      var Ne;
      ((Ne = M().validateOnInput) !== null && Ne !== void 0 ? Ne : pu().validateOnInput) && He(() => {
        xe(O.path);
      });
    }
    function ce() {
      var Ne;
      ((Ne = M().validateOnChange) !== null && Ne !== void 0 ? Ne : pu().validateOnChange) && He(() => {
        xe(O.path);
      });
    }
    const Se = b(() => {
      const Ne = {
        onChange: ce,
        onInput: Y,
        onBlur: U
      };
      return dr(z) ? Object.assign(Object.assign({}, Ne), z(Ed(O, Pd)).props || {}) : z != null && z.props ? Object.assign(Object.assign({}, Ne), z.props(Ed(O, Pd))) : Ne;
    });
    return [he(q, () => {
      var Ne, Le, Ge;
      return (Ge = (Ne = M().validateOnModelUpdate) !== null && Ne !== void 0 ? Ne : (Le = pu()) === null || Le === void 0 ? void 0 : Le.validateOnModelUpdate) !== null && Ge !== void 0 ? Ge : !0;
    }), Se];
  }
  function Dr(q) {
    return Array.isArray(q) ? q.map((z) => he(z, !0)) : he(q);
  }
  function ma(q, z) {
    const [de, O] = Dn(q, z);
    function M() {
      O.value.onBlur();
    }
    function U(ce) {
      const Se = c0(ce);
      ue(Nn(q), Se, !1), O.value.onInput();
    }
    function Y(ce) {
      const Se = c0(ce);
      ue(Nn(q), Se, !1), O.value.onChange();
    }
    return b(() => Object.assign(Object.assign({}, O.value), {
      onBlur: M,
      onInput: U,
      onChange: Y,
      value: de.value
    }));
  }
  function li(q, z) {
    const [de, O] = Dn(q, z), M = $(Nn(q));
    function U(Y) {
      de.value = Y;
    }
    return b(() => {
      const Y = dr(z) ? z(Ed(M, Pd)) : z || {};
      return Object.assign({ [Y.model || "modelValue"]: de.value, [`onUpdate:${Y.model || "modelValue"}`]: U }, O.value);
    });
  }
  return Object.assign(Object.assign({}, K), { values: Fl(l), handleReset: () => Me(), submitForm: Vn });
}
function qM(e, t, n, i) {
  const r = {
    touched: "some",
    pending: "some",
    valid: "every"
  }, s = b(() => !Fu(t, Ct(n)));
  function a() {
    const l = e.value;
    return ki(r).reduce((u, c) => {
      const d = r[c];
      return u[c] = l[d]((f) => f[c]), u;
    }, {});
  }
  const o = ti(a());
  return Wt(() => {
    const l = a();
    o.touched = l.touched, o.valid = l.valid, o.pending = l.pending;
  }), b(() => Object.assign(Object.assign({ initialValues: Ct(n) }, o), { valid: o.valid && !ki(i.value).length, dirty: s.value }));
}
function GM(e, t, n) {
  const i = wC(n), r = X(i), s = X(zt(i));
  function a(o, l = !1) {
    r.value = Ju(zt(r.value) || {}, zt(o)), s.value = Ju(zt(s.value) || {}, zt(o)), l && e.value.forEach((u) => {
      if (u.touched)
        return;
      const d = ms(r.value, u.path);
      us(t, u.path, zt(d));
    });
  }
  return {
    initialValues: r,
    originalInitialValues: s,
    setInitialValues: a
  };
}
function YM(e, t) {
  return t ? {
    valid: e.valid && t.valid,
    errors: [...e.errors, ...t.errors]
  } : e;
}
const h0 = (e) => ({
  props: {
    "error-messages": e.touched ? e.errors : [],
    "hide-details": !e.touched || e.errors.filter(
      (t) => typeof t == "string" && t.trim().length > 0
    ).length === 0 ? !1 : "auto"
  }
}), ZM = Bl({
  name: "VPFormLogin",
  components: {
    VPPasswordField: rk
  },
  props: {
    /**
     * The value of the username field. Accessible as a v-model using `v-model:username`.
     */
    username: {
      type: String,
      default: ""
    },
    /**
     * The value of the password field. Accessible as a v-model using `v-model:password`.
     */
    password: {
      type: String,
      default: ""
    },
    /**
     * The function to call when the form is submitted after validation.
     */
    onSubmit: {
      type: Function,
      required: !0
    },
    /**
     * The URL to which the form will be submitted. Will be passed to the function defined in the `onSubmit` prop.
     */
    action: {
      type: String,
      default: "#"
    },
    /**
     * The HTTP method to use when submitting the form. Will be passed to the function defined in the `onSubmit` prop.
     */
    method: {
      type: String,
      default: "post"
    },
    /**
     * Designates the border-radius applied to the component. This can be xs, sm, md, lg, xl or a numeric value.
     */
    border: {
      type: [String, Number, Boolean],
      default: !1
    },
    /**
     * The background color of the form. Can be the name of a theme color, a Vuetify Material Design color, or a CSS color value.
     */
    bgColor: {
      type: String,
      default: "transparent"
    },
    /**
     * Designates an elevation applied to the form between 0 and 24. You can find more information in the [Vuetify elevation documentation](https://vuetifyjs.com/en/styles/elevation/).
     */
    elevation: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Removes the form's elevation.
     */
    flat: {
      type: Boolean,
      default: !1
    },
    /**
     * Sets the height for the form.
     */
    height: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Apply a specific background image to the form.
     */
    backgroundImage: {
      type: String,
      default: void 0
    },
    /**
     * Sets the maximum height for the form.
     */
    maxHeight: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Sets the maximum width for the form.
     */
    maxWidth: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Sets the minimum height for the form.
     */
    minHeight: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Sets the minimum width for the form.
     */
    minWidth: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Sets the css positioning for the form.
     */
    position: {
      type: String,
      default: void 0
    },
    /**
     * Applies the [v-ripple](https://vuetifyjs.com/en/directives/ripple/) directive.
     */
    ripple: {
      type: [Boolean, Object],
      default: !1
    },
    /**
     * Designates the border-radius applied to the form. This can be 0, xs, sm, true, lg, xl, pill, circle, and shaped. Find more information on available border radius classes in the [Vuetify Border Radius documentation](https://vuetifyjs.com/en/styles/border-radius/).
     */
    rounded: {
      type: [Boolean, Number, String],
      default: void 0
    },
    /**
     * Specify a Vuetify theme for this form and all of its children.
     */
    theme: {
      type: String,
      default: void 0
    },
    /**
     * Removes any applied border-radius from the form.
     */
    tile: {
      type: Boolean,
      default: !1
    },
    /**
     * Applies a distinct style to the form.
     * Options are `text`, `flat`, `elevated`, `tonal`, `outlined`, and `plain`.
     */
    variant: {
      type: String,
      default: "elevated"
    },
    /**
     * Sets the width for the form.
     */
    width: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Title to be displayed on the form
     */
    title: {
      type: String,
      default: "Authentication"
    },
    /**
     * The density of the form fields.
     */
    density: {
      type: String,
      default: "default"
    },
    /**
     * The variant of the form fields.
     */
    fieldVariant: {
      type: String,
      default: "filled"
    },
    /**
     * Sets the color of the form fields when it not focused. Can be the name of a theme color, a Vuetify Material Design color, or a CSS color value.
     */
    fieldBaseColor: {
      type: String,
      default: void 0
    },
    /**
     * Set the background color of the form fields. Can be the name of a theme color, a Vuetify Material Design color, or a CSS color value.
     */
    fieldBackgroundColor: {
      type: String,
      default: void 0
    },
    /**
     * Removes elevation (shadow) added to element when using the `field-solo` or `field-solo-inverted` variants.
     */
    fieldFlat: {
      type: Boolean,
      default: !1
    },
    /**
     * Applies a border radius to the form fields
     */
    fieldRounded: {
      type: [Boolean, String, Number],
      default: void 0
    },
    /**
     * Prevents labels from moving when fields are focused on or dirty
     */
    fieldSingleLine: {
      type: Boolean,
      default: !1
    },
    /**
     * Specify a theme for the form fields and all children.
     */
    fieldTheme: {
      type: String,
      default: void 0
    },
    /**
     * Removes any applied border-radius from the form fields.
     */
    fieldTile: {
      type: Boolean,
      default: !1
    },
    /**
     * If the form fields should be clearable using a clear icon.
     */
    clearable: {
      type: Boolean,
      default: !0
    },
    /**
     * The validation function to use form the form's username field.
     */
    usernameValidator: {
      type: Function,
      required: !0
    },
    /**
     * The label to display for the username field.
     */
    usernameLabel: {
      type: String,
      default: "Username"
    },
    /**
     * The HTML5 input type to use for the username field.
     *
     * @values text, email
     */
    usernameType: {
      type: String,
      default: "text"
    },
    /**
     * The [HTML Autocomplete](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofilling-form-controls%3A-the-autocomplete-attribute) value to use for the username field.
     */
    usernameAutocomplete: {
      type: String,
      default: "username"
    },
    /**
     * Set the username field to autofocus on load.
     */
    usernameAutofocus: {
      type: Boolean,
      default: !1
    },
    /**
     * The icon to display for the username field.
     */
    usernameIcon: {
      type: String,
      default: void 0
    },
    /**
     * The position of the username icon.
     *
     * @values prepend, prepend-inner, append, append-inner
     */
    usernameIconPosition: {
      type: String,
      default: void 0
    },
    /**
     * Hint text to display when the username field is focused or `username-hint-persistent` is set.
     */
    usernameHint: {
      type: String,
      default: void 0
    },
    /**
     * Persist the hint text when the username field is not focused.
     */
    usernameHintPersistent: {
      type: Boolean,
      default: !1
    },
    /**
     * The validation function to use form the form's password field.
     */
    passwordValidator: {
      type: Function,
      required: !0
    },
    /**
     * The label to display for the password field.
     */
    passwordLabel: {
      type: String,
      default: "Password"
    },
    /**
     * The [HTML Autocomplete](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofilling-form-controls%3A-the-autocomplete-attribute) value to use for the password field.
     */
    passwordAutocomplete: {
      type: String,
      default: "current-password"
    },
    /**
     * The icon to display for the password field.
     */
    passwordIcon: {
      type: String,
      default: void 0
    },
    /**
     * The position of the password icon.
     *
     * @values prepend, prepend-inner, append
     */
    passwordIconPosition: {
      type: String,
      default: void 0
    },
    /**
     * Hint text to display when the password field is focused or `password-hint-persistent` is set.
     */
    passwordHint: {
      type: String,
      default: void 0
    },
    /**
     * Persist the hint text when the password field is not focused.
     */
    passwordHintPersistent: {
      type: Boolean,
      default: !1
    },
    /**
     * Icon to place after the content of the submission button
     */
    submitAppendIcon: {
      type: String,
      default: void 0
    },
    /**
     * Color of the submission button when not focused. Can be the name of a theme color, a Vuetify Material Design color, or a CSS color value.
     */
    submitBaseColor: {
      type: String,
      default: void 0
    },
    /**
     * Designates the border-radius applied to the submission button. This can be xs, sm, md, lg, xl or a numeric value.
     */
    submitBorder: {
      type: [String, Number, Boolean],
      default: !1
    },
    /**
     * The background color of the submission button. Can be the name of a theme color, a Vuetify Material Design color, or a CSS color value.
     */
    submitColor: {
      type: String,
      default: "primary"
    },
    /**
     * The density of the submission button.
     *
     * @values default, comfortable, compact
     */
    submitDensity: {
      type: String,
      default: "default"
    },
    /**
     * Designates an elevation applied to the submission button between 0 and 24. You can find more information in the [Vuetify elevation documentation](https://vuetifyjs.com/en/styles/elevation/).
     */
    submitElevation: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Removes the submission button's elevation.
     */
    submitFlat: {
      type: Boolean,
      default: !1
    },
    /**
     * Sets the height for the submission button.
     */
    submitHeight: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Icon to place before the content of the submission button
     */
    submitPrependIcon: {
      type: String,
      default: void 0
    },
    /**
     * Applies the [v-ripple](https://vuetifyjs.com/en/directives/ripple/) directive to the submission button.
     */
    submitRipple: {
      type: [Boolean, Object],
      default: !1
    },
    /**
     * Designates the border-radius applied to the submission button. This can be 0, xs, sm, true, lg, xl, pill, circle, and shaped. Find more information on available border radius classes in the [Vuetify Border Radius documentation](https://vuetifyjs.com/en/styles/border-radius/).
     */
    submitRounded: {
      type: [Boolean, Number, String],
      default: void 0
    },
    /**
     * Set the "size" of the submission button. Can be a number, string or one of the following predefined sizes: `x-small`, `small`, `default`, `medium`, `large`, `x-large`.
     */
    submitSize: {
      type: [String, Number],
      default: "x-large"
    },
    /**
     * Change the submission button to the "slim" variant
     */
    submitSlim: {
      type: Boolean,
      default: !1
    },
    /**
     * Specify the text content of the submission button
     */
    submitText: {
      type: String,
      default: "Log In"
    },
    /**
     * Specify a Vuetify theme for the submission button.
     */
    submitTheme: {
      type: String,
      default: void 0
    },
    /**
     * Removes any applied border-radius from the submission button.
     */
    submitTile: {
      type: Boolean,
      default: !1
    },
    /**
     * Applies a distinct style to the submission button.
     */
    submitVariant: {
      type: String,
      default: "elevated"
    }
  },
  emits: [
    /**
     * Emitted when the form is submitted via the `onSubmit` function.
     *
     * @event submit
     * @property {any} result The result of the `onSubmit` function
     */
    "submit",
    /**
     * Emitted when the `onSubmit` function throws an error.
     *
     * @event submit:error
     * @property {Error} error The error that was thrown
     */
    "submit:error",
    /**
     * Emitted when the value of the `username` field is updated
     *
     * @event update:username
     * @property {string|undefined} value The new value of the `username` field
     */
    "update:username",
    /**
     * Emitted when the value of the `password` field is updated
     *
     * @event update:password
     * @property {string|undefined} value The new value of the `password` field
     */
    "update:password"
  ],
  setup(e, { emit: t }) {
    const n = ja(e, "VPFormLogin"), i = b(() => n.action), r = b(() => n.method), s = b(() => n.border), a = b(() => n.bgColor), o = b(() => n.elevation), l = b(() => n.flat), u = b(() => n.height), c = b(() => n.backgroundImage), d = b(() => n.maxHeight), f = b(() => n.maxWidth), h = b(() => n.minHeight), m = b(() => n.minWidth), g = b(() => n.position), p = b(() => n.ripple), y = b(() => n.rounded), k = b(() => n.theme), T = b(() => n.tile), _ = b(() => n.variant), w = b(() => n.width), S = b(() => ({
      tag: "form",
      action: i.value,
      method: r.value,
      border: s.value,
      color: a.value,
      elevation: o.value,
      flat: l.value,
      height: u.value,
      image: c.value,
      maxHeight: d.value,
      maxWidth: f.value,
      minHeight: h.value,
      minWidth: m.value,
      position: g.value,
      ripple: p.value,
      rounded: y.value,
      theme: k.value,
      tile: T.value,
      variant: _.value,
      width: w.value
    })), C = b(() => n.title), x = b(() => ({
      title: C.value
    })), A = b(
      () => n.usernameValidator
    ), I = b(
      () => n.passwordValidator
    ), {
      handleSubmit: E,
      isSubmitting: P,
      isValidating: V,
      defineComponentBinds: N,
      errors: F,
      resetForm: $,
      resetField: Z,
      setFieldValue: j,
      setFieldTouched: H,
      setTouched: R,
      values: L
    } = UM({
      initialValues: {
        username: n.username,
        password: n.password
      },
      validationSchema: {
        username: (pt, ns) => A.value(pt, ns),
        password: (pt, ns) => I.value(pt, ns)
      }
    }), ne = b(() => n.username), oe = b(() => n.password);
    fe(
      () => ne.value,
      (pt) => {
        j("username", pt, !0);
      }
    ), fe(
      () => oe.value,
      (pt) => {
        j("password", pt, !0);
      }
    ), fe(
      () => L.username,
      (pt) => {
        t("update:username", pt);
      }
    ), fe(
      () => L.password,
      (pt) => {
        t("update:password", pt);
      }
    );
    const we = X(!1);
    let ee = new AbortController();
    const K = E(async (pt) => {
      if (!(we.value || !pt)) {
        ee && ee.abort(), ee = new AbortController(), ee.signal.addEventListener("abort", () => {
          we.value = !1;
        }), we.value = !0;
        try {
          const ns = await n.onSubmit(
            i.value,
            r.value,
            { ...pt },
            ee.signal,
            () => {
              ee.abort();
            }
          );
          t("submit", ns);
        } catch (ns) {
          t("submit:error", ns);
        }
        we.value = !1;
      }
    }), ue = (pt) => {
      pt.preventDefault(), K();
    }, ve = b(() => n.density), Fe = b(() => n.fieldVariant), he = b(() => n.fieldBaseColor), Oe = b(
      () => n.fieldBackgroundColor
    ), le = b(() => n.fieldFlat), be = b(() => n.fieldRounded), Pe = b(() => n.fieldSingleLine), te = b(() => n.fieldTheme), me = b(() => n.fieldTile), Me = b(() => n.clearable), Be = b(() => n.usernameLabel), xe = b(() => n.usernameType), ze = b(
      () => n.usernameAutocomplete
    ), Ke = b(
      () => n.usernameAutofocus
    ), ut = b(() => n.usernameIcon), vt = b(
      () => n.usernameIconPosition
    ), Vn = b(() => n.usernameHint), Dn = b(
      () => n.usernameHintPersistent
    ), Dr = b(() => n.passwordLabel), ma = b(
      () => n.passwordAutocomplete
    ), li = b(() => n.passwordIcon), q = b(
      () => n.passwordIconPosition
    ), z = b(() => n.passwordHint), de = b(
      () => n.passwordHintPersistent
    ), O = b(() => P.value), M = b(
      () => !O.value && Me.value
    ), U = b(() => {
      const pt = {};
      if (ut.value)
        switch (vt.value) {
          case "prepend":
            pt.prependIcon = ut.value;
            break;
          case "prepend-inner":
            pt.prependInnerIcon = ut.value;
            break;
          case "append":
            pt.appendIcon = ut.value;
            break;
          case "append-inner":
            pt.appendInnerIcon = ut.value;
            break;
        }
      return pt;
    }), Y = b(() => {
      const pt = {};
      if (li.value)
        switch (q.value) {
          case "prepend":
            pt.prependIcon = li.value;
            break;
          case "prepend-inner":
            pt.prependInnerIcon = li.value;
            break;
          case "append":
            pt.appendIcon = li.value;
            break;
        }
      return pt;
    }), ce = b(() => ({
      baseColor: he.value,
      bgColor: Oe.value,
      variant: Fe.value,
      scrollIntoView: !0,
      density: ve.value,
      disabled: O.value,
      clearable: M.value,
      flat: le.value,
      rounded: be.value,
      fieldSingleLine: Pe.value,
      theme: te.value,
      tile: me.value
    })), Se = b(() => ({
      username: {
        ...N("username", h0).value,
        ...ce.value,
        type: xe.value,
        label: Be.value,
        autocomplete: ze.value,
        autofocus: Ke.value,
        ...U.value,
        hint: Vn.value,
        persistentHint: Dn.value
      },
      password: {
        ...N("password", h0).value,
        ...ce.value,
        label: Dr.value,
        autocomplete: ma.value,
        ...Y.value,
        hint: z.value,
        persistentHint: de.value
      }
    })), Ie = b(
      () => P.value || we.value
    ), Ne = b(() => n.submitAppendIcon), Le = b(() => n.submitBaseColor), Ge = b(() => n.submitBorder), qe = b(() => n.submitColor), Et = b(() => n.submitDensity), Pt = b(() => n.submitElevation), ui = b(() => n.submitFlat), ts = b(() => n.submitHeight), va = b(
      () => n.submitPrependIcon
    ), Tm = b(() => n.submitRipple), xm = b(() => n.submitRounded), nr = b(() => n.submitSize), Am = b(() => n.submitSlim), Im = b(() => n.submitText), Em = b(() => n.submitTheme), Pm = b(() => n.submitTile), Om = b(() => n.submitVariant), Ds = b(() => ({
      appendIcon: Ne.value,
      baseColor: Le.value,
      border: Ge.value,
      color: qe.value,
      density: Et.value,
      elevation: Pt.value,
      flat: ui.value,
      height: ts.value,
      prependIcon: va.value,
      ripple: Tm.value,
      rounded: xm.value,
      size: nr.value,
      slim: Am.value,
      text: Im.value,
      theme: Em.value,
      tile: Pm.value,
      variant: Om.value,
      disabled: V.value,
      loading: Ie.value,
      block: !0,
      type: "submit"
    }));
    return {
      formWrapperCardBindings: S,
      headerSlotBindings: x,
      form: Se,
      formIsProcessing: Ie,
      formIsValidating: V,
      resetFormFields: $,
      resetFormField: Z,
      formErrors: F,
      setFormFieldTouched: H,
      setFormTouched: R,
      submit: ue,
      submitButtonBindings: Ds
    };
  }
}), KM = /* @__PURE__ */ XE("input", {
  type: "submit",
  style: { display: "none" }
}, null, -1);
function XM(e, t, n, i, r, s) {
  const a = tn("v-toolbar-title"), o = tn("v-spacer"), l = tn("v-toolbar-items"), u = tn("v-toolbar"), c = tn("v-divider"), d = tn("v-text-field"), f = tn("v-col"), h = tn("v-row"), m = tn("VPPasswordField"), g = tn("v-btn"), p = tn("v-container"), y = tn("v-card");
  return vl(), cf(y, ie(e.formWrapperCardBindings, {
    onSubmit: Av(e.submit, ["stop"])
  }), {
    default: dn(() => [
      KM,
      or(e.$slots, "header", os(ls(e.headerSlotBindings)), () => [
        v(u, {
          color: "transparent",
          density: "compact"
        }, {
          default: dn(() => [
            v(a, null, {
              default: dn(() => [
                _r(uh(e.title), 1)
              ]),
              _: 1
            }),
            v(o),
            v(l, null, {
              default: dn(() => [
                or(e.$slots, "header-actions", os(ls(e.headerSlotBindings)))
              ]),
              _: 3
            })
          ]),
          _: 3
        }),
        v(c),
        or(e.$slots, "before-fields"),
        v(p, null, {
          default: dn(() => [
            v(h, null, {
              default: dn(() => [
                v(f, { cols: "12" }, {
                  default: dn(() => [
                    or(e.$slots, "before-field-username", os(ls(e.form.username))),
                    v(d, os(ls(e.form.username)), null, 16),
                    or(e.$slots, "after-field-username", os(ls(e.form.username)))
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }),
            or(e.$slots, "between-fields"),
            v(h, null, {
              default: dn(() => [
                v(f, { cols: "12" }, {
                  default: dn(() => [
                    v(m, os(ls(e.form.password)), null, 16)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            or(e.$slots, "before-submission"),
            v(h, null, {
              default: dn(() => [
                v(f, { cols: "12" }, {
                  default: dn(() => [
                    v(g, os(ls(e.submitButtonBindings)), null, 16)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            or(e.$slots, "after-submission")
          ]),
          _: 3
        })
      ])
    ]),
    _: 3
  }, 16, ["onSubmit"]);
}
const JM = /* @__PURE__ */ Rc(ZM, [["render", XM]]), QM = Bl({
  name: "VPModelListTable",
  props: {
    /**
     * The columns to display in the table.
     * @default []
     */
    columns: {
      type: Array,
      default: () => []
    },
    /**
     * The background color of the table. Can be the name of a theme color, a Vuetify Material Design color, or a CSS color value.
     */
    backgroundColor: {
      type: String,
      default: "surface"
    },
    /**
     * The background color of the table's header section. Can be the name of a theme color, a Vuetify Material Design color, or a CSS color value.
     */
    headerBackgroundColor: {
      type: String,
      default: void 0
    },
    /**
     * The density of the table's header toolbar. Can be `default`, `prominent`, `comfortable`, `compact`
     * @values `default`, `prominent`, `comfortable`, `compact`
     */
    headerDensity: {
      type: String,
      default: "default"
    },
    /**
     * Designates an elevation applied to the table header toolbar between 0 and 24. You can find more information in the [Vuetify elevation documentation](https://vuetifyjs.com/en/styles/elevation/).
     */
    headerElevation: {
      type: [Number, String],
      default: 0
    },
    /**
     * Removes the box shadow from the table header toolbar.
     */
    headerFlat: {
      type: Boolean,
      default: !0
    },
    /**
     * The height of the table's header toolbar.
     */
    headerHeight: {
      type: [Number, String],
      default: void 0
    },
    /**
     * The image to display in the table's header toolbar.
     */
    headerImage: {
      type: String,
      default: void 0
    },
    /**
     * The theme to apply to the table's header toolbar.
     */
    headerTheme: {
      type: String,
      default: void 0
    }
  },
  setup(e) {
    const t = ja(e, "VPModelListTable"), n = async (d) => {
      console.log("options", d);
    }, i = b(
      () => [...t.columns].map(
        (d) => Object.assign(
          {
            sortable: !0,
            searchable: !0,
            searchType: "string"
          },
          d
        )
      )
    ), r = b(() => !1), s = X([]), a = X(10), o = X(0), l = ja({}, "VDataTableServer"), u = b(() => ({
      ...l,
      headers: [
        ...[...i.value].map((d) => ({
          key: d.property,
          value: d.property,
          title: d.title,
          align: d.alignment,
          width: d.width,
          minWidth: d.minWidth,
          maxWidth: d.maxWidth,
          nowrap: !0,
          sortable: d.sortable
        }))
      ],
      items: [],
      itemsLength: o.value,
      loading: r.value
    })), c = ja(
      {
        color: t.headerBackgroundColor || t.backgroundColor,
        density: t.headerDensity,
        elevation: t.headerElevation,
        flat: t.headerFlat,
        height: t.headerHeight,
        image: t.headerImage,
        theme: t.headerTheme
      },
      "VToolBar"
    );
    return {
      serverDataTableBind: u,
      serverDataTableSelections: s,
      tableItemsPerPage: a,
      onOptionsChanged: n,
      serverDataTableHeaderBindings: c
    };
  }
});
const eR = { class: "vp-model-list-table" };
function tR(e, t, n, i, r, s) {
  const a = tn("v-toolbar"), o = tn("v-divider"), l = tn("v-data-table-server"), u = tn("v-card");
  return vl(), Q_("div", eR, [
    v(u, {
      color: e.backgroundColor,
      flat: "",
      tile: ""
    }, {
      default: dn(() => [
        v(l, ie(e.serverDataTableBind, {
          modelValue: e.serverDataTableSelections,
          "onUpdate:modelValue": t[0] || (t[0] = (c) => e.serverDataTableSelections = c),
          "items-per-page": e.tableItemsPerPage,
          "onUpdate:itemsPerPage": t[1] || (t[1] = (c) => e.tableItemsPerPage = c),
          "onUpdate:options": e.onOptionsChanged
        }), {
          top: dn(() => [
            or(e.$slots, "pre-header"),
            v(a, os(ls(e.serverDataTableHeaderBindings)), {
              default: dn(() => [
                or(e.$slots, "header-prepend")
              ]),
              _: 3
            }, 16),
            v(o)
          ]),
          _: 3
        }, 16, ["modelValue", "items-per-page", "onUpdate:options"])
      ]),
      _: 3
    }, 8, ["color"])
  ]);
}
const nR = /* @__PURE__ */ Rc(QM, [["render", tR]]), m0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VPDateTime: XN,
  VPFormLogin: JM,
  VPModelListTable: nR,
  VPPasswordField: rk,
  VPTextFieldCopyable: YV
}, Symbol.toStringTag, { value: "Module" }));
function iR(e) {
  for (const t in m0)
    e.component(t, m0[t]);
}
const Y7 = { install: iR };
var _C = { exports: {} };
function Rp() {
}
Rp.prototype = {
  on: function(e, t, n) {
    var i = this.e || (this.e = {});
    return (i[e] || (i[e] = [])).push({
      fn: t,
      ctx: n
    }), this;
  },
  once: function(e, t, n) {
    var i = this;
    function r() {
      i.off(e, r), t.apply(n, arguments);
    }
    return r._ = t, this.on(e, r, n);
  },
  emit: function(e) {
    var t = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[e] || []).slice(), i = 0, r = n.length;
    for (i; i < r; i++)
      n[i].fn.apply(n[i].ctx, t);
    return this;
  },
  off: function(e, t) {
    var n = this.e || (this.e = {}), i = n[e], r = [];
    if (i && t)
      for (var s = 0, a = i.length; s < a; s++)
        i[s].fn !== t && i[s].fn._ !== t && r.push(i[s]);
    return r.length ? n[e] = r : delete n[e], this;
  }
};
_C.exports = Rp;
var Wd = _C.exports.TinyEmitter = Rp, Fp = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, $e = (e, t, n) => (Fp(e, t, "read from private field"), n ? n.call(e) : t.get(e)), zn = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, Nr = (e, t, n, i) => (Fp(e, t, "write to private field"), i ? i.call(e, n) : t.set(e, n), n), Fi = (e, t, n) => (Fp(e, t, "access private method"), n), Wi, Hs, jr, Aa, Qo, Qu, Ia, el, Bi, Ho, qv, SC, Lu, _f, jd, Gv, Hd, Yv, Zv, kC, yu, zd;
const Oh = Is("Bus");
function v0() {
  return Date.now().toString(36) + Math.random().toString(36).substring(2);
}
class Vh {
  /**
   * Create a new bus
   * @param namespace The namespace for the BroadcastChannel
   */
  constructor(t) {
    zn(this, qv), zn(this, Lu), zn(this, jd), zn(this, Hd), zn(this, Zv), zn(this, yu), zn(this, Wi, void 0), zn(this, Hs, void 0), zn(this, jr, void 0), zn(this, Aa, void 0), zn(this, Qo, void 0), zn(this, Qu, void 0), zn(this, Ia, void 0), zn(this, el, void 0), zn(this, Bi, void 0), zn(this, Ho, void 0), Nr(this, Wi, v0()), Nr(this, jr, new Wd()), Nr(this, Aa, new Wd()), Nr(this, Qo, new Wd()), Nr(this, Qu, /* @__PURE__ */ new Map()), Nr(this, Ia, X(!1)), Nr(this, el, X(void 0)), Nr(this, Bi, X({})), Nr(this, Ho, X({})), typeof BroadcastChannel < "u" && (Nr(this, Hs, new BroadcastChannel(t || (window == null ? void 0 : window.location.origin) || "vueprint")), $e(this, Hs).onmessage = Fi(this, qv, SC).bind(this)), typeof window < "u" && (window.addEventListener("focus", Fi(this, Lu, _f).bind(this, !0)), window.addEventListener("blur", Fi(this, Lu, _f).bind(this, !1)), window.addEventListener("visibilitychange", Fi(this, jd, Gv).bind(this)), Fi(this, jd, Gv).call(this)), Fi(this, yu, zd).call(this, "getActiveTabs", () => this.active.value), Fi(this, yu, zd).call(this, "awaitCrossTab", async ({ event: n, args: i }) => {
      await Fi(this, Hd, Yv).call(this, n, i);
    }), Oh(`Initialized Bus for tab ${$e(this, Wi)}`);
  }
  /**
   * The UUID of the tab
   */
  get uuid() {
    return $e(this, Wi);
  }
  /**
   * Whether the tab is active
   */
  get active() {
    return b(() => $e(this, Ia).value);
  }
  /**
   * Whether the tab has been inactive for too long and should have reduced functionality
   * to save user resources
   */
  get inactiveTooLong() {
    return b(() => $e(this, Ia).value === !0 || $e(this, el).value === void 0 ? !1 : Date.now() - $e(this, el).value > 6e4);
  }
  /**
   * Listen to an event
   * @param event The event to listen to
   * @param callback The callback to call when the event is emitted
   * @param options The options for listening to the event
   */
  on(t, n, i = {}) {
    if (i.local && $e(this, jr).on(t, n), i.crossTab && $e(this, Aa).on(t, n), i.immediate) {
      let r = !1;
      const s = $e(this, Bi).value[t] ? Object.values($e(this, Bi).value[t]) : [];
      i.local && $e(this, Bi).value[t] && (r = !0, n(...s)), i.crossTab && $e(this, Ho).value[t] && !r && (r = !0, n(...s));
    }
  }
  /**
   * Stop listening to an event
   * @param event The event to stop listening to
   * @param callback The callback to remove from the event
   * @param options The options for stopping listening to the event
   */
  off(t, n, i = {}) {
    i.local && $e(this, jr).off(t, n), i.crossTab && $e(this, Aa).off(t, n);
  }
  /**
   * Listen to an event once
   * @param event The event to listen to
   * @param callback The callback to call when the event is emitted
   * @param options The options for listening to the event
   */
  once(t, n, i = {}) {
    if (i.local && $e(this, jr).once(t, n), i.crossTab && $e(this, Aa).once(t, n), i.immediate) {
      let r = !1;
      const s = $e(this, Bi).value[t] ? Object.values($e(this, Bi).value[t]) : [];
      i.local && $e(this, Bi).value[t] && (r = !0, n(...s)), i.crossTab && $e(this, Ho).value[t] && !r && (r = !0, n(...s));
    }
  }
  /**
   * Trigger an event
   * @param event The name of the event to emit
   * @param options The options for emitting the event
   * @param args The arguments to pass to the event
   */
  emit(t, n = {}, ...i) {
    var r;
    n.local && ($e(this, jr).emit(t, ...i), $e(this, Bi).value[t] = i), n.crossTab && ((r = $e(this, Hs)) == null || r.postMessage(JSON.stringify({ event: t, args: i, from: $e(this, Wi) })), $e(this, Ho).value[t] = i);
  }
  /**
   * Trigger an event and await for all listeners to process it
   * @param event The name of the event to await listener processing for
   * @param args The arguments to pass to the event
   * @returns A promise that resolves when all listeners have processed the event
   *
   * @remarks
   * This method is especially useful within service workers where you may need to use `event.waitUntil` to ensure that all listeners have processed the event before the service worker is terminated
   */
  await(t, n = {}, ...i) {
    const r = [];
    return n.local && r.push(Fi(this, Hd, Yv).call(this, t, i)), n.crossTab && r.push(Fi(this, Zv, kC).call(this, t, i)), r.length ? Promise.all(r) : Promise.resolve();
  }
  /**
   * Make a request to all tabs and await their responses
   * @param method The method to call
   * @param payload The payload to send to the method being called
   * @param targets The uuids of the tabs to send the request to. Accepts "*" for all tabs
   * @param timeout The amount of time to wait for a response
   * @returns A map of responses from the tabs
   */
  async crossTabRequest(t, n, i = "*", r = 500) {
    if (!$e(this, Hs))
      throw new Error("BroadcastChannel is not available");
    const s = v0(), a = JSON.stringify({
      event: "crossTabRequest",
      args: [s, t, n, i],
      from: $e(this, Wi)
    }), o = /* @__PURE__ */ new Map(), l = (c, d) => {
      o.set(d, c);
    }, u = new Promise((c) => {
      $e(this, Qo).on(s, l), setTimeout(c, r);
    });
    return $e(this, Hs).postMessage(a), await u, $e(this, Qo).off(s, l), o;
  }
  /**
   * Add a function which will handle requests for a method called by {@link BusService.crossTabRequest}
   * @param method The method which the handler will handle requests for
   * @param handler The function which will handle requests and return results
   */
  addRequestHandler(t, n) {
    if (["getActiveTabs", "awaitCrossTab"].includes(t))
      throw new Error(`Method "${t}" is protected and cannot be overridden`);
    Fi(this, yu, zd).call(this, t, n);
  }
  /**
   * Get the active tabs
   * @param wait The time to wait before returning the active tabs
   * @returns The active tabs
   */
  async getActiveTabs(t = 500) {
    const n = /* @__PURE__ */ new Map();
    (await this.crossTabRequest("getActiveTabs", void 0, "*", t)).forEach((o, l) => {
      n.set(l, o);
    });
    const r = Array.from(n.entries());
    return r.push([$e(this, Wi), $e(this, Ia).value]), r.sort((o, l) => {
      const [u, c] = o, [d, f] = l;
      return c === f ? u.localeCompare(d, void 0, {
        numeric: !1,
        sensitivity: "base",
        ignorePunctuation: !0
      }) : c === !0 ? -1 : 1;
    }).map((o) => o[0]);
  }
  /**
   * Check if the tab is the main tab
   * @param wait The time to wait before returning the active tabs
   * @returns Whether the tab is the main tab
   */
  async isMain(t = 500) {
    const n = await this.getActiveTabs(t);
    return n.length > 0 ? n[0] === $e(this, Wi) : !1;
  }
}
Wi = /* @__PURE__ */ new WeakMap();
Hs = /* @__PURE__ */ new WeakMap();
jr = /* @__PURE__ */ new WeakMap();
Aa = /* @__PURE__ */ new WeakMap();
Qo = /* @__PURE__ */ new WeakMap();
Qu = /* @__PURE__ */ new WeakMap();
Ia = /* @__PURE__ */ new WeakMap();
el = /* @__PURE__ */ new WeakMap();
Bi = /* @__PURE__ */ new WeakMap();
Ho = /* @__PURE__ */ new WeakMap();
qv = /* @__PURE__ */ new WeakSet();
SC = function(e) {
  const t = e.data;
  let n, i = [], r;
  try {
    const s = JSON.parse(t);
    if (n = s.event, i = s.args, r = s.from, n === "crossTabRequest") {
      const [a, o, l, u] = i;
      if (u === "*" || u.includes($e(this, Wi))) {
        const c = $e(this, Qu).get(o);
        new Promise(async (f) => {
          let h;
          try {
            h = await (c == null ? void 0 : c(l));
          } catch (m) {
            Oh(`Error handling crossTabRequest "${o}"`, m);
          }
          f(h);
        }).then((f) => {
          $e(this, Hs).postMessage(
            JSON.stringify({
              event: "crossTabResponse",
              args: [a, f],
              from: $e(this, Wi)
            })
          );
        });
      } else
        return;
    }
    if (n === "crossTabResponse") {
      const [a, o] = i;
      $e(this, Qo).emit(a, o, r);
      return;
    }
    $e(this, Aa).emit(n, ...i, r);
  } catch {
    return;
  }
};
Lu = /* @__PURE__ */ new WeakSet();
_f = function(e) {
  Oh(`Tab is ${e ? "active" : "inactive"}`), $e(this, Ia).value = e, e ? ($e(this, Bi).value["tab:inactive"], this.emit("tab:active", { local: !0 })) : (delete $e(this, Bi).value["tab:active"], this.emit("tab:inactive", { local: !0 }), $e(this, el).value = Date.now()), this.emit("tab:uuid", { local: !1, crossTab: !0 }, $e(this, Wi), e);
};
jd = /* @__PURE__ */ new WeakSet();
Gv = function() {
  typeof document > "u" || Fi(this, Lu, _f).call(this, document.visibilityState === "visible");
};
Hd = /* @__PURE__ */ new WeakSet();
Yv = function(e, t) {
  const n = [];
  return $e(this, jr).e ? ($e(this, jr).e[e] && $e(this, jr).e[e].forEach(({ fn: i }) => {
    n.push(Promise.resolve(i.apply(null, t)));
  }), n.length ? Promise.all(n) : Promise.resolve()) : (["sw:fetch"].includes(e) || Oh(`No local bus listeners for "${e}"`), Promise.resolve());
};
Zv = /* @__PURE__ */ new WeakSet();
kC = function(e, t) {
  return new Promise((n) => {
    this.crossTabRequest("awaitCrossTab", { event: e, args: t }).then(() => {
      n(void 0);
    });
  });
};
yu = /* @__PURE__ */ new WeakSet();
zd = function(e, t) {
  $e(this, Qu).set(e, t);
};
const rR = {
  install: (e, t) => {
    const n = new Vh(t == null ? void 0 : t.namespace);
    e.provide("bus", n), e.config.globalProperties.$bus = n;
  }
};
var Bp = { exports: {} }, ul = typeof Reflect == "object" ? Reflect : null, g0 = ul && typeof ul.apply == "function" ? ul.apply : function(t, n, i) {
  return Function.prototype.apply.call(t, n, i);
}, Ud;
ul && typeof ul.ownKeys == "function" ? Ud = ul.ownKeys : Object.getOwnPropertySymbols ? Ud = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : Ud = function(t) {
  return Object.getOwnPropertyNames(t);
};
function sR(e) {
  console && console.warn && console.warn(e);
}
var CC = Number.isNaN || function(t) {
  return t !== t;
};
function _t() {
  _t.init.call(this);
}
Bp.exports = _t;
Bp.exports.once = uR;
_t.EventEmitter = _t;
_t.prototype._events = void 0;
_t.prototype._eventsCount = 0;
_t.prototype._maxListeners = void 0;
var p0 = 10;
function Dh(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(_t, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return p0;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || CC(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    p0 = e;
  }
});
_t.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
_t.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || CC(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function TC(e) {
  return e._maxListeners === void 0 ? _t.defaultMaxListeners : e._maxListeners;
}
_t.prototype.getMaxListeners = function() {
  return TC(this);
};
_t.prototype.emit = function(t) {
  for (var n = [], i = 1; i < arguments.length; i++)
    n.push(arguments[i]);
  var r = t === "error", s = this._events;
  if (s !== void 0)
    r = r && s.error === void 0;
  else if (!r)
    return !1;
  if (r) {
    var a;
    if (n.length > 0 && (a = n[0]), a instanceof Error)
      throw a;
    var o = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
    throw o.context = a, o;
  }
  var l = s[t];
  if (l === void 0)
    return !1;
  if (typeof l == "function")
    g0(l, this, n);
  else
    for (var u = l.length, c = PC(l, u), i = 0; i < u; ++i)
      g0(c[i], this, n);
  return !0;
};
function xC(e, t, n, i) {
  var r, s, a;
  if (Dh(n), s = e._events, s === void 0 ? (s = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (s.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    n.listener ? n.listener : n
  ), s = e._events), a = s[t]), a === void 0)
    a = s[t] = n, ++e._eventsCount;
  else if (typeof a == "function" ? a = s[t] = i ? [n, a] : [a, n] : i ? a.unshift(n) : a.push(n), r = TC(e), r > 0 && a.length > r && !a.warned) {
    a.warned = !0;
    var o = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    o.name = "MaxListenersExceededWarning", o.emitter = e, o.type = t, o.count = a.length, sR(o);
  }
  return e;
}
_t.prototype.addListener = function(t, n) {
  return xC(this, t, n, !1);
};
_t.prototype.on = _t.prototype.addListener;
_t.prototype.prependListener = function(t, n) {
  return xC(this, t, n, !0);
};
function aR() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function AC(e, t, n) {
  var i = { fired: !1, wrapFn: void 0, target: e, type: t, listener: n }, r = aR.bind(i);
  return r.listener = n, i.wrapFn = r, r;
}
_t.prototype.once = function(t, n) {
  return Dh(n), this.on(t, AC(this, t, n)), this;
};
_t.prototype.prependOnceListener = function(t, n) {
  return Dh(n), this.prependListener(t, AC(this, t, n)), this;
};
_t.prototype.removeListener = function(t, n) {
  var i, r, s, a, o;
  if (Dh(n), r = this._events, r === void 0)
    return this;
  if (i = r[t], i === void 0)
    return this;
  if (i === n || i.listener === n)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete r[t], r.removeListener && this.emit("removeListener", t, i.listener || n));
  else if (typeof i != "function") {
    for (s = -1, a = i.length - 1; a >= 0; a--)
      if (i[a] === n || i[a].listener === n) {
        o = i[a].listener, s = a;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? i.shift() : oR(i, s), i.length === 1 && (r[t] = i[0]), r.removeListener !== void 0 && this.emit("removeListener", t, o || n);
  }
  return this;
};
_t.prototype.off = _t.prototype.removeListener;
_t.prototype.removeAllListeners = function(t) {
  var n, i, r;
  if (i = this._events, i === void 0)
    return this;
  if (i.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : i[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete i[t]), this;
  if (arguments.length === 0) {
    var s = Object.keys(i), a;
    for (r = 0; r < s.length; ++r)
      a = s[r], a !== "removeListener" && this.removeAllListeners(a);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (n = i[t], typeof n == "function")
    this.removeListener(t, n);
  else if (n !== void 0)
    for (r = n.length - 1; r >= 0; r--)
      this.removeListener(t, n[r]);
  return this;
};
function IC(e, t, n) {
  var i = e._events;
  if (i === void 0)
    return [];
  var r = i[t];
  return r === void 0 ? [] : typeof r == "function" ? n ? [r.listener || r] : [r] : n ? lR(r) : PC(r, r.length);
}
_t.prototype.listeners = function(t) {
  return IC(this, t, !0);
};
_t.prototype.rawListeners = function(t) {
  return IC(this, t, !1);
};
_t.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : EC.call(e, t);
};
_t.prototype.listenerCount = EC;
function EC(e) {
  var t = this._events;
  if (t !== void 0) {
    var n = t[e];
    if (typeof n == "function")
      return 1;
    if (n !== void 0)
      return n.length;
  }
  return 0;
}
_t.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Ud(this._events) : [];
};
function PC(e, t) {
  for (var n = new Array(t), i = 0; i < t; ++i)
    n[i] = e[i];
  return n;
}
function oR(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function lR(e) {
  for (var t = new Array(e.length), n = 0; n < t.length; ++n)
    t[n] = e[n].listener || e[n];
  return t;
}
function uR(e, t) {
  return new Promise(function(n, i) {
    function r(a) {
      e.removeListener(t, s), i(a);
    }
    function s() {
      typeof e.removeListener == "function" && e.removeListener("error", r), n([].slice.call(arguments));
    }
    OC(e, t, s, { once: !0 }), t !== "error" && cR(e, r, { once: !0 });
  });
}
function cR(e, t, n) {
  typeof e.on == "function" && OC(e, "error", t, n);
}
function OC(e, t, n, i) {
  if (typeof e.on == "function")
    i.once ? e.once(t, n) : e.on(t, n);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function r(s) {
      i.once && e.removeEventListener(t, r), n(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var dR = Bp.exports, Lp = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, Qt = (e, t, n) => (Lp(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Ra = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, Sf = (e, t, n, i) => (Lp(e, t, "write to private field"), i ? i.call(e, n) : t.set(e, n), n), is = (e, t, n) => (Lp(e, t, "access private method"), n), lr, $u, tl, kf, Kv, cs, Bs, Nh, $p, ds, Ls;
const Wc = class Xv {
  /**
   * Creates a new instance of the MiliCron class.
   * @constructor
   * @param {boolean} [autostart=false] - Whether to automatically start the cron daemon upon instantiation.
   * @returns {MiliCron} - A new instance of the MiliCron class.
   */
  constructor(t) {
    Ra(this, kf), Ra(this, lr, void 0), Ra(this, $u, void 0), Ra(this, tl, !1), Sf(this, lr, new dR.EventEmitter({ captureRejections: !0 })), Qt(this, lr).setMaxListeners(1 / 0), t === !0 && this.start();
  }
  /**
   * Starts the cron daemon if it is not already running.
   * @function
   * @returns {void}
   */
  start() {
    Qt(this, tl) || is(this, kf, Kv).call(this);
  }
  /**
   * Stops the cron daemon if it is running.
   * @function
   * @returns {void}
   */
  stop() {
    Qt(this, $u) && clearTimeout(Qt(this, $u)), Sf(this, tl, !1);
  }
  /**
   * Stops the cron daemon if it is running and then starts it again.
   * @function
   * @returns {void}
   */
  restart() {
    this.stop(), this.start();
  }
  /**
   * Returns a boolean indicating whether the cron daemon is currently running.
   * @readonly
   * @returns {boolean} - A boolean indicating whether the cron daemon is currently running.
   */
  get running() {
    return Qt(this, tl);
  }
  $on(t, n) {
    Qt(this, lr).on(t, n);
  }
  $once(t, n) {
    Qt(this, lr).once(t, n);
  }
  $off(t, n) {
    Qt(this, lr).off(t, n);
  }
  /**
   * Removes all listeners for the specified event or all events if no event is specified.
   * @param {string} [event] - The name of the event to remove all listeners from.
   * @returns {void}
   * @see {@link events!EventEmitter.removeAllListeners | EventEmitter.removeAllListeners}
   */
  $clear(t) {
    t ? Qt(this, lr).removeAllListeners(t) : Qt(this, lr).removeAllListeners();
  }
  /**
   * Determines whether the given crontab expression matches the given date and time.
   * @param {string} crontab - The crontab expression to check.
   * @param {DateTime} now - The date and time to check against the crontab expression.
   * @returns {boolean} - A boolean indicating whether the crontab expression matches the given date and time.
   */
  crontabMatchesDateTime(t, n) {
    return Xv.crontabMatchesDateTime(t, n);
  }
  /**
   * Parses the given cron expression and returns either a `DateTime` object representing the next time the cron expression will match, or a `CronTabObject` containing the parsed cron expression.
   * @param {string} cronExpression - The cron expression to parse.
   * @param {DateTime} [now] - The current date and time to use as a reference when calculating the next match time. If not provided, the current date and time will be used.
   * @throws {Error} - Throws an error if the cron expression is so invalid that it cannot be recognized, or if the `now` parameter is not a valid `DateTime` object.
   * @returns {DateTime | CronTabObject} - A `DateTime` object representing the next time the cron expression will match, or a `CronTabObject` containing the parsed cron expression.
   */
  getParsedCronExpression(t, n) {
    return Xv.getParsedCronExpression(t, n);
  }
  /**
   * Check if the crontab expression matches the current time
   * @param crontab A crontab expression, crontab alias or unix timestamp
   * @param now A DateTime object representing the current time
   * @returns If the crontab expression matches the current time
   */
  static crontabMatchesDateTime(t, n) {
    if (!n.isValid)
      return !1;
    try {
      const i = this.getParsedCronExpression(t, n);
      return i instanceof Re ? i >= n.minus({ milliseconds: 9 }) && i <= n.plus({ milliseconds: 9 }) : [
        i.millisecondly.has(n.millisecond),
        i.secondly.has(n.second),
        i.minutely.has(n.minute),
        i.hourly.has(n.hour),
        i.dayOfMonthly.has(n.day),
        i.monthly.has(n.month),
        i.dayOfWeekly.has(n.weekday)
      ].every((r) => r === !0);
    } catch {
      return !1;
    }
  }
  /**
   * Parses the given cron expression and returns either a `DateTime` object representing the next time the cron expression will match, or a `CronTabObject` containing the parsed cron expression.
   * @param {string} cronExpression - The cron expression to parse.
   * @param {DateTime} [now] - The current date and time to use as a reference when calculating the next match time. If not provided, the current date and time will be used.
   * @throws {Error} - Throws an error if the cron expression is so invalid that it cannot be recognized, or if the `now` parameter is not a valid `DateTime` object.
   * @returns {DateTime | CronTabObject} - A `DateTime` object representing the next time the cron expression will match, or a `CronTabObject` containing the parsed cron expression.
   */
  static getParsedCronExpression(t, n) {
    if (!n)
      n = Re.now().toUTC();
    else if (!n.isValid)
      throw new Error("Invalid DateTime object");
    if (t.startsWith("@")) {
      const f = Qt(this, Nh, $p).expressions[t];
      if (f)
        return this.getParsedCronExpression(f);
    }
    const i = t.replace(/\s+/g, " ").split(" ").map((f) => f.trim());
    if (i.length === 1)
      return Re.fromSeconds(parseInt(i[0]));
    if (i.length > 7)
      throw new Error("Invalid crontab expression");
    for (; i.length < 7; )
      i.unshift("0");
    const [r, s, a, o, l, u, c] = i;
    return {
      millisecondly: is(this, ds, Ls).call(this, "millisecond", r, Qt(this, cs, Bs).millisecondly, n),
      secondly: is(this, ds, Ls).call(this, "second", s, Qt(this, cs, Bs).secondly, n),
      minutely: is(this, ds, Ls).call(this, "minute", a, Qt(this, cs, Bs).minutely, n),
      hourly: is(this, ds, Ls).call(this, "hour", o, Qt(this, cs, Bs).hourly, n),
      dayOfMonthly: is(this, ds, Ls).call(this, "dayOfMonth", l, Qt(this, cs, Bs).dayOfMonthly, n),
      monthly: is(this, ds, Ls).call(this, "month", u, Qt(this, cs, Bs).monthly, n),
      dayOfWeekly: is(this, ds, Ls).call(this, "dayOfWeek", c, Qt(this, cs, Bs).dayOfWeekly, n)
    };
  }
};
lr = /* @__PURE__ */ new WeakMap();
$u = /* @__PURE__ */ new WeakMap();
tl = /* @__PURE__ */ new WeakMap();
kf = /* @__PURE__ */ new WeakSet();
Kv = function() {
  Sf(this, tl, !0);
  const e = Re.now().toUTC();
  Qt(this, lr).eventNames().filter((n) => n !== "error").forEach((n) => {
    Wc.crontabMatchesDateTime(n.toString(), e) && Qt(this, lr).emit(n);
  }), Sf(this, $u, setTimeout(is(this, kf, Kv).bind(this), 10));
};
cs = /* @__PURE__ */ new WeakSet();
Bs = function() {
  const e = {
    millisecondly: {
      min: 0,
      max: 999,
      chars: [],
      validChars: /^[,*\d/-]+$/
    },
    secondly: {
      min: 0,
      max: 59,
      chars: [],
      validChars: /^[,*\d/-]+$/
    },
    minutely: {
      min: 0,
      max: 59,
      chars: [],
      validChars: /^[,*\d/-]+$/
    },
    hourly: {
      min: 0,
      max: 23,
      chars: [],
      validChars: /^[,*\d/-]+$/
    },
    dayOfMonthly: {
      min: 1,
      max: 31,
      chars: ["L"],
      validChars: /^[?,*\dL/-]+$/
    },
    monthly: {
      min: 1,
      max: 12,
      chars: [],
      validChars: /^[,*\d/-]+$/
    },
    dayOfWeekly: {
      min: 0,
      max: 7,
      chars: ["L"],
      validChars: /^[?,*\dL#/-]+$/
    }
  };
  return Object.freeze(e), e;
};
Nh = /* @__PURE__ */ new WeakSet();
$p = function() {
  const e = {
    expressions: {
      "@yearly": "0 0 0 0 1 1 *",
      "@monthly": "0 0 0 0 1 * *",
      "@weekly": "0 0 0 0 * * 0",
      "@daily": "0 0 0 0 * * *",
      "@hourly": "0 0 0 * * * *"
    },
    month: {
      JAN: 1,
      FEB: 2,
      MAR: 3,
      APR: 4,
      MAY: 5,
      JUN: 6,
      JUL: 7,
      AUG: 8,
      SEP: 9,
      OCT: 10,
      NOV: 11,
      DEC: 12
    },
    daysOfWeek: {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    }
  };
  return Object.freeze(e), e;
};
ds = /* @__PURE__ */ new WeakSet();
Ls = function(e, t, n, i) {
  const r = /* @__PURE__ */ new Set(), s = Qt(this, Nh, $p)[e];
  switch (e) {
    case "month":
    case "dayOfWeek":
      t = t.replace(/[a-z]{3}/gi, (o) => (o = o.toUpperCase(), s && typeof s[o] < "u" ? s[o].toString() : "X"));
      break;
  }
  return t === "X" || !n.validChars.test(t) || (t.includes("*") ? t = t.replace(/\*/g, n.min + "-" + n.max) : t.includes("?") && (t = t.replace(/\?/g, n.min + "-" + n.max)), t.split(",").forEach((o) => {
    if (o.includes("-"))
      if (o.includes("/")) {
        if (o.split("/").length !== 2)
          return;
        const [l, u] = o.split("/"), [c, d] = l.split("-"), f = parseInt(c), h = parseInt(d), m = parseInt(u);
        if (m <= 0 || f > h)
          return;
        for (let g = f; g <= h; g += m)
          r.add(g);
      } else {
        const [l, u] = o.split("-"), c = parseInt(l), d = parseInt(u);
        if (c > d)
          return;
        for (let f = c; f <= d; f++)
          r.add(f);
      }
    else if (o.includes("/")) {
      if (o.split("/").length !== 2)
        return;
      const [l, u] = o.split("/"), c = parseInt(l), d = parseInt(u);
      if (d <= 0 || c > n.max)
        return;
      for (let f = c; f <= n.max; f += d)
        r.add(f);
    } else if (o.includes("#")) {
      const [l, u] = o.split("#"), c = parseInt(l), d = parseInt(u);
      if (c > n.max)
        return;
      const h = Re.fromObject({
        year: i.year,
        month: i.month,
        day: 1
      }).weekday, g = Re.fromObject({
        year: i.year,
        month: i.month,
        day: 1 + (c - h)
      }).plus({
        weeks: d - 1
      });
      if (g.month !== i.month)
        return;
      r.add(g.day);
    } else if (o.includes("L")) {
      if (o.split("/").length !== 2)
        return;
      const [l, u] = o.split("/"), c = parseInt(l), d = parseInt(u);
      if (d <= 0 || c > n.max)
        return;
      for (let f = c; f <= n.max; f += d)
        r.add(f);
    } else {
      const l = parseInt(o);
      l >= n.min && l <= n.max && r.add(l);
    }
  }), e === "millisecond" && [...r].forEach((l) => {
    const u = l - 9 < n.min ? n.min : l - 9, c = l + 9 > n.max ? n.max : l + 9;
    for (let d = u; d <= c; d++)
      r.add(d);
  }), e === "dayOfWeek" && (r.has(7) && r.add(0), r.has(0) && r.add(7))), r;
};
Ra(Wc, cs);
Ra(Wc, Nh);
Ra(Wc, ds);
let Wp = Wc;
const fR = {
  install: (e) => {
    const t = new Wp();
    e.provide("cron", t), e.config.globalProperties.$cron = t;
  }
};
var nl = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function jp(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Cf = { exports: {} };
Cf.exports;
(function(e, t) {
  var n = 200, i = "__lodash_hash_undefined__", r = 800, s = 16, a = 9007199254740991, o = "[object Arguments]", l = "[object Array]", u = "[object AsyncFunction]", c = "[object Boolean]", d = "[object Date]", f = "[object Error]", h = "[object Function]", m = "[object GeneratorFunction]", g = "[object Map]", p = "[object Number]", y = "[object Null]", k = "[object Object]", T = "[object Proxy]", _ = "[object RegExp]", w = "[object Set]", S = "[object String]", C = "[object Undefined]", x = "[object WeakMap]", A = "[object ArrayBuffer]", I = "[object DataView]", E = "[object Float32Array]", P = "[object Float64Array]", V = "[object Int8Array]", N = "[object Int16Array]", F = "[object Int32Array]", $ = "[object Uint8Array]", Z = "[object Uint8ClampedArray]", j = "[object Uint16Array]", H = "[object Uint32Array]", R = /[\\^$.*+?()[\]{}|]/g, L = /^\[object .+?Constructor\]$/, ne = /^(?:0|[1-9]\d*)$/, oe = {};
  oe[E] = oe[P] = oe[V] = oe[N] = oe[F] = oe[$] = oe[Z] = oe[j] = oe[H] = !0, oe[o] = oe[l] = oe[A] = oe[c] = oe[I] = oe[d] = oe[f] = oe[h] = oe[g] = oe[p] = oe[k] = oe[_] = oe[w] = oe[S] = oe[x] = !1;
  var we = typeof nl == "object" && nl && nl.Object === Object && nl, ee = typeof self == "object" && self && self.Object === Object && self, K = we || ee || Function("return this")(), ue = t && !t.nodeType && t, ve = ue && !0 && e && !e.nodeType && e, Fe = ve && ve.exports === ue, he = Fe && we.process, Oe = function() {
    try {
      var D = ve && ve.require && ve.require("util").types;
      return D || he && he.binding && he.binding("util");
    } catch {
    }
  }(), le = Oe && Oe.isTypedArray;
  function be(D, W, Q) {
    switch (Q.length) {
      case 0:
        return D.call(W);
      case 1:
        return D.call(W, Q[0]);
      case 2:
        return D.call(W, Q[0], Q[1]);
      case 3:
        return D.call(W, Q[0], Q[1], Q[2]);
    }
    return D.apply(W, Q);
  }
  function Pe(D, W) {
    for (var Q = -1, Ve = Array(D); ++Q < D; )
      Ve[Q] = W(Q);
    return Ve;
  }
  function te(D) {
    return function(W) {
      return D(W);
    };
  }
  function me(D, W) {
    return D == null ? void 0 : D[W];
  }
  function Me(D, W) {
    return function(Q) {
      return D(W(Q));
    };
  }
  var Be = Array.prototype, xe = Function.prototype, ze = Object.prototype, Ke = K["__core-js_shared__"], ut = xe.toString, vt = ze.hasOwnProperty, Vn = function() {
    var D = /[^.]+$/.exec(Ke && Ke.keys && Ke.keys.IE_PROTO || "");
    return D ? "Symbol(src)_1." + D : "";
  }(), Dn = ze.toString, Dr = ut.call(Object), ma = RegExp(
    "^" + ut.call(vt).replace(R, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), li = Fe ? K.Buffer : void 0, q = K.Symbol, z = K.Uint8Array, de = li ? li.allocUnsafe : void 0, O = Me(Object.getPrototypeOf, Object), M = Object.create, U = ze.propertyIsEnumerable, Y = Be.splice, ce = q ? q.toStringTag : void 0, Se = function() {
    try {
      var D = Nm(Object, "defineProperty");
      return D({}, "", {}), D;
    } catch {
    }
  }(), Ie = li ? li.isBuffer : void 0, Ne = Math.max, Le = Date.now, Ge = Nm(K, "Map"), qe = Nm(Object, "create"), Et = function() {
    function D() {
    }
    return function(W) {
      if (!ga(W))
        return {};
      if (M)
        return M(W);
      D.prototype = W;
      var Q = new D();
      return D.prototype = void 0, Q;
    };
  }();
  function Pt(D) {
    var W = -1, Q = D == null ? 0 : D.length;
    for (this.clear(); ++W < Q; ) {
      var Ve = D[W];
      this.set(Ve[0], Ve[1]);
    }
  }
  function ui() {
    this.__data__ = qe ? qe(null) : {}, this.size = 0;
  }
  function ts(D) {
    var W = this.has(D) && delete this.__data__[D];
    return this.size -= W ? 1 : 0, W;
  }
  function va(D) {
    var W = this.__data__;
    if (qe) {
      var Q = W[D];
      return Q === i ? void 0 : Q;
    }
    return vt.call(W, D) ? W[D] : void 0;
  }
  function Tm(D) {
    var W = this.__data__;
    return qe ? W[D] !== void 0 : vt.call(W, D);
  }
  function xm(D, W) {
    var Q = this.__data__;
    return this.size += this.has(D) ? 0 : 1, Q[D] = qe && W === void 0 ? i : W, this;
  }
  Pt.prototype.clear = ui, Pt.prototype.delete = ts, Pt.prototype.get = va, Pt.prototype.has = Tm, Pt.prototype.set = xm;
  function nr(D) {
    var W = -1, Q = D == null ? 0 : D.length;
    for (this.clear(); ++W < Q; ) {
      var Ve = D[W];
      this.set(Ve[0], Ve[1]);
    }
  }
  function Am() {
    this.__data__ = [], this.size = 0;
  }
  function Im(D) {
    var W = this.__data__, Q = fd(W, D);
    if (Q < 0)
      return !1;
    var Ve = W.length - 1;
    return Q == Ve ? W.pop() : Y.call(W, Q, 1), --this.size, !0;
  }
  function Em(D) {
    var W = this.__data__, Q = fd(W, D);
    return Q < 0 ? void 0 : W[Q][1];
  }
  function Pm(D) {
    return fd(this.__data__, D) > -1;
  }
  function Om(D, W) {
    var Q = this.__data__, Ve = fd(Q, D);
    return Ve < 0 ? (++this.size, Q.push([D, W])) : Q[Ve][1] = W, this;
  }
  nr.prototype.clear = Am, nr.prototype.delete = Im, nr.prototype.get = Em, nr.prototype.has = Pm, nr.prototype.set = Om;
  function Ds(D) {
    var W = -1, Q = D == null ? 0 : D.length;
    for (this.clear(); ++W < Q; ) {
      var Ve = D[W];
      this.set(Ve[0], Ve[1]);
    }
  }
  function pt() {
    this.size = 0, this.__data__ = {
      hash: new Pt(),
      map: new (Ge || nr)(),
      string: new Pt()
    };
  }
  function ns(D) {
    var W = md(this, D).delete(D);
    return this.size -= W ? 1 : 0, W;
  }
  function JI(D) {
    return md(this, D).get(D);
  }
  function QI(D) {
    return md(this, D).has(D);
  }
  function eE(D, W) {
    var Q = md(this, D), Ve = Q.size;
    return Q.set(D, W), this.size += Q.size == Ve ? 0 : 1, this;
  }
  Ds.prototype.clear = pt, Ds.prototype.delete = ns, Ds.prototype.get = JI, Ds.prototype.has = QI, Ds.prototype.set = eE;
  function No(D) {
    var W = this.__data__ = new nr(D);
    this.size = W.size;
  }
  function tE() {
    this.__data__ = new nr(), this.size = 0;
  }
  function nE(D) {
    var W = this.__data__, Q = W.delete(D);
    return this.size = W.size, Q;
  }
  function iE(D) {
    return this.__data__.get(D);
  }
  function rE(D) {
    return this.__data__.has(D);
  }
  function sE(D, W) {
    var Q = this.__data__;
    if (Q instanceof nr) {
      var Ve = Q.__data__;
      if (!Ge || Ve.length < n - 1)
        return Ve.push([D, W]), this.size = ++Q.size, this;
      Q = this.__data__ = new Ds(Ve);
    }
    return Q.set(D, W), this.size = Q.size, this;
  }
  No.prototype.clear = tE, No.prototype.delete = nE, No.prototype.get = iE, No.prototype.has = rE, No.prototype.set = sE;
  function aE(D, W) {
    var Q = Fm(D), Ve = !Q && Rm(D), rt = !Q && !Ve && Vb(D), kt = !Q && !Ve && !rt && Nb(D), Ft = Q || Ve || rt || kt, it = Ft ? Pe(D.length, String) : [], Bt = it.length;
    for (var Mi in D)
      (W || vt.call(D, Mi)) && !(Ft && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Mi == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      rt && (Mi == "offset" || Mi == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      kt && (Mi == "buffer" || Mi == "byteLength" || Mi == "byteOffset") || // Skip index properties.
      Pb(Mi, Bt))) && it.push(Mi);
    return it;
  }
  function Vm(D, W, Q) {
    (Q !== void 0 && !vd(D[W], Q) || Q === void 0 && !(W in D)) && Dm(D, W, Q);
  }
  function oE(D, W, Q) {
    var Ve = D[W];
    (!(vt.call(D, W) && vd(Ve, Q)) || Q === void 0 && !(W in D)) && Dm(D, W, Q);
  }
  function fd(D, W) {
    for (var Q = D.length; Q--; )
      if (vd(D[Q][0], W))
        return Q;
    return -1;
  }
  function Dm(D, W, Q) {
    W == "__proto__" && Se ? Se(D, W, {
      configurable: !0,
      enumerable: !0,
      value: Q,
      writable: !0
    }) : D[W] = Q;
  }
  var lE = _E();
  function hd(D) {
    return D == null ? D === void 0 ? C : y : ce && ce in Object(D) ? SE(D) : IE(D);
  }
  function Ib(D) {
    return lu(D) && hd(D) == o;
  }
  function uE(D) {
    if (!ga(D) || xE(D))
      return !1;
    var W = Lm(D) ? ma : L;
    return W.test(VE(D));
  }
  function cE(D) {
    return lu(D) && Db(D.length) && !!oe[hd(D)];
  }
  function dE(D) {
    if (!ga(D))
      return AE(D);
    var W = Ob(D), Q = [];
    for (var Ve in D)
      Ve == "constructor" && (W || !vt.call(D, Ve)) || Q.push(Ve);
    return Q;
  }
  function Eb(D, W, Q, Ve, rt) {
    D !== W && lE(W, function(kt, Ft) {
      if (rt || (rt = new No()), ga(kt))
        fE(D, W, Ft, Q, Eb, Ve, rt);
      else {
        var it = Ve ? Ve(Mm(D, Ft), kt, Ft + "", D, W, rt) : void 0;
        it === void 0 && (it = kt), Vm(D, Ft, it);
      }
    }, Mb);
  }
  function fE(D, W, Q, Ve, rt, kt, Ft) {
    var it = Mm(D, Q), Bt = Mm(W, Q), Mi = Ft.get(Bt);
    if (Mi) {
      Vm(D, Q, Mi);
      return;
    }
    var _i = kt ? kt(it, Bt, Q + "", D, W, Ft) : void 0, uu = _i === void 0;
    if (uu) {
      var $m = Fm(Bt), Wm = !$m && Vb(Bt), Fb = !$m && !Wm && Nb(Bt);
      _i = Bt, $m || Wm || Fb ? Fm(it) ? _i = it : DE(it) ? _i = yE(it) : Wm ? (uu = !1, _i = vE(Bt, !0)) : Fb ? (uu = !1, _i = pE(Bt, !0)) : _i = [] : NE(Bt) || Rm(Bt) ? (_i = it, Rm(it) ? _i = ME(it) : (!ga(it) || Lm(it)) && (_i = kE(Bt))) : uu = !1;
    }
    uu && (Ft.set(Bt, _i), rt(_i, Bt, Ve, kt, Ft), Ft.delete(Bt)), Vm(D, Q, _i);
  }
  function hE(D, W) {
    return PE(EE(D, W, Rb), D + "");
  }
  var mE = Se ? function(D, W) {
    return Se(D, "toString", {
      configurable: !0,
      enumerable: !1,
      value: FE(W),
      writable: !0
    });
  } : Rb;
  function vE(D, W) {
    if (W)
      return D.slice();
    var Q = D.length, Ve = de ? de(Q) : new D.constructor(Q);
    return D.copy(Ve), Ve;
  }
  function gE(D) {
    var W = new D.constructor(D.byteLength);
    return new z(W).set(new z(D)), W;
  }
  function pE(D, W) {
    var Q = W ? gE(D.buffer) : D.buffer;
    return new D.constructor(Q, D.byteOffset, D.length);
  }
  function yE(D, W) {
    var Q = -1, Ve = D.length;
    for (W || (W = Array(Ve)); ++Q < Ve; )
      W[Q] = D[Q];
    return W;
  }
  function bE(D, W, Q, Ve) {
    var rt = !Q;
    Q || (Q = {});
    for (var kt = -1, Ft = W.length; ++kt < Ft; ) {
      var it = W[kt], Bt = Ve ? Ve(Q[it], D[it], it, Q, D) : void 0;
      Bt === void 0 && (Bt = D[it]), rt ? Dm(Q, it, Bt) : oE(Q, it, Bt);
    }
    return Q;
  }
  function wE(D) {
    return hE(function(W, Q) {
      var Ve = -1, rt = Q.length, kt = rt > 1 ? Q[rt - 1] : void 0, Ft = rt > 2 ? Q[2] : void 0;
      for (kt = D.length > 3 && typeof kt == "function" ? (rt--, kt) : void 0, Ft && CE(Q[0], Q[1], Ft) && (kt = rt < 3 ? void 0 : kt, rt = 1), W = Object(W); ++Ve < rt; ) {
        var it = Q[Ve];
        it && D(W, it, Ve, kt);
      }
      return W;
    });
  }
  function _E(D) {
    return function(W, Q, Ve) {
      for (var rt = -1, kt = Object(W), Ft = Ve(W), it = Ft.length; it--; ) {
        var Bt = Ft[D ? it : ++rt];
        if (Q(kt[Bt], Bt, kt) === !1)
          break;
      }
      return W;
    };
  }
  function md(D, W) {
    var Q = D.__data__;
    return TE(W) ? Q[typeof W == "string" ? "string" : "hash"] : Q.map;
  }
  function Nm(D, W) {
    var Q = me(D, W);
    return uE(Q) ? Q : void 0;
  }
  function SE(D) {
    var W = vt.call(D, ce), Q = D[ce];
    try {
      D[ce] = void 0;
      var Ve = !0;
    } catch {
    }
    var rt = Dn.call(D);
    return Ve && (W ? D[ce] = Q : delete D[ce]), rt;
  }
  function kE(D) {
    return typeof D.constructor == "function" && !Ob(D) ? Et(O(D)) : {};
  }
  function Pb(D, W) {
    var Q = typeof D;
    return W = W ?? a, !!W && (Q == "number" || Q != "symbol" && ne.test(D)) && D > -1 && D % 1 == 0 && D < W;
  }
  function CE(D, W, Q) {
    if (!ga(Q))
      return !1;
    var Ve = typeof W;
    return (Ve == "number" ? Bm(Q) && Pb(W, Q.length) : Ve == "string" && W in Q) ? vd(Q[W], D) : !1;
  }
  function TE(D) {
    var W = typeof D;
    return W == "string" || W == "number" || W == "symbol" || W == "boolean" ? D !== "__proto__" : D === null;
  }
  function xE(D) {
    return !!Vn && Vn in D;
  }
  function Ob(D) {
    var W = D && D.constructor, Q = typeof W == "function" && W.prototype || ze;
    return D === Q;
  }
  function AE(D) {
    var W = [];
    if (D != null)
      for (var Q in Object(D))
        W.push(Q);
    return W;
  }
  function IE(D) {
    return Dn.call(D);
  }
  function EE(D, W, Q) {
    return W = Ne(W === void 0 ? D.length - 1 : W, 0), function() {
      for (var Ve = arguments, rt = -1, kt = Ne(Ve.length - W, 0), Ft = Array(kt); ++rt < kt; )
        Ft[rt] = Ve[W + rt];
      rt = -1;
      for (var it = Array(W + 1); ++rt < W; )
        it[rt] = Ve[rt];
      return it[W] = Q(Ft), be(D, this, it);
    };
  }
  function Mm(D, W) {
    if (!(W === "constructor" && typeof D[W] == "function") && W != "__proto__")
      return D[W];
  }
  var PE = OE(mE);
  function OE(D) {
    var W = 0, Q = 0;
    return function() {
      var Ve = Le(), rt = s - (Ve - Q);
      if (Q = Ve, rt > 0) {
        if (++W >= r)
          return arguments[0];
      } else
        W = 0;
      return D.apply(void 0, arguments);
    };
  }
  function VE(D) {
    if (D != null) {
      try {
        return ut.call(D);
      } catch {
      }
      try {
        return D + "";
      } catch {
      }
    }
    return "";
  }
  function vd(D, W) {
    return D === W || D !== D && W !== W;
  }
  var Rm = Ib(function() {
    return arguments;
  }()) ? Ib : function(D) {
    return lu(D) && vt.call(D, "callee") && !U.call(D, "callee");
  }, Fm = Array.isArray;
  function Bm(D) {
    return D != null && Db(D.length) && !Lm(D);
  }
  function DE(D) {
    return lu(D) && Bm(D);
  }
  var Vb = Ie || BE;
  function Lm(D) {
    if (!ga(D))
      return !1;
    var W = hd(D);
    return W == h || W == m || W == u || W == T;
  }
  function Db(D) {
    return typeof D == "number" && D > -1 && D % 1 == 0 && D <= a;
  }
  function ga(D) {
    var W = typeof D;
    return D != null && (W == "object" || W == "function");
  }
  function lu(D) {
    return D != null && typeof D == "object";
  }
  function NE(D) {
    if (!lu(D) || hd(D) != k)
      return !1;
    var W = O(D);
    if (W === null)
      return !0;
    var Q = vt.call(W, "constructor") && W.constructor;
    return typeof Q == "function" && Q instanceof Q && ut.call(Q) == Dr;
  }
  var Nb = le ? te(le) : cE;
  function ME(D) {
    return bE(D, Mb(D));
  }
  function Mb(D) {
    return Bm(D) ? aE(D, !0) : dE(D);
  }
  var RE = wE(function(D, W, Q) {
    Eb(D, W, Q);
  });
  function FE(D) {
    return function() {
      return D;
    };
  }
  function Rb(D) {
    return D;
  }
  function BE() {
    return !1;
  }
  e.exports = RE;
})(Cf, Cf.exports);
var hR = Cf.exports;
const Mh = /* @__PURE__ */ jp(hR);
function So(e, t) {
  var n, i;
  if (typeof t == "function")
    i = t(e), i !== void 0 && (e = i);
  else if (Array.isArray(t))
    for (n = 0; n < t.length; n++)
      i = t[n](e), i !== void 0 && (e = i);
  return e;
}
function mR(e, t) {
  return e[0] === "-" && Array.isArray(t) && /^-\d+$/.test(e) ? t.length + parseInt(e, 10) : e;
}
function vR(e) {
  return /^\d+$/.test(e);
}
function qd(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function bu(e) {
  return Object(e) === e;
}
function Gd(e) {
  return Object.keys(e).length === 0;
}
var gR = ["__proto__", "prototype", "constructor"], pR = function(e) {
  return gR.indexOf(e) === -1;
};
function Rh(e, t) {
  e.indexOf("[") >= 0 && (e = e.replace(/\[/g, t).replace(/]/g, ""));
  var n = e.split(t), i = n.filter(pR);
  if (i.length !== n.length)
    throw Error("Refusing to update blacklisted property " + e);
  return n;
}
var y0 = Object.prototype.hasOwnProperty;
function ot(e, t, n, i) {
  if (!(this instanceof ot))
    return new ot(e, t, n, i);
  typeof t > "u" && (t = !1), typeof n > "u" && (n = !0), typeof i > "u" && (i = !0), this.separator = e || ".", this.override = t, this.useArray = n, this.useBrackets = i, this.keepArray = !1, this.cleanup = [];
}
var _l = new ot(".", !1, !0, !0);
function Ir(e) {
  return function() {
    return _l[e].apply(_l, arguments);
  };
}
ot.prototype._fill = function(e, t, n, i) {
  var r = e.shift();
  if (e.length > 0) {
    if (t[r] = t[r] || (this.useArray && vR(e[0]) ? [] : {}), !bu(t[r]))
      if (this.override)
        t[r] = {};
      else {
        if (!(bu(n) && Gd(n)))
          throw new Error(
            "Trying to redefine `" + r + "` which is a " + typeof t[r]
          );
        return;
      }
    this._fill(e, t[r], n, i);
  } else {
    if (!this.override && bu(t[r]) && !Gd(t[r])) {
      if (!(bu(n) && Gd(n)))
        throw new Error("Trying to redefine non-empty obj['" + r + "']");
      return;
    }
    t[r] = So(n, i);
  }
};
ot.prototype.object = function(e, t) {
  var n = this;
  return Object.keys(e).forEach(function(i) {
    var r = t === void 0 ? null : t[i], s = Rh(i, n.separator).join(n.separator);
    s.indexOf(n.separator) !== -1 ? (n._fill(s.split(n.separator), e, e[i], r), delete e[i]) : e[i] = So(e[i], r);
  }), e;
};
ot.prototype.str = function(e, t, n, i) {
  var r = Rh(e, this.separator).join(this.separator);
  return e.indexOf(this.separator) !== -1 ? this._fill(r.split(this.separator), n, t, i) : n[e] = So(t, i), n;
};
ot.prototype.pick = function(e, t, n, i) {
  var r, s, a, o, l;
  for (s = Rh(e, this.separator), r = 0; r < s.length; r++)
    if (o = mR(s[r], t), t && typeof t == "object" && o in t) {
      if (r === s.length - 1)
        return n ? (a = t[o], i && Array.isArray(t) ? t.splice(o, 1) : delete t[o], Array.isArray(t) && (l = s.slice(0, -1).join("."), this.cleanup.indexOf(l) === -1 && this.cleanup.push(l)), a) : t[o];
      t = t[o];
    } else
      return;
  return n && Array.isArray(t) && (t = t.filter(function(u) {
    return u !== void 0;
  })), t;
};
ot.prototype.delete = function(e, t) {
  return this.remove(e, t, !0);
};
ot.prototype.remove = function(e, t, n) {
  var i;
  if (this.cleanup = [], Array.isArray(e)) {
    for (i = 0; i < e.length; i++)
      this.pick(e[i], t, !0, n);
    return n || this._cleanup(t), t;
  } else
    return this.pick(e, t, !0, n);
};
ot.prototype._cleanup = function(e) {
  var t, n, i, r;
  if (this.cleanup.length) {
    for (n = 0; n < this.cleanup.length; n++)
      i = this.cleanup[n].split("."), r = i.splice(0, -1).join("."), t = r ? this.pick(r, e) : e, t = t[i[0]].filter(function(s) {
        return s !== void 0;
      }), this.set(this.cleanup[n], t, e);
    this.cleanup = [];
  }
};
ot.prototype.del = ot.prototype.remove;
ot.prototype.move = function(e, t, n, i, r) {
  return typeof i == "function" || Array.isArray(i) ? this.set(t, So(this.pick(e, n, !0), i), n, r) : (r = i, this.set(t, this.pick(e, n, !0), n, r)), n;
};
ot.prototype.transfer = function(e, t, n, i, r, s) {
  return typeof r == "function" || Array.isArray(r) ? this.set(
    t,
    So(this.pick(e, n, !0), r),
    i,
    s
  ) : (s = r, this.set(t, this.pick(e, n, !0), i, s)), i;
};
ot.prototype.copy = function(e, t, n, i, r, s) {
  return typeof r == "function" || Array.isArray(r) ? this.set(
    t,
    So(
      // clone what is picked
      JSON.parse(JSON.stringify(this.pick(e, n, !1))),
      r
    ),
    i,
    s
  ) : (s = r, this.set(t, this.pick(e, n, !1), i, s)), i;
};
ot.prototype.set = function(e, t, n, i) {
  var r, s, a, o;
  if (typeof t > "u")
    return n;
  for (a = Rh(e, this.separator), r = 0; r < a.length; r++) {
    if (o = a[r], r === a.length - 1)
      if (i && qd(t) && qd(n[o]))
        for (s in t)
          y0.call(t, s) && (n[o][s] = t[s]);
      else if (i && Array.isArray(n[o]) && Array.isArray(t))
        for (var l = 0; l < t.length; l++)
          n[a[r]].push(t[l]);
      else
        n[o] = t;
    else
      // force the value to be an object
      (!y0.call(n, o) || !qd(n[o]) && !Array.isArray(n[o])) && (/^\d+$/.test(a[r + 1]) ? n[o] = [] : n[o] = {});
    n = n[o];
  }
  return n;
};
ot.prototype.transform = function(e, t, n) {
  return t = t || {}, n = n || {}, Object.keys(e).forEach(
    (function(i) {
      this.set(e[i], this.pick(i, t), n);
    }).bind(this)
  ), n;
};
ot.prototype.dot = function(e, t, n) {
  t = t || {}, n = n || [];
  var i = Array.isArray(e);
  return Object.keys(e).forEach(
    (function(r) {
      var s = i && this.useBrackets ? "[" + r + "]" : r;
      if (bu(e[r]) && (qd(e[r]) && !Gd(e[r]) || Array.isArray(e[r]) && !this.keepArray && e[r].length !== 0))
        if (i && this.useBrackets) {
          var a = n[n.length - 1] || "";
          return this.dot(
            e[r],
            t,
            n.slice(0, -1).concat(a + s)
          );
        } else
          return this.dot(e[r], t, n.concat(s));
      else
        i && this.useBrackets ? t[n.join(this.separator).concat("[" + r + "]")] = e[r] : t[n.concat(s).join(this.separator)] = e[r];
    }).bind(this)
  ), t;
};
ot.pick = Ir("pick");
ot.move = Ir("move");
ot.transfer = Ir("transfer");
ot.transform = Ir("transform");
ot.copy = Ir("copy");
ot.object = Ir("object");
ot.str = Ir("str");
ot.set = Ir("set");
ot.delete = Ir("delete");
ot.del = ot.remove = Ir("remove");
ot.dot = Ir("dot");
["override", "overwrite"].forEach(function(e) {
  Object.defineProperty(ot, e, {
    get: function() {
      return _l.override;
    },
    set: function(t) {
      _l.override = !!t;
    }
  });
});
["useArray", "keepArray", "useBrackets"].forEach(function(e) {
  Object.defineProperty(ot, e, {
    get: function() {
      return _l[e];
    },
    set: function(t) {
      _l[e] = t;
    }
  });
});
ot._process = So;
var yR = ot;
const sv = /* @__PURE__ */ jp(yR);
var Hp = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, Ae = (e, t, n) => (Hp(e, t, "read from private field"), n ? n.call(e) : t.get(e)), sr = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, Si = (e, t, n, i) => (Hp(e, t, "write to private field"), i ? i.call(e, n) : t.set(e, n), n), Mr = (e, t, n) => (Hp(e, t, "access private method"), n), Qn, Jn, Zt, Rn, zo, Yd, Rr, ar, wu, _u, Zd, rs, $s;
const ci = Is("LocalStorage");
class Fh {
  /**
   * Create a new LocalStorage instance.
   * @param namespace The namespace to use for the local storage.
   */
  constructor(t) {
    sr(this, _u), sr(this, rs), sr(this, Qn, void 0), sr(this, Jn, void 0), sr(this, Zt, void 0), sr(this, Rn, void 0), sr(this, zo, void 0), sr(this, Yd, !1), sr(this, Rr, void 0), sr(this, ar, void 0), sr(this, wu, void 0), Si(this, Qn, t), Si(this, ar, !(typeof window < "u")), Si(this, Jn, new Wd()), Si(this, Rn, X({})), typeof window < "u" ? (Si(this, wu, new BroadcastChannel(`ls:${t}`)), Ae(this, wu).onmessage = () => {
      ci("Updating due to change in another tab."), this.refresh();
    }, this.on("change", () => {
      var n;
      ci("Notifying other tabs about change."), (n = Ae(this, wu)) == null || n.postMessage("change");
    }), Si(this, zo, new Promise((n) => {
      import("./secure-ls-d53af366.mjs").then(function(i) {
        return i.s;
      }).then(({ default: i }) => {
        Si(this, Zt, new i({
          encodingType: "aes",
          isCompression: !0,
          encryptionSecret: t
        })), Mr(this, _u, Zd).call(this), Ae(this, Jn).on("tab:active", Mr(this, _u, Zd).bind(this), { local: !0 }), Si(this, Rr, fe(
          () => Ae(this, Rn).value,
          () => {
            Ae(this, Jn).emit("change"), Mr(this, rs, $s).call(this);
          },
          {
            deep: !0
          }
        )), ci(`Loaded Encrypted Local Storage Values for ${t}.`), Si(this, Yd, !0), Ae(this, Jn).emit("loaded"), n();
      });
    }))) : Si(this, zo, Promise.resolve()), Ae(this, zo).then(() => {
      ci(`Loaded Encrypted Local Storage for ${t}.`);
    }), this.on("loaded", () => {
      if (window) {
        window._vueprint_loaded || (window._vueprint_loaded = {}), window._vueprint_loaded.localstorage = !0;
        const n = new CustomEvent("localstorage:loaded", { detail: {} });
        window.dispatchEvent(n);
      }
    }), Si(this, Rr, () => {
    });
  }
  /**
   * Whether or not the local storage has been loaded.
   */
  get loaded() {
    return Ae(this, Yd);
  }
  /**
   * A promise which resolves when the local storage has been loaded.
   */
  get promise() {
    return Ae(this, zo);
  }
  /**
   * The current content of the local storage.
   */
  get value() {
    return Ae(this, Rn).value;
  }
  /**
   * Refresh the information in the service from the browser's local storage.
   */
  refresh() {
    Ae(this, Rr) && Ae(this, Rr).call(this), Mr(this, _u, Zd).call(this), Si(this, Rr, fe(
      () => Ae(this, Rn).value,
      () => {
        Ae(this, Jn).emit("change"), Mr(this, rs, $s).call(this);
      },
      {
        deep: !0
      }
    ));
  }
  /**
   * Get the encryption secret used by the local storage.
   */
  getEncryptionSecret() {
    var t;
    return !Ae(this, Zt) && !Ae(this, ar) && ci(
      `Trying to fetch encryption secret from localStorage ${Ae(this, Qn)} before it is loaded.`
    ), ((t = Ae(this, Zt)) == null ? void 0 : t.getEncryptionSecret()) || "";
  }
  /**
   * Get the value of a key in the local storage.
   * @param key The key to fetch from the local storage.
   * @returns The value of the key in the local storage, if it exists
   */
  get(t) {
    return !Ae(this, Zt) && !Ae(this, ar) && ci(`Trying to fetch ${t} from localStorage ${Ae(this, Qn)} before it is loaded.`), sv.pick(t, Ae(this, Rn).value);
  }
  /**
   * Get the value of a key in the local storage.
   * @param key The key to fetch from the local storage.
   * @returns The value of the key in the local storage, if it exists
   */
  getDataFromLocalStorage(t) {
    var n;
    return !Ae(this, Zt) && !Ae(this, ar) && ci(`Trying to fetch ${t} from localStorage ${Ae(this, Qn)} before it is loaded.`), ((n = Ae(this, Zt)) == null ? void 0 : n.getDataFromLocalStorage(t)) || null;
  }
  /**
   * Get all of the keys in the local storage.
   * @returns An array of all of the keys in the local storage.
   */
  getAllKeys() {
    return !Ae(this, Zt) && !Ae(this, ar) && ci(`Trying to fetch keys from localStorage ${Ae(this, Qn)} before it is loaded.`), Object.keys(Ae(this, Rn).value);
  }
  /**
   * Set the value of a key in the local storage.
   * @param key The key to set in the local storage.
   * @param data The value to set for the key in the local storage.
   */
  set(t, n) {
    !Ae(this, Zt) && !Ae(this, ar) && ci(`Trying to set ${t} in localStorage ${Ae(this, Qn)} before it is loaded.`), Ae(this, Rr) && Ae(this, Rr).call(this), sv.set(t, n, Ae(this, Rn).value), Mr(this, rs, $s).call(this), Si(this, Rr, fe(
      () => Ae(this, Rn).value,
      () => {
        Ae(this, Jn).emit("change"), Mr(this, rs, $s).call(this);
      },
      {
        deep: !0
      }
    )), Ae(this, Jn).emit("change");
  }
  /**
   * Merge data into the local storage.
   * @param data The data to merge into the local storage.
   */
  merge(t) {
    const n = { ...Ae(this, Rn).value }, i = { ...t }, r = Mh({}, n, i);
    Ae(this, Rn).value = r, Mr(this, rs, $s).call(this);
  }
  /**
   * Set the value of a key in the local storage.
   * @param key The key to set in the local storage.
   * @param data The value to set for the key in the local storage.
   */
  setDataToLocalStorage(t, n) {
    var i;
    return Ae(this, Zt) && Ae(this, Jn).emit("setDataToLocalStorage", t, n), (i = Ae(this, Zt)) == null ? void 0 : i.setDataToLocalStorage(t, n);
  }
  /**
   * Remove a key from the local storage.
   * @param key The key to remove from the local storage.
   */
  remove(t) {
    !Ae(this, Zt) && !Ae(this, ar) && ci(`Trying to remove ${t} from localStorage ${Ae(this, Qn)} before it is loaded.`), sv.delete(t, Ae(this, Rn).value), Mr(this, rs, $s).call(this);
  }
  /**
   * Remove all keys from the local storage.
   */
  removeAll() {
    !Ae(this, Zt) && !Ae(this, ar) && ci(`Trying to remove all keys from localStorage ${Ae(this, Qn)} before it is loaded.`), Ae(this, Rn).value = {}, Mr(this, rs, $s).call(this);
  }
  /**
   * Clear the local storage.
   */
  clear() {
    var t;
    return this.removeAll(), Ae(this, Zt) ? Ae(this, Jn).emit("clear") : ci(`Trying to clear localStorage ${Ae(this, Qn)} before it is loaded.`), (t = Ae(this, Zt)) == null ? void 0 : t.clear();
  }
  /**
   * Reset all keys in the local storage.
   */
  resetAllKeys() {
    var t;
    return Ae(this, Zt) && Ae(this, Jn).emit("resetAllKeys"), ((t = Ae(this, Zt)) == null ? void 0 : t.resetAllKeys()) || [];
  }
  /**
   * Add a listener for an event on the local bus.
   * @param event The event name.
   * @param callback The callback function.
   */
  on(t, n) {
    Ae(this, Jn).on(t, n);
  }
  /**
   * Remove a listener for an event on the local bus.
   * @param event The event name.
   * @param callback The callback function.
   */
  off(t, n) {
    Ae(this, Jn).off(t, n);
  }
  /**
   * Add a listener for an event on the local bus one time
   * @param event The event name.
   * @param callback The callback function.
   */
  once(t, n) {
    Ae(this, Jn).once(t, n);
  }
}
Qn = /* @__PURE__ */ new WeakMap();
Jn = /* @__PURE__ */ new WeakMap();
Zt = /* @__PURE__ */ new WeakMap();
Rn = /* @__PURE__ */ new WeakMap();
zo = /* @__PURE__ */ new WeakMap();
Yd = /* @__PURE__ */ new WeakMap();
Rr = /* @__PURE__ */ new WeakMap();
ar = /* @__PURE__ */ new WeakMap();
wu = /* @__PURE__ */ new WeakMap();
_u = /* @__PURE__ */ new WeakSet();
Zd = function() {
  if (Ae(this, Zt)) {
    let e;
    try {
      e = JSON.parse(Ae(this, Zt).get(Ae(this, Qn)) || "{}");
    } catch (n) {
      ci(`Error parsing localStorage ${Ae(this, Qn)}.`, n), e = {};
    }
    const t = Mh({}, Ae(this, Rn).value, e);
    Ae(this, Rn).value = t;
  } else
    Ae(this, ar) || ci(`Trying to refresh localStorage ${Ae(this, Qn)} before it is loaded.`);
};
rs = /* @__PURE__ */ new WeakSet();
$s = function() {
  Ae(this, Zt) && Ae(this, Zt).set(Ae(this, Qn), JSON.stringify({ ...Ae(this, Rn).value }));
};
const bR = {
  install: (e, t) => {
    const n = new Fh((t == null ? void 0 : t.namespace) || "app");
    e.provide("ls", n), e.config.globalProperties.$ls = n;
  }
}, wR = (e, t, n) => {
  const i = new Set(Object.values(t).flatMap((a) => Object.keys(a.colors))), r = Mh({}, n, {
    theme: {
      defaultTheme: e,
      variations: {
        colors: Array.from(i),
        lighten: 5,
        darken: 5
      },
      themes: t
    }
  });
  return XS(r);
}, _R = {
  install: (e, t) => {
    const n = (t == null ? void 0 : t.defaultTheme) || "main", i = (t == null ? void 0 : t.themes) || {
      main: {
        dark: !1,
        colors: {
          background: "#e3e3e3",
          surface: "#eef0f0",
          primary: "#34495E",
          secondary: "#41B883",
          accent: "#676464",
          highlight: "#34495E",
          notify: "#E53935",
          success: "#06972E",
          info: "#3F51B5",
          warning: "#FFA000",
          error: "#E43333",
          question: "#554C7D",
          cancel: "#666666"
        }
      }
    }, r = (t == null ? void 0 : t.options) || {}, s = wR(n, i, r);
    e.use(s);
  }
};
function VC(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: SR } = Object.prototype, { getPrototypeOf: zp } = Object, Bh = ((e) => (t) => {
  const n = SR.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Er = (e) => (e = e.toLowerCase(), (t) => Bh(t) === e), Lh = (e) => (t) => typeof t === e, { isArray: Gl } = Array, ec = Lh("undefined");
function kR(e) {
  return e !== null && !ec(e) && e.constructor !== null && !ec(e.constructor) && Yi(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const DC = Er("ArrayBuffer");
function CR(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && DC(e.buffer), t;
}
const TR = Lh("string"), Yi = Lh("function"), NC = Lh("number"), $h = (e) => e !== null && typeof e == "object", xR = (e) => e === !0 || e === !1, Kd = (e) => {
  if (Bh(e) !== "object")
    return !1;
  const t = zp(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, AR = Er("Date"), IR = Er("File"), ER = Er("Blob"), PR = Er("FileList"), OR = (e) => $h(e) && Yi(e.pipe), VR = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Yi(e.append) && ((t = Bh(e)) === "formdata" || // detect form-data instance
  t === "object" && Yi(e.toString) && e.toString() === "[object FormData]"));
}, DR = Er("URLSearchParams"), [NR, MR, RR, FR] = ["ReadableStream", "Request", "Response", "Headers"].map(Er), BR = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function jc(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let i, r;
  if (typeof e != "object" && (e = [e]), Gl(e))
    for (i = 0, r = e.length; i < r; i++)
      t.call(null, e[i], i, e);
  else {
    const s = n ? Object.getOwnPropertyNames(e) : Object.keys(e), a = s.length;
    let o;
    for (i = 0; i < a; i++)
      o = s[i], t.call(null, e[o], o, e);
  }
}
function MC(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let i = n.length, r;
  for (; i-- > 0; )
    if (r = n[i], t === r.toLowerCase())
      return r;
  return null;
}
const RC = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), FC = (e) => !ec(e) && e !== RC;
function Jv() {
  const { caseless: e } = FC(this) && this || {}, t = {}, n = (i, r) => {
    const s = e && MC(t, r) || r;
    Kd(t[s]) && Kd(i) ? t[s] = Jv(t[s], i) : Kd(i) ? t[s] = Jv({}, i) : Gl(i) ? t[s] = i.slice() : t[s] = i;
  };
  for (let i = 0, r = arguments.length; i < r; i++)
    arguments[i] && jc(arguments[i], n);
  return t;
}
const LR = (e, t, n, { allOwnKeys: i } = {}) => (jc(t, (r, s) => {
  n && Yi(r) ? e[s] = VC(r, n) : e[s] = r;
}, { allOwnKeys: i }), e), $R = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), WR = (e, t, n, i) => {
  e.prototype = Object.create(t.prototype, i), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, jR = (e, t, n, i) => {
  let r, s, a;
  const o = {};
  if (t = t || {}, e == null)
    return t;
  do {
    for (r = Object.getOwnPropertyNames(e), s = r.length; s-- > 0; )
      a = r[s], (!i || i(a, e, t)) && !o[a] && (t[a] = e[a], o[a] = !0);
    e = n !== !1 && zp(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, HR = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const i = e.indexOf(t, n);
  return i !== -1 && i === n;
}, zR = (e) => {
  if (!e)
    return null;
  if (Gl(e))
    return e;
  let t = e.length;
  if (!NC(t))
    return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, UR = ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && zp(Uint8Array)), qR = (e, t) => {
  const i = (e && e[Symbol.iterator]).call(e);
  let r;
  for (; (r = i.next()) && !r.done; ) {
    const s = r.value;
    t.call(e, s[0], s[1]);
  }
}, GR = (e, t) => {
  let n;
  const i = [];
  for (; (n = e.exec(t)) !== null; )
    i.push(n);
  return i;
}, YR = Er("HTMLFormElement"), ZR = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, i, r) {
    return i.toUpperCase() + r;
  }
), b0 = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), KR = Er("RegExp"), BC = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), i = {};
  jc(n, (r, s) => {
    let a;
    (a = t(r, s, e)) !== !1 && (i[s] = a || r);
  }), Object.defineProperties(e, i);
}, XR = (e) => {
  BC(e, (t, n) => {
    if (Yi(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const i = e[n];
    if (Yi(i)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, JR = (e, t) => {
  const n = {}, i = (r) => {
    r.forEach((s) => {
      n[s] = !0;
    });
  };
  return Gl(e) ? i(e) : i(String(e).split(t)), n;
}, QR = () => {
}, eF = (e, t) => e != null && Number.isFinite(e = +e) ? e : t, av = "abcdefghijklmnopqrstuvwxyz", w0 = "0123456789", LC = {
  DIGIT: w0,
  ALPHA: av,
  ALPHA_DIGIT: av + av.toUpperCase() + w0
}, tF = (e = 16, t = LC.ALPHA_DIGIT) => {
  let n = "";
  const { length: i } = t;
  for (; e--; )
    n += t[Math.random() * i | 0];
  return n;
};
function nF(e) {
  return !!(e && Yi(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const iF = (e) => {
  const t = new Array(10), n = (i, r) => {
    if ($h(i)) {
      if (t.indexOf(i) >= 0)
        return;
      if (!("toJSON" in i)) {
        t[r] = i;
        const s = Gl(i) ? [] : {};
        return jc(i, (a, o) => {
          const l = n(a, r + 1);
          !ec(l) && (s[o] = l);
        }), t[r] = void 0, s;
      }
    }
    return i;
  };
  return n(e, 0);
}, rF = Er("AsyncFunction"), sF = (e) => e && ($h(e) || Yi(e)) && Yi(e.then) && Yi(e.catch), ae = {
  isArray: Gl,
  isArrayBuffer: DC,
  isBuffer: kR,
  isFormData: VR,
  isArrayBufferView: CR,
  isString: TR,
  isNumber: NC,
  isBoolean: xR,
  isObject: $h,
  isPlainObject: Kd,
  isReadableStream: NR,
  isRequest: MR,
  isResponse: RR,
  isHeaders: FR,
  isUndefined: ec,
  isDate: AR,
  isFile: IR,
  isBlob: ER,
  isRegExp: KR,
  isFunction: Yi,
  isStream: OR,
  isURLSearchParams: DR,
  isTypedArray: UR,
  isFileList: PR,
  forEach: jc,
  merge: Jv,
  extend: LR,
  trim: BR,
  stripBOM: $R,
  inherits: WR,
  toFlatObject: jR,
  kindOf: Bh,
  kindOfTest: Er,
  endsWith: HR,
  toArray: zR,
  forEachEntry: qR,
  matchAll: GR,
  isHTMLForm: YR,
  hasOwnProperty: b0,
  hasOwnProp: b0,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: BC,
  freezeMethods: XR,
  toObjectSet: JR,
  toCamelCase: ZR,
  noop: QR,
  toFiniteNumber: eF,
  findKey: MC,
  global: RC,
  isContextDefined: FC,
  ALPHABET: LC,
  generateString: tF,
  isSpecCompliantForm: nF,
  toJSONObject: iF,
  isAsyncFn: rF,
  isThenable: sF
};
function Ye(e, t, n, i, r) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), i && (this.request = i), r && (this.response = r);
}
ae.inherits(Ye, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: ae.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const $C = Ye.prototype, WC = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  WC[e] = { value: e };
});
Object.defineProperties(Ye, WC);
Object.defineProperty($C, "isAxiosError", { value: !0 });
Ye.from = (e, t, n, i, r, s) => {
  const a = Object.create($C);
  return ae.toFlatObject(e, a, function(l) {
    return l !== Error.prototype;
  }, (o) => o !== "isAxiosError"), Ye.call(a, e.message, t, n, i, r), a.cause = e, a.name = e.name, s && Object.assign(a, s), a;
};
const aF = null;
function Qv(e) {
  return ae.isPlainObject(e) || ae.isArray(e);
}
function jC(e) {
  return ae.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function _0(e, t, n) {
  return e ? e.concat(t).map(function(r, s) {
    return r = jC(r), !n && s ? "[" + r + "]" : r;
  }).join(n ? "." : "") : t;
}
function oF(e) {
  return ae.isArray(e) && !e.some(Qv);
}
const lF = ae.toFlatObject(ae, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Wh(e, t, n) {
  if (!ae.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = ae.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(g, p) {
    return !ae.isUndefined(p[g]);
  });
  const i = n.metaTokens, r = n.visitor || c, s = n.dots, a = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && ae.isSpecCompliantForm(t);
  if (!ae.isFunction(r))
    throw new TypeError("visitor must be a function");
  function u(m) {
    if (m === null)
      return "";
    if (ae.isDate(m))
      return m.toISOString();
    if (!l && ae.isBlob(m))
      throw new Ye("Blob is not supported. Use a Buffer instead.");
    return ae.isArrayBuffer(m) || ae.isTypedArray(m) ? l && typeof Blob == "function" ? new Blob([m]) : Buffer.from(m) : m;
  }
  function c(m, g, p) {
    let y = m;
    if (m && !p && typeof m == "object") {
      if (ae.endsWith(g, "{}"))
        g = i ? g : g.slice(0, -2), m = JSON.stringify(m);
      else if (ae.isArray(m) && oF(m) || (ae.isFileList(m) || ae.endsWith(g, "[]")) && (y = ae.toArray(m)))
        return g = jC(g), y.forEach(function(T, _) {
          !(ae.isUndefined(T) || T === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            a === !0 ? _0([g], _, s) : a === null ? g : g + "[]",
            u(T)
          );
        }), !1;
    }
    return Qv(m) ? !0 : (t.append(_0(p, g, s), u(m)), !1);
  }
  const d = [], f = Object.assign(lF, {
    defaultVisitor: c,
    convertValue: u,
    isVisitable: Qv
  });
  function h(m, g) {
    if (!ae.isUndefined(m)) {
      if (d.indexOf(m) !== -1)
        throw Error("Circular reference detected in " + g.join("."));
      d.push(m), ae.forEach(m, function(y, k) {
        (!(ae.isUndefined(y) || y === null) && r.call(
          t,
          y,
          ae.isString(k) ? k.trim() : k,
          g,
          f
        )) === !0 && h(y, g ? g.concat(k) : [k]);
      }), d.pop();
    }
  }
  if (!ae.isObject(e))
    throw new TypeError("data must be an object");
  return h(e), t;
}
function S0(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(i) {
    return t[i];
  });
}
function Up(e, t) {
  this._pairs = [], e && Wh(e, this, t);
}
const HC = Up.prototype;
HC.append = function(t, n) {
  this._pairs.push([t, n]);
};
HC.toString = function(t) {
  const n = t ? function(i) {
    return t.call(this, i, S0);
  } : S0;
  return this._pairs.map(function(r) {
    return n(r[0]) + "=" + n(r[1]);
  }, "").join("&");
};
function uF(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function zC(e, t, n) {
  if (!t)
    return e;
  const i = n && n.encode || uF, r = n && n.serialize;
  let s;
  if (r ? s = r(t, n) : s = ae.isURLSearchParams(t) ? t.toString() : new Up(t, n).toString(i), s) {
    const a = e.indexOf("#");
    a !== -1 && (e = e.slice(0, a)), e += (e.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return e;
}
class cF {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, i) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: i ? i.synchronous : !1,
      runWhen: i ? i.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    ae.forEach(this.handlers, function(i) {
      i !== null && t(i);
    });
  }
}
const k0 = cF, UC = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, dF = typeof URLSearchParams < "u" ? URLSearchParams : Up, fF = typeof FormData < "u" ? FormData : null, hF = typeof Blob < "u" ? Blob : null, mF = {
  isBrowser: !0,
  classes: {
    URLSearchParams: dF,
    FormData: fF,
    Blob: hF
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, qp = typeof window < "u" && typeof document < "u", vF = ((e) => qp && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator < "u" && navigator.product), gF = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), pF = qp && window.location.href || "http://localhost", yF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: qp,
  hasStandardBrowserEnv: vF,
  hasStandardBrowserWebWorkerEnv: gF,
  origin: pF
}, Symbol.toStringTag, { value: "Module" })), yr = {
  ...yF,
  ...mF
};
function bF(e, t) {
  return Wh(e, new yr.classes.URLSearchParams(), Object.assign({
    visitor: function(n, i, r, s) {
      return yr.isNode && ae.isBuffer(n) ? (this.append(i, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function wF(e) {
  return ae.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function _F(e) {
  const t = {}, n = Object.keys(e);
  let i;
  const r = n.length;
  let s;
  for (i = 0; i < r; i++)
    s = n[i], t[s] = e[s];
  return t;
}
function qC(e) {
  function t(n, i, r, s) {
    let a = n[s++];
    if (a === "__proto__")
      return !0;
    const o = Number.isFinite(+a), l = s >= n.length;
    return a = !a && ae.isArray(r) ? r.length : a, l ? (ae.hasOwnProp(r, a) ? r[a] = [r[a], i] : r[a] = i, !o) : ((!r[a] || !ae.isObject(r[a])) && (r[a] = []), t(n, i, r[a], s) && ae.isArray(r[a]) && (r[a] = _F(r[a])), !o);
  }
  if (ae.isFormData(e) && ae.isFunction(e.entries)) {
    const n = {};
    return ae.forEachEntry(e, (i, r) => {
      t(wF(i), r, n, 0);
    }), n;
  }
  return null;
}
function SF(e, t, n) {
  if (ae.isString(e))
    try {
      return (t || JSON.parse)(e), ae.trim(e);
    } catch (i) {
      if (i.name !== "SyntaxError")
        throw i;
    }
  return (n || JSON.stringify)(e);
}
const Gp = {
  transitional: UC,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, n) {
    const i = n.getContentType() || "", r = i.indexOf("application/json") > -1, s = ae.isObject(t);
    if (s && ae.isHTMLForm(t) && (t = new FormData(t)), ae.isFormData(t))
      return r ? JSON.stringify(qC(t)) : t;
    if (ae.isArrayBuffer(t) || ae.isBuffer(t) || ae.isStream(t) || ae.isFile(t) || ae.isBlob(t) || ae.isReadableStream(t))
      return t;
    if (ae.isArrayBufferView(t))
      return t.buffer;
    if (ae.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let o;
    if (s) {
      if (i.indexOf("application/x-www-form-urlencoded") > -1)
        return bF(t, this.formSerializer).toString();
      if ((o = ae.isFileList(t)) || i.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return Wh(
          o ? { "files[]": t } : t,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return s || r ? (n.setContentType("application/json", !1), SF(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || Gp.transitional, i = n && n.forcedJSONParsing, r = this.responseType === "json";
    if (ae.isResponse(t) || ae.isReadableStream(t))
      return t;
    if (t && ae.isString(t) && (i && !this.responseType || r)) {
      const a = !(n && n.silentJSONParsing) && r;
      try {
        return JSON.parse(t);
      } catch (o) {
        if (a)
          throw o.name === "SyntaxError" ? Ye.from(o, Ye.ERR_BAD_RESPONSE, this, null, this.response) : o;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: yr.classes.FormData,
    Blob: yr.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
ae.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  Gp.headers[e] = {};
});
const Yp = Gp, kF = ae.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), CF = (e) => {
  const t = {};
  let n, i, r;
  return e && e.split(`
`).forEach(function(a) {
    r = a.indexOf(":"), n = a.substring(0, r).trim().toLowerCase(), i = a.substring(r + 1).trim(), !(!n || t[n] && kF[n]) && (n === "set-cookie" ? t[n] ? t[n].push(i) : t[n] = [i] : t[n] = t[n] ? t[n] + ", " + i : i);
  }), t;
}, C0 = Symbol("internals");
function fu(e) {
  return e && String(e).trim().toLowerCase();
}
function Xd(e) {
  return e === !1 || e == null ? e : ae.isArray(e) ? e.map(Xd) : String(e);
}
function TF(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let i;
  for (; i = n.exec(e); )
    t[i[1]] = i[2];
  return t;
}
const xF = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function ov(e, t, n, i, r) {
  if (ae.isFunction(i))
    return i.call(this, t, n);
  if (r && (t = n), !!ae.isString(t)) {
    if (ae.isString(i))
      return t.indexOf(i) !== -1;
    if (ae.isRegExp(i))
      return i.test(t);
  }
}
function AF(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, i) => n.toUpperCase() + i);
}
function IF(e, t) {
  const n = ae.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((i) => {
    Object.defineProperty(e, i + n, {
      value: function(r, s, a) {
        return this[i].call(this, t, r, s, a);
      },
      configurable: !0
    });
  });
}
class jh {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, i) {
    const r = this;
    function s(o, l, u) {
      const c = fu(l);
      if (!c)
        throw new Error("header name must be a non-empty string");
      const d = ae.findKey(r, c);
      (!d || r[d] === void 0 || u === !0 || u === void 0 && r[d] !== !1) && (r[d || l] = Xd(o));
    }
    const a = (o, l) => ae.forEach(o, (u, c) => s(u, c, l));
    if (ae.isPlainObject(t) || t instanceof this.constructor)
      a(t, n);
    else if (ae.isString(t) && (t = t.trim()) && !xF(t))
      a(CF(t), n);
    else if (ae.isHeaders(t))
      for (const [o, l] of t.entries())
        s(l, o, i);
    else
      t != null && s(n, t, i);
    return this;
  }
  get(t, n) {
    if (t = fu(t), t) {
      const i = ae.findKey(this, t);
      if (i) {
        const r = this[i];
        if (!n)
          return r;
        if (n === !0)
          return TF(r);
        if (ae.isFunction(n))
          return n.call(this, r, i);
        if (ae.isRegExp(n))
          return n.exec(r);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = fu(t), t) {
      const i = ae.findKey(this, t);
      return !!(i && this[i] !== void 0 && (!n || ov(this, this[i], i, n)));
    }
    return !1;
  }
  delete(t, n) {
    const i = this;
    let r = !1;
    function s(a) {
      if (a = fu(a), a) {
        const o = ae.findKey(i, a);
        o && (!n || ov(i, i[o], o, n)) && (delete i[o], r = !0);
      }
    }
    return ae.isArray(t) ? t.forEach(s) : s(t), r;
  }
  clear(t) {
    const n = Object.keys(this);
    let i = n.length, r = !1;
    for (; i--; ) {
      const s = n[i];
      (!t || ov(this, this[s], s, t, !0)) && (delete this[s], r = !0);
    }
    return r;
  }
  normalize(t) {
    const n = this, i = {};
    return ae.forEach(this, (r, s) => {
      const a = ae.findKey(i, s);
      if (a) {
        n[a] = Xd(r), delete n[s];
        return;
      }
      const o = t ? AF(s) : String(s).trim();
      o !== s && delete n[s], n[o] = Xd(r), i[o] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return ae.forEach(this, (i, r) => {
      i != null && i !== !1 && (n[r] = t && ae.isArray(i) ? i.join(", ") : i);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const i = new this(t);
    return n.forEach((r) => i.set(r)), i;
  }
  static accessor(t) {
    const i = (this[C0] = this[C0] = {
      accessors: {}
    }).accessors, r = this.prototype;
    function s(a) {
      const o = fu(a);
      i[o] || (IF(r, a), i[o] = !0);
    }
    return ae.isArray(t) ? t.forEach(s) : s(t), this;
  }
}
jh.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
ae.reduceDescriptors(jh.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(i) {
      this[n] = i;
    }
  };
});
ae.freezeMethods(jh);
const br = jh;
function lv(e, t) {
  const n = this || Yp, i = t || n, r = br.from(i.headers);
  let s = i.data;
  return ae.forEach(e, function(o) {
    s = o.call(n, s, r.normalize(), t ? t.status : void 0);
  }), r.normalize(), s;
}
function GC(e) {
  return !!(e && e.__CANCEL__);
}
function Yl(e, t, n) {
  Ye.call(this, e ?? "canceled", Ye.ERR_CANCELED, t, n), this.name = "CanceledError";
}
ae.inherits(Yl, Ye, {
  __CANCEL__: !0
});
function YC(e, t, n) {
  const i = n.config.validateStatus;
  !n.status || !i || i(n.status) ? e(n) : t(new Ye(
    "Request failed with status code " + n.status,
    [Ye.ERR_BAD_REQUEST, Ye.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function EF(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function PF(e, t) {
  e = e || 10;
  const n = new Array(e), i = new Array(e);
  let r = 0, s = 0, a;
  return t = t !== void 0 ? t : 1e3, function(l) {
    const u = Date.now(), c = i[s];
    a || (a = u), n[r] = l, i[r] = u;
    let d = s, f = 0;
    for (; d !== r; )
      f += n[d++], d = d % e;
    if (r = (r + 1) % e, r === s && (s = (s + 1) % e), u - a < t)
      return;
    const h = c && u - c;
    return h ? Math.round(f * 1e3 / h) : void 0;
  };
}
function OF(e, t) {
  let n = 0;
  const i = 1e3 / t;
  let r = null;
  return function() {
    const a = this === !0, o = Date.now();
    if (a || o - n > i)
      return r && (clearTimeout(r), r = null), n = o, e.apply(null, arguments);
    r || (r = setTimeout(() => (r = null, n = Date.now(), e.apply(null, arguments)), i - (o - n)));
  };
}
const Tf = (e, t, n = 3) => {
  let i = 0;
  const r = PF(50, 250);
  return OF((s) => {
    const a = s.loaded, o = s.lengthComputable ? s.total : void 0, l = a - i, u = r(l), c = a <= o;
    i = a;
    const d = {
      loaded: a,
      total: o,
      progress: o ? a / o : void 0,
      bytes: l,
      rate: u || void 0,
      estimated: u && o && c ? (o - a) / u : void 0,
      event: s,
      lengthComputable: o != null
    };
    d[t ? "download" : "upload"] = !0, e(d);
  }, n);
}, VF = yr.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a");
    let i;
    function r(s) {
      let a = s;
      return t && (n.setAttribute("href", a), a = n.href), n.setAttribute("href", a), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return i = r(window.location.href), function(a) {
      const o = ae.isString(a) ? r(a) : a;
      return o.protocol === i.protocol && o.host === i.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function() {
    return function() {
      return !0;
    };
  }()
), DF = yr.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, i, r, s) {
      const a = [e + "=" + encodeURIComponent(t)];
      ae.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()), ae.isString(i) && a.push("path=" + i), ae.isString(r) && a.push("domain=" + r), s === !0 && a.push("secure"), document.cookie = a.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function NF(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function MF(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function ZC(e, t) {
  return e && !NF(t) ? MF(e, t) : t;
}
const T0 = (e) => e instanceof br ? { ...e } : e;
function Za(e, t) {
  t = t || {};
  const n = {};
  function i(u, c, d) {
    return ae.isPlainObject(u) && ae.isPlainObject(c) ? ae.merge.call({ caseless: d }, u, c) : ae.isPlainObject(c) ? ae.merge({}, c) : ae.isArray(c) ? c.slice() : c;
  }
  function r(u, c, d) {
    if (ae.isUndefined(c)) {
      if (!ae.isUndefined(u))
        return i(void 0, u, d);
    } else
      return i(u, c, d);
  }
  function s(u, c) {
    if (!ae.isUndefined(c))
      return i(void 0, c);
  }
  function a(u, c) {
    if (ae.isUndefined(c)) {
      if (!ae.isUndefined(u))
        return i(void 0, u);
    } else
      return i(void 0, c);
  }
  function o(u, c, d) {
    if (d in t)
      return i(u, c);
    if (d in e)
      return i(void 0, u);
  }
  const l = {
    url: s,
    method: s,
    data: s,
    baseURL: a,
    transformRequest: a,
    transformResponse: a,
    paramsSerializer: a,
    timeout: a,
    timeoutMessage: a,
    withCredentials: a,
    withXSRFToken: a,
    adapter: a,
    responseType: a,
    xsrfCookieName: a,
    xsrfHeaderName: a,
    onUploadProgress: a,
    onDownloadProgress: a,
    decompress: a,
    maxContentLength: a,
    maxBodyLength: a,
    beforeRedirect: a,
    transport: a,
    httpAgent: a,
    httpsAgent: a,
    cancelToken: a,
    socketPath: a,
    responseEncoding: a,
    validateStatus: o,
    headers: (u, c) => r(T0(u), T0(c), !0)
  };
  return ae.forEach(Object.keys(Object.assign({}, e, t)), function(c) {
    const d = l[c] || r, f = d(e[c], t[c], c);
    ae.isUndefined(f) && d !== o || (n[c] = f);
  }), n;
}
const KC = (e) => {
  const t = Za({}, e);
  let { data: n, withXSRFToken: i, xsrfHeaderName: r, xsrfCookieName: s, headers: a, auth: o } = t;
  t.headers = a = br.from(a), t.url = zC(ZC(t.baseURL, t.url), e.params, e.paramsSerializer), o && a.set(
    "Authorization",
    "Basic " + btoa((o.username || "") + ":" + (o.password ? unescape(encodeURIComponent(o.password)) : ""))
  );
  let l;
  if (ae.isFormData(n)) {
    if (yr.hasStandardBrowserEnv || yr.hasStandardBrowserWebWorkerEnv)
      a.setContentType(void 0);
    else if ((l = a.getContentType()) !== !1) {
      const [u, ...c] = l ? l.split(";").map((d) => d.trim()).filter(Boolean) : [];
      a.setContentType([u || "multipart/form-data", ...c].join("; "));
    }
  }
  if (yr.hasStandardBrowserEnv && (i && ae.isFunction(i) && (i = i(t)), i || i !== !1 && VF(t.url))) {
    const u = r && s && DF.read(s);
    u && a.set(r, u);
  }
  return t;
}, RF = typeof XMLHttpRequest < "u", FF = RF && function(e) {
  return new Promise(function(n, i) {
    const r = KC(e);
    let s = r.data;
    const a = br.from(r.headers).normalize();
    let { responseType: o } = r, l;
    function u() {
      r.cancelToken && r.cancelToken.unsubscribe(l), r.signal && r.signal.removeEventListener("abort", l);
    }
    let c = new XMLHttpRequest();
    c.open(r.method.toUpperCase(), r.url, !0), c.timeout = r.timeout;
    function d() {
      if (!c)
        return;
      const h = br.from(
        "getAllResponseHeaders" in c && c.getAllResponseHeaders()
      ), g = {
        data: !o || o === "text" || o === "json" ? c.responseText : c.response,
        status: c.status,
        statusText: c.statusText,
        headers: h,
        config: e,
        request: c
      };
      YC(function(y) {
        n(y), u();
      }, function(y) {
        i(y), u();
      }, g), c = null;
    }
    "onloadend" in c ? c.onloadend = d : c.onreadystatechange = function() {
      !c || c.readyState !== 4 || c.status === 0 && !(c.responseURL && c.responseURL.indexOf("file:") === 0) || setTimeout(d);
    }, c.onabort = function() {
      c && (i(new Ye("Request aborted", Ye.ECONNABORTED, r, c)), c = null);
    }, c.onerror = function() {
      i(new Ye("Network Error", Ye.ERR_NETWORK, r, c)), c = null;
    }, c.ontimeout = function() {
      let m = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded";
      const g = r.transitional || UC;
      r.timeoutErrorMessage && (m = r.timeoutErrorMessage), i(new Ye(
        m,
        g.clarifyTimeoutError ? Ye.ETIMEDOUT : Ye.ECONNABORTED,
        r,
        c
      )), c = null;
    }, s === void 0 && a.setContentType(null), "setRequestHeader" in c && ae.forEach(a.toJSON(), function(m, g) {
      c.setRequestHeader(g, m);
    }), ae.isUndefined(r.withCredentials) || (c.withCredentials = !!r.withCredentials), o && o !== "json" && (c.responseType = r.responseType), typeof r.onDownloadProgress == "function" && c.addEventListener("progress", Tf(r.onDownloadProgress, !0)), typeof r.onUploadProgress == "function" && c.upload && c.upload.addEventListener("progress", Tf(r.onUploadProgress)), (r.cancelToken || r.signal) && (l = (h) => {
      c && (i(!h || h.type ? new Yl(null, e, c) : h), c.abort(), c = null);
    }, r.cancelToken && r.cancelToken.subscribe(l), r.signal && (r.signal.aborted ? l() : r.signal.addEventListener("abort", l)));
    const f = EF(r.url);
    if (f && yr.protocols.indexOf(f) === -1) {
      i(new Ye("Unsupported protocol " + f + ":", Ye.ERR_BAD_REQUEST, e));
      return;
    }
    c.send(s || null);
  });
}, BF = (e, t) => {
  let n = new AbortController(), i;
  const r = function(l) {
    if (!i) {
      i = !0, a();
      const u = l instanceof Error ? l : this.reason;
      n.abort(u instanceof Ye ? u : new Yl(u instanceof Error ? u.message : u));
    }
  };
  let s = t && setTimeout(() => {
    r(new Ye(`timeout ${t} of ms exceeded`, Ye.ETIMEDOUT));
  }, t);
  const a = () => {
    e && (s && clearTimeout(s), s = null, e.forEach((l) => {
      l && (l.removeEventListener ? l.removeEventListener("abort", r) : l.unsubscribe(r));
    }), e = null);
  };
  e.forEach((l) => l && l.addEventListener && l.addEventListener("abort", r));
  const { signal: o } = n;
  return o.unsubscribe = a, [o, () => {
    s && clearTimeout(s), s = null;
  }];
}, LF = BF, $F = function* (e, t) {
  let n = e.byteLength;
  if (!t || n < t) {
    yield e;
    return;
  }
  let i = 0, r;
  for (; i < n; )
    r = i + t, yield e.slice(i, r), i = r;
}, WF = async function* (e, t, n) {
  for await (const i of e)
    yield* $F(ArrayBuffer.isView(i) ? i : await n(String(i)), t);
}, x0 = (e, t, n, i, r) => {
  const s = WF(e, t, r);
  let a = 0;
  return new ReadableStream({
    type: "bytes",
    async pull(o) {
      const { done: l, value: u } = await s.next();
      if (l) {
        o.close(), i();
        return;
      }
      let c = u.byteLength;
      n && n(a += c), o.enqueue(new Uint8Array(u));
    },
    cancel(o) {
      return i(o), s.return();
    }
  }, {
    highWaterMark: 2
  });
}, A0 = (e, t) => {
  const n = e != null;
  return (i) => setTimeout(() => t({
    lengthComputable: n,
    total: e,
    loaded: i
  }));
}, Hh = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", XC = Hh && typeof ReadableStream == "function", eg = Hh && (typeof TextEncoder == "function" ? ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), jF = XC && (() => {
  let e = !1;
  const t = new Request(yr.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
})(), I0 = 64 * 1024, tg = XC && !!(() => {
  try {
    return ae.isReadableStream(new Response("").body);
  } catch {
  }
})(), xf = {
  stream: tg && ((e) => e.body)
};
Hh && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !xf[t] && (xf[t] = ae.isFunction(e[t]) ? (n) => n[t]() : (n, i) => {
      throw new Ye(`Response type '${t}' is not supported`, Ye.ERR_NOT_SUPPORT, i);
    });
  });
})(new Response());
const HF = async (e) => {
  if (e == null)
    return 0;
  if (ae.isBlob(e))
    return e.size;
  if (ae.isSpecCompliantForm(e))
    return (await new Request(e).arrayBuffer()).byteLength;
  if (ae.isArrayBufferView(e))
    return e.byteLength;
  if (ae.isURLSearchParams(e) && (e = e + ""), ae.isString(e))
    return (await eg(e)).byteLength;
}, zF = async (e, t) => {
  const n = ae.toFiniteNumber(e.getContentLength());
  return n ?? HF(t);
}, UF = Hh && (async (e) => {
  let {
    url: t,
    method: n,
    data: i,
    signal: r,
    cancelToken: s,
    timeout: a,
    onDownloadProgress: o,
    onUploadProgress: l,
    responseType: u,
    headers: c,
    withCredentials: d = "same-origin",
    fetchOptions: f
  } = KC(e);
  u = u ? (u + "").toLowerCase() : "text";
  let [h, m] = r || s || a ? LF([r, s], a) : [], g, p;
  const y = () => {
    !g && setTimeout(() => {
      h && h.unsubscribe();
    }), g = !0;
  };
  let k;
  try {
    if (l && jF && n !== "get" && n !== "head" && (k = await zF(c, i)) !== 0) {
      let S = new Request(t, {
        method: "POST",
        body: i,
        duplex: "half"
      }), C;
      ae.isFormData(i) && (C = S.headers.get("content-type")) && c.setContentType(C), S.body && (i = x0(S.body, I0, A0(
        k,
        Tf(l)
      ), null, eg));
    }
    ae.isString(d) || (d = d ? "cors" : "omit"), p = new Request(t, {
      ...f,
      signal: h,
      method: n.toUpperCase(),
      headers: c.normalize().toJSON(),
      body: i,
      duplex: "half",
      withCredentials: d
    });
    let T = await fetch(p);
    const _ = tg && (u === "stream" || u === "response");
    if (tg && (o || _)) {
      const S = {};
      ["status", "statusText", "headers"].forEach((x) => {
        S[x] = T[x];
      });
      const C = ae.toFiniteNumber(T.headers.get("content-length"));
      T = new Response(
        x0(T.body, I0, o && A0(
          C,
          Tf(o, !0)
        ), _ && y, eg),
        S
      );
    }
    u = u || "text";
    let w = await xf[ae.findKey(xf, u) || "text"](T, e);
    return !_ && y(), m && m(), await new Promise((S, C) => {
      YC(S, C, {
        data: w,
        headers: br.from(T.headers),
        status: T.status,
        statusText: T.statusText,
        config: e,
        request: p
      });
    });
  } catch (T) {
    throw y(), T && T.name === "TypeError" && /fetch/i.test(T.message) ? Object.assign(
      new Ye("Network Error", Ye.ERR_NETWORK, e, p),
      {
        cause: T.cause || T
      }
    ) : Ye.from(T, T && T.code, e, p);
  }
}), ng = {
  http: aF,
  xhr: FF,
  fetch: UF
};
ae.forEach(ng, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const E0 = (e) => `- ${e}`, qF = (e) => ae.isFunction(e) || e === null || e === !1, JC = {
  getAdapter: (e) => {
    e = ae.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, i;
    const r = {};
    for (let s = 0; s < t; s++) {
      n = e[s];
      let a;
      if (i = n, !qF(n) && (i = ng[(a = String(n)).toLowerCase()], i === void 0))
        throw new Ye(`Unknown adapter '${a}'`);
      if (i)
        break;
      r[a || "#" + s] = i;
    }
    if (!i) {
      const s = Object.entries(r).map(
        ([o, l]) => `adapter ${o} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let a = t ? s.length > 1 ? `since :
` + s.map(E0).join(`
`) : " " + E0(s[0]) : "as no adapter specified";
      throw new Ye(
        "There is no suitable adapter to dispatch the request " + a,
        "ERR_NOT_SUPPORT"
      );
    }
    return i;
  },
  adapters: ng
};
function uv(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Yl(null, e);
}
function P0(e) {
  return uv(e), e.headers = br.from(e.headers), e.data = lv.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), JC.getAdapter(e.adapter || Yp.adapter)(e).then(function(i) {
    return uv(e), i.data = lv.call(
      e,
      e.transformResponse,
      i
    ), i.headers = br.from(i.headers), i;
  }, function(i) {
    return GC(i) || (uv(e), i && i.response && (i.response.data = lv.call(
      e,
      e.transformResponse,
      i.response
    ), i.response.headers = br.from(i.response.headers))), Promise.reject(i);
  });
}
const QC = "1.7.2", Zp = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Zp[e] = function(i) {
    return typeof i === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const O0 = {};
Zp.transitional = function(t, n, i) {
  function r(s, a) {
    return "[Axios v" + QC + "] Transitional option '" + s + "'" + a + (i ? ". " + i : "");
  }
  return (s, a, o) => {
    if (t === !1)
      throw new Ye(
        r(a, " has been removed" + (n ? " in " + n : "")),
        Ye.ERR_DEPRECATED
      );
    return n && !O0[a] && (O0[a] = !0, console.warn(
      r(
        a,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(s, a, o) : !0;
  };
};
function GF(e, t, n) {
  if (typeof e != "object")
    throw new Ye("options must be an object", Ye.ERR_BAD_OPTION_VALUE);
  const i = Object.keys(e);
  let r = i.length;
  for (; r-- > 0; ) {
    const s = i[r], a = t[s];
    if (a) {
      const o = e[s], l = o === void 0 || a(o, s, e);
      if (l !== !0)
        throw new Ye("option " + s + " must be " + l, Ye.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new Ye("Unknown option " + s, Ye.ERR_BAD_OPTION);
  }
}
const ig = {
  assertOptions: GF,
  validators: Zp
}, Rs = ig.validators;
class Af {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new k0(),
      response: new k0()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (i) {
      if (i instanceof Error) {
        let r;
        Error.captureStackTrace ? Error.captureStackTrace(r = {}) : r = new Error();
        const s = r.stack ? r.stack.replace(/^.+\n/, "") : "";
        try {
          i.stack ? s && !String(i.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (i.stack += `
` + s) : i.stack = s;
        } catch {
        }
      }
      throw i;
    }
  }
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Za(this.defaults, n);
    const { transitional: i, paramsSerializer: r, headers: s } = n;
    i !== void 0 && ig.assertOptions(i, {
      silentJSONParsing: Rs.transitional(Rs.boolean),
      forcedJSONParsing: Rs.transitional(Rs.boolean),
      clarifyTimeoutError: Rs.transitional(Rs.boolean)
    }, !1), r != null && (ae.isFunction(r) ? n.paramsSerializer = {
      serialize: r
    } : ig.assertOptions(r, {
      encode: Rs.function,
      serialize: Rs.function
    }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let a = s && ae.merge(
      s.common,
      s[n.method]
    );
    s && ae.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (m) => {
        delete s[m];
      }
    ), n.headers = br.concat(a, s);
    const o = [];
    let l = !0;
    this.interceptors.request.forEach(function(g) {
      typeof g.runWhen == "function" && g.runWhen(n) === !1 || (l = l && g.synchronous, o.unshift(g.fulfilled, g.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function(g) {
      u.push(g.fulfilled, g.rejected);
    });
    let c, d = 0, f;
    if (!l) {
      const m = [P0.bind(this), void 0];
      for (m.unshift.apply(m, o), m.push.apply(m, u), f = m.length, c = Promise.resolve(n); d < f; )
        c = c.then(m[d++], m[d++]);
      return c;
    }
    f = o.length;
    let h = n;
    for (d = 0; d < f; ) {
      const m = o[d++], g = o[d++];
      try {
        h = m(h);
      } catch (p) {
        g.call(this, p);
        break;
      }
    }
    try {
      c = P0.call(this, h);
    } catch (m) {
      return Promise.reject(m);
    }
    for (d = 0, f = u.length; d < f; )
      c = c.then(u[d++], u[d++]);
    return c;
  }
  getUri(t) {
    t = Za(this.defaults, t);
    const n = ZC(t.baseURL, t.url);
    return zC(n, t.params, t.paramsSerializer);
  }
}
ae.forEach(["delete", "get", "head", "options"], function(t) {
  Af.prototype[t] = function(n, i) {
    return this.request(Za(i || {}, {
      method: t,
      url: n,
      data: (i || {}).data
    }));
  };
});
ae.forEach(["post", "put", "patch"], function(t) {
  function n(i) {
    return function(s, a, o) {
      return this.request(Za(o || {}, {
        method: t,
        headers: i ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: a
      }));
    };
  }
  Af.prototype[t] = n(), Af.prototype[t + "Form"] = n(!0);
});
const Jd = Af;
class Kp {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(s) {
      n = s;
    });
    const i = this;
    this.promise.then((r) => {
      if (!i._listeners)
        return;
      let s = i._listeners.length;
      for (; s-- > 0; )
        i._listeners[s](r);
      i._listeners = null;
    }), this.promise.then = (r) => {
      let s;
      const a = new Promise((o) => {
        i.subscribe(o), s = o;
      }).then(r);
      return a.cancel = function() {
        i.unsubscribe(s);
      }, a;
    }, t(function(s, a, o) {
      i.reason || (i.reason = new Yl(s, a, o), n(i.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new Kp(function(r) {
        t = r;
      }),
      cancel: t
    };
  }
}
const YF = Kp;
function ZF(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function KF(e) {
  return ae.isObject(e) && e.isAxiosError === !0;
}
const rg = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(rg).forEach(([e, t]) => {
  rg[t] = e;
});
const XF = rg;
function eT(e) {
  const t = new Jd(e), n = VC(Jd.prototype.request, t);
  return ae.extend(n, Jd.prototype, t, { allOwnKeys: !0 }), ae.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(r) {
    return eT(Za(e, r));
  }, n;
}
const vn = eT(Yp);
vn.Axios = Jd;
vn.CanceledError = Yl;
vn.CancelToken = YF;
vn.isCancel = GC;
vn.VERSION = QC;
vn.toFormData = Wh;
vn.AxiosError = Ye;
vn.Cancel = vn.CanceledError;
vn.all = function(t) {
  return Promise.all(t);
};
vn.spread = ZF;
vn.isAxiosError = KF;
vn.mergeConfig = Za;
vn.AxiosHeaders = br;
vn.formToJSON = (e) => qC(ae.isHTMLForm(e) ? new FormData(e) : e);
vn.getAdapter = JC.getAdapter;
vn.HttpStatusCode = XF;
vn.default = vn;
const JF = vn, QF = (e, t, n) => {
  if (!(t instanceof Fh))
    throw new Error("Invalid or missing LocalStorageService instance");
  if (!(n instanceof Vh))
    throw new Error("Invalid or missing Bus instance");
  const i = JF.create({
    baseURL: e,
    headers: {
      "Content-Type": "application/json"
    },
    validateStatus: () => !0
  });
  return i.interceptors.request.use(
    (r) => {
      if (t && t.loaded) {
        const s = t.get("bearer");
        s && (r.headers.Authorization = `Bearer ${s}`);
      }
      return r;
    },
    (r) => Promise.reject(r)
  ), i.interceptors.response.use(
    (r) => (r.status === 401 && n && n.emit("api:unauthorized", {
      local: !0,
      crossTab: !0
    }), r),
    (r) => (r.response && r.response.status === 401 && n && n.emit("api:unauthorized", {
      local: !0,
      crossTab: !0
    }), Promise.reject(r))
  ), i;
}, eB = (e) => typeof e == "function" && typeof e.defaults == "object" && typeof e.request == "function" && typeof e.get == "function" && typeof e.delete == "function" && typeof e.head == "function" && typeof e.options == "function" && typeof e.post == "function" && typeof e.put == "function" && typeof e.patch == "function", tB = {
  install: (e, t) => {
    const n = t != null && t.baseURL || window ? window.location.origin : "http://localhost:3000", i = QF(
      n,
      e.config.globalProperties.$ls,
      e.config.globalProperties.$bus
    );
    e.provide("api", i), e.config.globalProperties.$api = i;
  }
};
var Xp = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, ye = (e, t, n) => (Xp(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Gt = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, Cn = (e, t, n, i) => (Xp(e, t, "write to private field"), i ? i.call(e, n) : t.set(e, n), n), pn = (e, t, n) => (Xp(e, t, "access private method"), n), Mn, tc, Bn, Sa, Br, $r, ur, Lr, Ci, Su, ku, Cu, Tu, xu, Qd, Fa, If, Au, Fr, ss, nc, Ef, qs, Ba, ef, sg;
const Li = Is("Identity");
class tT {
  /**
   * Create a new Identity instance
   * @param bus A BusService instance
   * @param ls A LocalStorageService instance
   * @param cron A MiliCron instance
   * @param api An Axios instance
   * @param tokenRefresh A token refresh callback
   * @param tokenRefreshBuffer The amount of time in milliseconds before the token expires before a token is considered refreshable (default: 5 minutes)
   */
  constructor(t, n, i, r, s, a = 60 * 5) {
    if (Gt(this, Fr), Gt(this, nc), Gt(this, qs), Gt(this, ef), Gt(this, Mn, void 0), Gt(this, tc, void 0), Gt(this, Bn, void 0), Gt(this, Sa, void 0), Gt(this, Br, void 0), Gt(this, $r, void 0), Gt(this, ur, void 0), Gt(this, Lr, void 0), Gt(this, Ci, X(void 0)), Gt(this, Su, void 0), Gt(this, ku, void 0), Gt(this, Cu, void 0), Gt(this, Tu, void 0), Gt(this, xu, void 0), Gt(this, Qd, void 0), Gt(this, Fa, void 0), Gt(this, If, void 0), Gt(this, Au, void 0), !(t instanceof Vh))
      throw Li({ bus: t }), new Error("Invalid or missing BusService instance");
    if (!(n instanceof Fh))
      throw Li({ ls: n }), new Error("Invalid or missing LocalStorageService instance");
    if (!(i instanceof Wp))
      throw Li({ cron: i }), new Error("Invalid or missing MiliCron instance");
    if (!eB(r))
      throw Li({ api: r }), new Error("Invalid or missing Axios instance");
    Cn(this, Br, X(!1)), Cn(this, Mn, t), Cn(this, tc, r), Cn(this, Bn, n), Cn(this, If, s), Cn(this, Au, a), Cn(this, Sa, i), Cn(this, $r, X(void 0)), Cn(this, ur, X(void 0)), Cn(this, Lr, X(void 0)), Cn(this, Ci, X(void 0)), Cn(this, ku, b(() => ye(this, Ci).value !== void 0 && ye(this, Ci).value > 0 && ye(this, Ci).value <= ye(this, Au))), Cn(this, Tu, b(() => ye(this, Br).value === !0 && ye(this, $r).value !== void 0 && ye(this, Ci).value !== void 0 && ye(this, Ci).value > 0)), Cn(this, xu, b(() => ye(this, Tu).value && ye(this, Lr).value !== void 0 && ye(this, Lr).value !== null && Object.keys(ye(this, Lr).value).length > 0)), Cn(this, Qd, b(() => {
      if (ye(this, xu).value)
        return {
          ...ye(this, Lr).value
        };
    })), Cn(this, Fa, X(void 0));
  }
  /**
   * Whether or not the Identity service has booted
   */
  get booted() {
    return ye(this, Br);
  }
  /**
   * Whether or not the visitor is authenticated
   */
  get authenticated() {
    return ye(this, Tu);
  }
  /**
   * Whether or not the visitor is identified
   */
  get identified() {
    return ye(this, xu);
  }
  /**
   * The user's identity
   */
  get user() {
    return ye(this, Qd);
  }
  /**
   * Whether or not the token is refreshable
   */
  get refreshable() {
    return ye(this, ku);
  }
  /**
   * The time until the authentication expires
   */
  get ttl() {
    return ye(this, Ci);
  }
  /**
   * Save the bearer token, expiration, and user identity to the LocalStorageService and update the authentication & identification state
   * @param bearer The bearer token
   * @param expiration The expiration time of the token
   * @param identity The user's identity
   * @returns void
   */
  login(t, n, i) {
    if (!ye(this, Br)) {
      Li("Login not processed because not booted");
      return;
    }
    ye(this, Bn).set("bearer", t), ye(this, $r).value = t, ye(this, Bn).set("expiration", n), ye(this, ur).value = n, ye(this, Bn).set("user.identity", i), ye(this, Lr).value = i, pn(this, qs, Ba).call(this), ye(this, Mn).emit(
      "identity:login",
      {
        local: !0,
        crossTab: !0
      },
      t,
      n,
      i
    );
  }
  /**
   * Remove the bearer token, expiration, and user identity from the LocalStorageService and update the authentication & identification state
   * @returns void
   */
  logout() {
    ye(this, Bn).remove("bearer"), ye(this, $r).value = void 0, ye(this, Bn).remove("expiration"), ye(this, ur).value = void 0, ye(this, Bn).remove("user.identity"), ye(this, Lr).value = void 0, ye(this, Mn).emit("identity:logout", {
      local: !0,
      crossTab: !0
    });
  }
  /**
   * Boot the Identity service
   */
  boot() {
    ye(this, Mn).on("api:unauthorized", this.logout.bind(this), { local: !0, crossTab: !0 }), ye(this, Mn).on("identity:login", pn(this, Fr, ss).bind(this), {
      local: !0,
      crossTab: !0,
      immediate: !0
    }), ye(this, Mn).on("identity:logout", pn(this, Fr, ss).bind(this), {
      local: !0,
      crossTab: !0,
      immediate: !0
    }), ye(this, Mn).on("tab:active", pn(this, Fr, ss).bind(this), {
      local: !0
    }), ye(this, Mn).on("authentication:refreshable", pn(this, ef, sg).bind(this), {
      local: !0,
      crossTab: !0,
      immediate: !0
    }), ye(this, Sa).$on("*/250 * * * * *", pn(this, Fr, ss).bind(this)), ye(this, Sa).$on("* * * * *", pn(this, qs, Ba).bind(this)), Cn(this, Su, fe(
      () => ye(this, Ci).value,
      (t, n) => {
        t !== n && (t === void 0 && n !== void 0 && ye(this, $r).value !== void 0 ? (Li("Authentication Expired. Logging Out."), this.logout()) : t !== void 0 && t <= 0 && (Li("Authentication Expired. Logging Out."), this.logout()));
      },
      {
        immediate: !0
      }
    )), Cn(this, Cu, fe(
      () => ye(this, ku).value,
      (t) => {
        t && (Li("Token is refreshable"), ye(this, Mn).emit("authentication:refreshable", {
          local: !0,
          crossTab: !0
        }));
      }
    )), pn(this, nc, Ef).call(this, !0);
  }
  /**
   * Shutdown the Identity service
   */
  shutdown() {
    ye(this, Mn).off("api:unauthorized", this.logout.bind(this), { local: !0, crossTab: !0 }), ye(this, Mn).off("identity:login", pn(this, Fr, ss).bind(this), {
      local: !0,
      crossTab: !0
    }), ye(this, Mn).off("tab:active", pn(this, Fr, ss).bind(this), {
      local: !0
    }), ye(this, Mn).off("identity:logout", pn(this, Fr, ss).bind(this), {
      local: !0,
      crossTab: !0
    }), ye(this, Sa).$off("*/250 * * * * *", pn(this, Fr, ss).bind(this)), ye(this, Sa).$off("* * * * *", pn(this, qs, Ba).bind(this)), ye(this, Su) && ye(this, Su).call(this), ye(this, Cu) && ye(this, Cu).call(this), ye(this, Br).value = !1, Li("Shutdown");
  }
  /**
   * Force a refresh of the token
   * @private
   * @remarks This method is not intended to be used by the consumer of the Identity service, but is for development and testing purposes
   */
  async forceRefreshToken() {
    ye(this, Br).value && await pn(this, ef, sg).call(this);
  }
  /**
   * Make the token refreshable
   * @private
   * @remarks This method is not intended to be used by the consumer of the Identity service, but is for development and testing purposes
   */
  $makeRefreshable() {
    if (ye(this, Br).value && typeof ye(this, $r).value == "string" && typeof ye(this, ur).value == "string") {
      const t = Re.now().plus({ seconds: ye(this, Au) }).toISO();
      ye(this, Bn).set("expiration", t), ye(this, ur).value = t, pn(this, qs, Ba).call(this);
    }
  }
}
Mn = /* @__PURE__ */ new WeakMap();
tc = /* @__PURE__ */ new WeakMap();
Bn = /* @__PURE__ */ new WeakMap();
Sa = /* @__PURE__ */ new WeakMap();
Br = /* @__PURE__ */ new WeakMap();
$r = /* @__PURE__ */ new WeakMap();
ur = /* @__PURE__ */ new WeakMap();
Lr = /* @__PURE__ */ new WeakMap();
Ci = /* @__PURE__ */ new WeakMap();
Su = /* @__PURE__ */ new WeakMap();
ku = /* @__PURE__ */ new WeakMap();
Cu = /* @__PURE__ */ new WeakMap();
Tu = /* @__PURE__ */ new WeakMap();
xu = /* @__PURE__ */ new WeakMap();
Qd = /* @__PURE__ */ new WeakMap();
Fa = /* @__PURE__ */ new WeakMap();
If = /* @__PURE__ */ new WeakMap();
Au = /* @__PURE__ */ new WeakMap();
Fr = /* @__PURE__ */ new WeakSet();
ss = function() {
  pn(this, nc, Ef).call(this);
};
nc = /* @__PURE__ */ new WeakSet();
Ef = function(e = !1) {
  if (!ye(this, Bn).loaded) {
    ye(this, Bn).promise.then(() => {
      pn(this, nc, Ef).call(this, e);
    });
    return;
  }
  ye(this, $r).value = ye(this, Bn).get("bearer"), ye(this, ur).value = ye(this, Bn).get("expiration"), ye(this, Lr).value = ye(this, Bn).get("user.identity"), e && (pn(this, qs, Ba).call(this), ye(this, Br).value = !0, Li("Booted"));
};
qs = /* @__PURE__ */ new WeakSet();
Ba = function() {
  if (ye(this, ur).value) {
    const e = Re.fromISO(ye(this, ur).value);
    if (!e.isValid) {
      ye(this, Ci).value = void 0;
      return;
    }
    const t = Re.now(), n = e.diff(t, "seconds");
    ye(this, Ci).value = n.seconds;
  } else {
    ye(this, Ci).value = void 0;
    return;
  }
};
ef = /* @__PURE__ */ new WeakSet();
sg = async function() {
  if (ye(this, Mn) && ye(this, tc))
    if (await ye(this, Mn).isMain(500)) {
      ye(this, Fa).value && ye(this, Fa).value.abort(), ye(this, Fa).value = new AbortController();
      try {
        const { bearer: t, expiration: n } = await ye(this, If).call(this, ye(this, tc), ye(this, Fa).value.signal);
        ye(this, Bn).set("bearer", t), ye(this, $r).value = t, ye(this, Bn).set("expiration", n), ye(this, ur).value = n, pn(this, qs, Ba).call(this);
      } catch {
        Li("Failed to refresh token");
      }
    } else
      Li("Not main tab. Allowing main tab to refresh token.");
};
const nB = {
  install: (e, t) => {
    const n = (t == null ? void 0 : t.tokenRefreshBuffer) || 300, i = (t == null ? void 0 : t.tokenRefresh) || (() => ({
      bearer: "",
      expiration: Re.now().plus({ minutes: n * 3 }).toISO()
    })), r = new tT(
      e.config.globalProperties.$bus,
      e.config.globalProperties.$ls,
      e.config.globalProperties.$cron,
      e.config.globalProperties.$api,
      i,
      n
    );
    e.provide("identity", r), e.config.globalProperties.$identity = r;
  }
}, Z7 = {
  install: (e, t) => {
    e.use(rR, t == null ? void 0 : t.bus), e.use(fR), e.use(bR, t == null ? void 0 : t.ls), e.use(_R, t == null ? void 0 : t.vuetify), e.use(tB, t == null ? void 0 : t.api), e.use(nB, t == null ? void 0 : t.identity);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const nT = function(e) {
  const t = [];
  let n = 0;
  for (let i = 0; i < e.length; i++) {
    let r = e.charCodeAt(i);
    r < 128 ? t[n++] = r : r < 2048 ? (t[n++] = r >> 6 | 192, t[n++] = r & 63 | 128) : (r & 64512) === 55296 && i + 1 < e.length && (e.charCodeAt(i + 1) & 64512) === 56320 ? (r = 65536 + ((r & 1023) << 10) + (e.charCodeAt(++i) & 1023), t[n++] = r >> 18 | 240, t[n++] = r >> 12 & 63 | 128, t[n++] = r >> 6 & 63 | 128, t[n++] = r & 63 | 128) : (t[n++] = r >> 12 | 224, t[n++] = r >> 6 & 63 | 128, t[n++] = r & 63 | 128);
  }
  return t;
}, iB = function(e) {
  const t = [];
  let n = 0, i = 0;
  for (; n < e.length; ) {
    const r = e[n++];
    if (r < 128)
      t[i++] = String.fromCharCode(r);
    else if (r > 191 && r < 224) {
      const s = e[n++];
      t[i++] = String.fromCharCode((r & 31) << 6 | s & 63);
    } else if (r > 239 && r < 365) {
      const s = e[n++], a = e[n++], o = e[n++], l = ((r & 7) << 18 | (s & 63) << 12 | (a & 63) << 6 | o & 63) - 65536;
      t[i++] = String.fromCharCode(55296 + (l >> 10)), t[i++] = String.fromCharCode(56320 + (l & 1023));
    } else {
      const s = e[n++], a = e[n++];
      t[i++] = String.fromCharCode((r & 15) << 12 | (s & 63) << 6 | a & 63);
    }
  }
  return t.join("");
}, iT = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob == "function",
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray(e, t) {
    if (!Array.isArray(e))
      throw Error("encodeByteArray takes an array as a parameter");
    this.init_();
    const n = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, i = [];
    for (let r = 0; r < e.length; r += 3) {
      const s = e[r], a = r + 1 < e.length, o = a ? e[r + 1] : 0, l = r + 2 < e.length, u = l ? e[r + 2] : 0, c = s >> 2, d = (s & 3) << 4 | o >> 4;
      let f = (o & 15) << 2 | u >> 6, h = u & 63;
      l || (h = 64, a || (f = 64)), i.push(n[c], n[d], n[f], n[h]);
    }
    return i.join("");
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString(e, t) {
    return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(nT(e), t);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString(e, t) {
    return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : iB(this.decodeStringToByteArray(e, t));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray(e, t) {
    this.init_();
    const n = t ? this.charToByteMapWebSafe_ : this.charToByteMap_, i = [];
    for (let r = 0; r < e.length; ) {
      const s = n[e.charAt(r++)], o = r < e.length ? n[e.charAt(r)] : 0;
      ++r;
      const u = r < e.length ? n[e.charAt(r)] : 64;
      ++r;
      const d = r < e.length ? n[e.charAt(r)] : 64;
      if (++r, s == null || o == null || u == null || d == null)
        throw new rB();
      const f = s << 2 | o >> 4;
      if (i.push(f), u !== 64) {
        const h = o << 4 & 240 | u >> 2;
        if (i.push(h), d !== 64) {
          const m = u << 6 & 192 | d;
          i.push(m);
        }
      }
    }
    return i;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
      for (let e = 0; e < this.ENCODED_VALS.length; e++)
        this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e), this.charToByteMap_[this.byteToCharMap_[e]] = e, this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e, e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e);
    }
  }
};
class rB extends Error {
  constructor() {
    super(...arguments), this.name = "DecodeBase64StringError";
  }
}
const sB = function(e) {
  const t = nT(e);
  return iT.encodeByteArray(t, !0);
}, rT = function(e) {
  return sB(e).replace(/\./g, "");
}, aB = function(e) {
  try {
    return iT.decodeString(e, !0);
  } catch (t) {
    console.error("base64Decode failed: ", t);
  }
  return null;
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function oB() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const lB = () => oB().__FIREBASE_DEFAULTS__, uB = () => {
  if (typeof process > "u" || typeof process.env > "u")
    return;
  const e = process.env.__FIREBASE_DEFAULTS__;
  if (e)
    return JSON.parse(e);
}, cB = () => {
  if (typeof document > "u")
    return;
  let e;
  try {
    e = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch {
    return;
  }
  const t = e && aB(e[1]);
  return t && JSON.parse(t);
}, dB = () => {
  try {
    return lB() || uB() || cB();
  } catch (e) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);
    return;
  }
}, sT = () => {
  var e;
  return (e = dB()) === null || e === void 0 ? void 0 : e.config;
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class fB {
  constructor() {
    this.reject = () => {
    }, this.resolve = () => {
    }, this.promise = new Promise((t, n) => {
      this.resolve = t, this.reject = n;
    });
  }
  /**
   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(t) {
    return (n, i) => {
      n ? this.reject(n) : this.resolve(i), typeof t == "function" && (this.promise.catch(() => {
      }), t.length === 1 ? t(n) : t(n, i));
    };
  }
}
function aT() {
  try {
    return typeof indexedDB == "object";
  } catch {
    return !1;
  }
}
function oT() {
  return new Promise((e, t) => {
    try {
      let n = !0;
      const i = "validate-browser-context-for-indexeddb-analytics-module", r = self.indexedDB.open(i);
      r.onsuccess = () => {
        r.result.close(), n || self.indexedDB.deleteDatabase(i), e(!0);
      }, r.onupgradeneeded = () => {
        n = !1;
      }, r.onerror = () => {
        var s;
        t(((s = r.error) === null || s === void 0 ? void 0 : s.message) || "");
      };
    } catch (n) {
      t(n);
    }
  });
}
function hB() {
  return !(typeof navigator > "u" || !navigator.cookieEnabled);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mB = "FirebaseError";
class Zl extends Error {
  constructor(t, n, i) {
    super(n), this.code = t, this.customData = i, this.name = mB, Object.setPrototypeOf(this, Zl.prototype), Error.captureStackTrace && Error.captureStackTrace(this, zh.prototype.create);
  }
}
class zh {
  constructor(t, n, i) {
    this.service = t, this.serviceName = n, this.errors = i;
  }
  create(t, ...n) {
    const i = n[0] || {}, r = `${this.service}/${t}`, s = this.errors[t], a = s ? vB(s, i) : "Error", o = `${this.serviceName}: ${a} (${r}).`;
    return new Zl(r, o, i);
  }
}
function vB(e, t) {
  return e.replace(gB, (n, i) => {
    const r = t[i];
    return r != null ? String(r) : `<${i}?>`;
  });
}
const gB = /\{\$([^}]+)}/g;
function ag(e, t) {
  if (e === t)
    return !0;
  const n = Object.keys(e), i = Object.keys(t);
  for (const r of n) {
    if (!i.includes(r))
      return !1;
    const s = e[r], a = t[r];
    if (V0(s) && V0(a)) {
      if (!ag(s, a))
        return !1;
    } else if (s !== a)
      return !1;
  }
  for (const r of i)
    if (!n.includes(r))
      return !1;
  return !0;
}
function V0(e) {
  return e !== null && typeof e == "object";
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Jp(e) {
  return e && e._delegate ? e._delegate : e;
}
class ra {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(t, n, i) {
    this.name = t, this.instanceFactory = n, this.type = i, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
  }
  setInstantiationMode(t) {
    return this.instantiationMode = t, this;
  }
  setMultipleInstances(t) {
    return this.multipleInstances = t, this;
  }
  setServiceProps(t) {
    return this.serviceProps = t, this;
  }
  setInstanceCreatedCallback(t) {
    return this.onInstanceCreated = t, this;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ka = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class pB {
  constructor(t, n) {
    this.name = t, this.container = n, this.component = null, this.instances = /* @__PURE__ */ new Map(), this.instancesDeferred = /* @__PURE__ */ new Map(), this.instancesOptions = /* @__PURE__ */ new Map(), this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  /**
   * @param identifier A provider can provide mulitple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(t) {
    const n = this.normalizeInstanceIdentifier(t);
    if (!this.instancesDeferred.has(n)) {
      const i = new fB();
      if (this.instancesDeferred.set(n, i), this.isInitialized(n) || this.shouldAutoInitialize())
        try {
          const r = this.getOrInitializeService({
            instanceIdentifier: n
          });
          r && i.resolve(r);
        } catch {
        }
    }
    return this.instancesDeferred.get(n).promise;
  }
  getImmediate(t) {
    var n;
    const i = this.normalizeInstanceIdentifier(t == null ? void 0 : t.identifier), r = (n = t == null ? void 0 : t.optional) !== null && n !== void 0 ? n : !1;
    if (this.isInitialized(i) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({
          instanceIdentifier: i
        });
      } catch (s) {
        if (r)
          return null;
        throw s;
      }
    else {
      if (r)
        return null;
      throw Error(`Service ${this.name} is not available`);
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(t) {
    if (t.name !== this.name)
      throw Error(`Mismatching Component ${t.name} for Provider ${this.name}.`);
    if (this.component)
      throw Error(`Component for ${this.name} has already been provided`);
    if (this.component = t, !!this.shouldAutoInitialize()) {
      if (bB(t))
        try {
          this.getOrInitializeService({ instanceIdentifier: ka });
        } catch {
        }
      for (const [n, i] of this.instancesDeferred.entries()) {
        const r = this.normalizeInstanceIdentifier(n);
        try {
          const s = this.getOrInitializeService({
            instanceIdentifier: r
          });
          i.resolve(s);
        } catch {
        }
      }
    }
  }
  clearInstance(t = ka) {
    this.instancesDeferred.delete(t), this.instancesOptions.delete(t), this.instances.delete(t);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const t = Array.from(this.instances.values());
    await Promise.all([
      ...t.filter((n) => "INTERNAL" in n).map((n) => n.INTERNAL.delete()),
      ...t.filter((n) => "_delete" in n).map((n) => n._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(t = ka) {
    return this.instances.has(t);
  }
  getOptions(t = ka) {
    return this.instancesOptions.get(t) || {};
  }
  initialize(t = {}) {
    const { options: n = {} } = t, i = this.normalizeInstanceIdentifier(t.instanceIdentifier);
    if (this.isInitialized(i))
      throw Error(`${this.name}(${i}) has already been initialized`);
    if (!this.isComponentSet())
      throw Error(`Component ${this.name} has not been registered yet`);
    const r = this.getOrInitializeService({
      instanceIdentifier: i,
      options: n
    });
    for (const [s, a] of this.instancesDeferred.entries()) {
      const o = this.normalizeInstanceIdentifier(s);
      i === o && a.resolve(r);
    }
    return r;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(t, n) {
    var i;
    const r = this.normalizeInstanceIdentifier(n), s = (i = this.onInitCallbacks.get(r)) !== null && i !== void 0 ? i : /* @__PURE__ */ new Set();
    s.add(t), this.onInitCallbacks.set(r, s);
    const a = this.instances.get(r);
    return a && t(a, r), () => {
      s.delete(t);
    };
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(t, n) {
    const i = this.onInitCallbacks.get(n);
    if (i)
      for (const r of i)
        try {
          r(t, n);
        } catch {
        }
  }
  getOrInitializeService({ instanceIdentifier: t, options: n = {} }) {
    let i = this.instances.get(t);
    if (!i && this.component && (i = this.component.instanceFactory(this.container, {
      instanceIdentifier: yB(t),
      options: n
    }), this.instances.set(t, i), this.instancesOptions.set(t, n), this.invokeOnInitCallbacks(i, t), this.component.onInstanceCreated))
      try {
        this.component.onInstanceCreated(this.container, t, i);
      } catch {
      }
    return i || null;
  }
  normalizeInstanceIdentifier(t = ka) {
    return this.component ? this.component.multipleInstances ? t : ka : t;
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}
function yB(e) {
  return e === ka ? void 0 : e;
}
function bB(e) {
  return e.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wB {
  constructor(t) {
    this.name = t, this.providers = /* @__PURE__ */ new Map();
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(t) {
    const n = this.getProvider(t.name);
    if (n.isComponentSet())
      throw new Error(`Component ${t.name} has already been registered with ${this.name}`);
    n.setComponent(t);
  }
  addOrOverwriteComponent(t) {
    this.getProvider(t.name).isComponentSet() && this.providers.delete(t.name), this.addComponent(t);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(t) {
    if (this.providers.has(t))
      return this.providers.get(t);
    const n = new pB(t, this);
    return this.providers.set(t, n), n;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Dt;
(function(e) {
  e[e.DEBUG = 0] = "DEBUG", e[e.VERBOSE = 1] = "VERBOSE", e[e.INFO = 2] = "INFO", e[e.WARN = 3] = "WARN", e[e.ERROR = 4] = "ERROR", e[e.SILENT = 5] = "SILENT";
})(Dt || (Dt = {}));
const _B = {
  debug: Dt.DEBUG,
  verbose: Dt.VERBOSE,
  info: Dt.INFO,
  warn: Dt.WARN,
  error: Dt.ERROR,
  silent: Dt.SILENT
}, SB = Dt.INFO, kB = {
  [Dt.DEBUG]: "log",
  [Dt.VERBOSE]: "log",
  [Dt.INFO]: "info",
  [Dt.WARN]: "warn",
  [Dt.ERROR]: "error"
}, CB = (e, t, ...n) => {
  if (t < e.logLevel)
    return;
  const i = (/* @__PURE__ */ new Date()).toISOString(), r = kB[t];
  if (r)
    console[r](`[${i}]  ${e.name}:`, ...n);
  else
    throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`);
};
class TB {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(t) {
    this.name = t, this._logLevel = SB, this._logHandler = CB, this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(t) {
    if (!(t in Dt))
      throw new TypeError(`Invalid value "${t}" assigned to \`logLevel\``);
    this._logLevel = t;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(t) {
    this._logLevel = typeof t == "string" ? _B[t] : t;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(t) {
    if (typeof t != "function")
      throw new TypeError("Value assigned to `logHandler` must be a function");
    this._logHandler = t;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(t) {
    this._userLogHandler = t;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...t) {
    this._userLogHandler && this._userLogHandler(this, Dt.DEBUG, ...t), this._logHandler(this, Dt.DEBUG, ...t);
  }
  log(...t) {
    this._userLogHandler && this._userLogHandler(this, Dt.VERBOSE, ...t), this._logHandler(this, Dt.VERBOSE, ...t);
  }
  info(...t) {
    this._userLogHandler && this._userLogHandler(this, Dt.INFO, ...t), this._logHandler(this, Dt.INFO, ...t);
  }
  warn(...t) {
    this._userLogHandler && this._userLogHandler(this, Dt.WARN, ...t), this._logHandler(this, Dt.WARN, ...t);
  }
  error(...t) {
    this._userLogHandler && this._userLogHandler(this, Dt.ERROR, ...t), this._logHandler(this, Dt.ERROR, ...t);
  }
}
const xB = (e, t) => t.some((n) => e instanceof n);
let D0, N0;
function AB() {
  return D0 || (D0 = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function IB() {
  return N0 || (N0 = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const lT = /* @__PURE__ */ new WeakMap(), og = /* @__PURE__ */ new WeakMap(), uT = /* @__PURE__ */ new WeakMap(), cv = /* @__PURE__ */ new WeakMap(), Qp = /* @__PURE__ */ new WeakMap();
function EB(e) {
  const t = new Promise((n, i) => {
    const r = () => {
      e.removeEventListener("success", s), e.removeEventListener("error", a);
    }, s = () => {
      n(gs(e.result)), r();
    }, a = () => {
      i(e.error), r();
    };
    e.addEventListener("success", s), e.addEventListener("error", a);
  });
  return t.then((n) => {
    n instanceof IDBCursor && lT.set(n, e);
  }).catch(() => {
  }), Qp.set(t, e), t;
}
function PB(e) {
  if (og.has(e))
    return;
  const t = new Promise((n, i) => {
    const r = () => {
      e.removeEventListener("complete", s), e.removeEventListener("error", a), e.removeEventListener("abort", a);
    }, s = () => {
      n(), r();
    }, a = () => {
      i(e.error || new DOMException("AbortError", "AbortError")), r();
    };
    e.addEventListener("complete", s), e.addEventListener("error", a), e.addEventListener("abort", a);
  });
  og.set(e, t);
}
let lg = {
  get(e, t, n) {
    if (e instanceof IDBTransaction) {
      if (t === "done")
        return og.get(e);
      if (t === "objectStoreNames")
        return e.objectStoreNames || uT.get(e);
      if (t === "store")
        return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
    }
    return gs(e[t]);
  },
  set(e, t, n) {
    return e[t] = n, !0;
  },
  has(e, t) {
    return e instanceof IDBTransaction && (t === "done" || t === "store") ? !0 : t in e;
  }
};
function OB(e) {
  lg = e(lg);
}
function VB(e) {
  return e === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(t, ...n) {
    const i = e.call(dv(this), t, ...n);
    return uT.set(i, t.sort ? t.sort() : [t]), gs(i);
  } : IB().includes(e) ? function(...t) {
    return e.apply(dv(this), t), gs(lT.get(this));
  } : function(...t) {
    return gs(e.apply(dv(this), t));
  };
}
function DB(e) {
  return typeof e == "function" ? VB(e) : (e instanceof IDBTransaction && PB(e), xB(e, AB()) ? new Proxy(e, lg) : e);
}
function gs(e) {
  if (e instanceof IDBRequest)
    return EB(e);
  if (cv.has(e))
    return cv.get(e);
  const t = DB(e);
  return t !== e && (cv.set(e, t), Qp.set(t, e)), t;
}
const dv = (e) => Qp.get(e);
function Uh(e, t, { blocked: n, upgrade: i, blocking: r, terminated: s } = {}) {
  const a = indexedDB.open(e, t), o = gs(a);
  return i && a.addEventListener("upgradeneeded", (l) => {
    i(gs(a.result), l.oldVersion, l.newVersion, gs(a.transaction), l);
  }), n && a.addEventListener("blocked", (l) => n(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    l.oldVersion,
    l.newVersion,
    l
  )), o.then((l) => {
    s && l.addEventListener("close", () => s()), r && l.addEventListener("versionchange", (u) => r(u.oldVersion, u.newVersion, u));
  }).catch(() => {
  }), o;
}
function fv(e, { blocked: t } = {}) {
  const n = indexedDB.deleteDatabase(e);
  return t && n.addEventListener("blocked", (i) => t(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    i.oldVersion,
    i
  )), gs(n).then(() => {
  });
}
const NB = ["get", "getKey", "getAll", "getAllKeys", "count"], MB = ["put", "add", "delete", "clear"], hv = /* @__PURE__ */ new Map();
function M0(e, t) {
  if (!(e instanceof IDBDatabase && !(t in e) && typeof t == "string"))
    return;
  if (hv.get(t))
    return hv.get(t);
  const n = t.replace(/FromIndex$/, ""), i = t !== n, r = MB.includes(n);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(n in (i ? IDBIndex : IDBObjectStore).prototype) || !(r || NB.includes(n))
  )
    return;
  const s = async function(a, ...o) {
    const l = this.transaction(a, r ? "readwrite" : "readonly");
    let u = l.store;
    return i && (u = u.index(o.shift())), (await Promise.all([
      u[n](...o),
      r && l.done
    ]))[0];
  };
  return hv.set(t, s), s;
}
OB((e) => ({
  ...e,
  get: (t, n, i) => M0(t, n) || e.get(t, n, i),
  has: (t, n) => !!M0(t, n) || e.has(t, n)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RB {
  constructor(t) {
    this.container = t;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    return this.container.getProviders().map((n) => {
      if (FB(n)) {
        const i = n.getImmediate();
        return `${i.library}/${i.version}`;
      } else
        return null;
    }).filter((n) => n).join(" ");
  }
}
function FB(e) {
  const t = e.getComponent();
  return (t == null ? void 0 : t.type) === "VERSION";
}
const ug = "@firebase/app", R0 = "0.10.4";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ka = new TB("@firebase/app"), BB = "@firebase/app-compat", LB = "@firebase/analytics-compat", $B = "@firebase/analytics", WB = "@firebase/app-check-compat", jB = "@firebase/app-check", HB = "@firebase/auth", zB = "@firebase/auth-compat", UB = "@firebase/database", qB = "@firebase/database-compat", GB = "@firebase/functions", YB = "@firebase/functions-compat", ZB = "@firebase/installations", KB = "@firebase/installations-compat", XB = "@firebase/messaging", JB = "@firebase/messaging-compat", QB = "@firebase/performance", eL = "@firebase/performance-compat", tL = "@firebase/remote-config", nL = "@firebase/remote-config-compat", iL = "@firebase/storage", rL = "@firebase/storage-compat", sL = "@firebase/firestore", aL = "@firebase/vertexai-preview", oL = "@firebase/firestore-compat", lL = "firebase";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const cg = "[DEFAULT]", uL = {
  [ug]: "fire-core",
  [BB]: "fire-core-compat",
  [$B]: "fire-analytics",
  [LB]: "fire-analytics-compat",
  [jB]: "fire-app-check",
  [WB]: "fire-app-check-compat",
  [HB]: "fire-auth",
  [zB]: "fire-auth-compat",
  [UB]: "fire-rtdb",
  [qB]: "fire-rtdb-compat",
  [GB]: "fire-fn",
  [YB]: "fire-fn-compat",
  [ZB]: "fire-iid",
  [KB]: "fire-iid-compat",
  [XB]: "fire-fcm",
  [JB]: "fire-fcm-compat",
  [QB]: "fire-perf",
  [eL]: "fire-perf-compat",
  [tL]: "fire-rc",
  [nL]: "fire-rc-compat",
  [iL]: "fire-gcs",
  [rL]: "fire-gcs-compat",
  [sL]: "fire-fst",
  [oL]: "fire-fst-compat",
  [aL]: "fire-vertex",
  "fire-js": "fire-js",
  [lL]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Pf = /* @__PURE__ */ new Map(), cL = /* @__PURE__ */ new Map(), dg = /* @__PURE__ */ new Map();
function F0(e, t) {
  try {
    e.container.addComponent(t);
  } catch (n) {
    Ka.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`, n);
  }
}
function Xa(e) {
  const t = e.name;
  if (dg.has(t))
    return Ka.debug(`There were multiple attempts to register component ${t}.`), !1;
  dg.set(t, e);
  for (const n of Pf.values())
    F0(n, e);
  for (const n of cL.values())
    F0(n, e);
  return !0;
}
function ey(e, t) {
  const n = e.container.getProvider("heartbeat").getImmediate({ optional: !0 });
  return n && n.triggerHeartbeat(), e.container.getProvider(t);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const dL = {
  "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
  "bad-app-name": "Illegal App name: '{$appName}'",
  "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
  "app-deleted": "Firebase App named '{$appName}' already deleted",
  "server-app-deleted": "Firebase Server App has been deleted",
  "no-options": "Need to provide options, when not being deployed to hosting via source.",
  "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  "invalid-log-argument": "First argument to `onLog` must be null or a function.",
  "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
  "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
  "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments."
}, Qs = new zh("app", "Firebase", dL);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class fL {
  constructor(t, n, i) {
    this._isDeleted = !1, this._options = Object.assign({}, t), this._config = Object.assign({}, n), this._name = n.name, this._automaticDataCollectionEnabled = n.automaticDataCollectionEnabled, this._container = i, this.container.addComponent(new ra(
      "app",
      () => this,
      "PUBLIC"
      /* ComponentType.PUBLIC */
    ));
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(t) {
    this.checkDestroyed(), this._automaticDataCollectionEnabled = t;
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(t) {
    this._isDeleted = t;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted)
      throw Qs.create("app-deleted", { appName: this._name });
  }
}
function cT(e, t = {}) {
  let n = e;
  typeof t != "object" && (t = { name: t });
  const i = Object.assign({ name: cg, automaticDataCollectionEnabled: !1 }, t), r = i.name;
  if (typeof r != "string" || !r)
    throw Qs.create("bad-app-name", {
      appName: String(r)
    });
  if (n || (n = sT()), !n)
    throw Qs.create(
      "no-options"
      /* AppError.NO_OPTIONS */
    );
  const s = Pf.get(r);
  if (s) {
    if (ag(n, s.options) && ag(i, s.config))
      return s;
    throw Qs.create("duplicate-app", { appName: r });
  }
  const a = new wB(r);
  for (const l of dg.values())
    a.addComponent(l);
  const o = new fL(n, i, a);
  return Pf.set(r, o), o;
}
function hL(e = cg) {
  const t = Pf.get(e);
  if (!t && e === cg && sT())
    return cT();
  if (!t)
    throw Qs.create("no-app", { appName: e });
  return t;
}
function ea(e, t, n) {
  var i;
  let r = (i = uL[e]) !== null && i !== void 0 ? i : e;
  n && (r += `-${n}`);
  const s = r.match(/\s|\//), a = t.match(/\s|\//);
  if (s || a) {
    const o = [
      `Unable to register library "${r}" with version "${t}":`
    ];
    s && o.push(`library name "${r}" contains illegal characters (whitespace or "/")`), s && a && o.push("and"), a && o.push(`version name "${t}" contains illegal characters (whitespace or "/")`), Ka.warn(o.join(" "));
    return;
  }
  Xa(new ra(
    `${r}-version`,
    () => ({ library: r, version: t }),
    "VERSION"
    /* ComponentType.VERSION */
  ));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mL = "firebase-heartbeat-database", vL = 1, ic = "firebase-heartbeat-store";
let mv = null;
function dT() {
  return mv || (mv = Uh(mL, vL, {
    upgrade: (e, t) => {
      switch (t) {
        case 0:
          try {
            e.createObjectStore(ic);
          } catch (n) {
            console.warn(n);
          }
      }
    }
  }).catch((e) => {
    throw Qs.create("idb-open", {
      originalErrorMessage: e.message
    });
  })), mv;
}
async function gL(e) {
  try {
    const n = (await dT()).transaction(ic), i = await n.objectStore(ic).get(fT(e));
    return await n.done, i;
  } catch (t) {
    if (t instanceof Zl)
      Ka.warn(t.message);
    else {
      const n = Qs.create("idb-get", {
        originalErrorMessage: t == null ? void 0 : t.message
      });
      Ka.warn(n.message);
    }
  }
}
async function B0(e, t) {
  try {
    const i = (await dT()).transaction(ic, "readwrite");
    await i.objectStore(ic).put(t, fT(e)), await i.done;
  } catch (n) {
    if (n instanceof Zl)
      Ka.warn(n.message);
    else {
      const i = Qs.create("idb-set", {
        originalErrorMessage: n == null ? void 0 : n.message
      });
      Ka.warn(i.message);
    }
  }
}
function fT(e) {
  return `${e.name}!${e.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const pL = 1024, yL = 30 * 24 * 60 * 60 * 1e3;
class bL {
  constructor(t) {
    this.container = t, this._heartbeatsCache = null;
    const n = this.container.getProvider("app").getImmediate();
    this._storage = new _L(n), this._heartbeatsCachePromise = this._storage.read().then((i) => (this._heartbeatsCache = i, i));
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    var t, n;
    const r = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), s = L0();
    if (!(((t = this._heartbeatsCache) === null || t === void 0 ? void 0 : t.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise, ((n = this._heartbeatsCache) === null || n === void 0 ? void 0 : n.heartbeats) == null)) && !(this._heartbeatsCache.lastSentHeartbeatDate === s || this._heartbeatsCache.heartbeats.some((a) => a.date === s)))
      return this._heartbeatsCache.heartbeats.push({ date: s, agent: r }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((a) => {
        const o = new Date(a.date).valueOf();
        return Date.now() - o <= yL;
      }), this._storage.overwrite(this._heartbeatsCache);
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    var t;
    if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, ((t = this._heartbeatsCache) === null || t === void 0 ? void 0 : t.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0)
      return "";
    const n = L0(), { heartbeatsToSend: i, unsentEntries: r } = wL(this._heartbeatsCache.heartbeats), s = rT(JSON.stringify({ version: 2, heartbeats: i }));
    return this._heartbeatsCache.lastSentHeartbeatDate = n, r.length > 0 ? (this._heartbeatsCache.heartbeats = r, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), s;
  }
}
function L0() {
  return (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);
}
function wL(e, t = pL) {
  const n = [];
  let i = e.slice();
  for (const r of e) {
    const s = n.find((a) => a.agent === r.agent);
    if (s) {
      if (s.dates.push(r.date), $0(n) > t) {
        s.dates.pop();
        break;
      }
    } else if (n.push({
      agent: r.agent,
      dates: [r.date]
    }), $0(n) > t) {
      n.pop();
      break;
    }
    i = i.slice(1);
  }
  return {
    heartbeatsToSend: n,
    unsentEntries: i
  };
}
class _L {
  constructor(t) {
    this.app = t, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    return aT() ? oT().then(() => !0).catch(() => !1) : !1;
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    if (await this._canUseIndexedDBPromise) {
      const n = await gL(this.app);
      return n != null && n.heartbeats ? n : { heartbeats: [] };
    } else
      return { heartbeats: [] };
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(t) {
    var n;
    if (await this._canUseIndexedDBPromise) {
      const r = await this.read();
      return B0(this.app, {
        lastSentHeartbeatDate: (n = t.lastSentHeartbeatDate) !== null && n !== void 0 ? n : r.lastSentHeartbeatDate,
        heartbeats: t.heartbeats
      });
    } else
      return;
  }
  // add heartbeats
  async add(t) {
    var n;
    if (await this._canUseIndexedDBPromise) {
      const r = await this.read();
      return B0(this.app, {
        lastSentHeartbeatDate: (n = t.lastSentHeartbeatDate) !== null && n !== void 0 ? n : r.lastSentHeartbeatDate,
        heartbeats: [
          ...r.heartbeats,
          ...t.heartbeats
        ]
      });
    } else
      return;
  }
}
function $0(e) {
  return rT(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: e })
  ).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function SL(e) {
  Xa(new ra(
    "platform-logger",
    (t) => new RB(t),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), Xa(new ra(
    "heartbeat",
    (t) => new bL(t),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), ea(ug, R0, e), ea(ug, R0, "esm2017"), ea("fire-js", "");
}
SL("");
var kL = "firebase", CL = "10.12.1";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
ea(kL, CL, "app");
const hT = "@firebase/installations", ty = "0.6.7";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mT = 1e4, vT = `w:${ty}`, gT = "FIS_v2", TL = "https://firebaseinstallations.googleapis.com/v1", xL = 60 * 60 * 1e3, AL = "installations", IL = "Installations";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const EL = {
  "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
  "not-registered": "Firebase Installation is not registered.",
  "installation-not-found": "Firebase Installation not found.",
  "request-failed": '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
  "app-offline": "Could not process request. Application offline.",
  "delete-pending-registration": "Can't delete installation while there is a pending registration request."
}, Ja = new zh(AL, IL, EL);
function pT(e) {
  return e instanceof Zl && e.code.includes(
    "request-failed"
    /* ErrorCode.REQUEST_FAILED */
  );
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function yT({ projectId: e }) {
  return `${TL}/projects/${e}/installations`;
}
function bT(e) {
  return {
    token: e.token,
    requestStatus: 2,
    expiresIn: OL(e.expiresIn),
    creationTime: Date.now()
  };
}
async function wT(e, t) {
  const i = (await t.json()).error;
  return Ja.create("request-failed", {
    requestName: e,
    serverCode: i.code,
    serverMessage: i.message,
    serverStatus: i.status
  });
}
function _T({ apiKey: e }) {
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": e
  });
}
function PL(e, { refreshToken: t }) {
  const n = _T(e);
  return n.append("Authorization", VL(t)), n;
}
async function ST(e) {
  const t = await e();
  return t.status >= 500 && t.status < 600 ? e() : t;
}
function OL(e) {
  return Number(e.replace("s", "000"));
}
function VL(e) {
  return `${gT} ${e}`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function DL({ appConfig: e, heartbeatServiceProvider: t }, { fid: n }) {
  const i = yT(e), r = _T(e), s = t.getImmediate({
    optional: !0
  });
  if (s) {
    const u = await s.getHeartbeatsHeader();
    u && r.append("x-firebase-client", u);
  }
  const a = {
    fid: n,
    authVersion: gT,
    appId: e.appId,
    sdkVersion: vT
  }, o = {
    method: "POST",
    headers: r,
    body: JSON.stringify(a)
  }, l = await ST(() => fetch(i, o));
  if (l.ok) {
    const u = await l.json();
    return {
      fid: u.fid || n,
      registrationStatus: 2,
      refreshToken: u.refreshToken,
      authToken: bT(u.authToken)
    };
  } else
    throw await wT("Create Installation", l);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function kT(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function NL(e) {
  return btoa(String.fromCharCode(...e)).replace(/\+/g, "-").replace(/\//g, "_");
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ML = /^[cdef][\w-]{21}$/, fg = "";
function RL() {
  try {
    const e = new Uint8Array(17);
    (self.crypto || self.msCrypto).getRandomValues(e), e[0] = 112 + e[0] % 16;
    const n = FL(e);
    return ML.test(n) ? n : fg;
  } catch {
    return fg;
  }
}
function FL(e) {
  return NL(e).substr(0, 22);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function qh(e) {
  return `${e.appName}!${e.appId}`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CT = /* @__PURE__ */ new Map();
function TT(e, t) {
  const n = qh(e);
  xT(n, t), BL(n, t);
}
function xT(e, t) {
  const n = CT.get(e);
  if (n)
    for (const i of n)
      i(t);
}
function BL(e, t) {
  const n = LL();
  n && n.postMessage({ key: e, fid: t }), $L();
}
let La = null;
function LL() {
  return !La && "BroadcastChannel" in self && (La = new BroadcastChannel("[Firebase] FID Change"), La.onmessage = (e) => {
    xT(e.data.key, e.data.fid);
  }), La;
}
function $L() {
  CT.size === 0 && La && (La.close(), La = null);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WL = "firebase-installations-database", jL = 1, Qa = "firebase-installations-store";
let vv = null;
function ny() {
  return vv || (vv = Uh(WL, jL, {
    upgrade: (e, t) => {
      switch (t) {
        case 0:
          e.createObjectStore(Qa);
      }
    }
  })), vv;
}
async function Of(e, t) {
  const n = qh(e), r = (await ny()).transaction(Qa, "readwrite"), s = r.objectStore(Qa), a = await s.get(n);
  return await s.put(t, n), await r.done, (!a || a.fid !== t.fid) && TT(e, t.fid), t;
}
async function AT(e) {
  const t = qh(e), i = (await ny()).transaction(Qa, "readwrite");
  await i.objectStore(Qa).delete(t), await i.done;
}
async function Gh(e, t) {
  const n = qh(e), r = (await ny()).transaction(Qa, "readwrite"), s = r.objectStore(Qa), a = await s.get(n), o = t(a);
  return o === void 0 ? await s.delete(n) : await s.put(o, n), await r.done, o && (!a || a.fid !== o.fid) && TT(e, o.fid), o;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function iy(e) {
  let t;
  const n = await Gh(e.appConfig, (i) => {
    const r = HL(i), s = zL(e, r);
    return t = s.registrationPromise, s.installationEntry;
  });
  return n.fid === fg ? { installationEntry: await t } : {
    installationEntry: n,
    registrationPromise: t
  };
}
function HL(e) {
  const t = e || {
    fid: RL(),
    registrationStatus: 0
    /* RequestStatus.NOT_STARTED */
  };
  return IT(t);
}
function zL(e, t) {
  if (t.registrationStatus === 0) {
    if (!navigator.onLine) {
      const r = Promise.reject(Ja.create(
        "app-offline"
        /* ErrorCode.APP_OFFLINE */
      ));
      return {
        installationEntry: t,
        registrationPromise: r
      };
    }
    const n = {
      fid: t.fid,
      registrationStatus: 1,
      registrationTime: Date.now()
    }, i = UL(e, n);
    return { installationEntry: n, registrationPromise: i };
  } else
    return t.registrationStatus === 1 ? {
      installationEntry: t,
      registrationPromise: qL(e)
    } : { installationEntry: t };
}
async function UL(e, t) {
  try {
    const n = await DL(e, t);
    return Of(e.appConfig, n);
  } catch (n) {
    throw pT(n) && n.customData.serverCode === 409 ? await AT(e.appConfig) : await Of(e.appConfig, {
      fid: t.fid,
      registrationStatus: 0
      /* RequestStatus.NOT_STARTED */
    }), n;
  }
}
async function qL(e) {
  let t = await W0(e.appConfig);
  for (; t.registrationStatus === 1; )
    await kT(100), t = await W0(e.appConfig);
  if (t.registrationStatus === 0) {
    const { installationEntry: n, registrationPromise: i } = await iy(e);
    return i || n;
  }
  return t;
}
function W0(e) {
  return Gh(e, (t) => {
    if (!t)
      throw Ja.create(
        "installation-not-found"
        /* ErrorCode.INSTALLATION_NOT_FOUND */
      );
    return IT(t);
  });
}
function IT(e) {
  return GL(e) ? {
    fid: e.fid,
    registrationStatus: 0
    /* RequestStatus.NOT_STARTED */
  } : e;
}
function GL(e) {
  return e.registrationStatus === 1 && e.registrationTime + mT < Date.now();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function YL({ appConfig: e, heartbeatServiceProvider: t }, n) {
  const i = ZL(e, n), r = PL(e, n), s = t.getImmediate({
    optional: !0
  });
  if (s) {
    const u = await s.getHeartbeatsHeader();
    u && r.append("x-firebase-client", u);
  }
  const a = {
    installation: {
      sdkVersion: vT,
      appId: e.appId
    }
  }, o = {
    method: "POST",
    headers: r,
    body: JSON.stringify(a)
  }, l = await ST(() => fetch(i, o));
  if (l.ok) {
    const u = await l.json();
    return bT(u);
  } else
    throw await wT("Generate Auth Token", l);
}
function ZL(e, { fid: t }) {
  return `${yT(e)}/${t}/authTokens:generate`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function ry(e, t = !1) {
  let n;
  const i = await Gh(e.appConfig, (s) => {
    if (!ET(s))
      throw Ja.create(
        "not-registered"
        /* ErrorCode.NOT_REGISTERED */
      );
    const a = s.authToken;
    if (!t && JL(a))
      return s;
    if (a.requestStatus === 1)
      return n = KL(e, t), s;
    {
      if (!navigator.onLine)
        throw Ja.create(
          "app-offline"
          /* ErrorCode.APP_OFFLINE */
        );
      const o = e2(s);
      return n = XL(e, o), o;
    }
  });
  return n ? await n : i.authToken;
}
async function KL(e, t) {
  let n = await j0(e.appConfig);
  for (; n.authToken.requestStatus === 1; )
    await kT(100), n = await j0(e.appConfig);
  const i = n.authToken;
  return i.requestStatus === 0 ? ry(e, t) : i;
}
function j0(e) {
  return Gh(e, (t) => {
    if (!ET(t))
      throw Ja.create(
        "not-registered"
        /* ErrorCode.NOT_REGISTERED */
      );
    const n = t.authToken;
    return t2(n) ? Object.assign(Object.assign({}, t), { authToken: {
      requestStatus: 0
      /* RequestStatus.NOT_STARTED */
    } }) : t;
  });
}
async function XL(e, t) {
  try {
    const n = await YL(e, t), i = Object.assign(Object.assign({}, t), { authToken: n });
    return await Of(e.appConfig, i), n;
  } catch (n) {
    if (pT(n) && (n.customData.serverCode === 401 || n.customData.serverCode === 404))
      await AT(e.appConfig);
    else {
      const i = Object.assign(Object.assign({}, t), { authToken: {
        requestStatus: 0
        /* RequestStatus.NOT_STARTED */
      } });
      await Of(e.appConfig, i);
    }
    throw n;
  }
}
function ET(e) {
  return e !== void 0 && e.registrationStatus === 2;
}
function JL(e) {
  return e.requestStatus === 2 && !QL(e);
}
function QL(e) {
  const t = Date.now();
  return t < e.creationTime || e.creationTime + e.expiresIn < t + xL;
}
function e2(e) {
  const t = {
    requestStatus: 1,
    requestTime: Date.now()
  };
  return Object.assign(Object.assign({}, e), { authToken: t });
}
function t2(e) {
  return e.requestStatus === 1 && e.requestTime + mT < Date.now();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function n2(e) {
  const t = e, { installationEntry: n, registrationPromise: i } = await iy(t);
  return i ? i.catch(console.error) : ry(t).catch(console.error), n.fid;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function i2(e, t = !1) {
  const n = e;
  return await r2(n), (await ry(n, t)).token;
}
async function r2(e) {
  const { registrationPromise: t } = await iy(e);
  t && await t;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function s2(e) {
  if (!e || !e.options)
    throw gv("App Configuration");
  if (!e.name)
    throw gv("App Name");
  const t = [
    "projectId",
    "apiKey",
    "appId"
  ];
  for (const n of t)
    if (!e.options[n])
      throw gv(n);
  return {
    appName: e.name,
    projectId: e.options.projectId,
    apiKey: e.options.apiKey,
    appId: e.options.appId
  };
}
function gv(e) {
  return Ja.create("missing-app-config-values", {
    valueName: e
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PT = "installations", a2 = "installations-internal", o2 = (e) => {
  const t = e.getProvider("app").getImmediate(), n = s2(t), i = ey(t, "heartbeat");
  return {
    app: t,
    appConfig: n,
    heartbeatServiceProvider: i,
    _delete: () => Promise.resolve()
  };
}, l2 = (e) => {
  const t = e.getProvider("app").getImmediate(), n = ey(t, PT).getImmediate();
  return {
    getId: () => n2(n),
    getToken: (r) => i2(n, r)
  };
};
function u2() {
  Xa(new ra(
    PT,
    o2,
    "PUBLIC"
    /* ComponentType.PUBLIC */
  )), Xa(new ra(
    a2,
    l2,
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ));
}
u2();
ea(hT, ty);
ea(hT, ty, "esm2017");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const c2 = "/firebase-messaging-sw.js", d2 = "/firebase-cloud-messaging-push-scope", OT = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4", f2 = "https://fcmregistrations.googleapis.com/v1", VT = "google.c.a.c_id", h2 = "google.c.a.c_l", m2 = "google.c.a.ts", v2 = "google.c.a.e";
var H0;
(function(e) {
  e[e.DATA_MESSAGE = 1] = "DATA_MESSAGE", e[e.DISPLAY_NOTIFICATION = 3] = "DISPLAY_NOTIFICATION";
})(H0 || (H0 = {}));
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
var rc;
(function(e) {
  e.PUSH_RECEIVED = "push-received", e.NOTIFICATION_CLICKED = "notification-clicked";
})(rc || (rc = {}));
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function fs(e) {
  const t = new Uint8Array(e);
  return btoa(String.fromCharCode(...t)).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function g2(e) {
  const t = "=".repeat((4 - e.length % 4) % 4), n = (e + t).replace(/\-/g, "+").replace(/_/g, "/"), i = atob(n), r = new Uint8Array(i.length);
  for (let s = 0; s < i.length; ++s)
    r[s] = i.charCodeAt(s);
  return r;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const pv = "fcm_token_details_db", p2 = 5, z0 = "fcm_token_object_Store";
async function y2(e) {
  if ("databases" in indexedDB && !(await indexedDB.databases()).map((s) => s.name).includes(pv))
    return null;
  let t = null;
  return (await Uh(pv, p2, {
    upgrade: async (i, r, s, a) => {
      var o;
      if (r < 2 || !i.objectStoreNames.contains(z0))
        return;
      const l = a.objectStore(z0), u = await l.index("fcmSenderId").get(e);
      if (await l.clear(), !!u) {
        if (r === 2) {
          const c = u;
          if (!c.auth || !c.p256dh || !c.endpoint)
            return;
          t = {
            token: c.fcmToken,
            createTime: (o = c.createTime) !== null && o !== void 0 ? o : Date.now(),
            subscriptionOptions: {
              auth: c.auth,
              p256dh: c.p256dh,
              endpoint: c.endpoint,
              swScope: c.swScope,
              vapidKey: typeof c.vapidKey == "string" ? c.vapidKey : fs(c.vapidKey)
            }
          };
        } else if (r === 3) {
          const c = u;
          t = {
            token: c.fcmToken,
            createTime: c.createTime,
            subscriptionOptions: {
              auth: fs(c.auth),
              p256dh: fs(c.p256dh),
              endpoint: c.endpoint,
              swScope: c.swScope,
              vapidKey: fs(c.vapidKey)
            }
          };
        } else if (r === 4) {
          const c = u;
          t = {
            token: c.fcmToken,
            createTime: c.createTime,
            subscriptionOptions: {
              auth: fs(c.auth),
              p256dh: fs(c.p256dh),
              endpoint: c.endpoint,
              swScope: c.swScope,
              vapidKey: fs(c.vapidKey)
            }
          };
        }
      }
    }
  })).close(), await fv(pv), await fv("fcm_vapid_details_db"), await fv("undefined"), b2(t) ? t : null;
}
function b2(e) {
  if (!e || !e.subscriptionOptions)
    return !1;
  const { subscriptionOptions: t } = e;
  return typeof e.createTime == "number" && e.createTime > 0 && typeof e.token == "string" && e.token.length > 0 && typeof t.auth == "string" && t.auth.length > 0 && typeof t.p256dh == "string" && t.p256dh.length > 0 && typeof t.endpoint == "string" && t.endpoint.length > 0 && typeof t.swScope == "string" && t.swScope.length > 0 && typeof t.vapidKey == "string" && t.vapidKey.length > 0;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const w2 = "firebase-messaging-database", _2 = 1, sc = "firebase-messaging-store";
let yv = null;
function DT() {
  return yv || (yv = Uh(w2, _2, {
    upgrade: (e, t) => {
      switch (t) {
        case 0:
          e.createObjectStore(sc);
      }
    }
  })), yv;
}
async function S2(e) {
  const t = NT(e), i = await (await DT()).transaction(sc).objectStore(sc).get(t);
  if (i)
    return i;
  {
    const r = await y2(e.appConfig.senderId);
    if (r)
      return await sy(e, r), r;
  }
}
async function sy(e, t) {
  const n = NT(e), r = (await DT()).transaction(sc, "readwrite");
  return await r.objectStore(sc).put(t, n), await r.done, t;
}
function NT({ appConfig: e }) {
  return e.appId;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const k2 = {
  "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
  "only-available-in-window": "This method is available in a Window context.",
  "only-available-in-sw": "This method is available in a service worker context.",
  "permission-default": "The notification permission was not granted and dismissed instead.",
  "permission-blocked": "The notification permission was not granted and blocked instead.",
  "unsupported-browser": "This browser doesn't support the API's required to use the Firebase SDK.",
  "indexed-db-unsupported": "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)",
  "failed-service-worker-registration": "We are unable to register the default service worker. {$browserErrorMessage}",
  "token-subscribe-failed": "A problem occurred while subscribing the user to FCM: {$errorInfo}",
  "token-subscribe-no-token": "FCM returned no token when subscribing the user to push.",
  "token-unsubscribe-failed": "A problem occurred while unsubscribing the user from FCM: {$errorInfo}",
  "token-update-failed": "A problem occurred while updating the user from FCM: {$errorInfo}",
  "token-update-no-token": "FCM returned no token when updating the user to push.",
  "use-sw-after-get-token": "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.",
  "invalid-sw-registration": "The input to useServiceWorker() must be a ServiceWorkerRegistration.",
  "invalid-bg-handler": "The input to setBackgroundMessageHandler() must be a function.",
  "invalid-vapid-key": "The public VAPID key must be a string.",
  "use-vapid-key-after-get-token": "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used."
}, Yn = new zh("messaging", "Messaging", k2);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function C2(e, t) {
  const n = await oy(e), i = MT(t), r = {
    method: "POST",
    headers: n,
    body: JSON.stringify(i)
  };
  let s;
  try {
    s = await (await fetch(ay(e.appConfig), r)).json();
  } catch (a) {
    throw Yn.create("token-subscribe-failed", {
      errorInfo: a == null ? void 0 : a.toString()
    });
  }
  if (s.error) {
    const a = s.error.message;
    throw Yn.create("token-subscribe-failed", {
      errorInfo: a
    });
  }
  if (!s.token)
    throw Yn.create(
      "token-subscribe-no-token"
      /* ErrorCode.TOKEN_SUBSCRIBE_NO_TOKEN */
    );
  return s.token;
}
async function T2(e, t) {
  const n = await oy(e), i = MT(t.subscriptionOptions), r = {
    method: "PATCH",
    headers: n,
    body: JSON.stringify(i)
  };
  let s;
  try {
    s = await (await fetch(`${ay(e.appConfig)}/${t.token}`, r)).json();
  } catch (a) {
    throw Yn.create("token-update-failed", {
      errorInfo: a == null ? void 0 : a.toString()
    });
  }
  if (s.error) {
    const a = s.error.message;
    throw Yn.create("token-update-failed", {
      errorInfo: a
    });
  }
  if (!s.token)
    throw Yn.create(
      "token-update-no-token"
      /* ErrorCode.TOKEN_UPDATE_NO_TOKEN */
    );
  return s.token;
}
async function x2(e, t) {
  const i = {
    method: "DELETE",
    headers: await oy(e)
  };
  try {
    const s = await (await fetch(`${ay(e.appConfig)}/${t}`, i)).json();
    if (s.error) {
      const a = s.error.message;
      throw Yn.create("token-unsubscribe-failed", {
        errorInfo: a
      });
    }
  } catch (r) {
    throw Yn.create("token-unsubscribe-failed", {
      errorInfo: r == null ? void 0 : r.toString()
    });
  }
}
function ay({ projectId: e }) {
  return `${f2}/projects/${e}/registrations`;
}
async function oy({ appConfig: e, installations: t }) {
  const n = await t.getToken();
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": e.apiKey,
    "x-goog-firebase-installations-auth": `FIS ${n}`
  });
}
function MT({ p256dh: e, auth: t, endpoint: n, vapidKey: i }) {
  const r = {
    web: {
      endpoint: n,
      auth: t,
      p256dh: e
    }
  };
  return i !== OT && (r.web.applicationPubKey = i), r;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const A2 = 7 * 24 * 60 * 60 * 1e3;
async function I2(e) {
  const t = await P2(e.swRegistration, e.vapidKey), n = {
    vapidKey: e.vapidKey,
    swScope: e.swRegistration.scope,
    endpoint: t.endpoint,
    auth: fs(t.getKey("auth")),
    p256dh: fs(t.getKey("p256dh"))
  }, i = await S2(e.firebaseDependencies);
  if (i) {
    if (O2(i.subscriptionOptions, n))
      return Date.now() >= i.createTime + A2 ? E2(e, {
        token: i.token,
        createTime: Date.now(),
        subscriptionOptions: n
      }) : i.token;
    try {
      await x2(e.firebaseDependencies, i.token);
    } catch (r) {
      console.warn(r);
    }
    return U0(e.firebaseDependencies, n);
  } else
    return U0(e.firebaseDependencies, n);
}
async function E2(e, t) {
  try {
    const n = await T2(e.firebaseDependencies, t), i = Object.assign(Object.assign({}, t), { token: n, createTime: Date.now() });
    return await sy(e.firebaseDependencies, i), n;
  } catch (n) {
    throw n;
  }
}
async function U0(e, t) {
  const i = {
    token: await C2(e, t),
    createTime: Date.now(),
    subscriptionOptions: t
  };
  return await sy(e, i), i.token;
}
async function P2(e, t) {
  const n = await e.pushManager.getSubscription();
  return n || e.pushManager.subscribe({
    userVisibleOnly: !0,
    // Chrome <= 75 doesn't support base64-encoded VAPID key. For backward compatibility, VAPID key
    // submitted to pushManager#subscribe must be of type Uint8Array.
    applicationServerKey: g2(t)
  });
}
function O2(e, t) {
  const n = t.vapidKey === e.vapidKey, i = t.endpoint === e.endpoint, r = t.auth === e.auth, s = t.p256dh === e.p256dh;
  return n && i && r && s;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function q0(e) {
  const t = {
    from: e.from,
    // eslint-disable-next-line camelcase
    collapseKey: e.collapse_key,
    // eslint-disable-next-line camelcase
    messageId: e.fcmMessageId
  };
  return V2(t, e), D2(t, e), N2(t, e), t;
}
function V2(e, t) {
  if (!t.notification)
    return;
  e.notification = {};
  const n = t.notification.title;
  n && (e.notification.title = n);
  const i = t.notification.body;
  i && (e.notification.body = i);
  const r = t.notification.image;
  r && (e.notification.image = r);
  const s = t.notification.icon;
  s && (e.notification.icon = s);
}
function D2(e, t) {
  t.data && (e.data = t.data);
}
function N2(e, t) {
  var n, i, r, s, a;
  if (!t.fcmOptions && !(!((n = t.notification) === null || n === void 0) && n.click_action))
    return;
  e.fcmOptions = {};
  const o = (r = (i = t.fcmOptions) === null || i === void 0 ? void 0 : i.link) !== null && r !== void 0 ? r : (s = t.notification) === null || s === void 0 ? void 0 : s.click_action;
  o && (e.fcmOptions.link = o);
  const l = (a = t.fcmOptions) === null || a === void 0 ? void 0 : a.analytics_label;
  l && (e.fcmOptions.analyticsLabel = l);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function M2(e) {
  return typeof e == "object" && !!e && VT in e;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
RT("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o");
RT("AzSCbw63g1R0nCw85jG8", "Iaya3yLKwmgvh7cF0q4");
function RT(e, t) {
  const n = [];
  for (let i = 0; i < e.length; i++)
    n.push(e.charAt(i)), i < t.length && n.push(t.charAt(i));
  return n.join("");
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function R2(e) {
  if (!e || !e.options)
    throw bv("App Configuration Object");
  if (!e.name)
    throw bv("App Name");
  const t = [
    "projectId",
    "apiKey",
    "appId",
    "messagingSenderId"
  ], { options: n } = e;
  for (const i of t)
    if (!n[i])
      throw bv(i);
  return {
    appName: e.name,
    projectId: n.projectId,
    apiKey: n.apiKey,
    appId: n.appId,
    senderId: n.messagingSenderId
  };
}
function bv(e) {
  return Yn.create("missing-app-config-values", {
    valueName: e
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class F2 {
  constructor(t, n, i) {
    this.deliveryMetricsExportedToBigQueryEnabled = !1, this.onBackgroundMessageHandler = null, this.onMessageHandler = null, this.logEvents = [], this.isLogServiceStarted = !1;
    const r = R2(t);
    this.firebaseDependencies = {
      app: t,
      appConfig: r,
      installations: n,
      analyticsProvider: i
    };
  }
  _delete() {
    return Promise.resolve();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function B2(e) {
  try {
    e.swRegistration = await navigator.serviceWorker.register(c2, {
      scope: d2
    }), e.swRegistration.update().catch(() => {
    });
  } catch (t) {
    throw Yn.create("failed-service-worker-registration", {
      browserErrorMessage: t == null ? void 0 : t.message
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function L2(e, t) {
  if (!t && !e.swRegistration && await B2(e), !(!t && e.swRegistration)) {
    if (!(t instanceof ServiceWorkerRegistration))
      throw Yn.create(
        "invalid-sw-registration"
        /* ErrorCode.INVALID_SW_REGISTRATION */
      );
    e.swRegistration = t;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function $2(e, t) {
  t ? e.vapidKey = t : e.vapidKey || (e.vapidKey = OT);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function FT(e, t) {
  if (!navigator)
    throw Yn.create(
      "only-available-in-window"
      /* ErrorCode.AVAILABLE_IN_WINDOW */
    );
  if (Notification.permission === "default" && await Notification.requestPermission(), Notification.permission !== "granted")
    throw Yn.create(
      "permission-blocked"
      /* ErrorCode.PERMISSION_BLOCKED */
    );
  return await $2(e, t == null ? void 0 : t.vapidKey), await L2(e, t == null ? void 0 : t.serviceWorkerRegistration), I2(e);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function W2(e, t, n) {
  const i = j2(t);
  (await e.firebaseDependencies.analyticsProvider.get()).logEvent(i, {
    /* eslint-disable camelcase */
    message_id: n[VT],
    message_name: n[h2],
    message_time: n[m2],
    message_device_time: Math.floor(Date.now() / 1e3)
    /* eslint-enable camelcase */
  });
}
function j2(e) {
  switch (e) {
    case rc.NOTIFICATION_CLICKED:
      return "notification_open";
    case rc.PUSH_RECEIVED:
      return "notification_foreground";
    default:
      throw new Error();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function H2(e, t) {
  const n = t.data;
  if (!n.isFirebaseMessaging)
    return;
  e.onMessageHandler && n.messageType === rc.PUSH_RECEIVED && (typeof e.onMessageHandler == "function" ? e.onMessageHandler(q0(n)) : e.onMessageHandler.next(q0(n)));
  const i = n.data;
  M2(i) && i[v2] === "1" && await W2(e, n.messageType, i);
}
const G0 = "@firebase/messaging", Y0 = "0.12.9";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const z2 = (e) => {
  const t = new F2(e.getProvider("app").getImmediate(), e.getProvider("installations-internal").getImmediate(), e.getProvider("analytics-internal"));
  return navigator.serviceWorker.addEventListener("message", (n) => H2(t, n)), t;
}, U2 = (e) => {
  const t = e.getProvider("messaging").getImmediate();
  return {
    getToken: (i) => FT(t, i)
  };
};
function q2() {
  Xa(new ra(
    "messaging",
    z2,
    "PUBLIC"
    /* ComponentType.PUBLIC */
  )), Xa(new ra(
    "messaging-internal",
    U2,
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), ea(G0, Y0), ea(G0, Y0, "esm2017");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function G2() {
  try {
    await oT();
  } catch {
    return !1;
  }
  return typeof window < "u" && aT() && hB() && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Y2(e, t) {
  if (!navigator)
    throw Yn.create(
      "only-available-in-window"
      /* ErrorCode.AVAILABLE_IN_WINDOW */
    );
  return e.onMessageHandler = t, () => {
    e.onMessageHandler = null;
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Z2(e = hL()) {
  return G2().then((t) => {
    if (!t)
      throw Yn.create(
        "unsupported-browser"
        /* ErrorCode.UNSUPPORTED_BROWSER */
      );
  }, (t) => {
    throw Yn.create(
      "indexed-db-unsupported"
      /* ErrorCode.INDEXED_DB_UNSUPPORTED */
    );
  }), ey(Jp(e), "messaging").getImmediate();
}
async function K2(e, t) {
  return e = Jp(e), FT(e, t);
}
function X2(e, t) {
  return e = Jp(e), Y2(e, t);
}
q2();
var BT = { exports: {} };
/**
 * @license
 *
 * Push v1.0.9
 * =========
 * A compact, cross-browser solution for the JavaScript Notifications API
 *
 * Credits
 * -------
 * Tsvetan Tsvetkov (ttsvetko)
 * Alex Gibson (alexgibson)
 *
 * License
 * -------
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-2017 Tyler Nickerson
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
(function(e, t) {
  (function(n, i) {
    e.exports = i();
  })(nl, function() {
    var n = { errors: { incompatible: "".concat("PushError:", " Push.js is incompatible with browser."), invalid_plugin: "".concat("PushError:", " plugin class missing from plugin manifest (invalid plugin). Please check the documentation."), invalid_title: "".concat("PushError:", " title of notification must be a string"), permission_denied: "".concat("PushError:", " permission request declined"), sw_notification_error: "".concat("PushError:", " could not show a ServiceWorker notification due to the following reason: "), sw_registration_error: "".concat("PushError:", " could not register the ServiceWorker due to the following reason: "), unknown_interface: "".concat("PushError:", " unable to create notification: unknown interface") } };
    function i(T) {
      return (i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(_) {
        return typeof _;
      } : function(_) {
        return _ && typeof Symbol == "function" && _.constructor === Symbol && _ !== Symbol.prototype ? "symbol" : typeof _;
      })(T);
    }
    function r(T, _) {
      if (!(T instanceof _))
        throw new TypeError("Cannot call a class as a function");
    }
    function s(T, _) {
      for (var w = 0; w < _.length; w++) {
        var S = _[w];
        S.enumerable = S.enumerable || !1, S.configurable = !0, "value" in S && (S.writable = !0), Object.defineProperty(T, S.key, S);
      }
    }
    function a(T, _, w) {
      return _ && s(T.prototype, _), w && s(T, w), T;
    }
    function o(T, _) {
      if (typeof _ != "function" && _ !== null)
        throw new TypeError("Super expression must either be null or a function");
      T.prototype = Object.create(_ && _.prototype, { constructor: { value: T, writable: !0, configurable: !0 } }), _ && u(T, _);
    }
    function l(T) {
      return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(_) {
        return _.__proto__ || Object.getPrototypeOf(_);
      })(T);
    }
    function u(T, _) {
      return (u = Object.setPrototypeOf || function(w, S) {
        return w.__proto__ = S, w;
      })(T, _);
    }
    function c(T, _) {
      return !_ || typeof _ != "object" && typeof _ != "function" ? function(w) {
        if (w === void 0)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return w;
      }(T) : _;
    }
    var d = function() {
      function T(_) {
        r(this, T), this._win = _, this.GRANTED = "granted", this.DEFAULT = "default", this.DENIED = "denied", this._permissions = [this.GRANTED, this.DEFAULT, this.DENIED];
      }
      return a(T, [{ key: "request", value: function(_, w) {
        return arguments.length > 0 ? this._requestWithCallback.apply(this, arguments) : this._requestAsPromise();
      } }, { key: "_requestWithCallback", value: function(_, w) {
        var S, C = this, x = this.get(), A = !1, I = function() {
          var E = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : C._win.Notification.permission;
          A || (A = !0, E === void 0 && C._win.webkitNotifications && (E = C._win.webkitNotifications.checkPermission()), E === C.GRANTED || E === 0 ? _ && _() : w && w());
        };
        x !== this.DEFAULT ? I(x) : this._win.webkitNotifications && this._win.webkitNotifications.checkPermission ? this._win.webkitNotifications.requestPermission(I) : this._win.Notification && this._win.Notification.requestPermission ? (S = this._win.Notification.requestPermission(I)) && S.then && S.then(I).catch(function() {
          w && w();
        }) : _ && _();
      } }, { key: "_requestAsPromise", value: function() {
        var _ = this, w = this.get(), S = w !== this.DEFAULT, C = this._win.Notification && this._win.Notification.requestPermission, x = this._win.webkitNotifications && this._win.webkitNotifications.checkPermission;
        return new Promise(function(A, I) {
          var E, P = !1, V = function(N) {
            P || (P = !0, function(F) {
              return F === _.GRANTED || F === 0;
            }(N) ? A() : I());
          };
          S ? V(w) : x ? _._win.webkitNotifications.requestPermission(function(N) {
            V(N);
          }) : C ? (E = _._win.Notification.requestPermission(V)) && E.then && E.then(V).catch(I) : A();
        });
      } }, { key: "has", value: function() {
        return this.get() === this.GRANTED;
      } }, { key: "get", value: function() {
        return this._win.Notification && this._win.Notification.permission ? this._win.Notification.permission : this._win.webkitNotifications && this._win.webkitNotifications.checkPermission ? this._permissions[this._win.webkitNotifications.checkPermission()] : navigator.mozNotification ? this.GRANTED : this._win.external && this._win.external.msIsSiteMode ? this._win.external.msIsSiteMode() ? this.GRANTED : this.DEFAULT : this.GRANTED;
      } }]), T;
    }(), f = function() {
      function T() {
        r(this, T);
      }
      return a(T, null, [{ key: "isUndefined", value: function(_) {
        return _ === void 0;
      } }, { key: "isNull", value: function(_) {
        return obj === null;
      } }, { key: "isString", value: function(_) {
        return typeof _ == "string";
      } }, { key: "isFunction", value: function(_) {
        return _ && {}.toString.call(_) === "[object Function]";
      } }, { key: "isObject", value: function(_) {
        return i(_) === "object";
      } }, { key: "objectMerge", value: function(_, w) {
        for (var S in w)
          _.hasOwnProperty(S) && this.isObject(_[S]) && this.isObject(w[S]) ? this.objectMerge(_[S], w[S]) : _[S] = w[S];
      } }]), T;
    }(), h = function T(_) {
      r(this, T), this._win = _;
    }, m = function(T) {
      function _() {
        return r(this, _), c(this, l(_).apply(this, arguments));
      }
      return o(_, h), a(_, [{ key: "isSupported", value: function() {
        return this._win.Notification !== void 0;
      } }, { key: "create", value: function(w, S) {
        return new this._win.Notification(w, { icon: f.isString(S.icon) || f.isUndefined(S.icon) || f.isNull(S.icon) ? S.icon : S.icon.x32, body: S.body, tag: S.tag, requireInteraction: S.requireInteraction });
      } }, { key: "close", value: function(w) {
        w.close();
      } }]), _;
    }(), g = function(T) {
      function _() {
        return r(this, _), c(this, l(_).apply(this, arguments));
      }
      return o(_, h), a(_, [{ key: "isSupported", value: function() {
        return this._win.navigator !== void 0 && this._win.navigator.serviceWorker !== void 0;
      } }, { key: "getFunctionBody", value: function(w) {
        var S = w.toString().match(/function[^{]+{([\s\S]*)}$/);
        return S != null && S.length > 1 ? S[1] : null;
      } }, { key: "create", value: function(w, S, C, x, A) {
        var I = this;
        this._win.navigator.serviceWorker.register(x), this._win.navigator.serviceWorker.ready.then(function(E) {
          var P = { id: w, link: C.link, origin: document.location.href, onClick: f.isFunction(C.onClick) ? I.getFunctionBody(C.onClick) : "", onClose: f.isFunction(C.onClose) ? I.getFunctionBody(C.onClose) : "" };
          C.data !== void 0 && C.data !== null && (P = Object.assign(P, C.data)), E.showNotification(S, { icon: C.icon, body: C.body, vibrate: C.vibrate, tag: C.tag, data: P, requireInteraction: C.requireInteraction, silent: C.silent }).then(function() {
            E.getNotifications().then(function(V) {
              E.active.postMessage(""), A(V);
            });
          }).catch(function(V) {
            throw new Error(n.errors.sw_notification_error + V.message);
          });
        }).catch(function(E) {
          throw new Error(n.errors.sw_registration_error + E.message);
        });
      } }, { key: "close", value: function() {
      } }]), _;
    }(), p = function(T) {
      function _() {
        return r(this, _), c(this, l(_).apply(this, arguments));
      }
      return o(_, h), a(_, [{ key: "isSupported", value: function() {
        return this._win.navigator.mozNotification !== void 0;
      } }, { key: "create", value: function(w, S) {
        var C = this._win.navigator.mozNotification.createNotification(w, S.body, S.icon);
        return C.show(), C;
      } }]), _;
    }(), y = function(T) {
      function _() {
        return r(this, _), c(this, l(_).apply(this, arguments));
      }
      return o(_, h), a(_, [{ key: "isSupported", value: function() {
        return this._win.external !== void 0 && this._win.external.msIsSiteMode !== void 0;
      } }, { key: "create", value: function(w, S) {
        return this._win.external.msSiteModeClearIconOverlay(), this._win.external.msSiteModeSetIconOverlay(f.isString(S.icon) || f.isUndefined(S.icon) ? S.icon : S.icon.x16, w), this._win.external.msSiteModeActivate(), null;
      } }, { key: "close", value: function() {
        this._win.external.msSiteModeClearIconOverlay();
      } }]), _;
    }(), k = function(T) {
      function _() {
        return r(this, _), c(this, l(_).apply(this, arguments));
      }
      return o(_, h), a(_, [{ key: "isSupported", value: function() {
        return this._win.webkitNotifications !== void 0;
      } }, { key: "create", value: function(w, S) {
        var C = this._win.webkitNotifications.createNotification(S.icon, w, S.body);
        return C.show(), C;
      } }, { key: "close", value: function(w) {
        w.cancel();
      } }]), _;
    }();
    return new (function() {
      function T(_) {
        r(this, T), this._currentId = 0, this._notifications = {}, this._win = _, this.Permission = new d(_), this._agents = { desktop: new m(_), chrome: new g(_), firefox: new p(_), ms: new y(_), webkit: new k(_) }, this._configuration = { serviceWorker: "/serviceWorker.min.js", fallback: function(w) {
        } };
      }
      return a(T, [{ key: "_closeNotification", value: function(_) {
        var w = !0, S = this._notifications[_];
        if (S !== void 0) {
          if (w = this._removeNotification(_), this._agents.desktop.isSupported())
            this._agents.desktop.close(S);
          else if (this._agents.webkit.isSupported())
            this._agents.webkit.close(S);
          else {
            if (!this._agents.ms.isSupported())
              throw w = !1, new Error(n.errors.unknown_interface);
            this._agents.ms.close();
          }
          return w;
        }
        return !1;
      } }, { key: "_addNotification", value: function(_) {
        var w = this._currentId;
        return this._notifications[w] = _, this._currentId++, w;
      } }, { key: "_removeNotification", value: function(_) {
        var w = !1;
        return this._notifications.hasOwnProperty(_) && (delete this._notifications[_], w = !0), w;
      } }, { key: "_prepareNotification", value: function(_, w) {
        var S, C = this;
        return S = { get: function() {
          return C._notifications[_];
        }, close: function() {
          C._closeNotification(_);
        } }, w.timeout && setTimeout(function() {
          S.close();
        }, w.timeout), S;
      } }, { key: "_serviceWorkerCallback", value: function(_, w, S) {
        var C = this, x = this._addNotification(_[_.length - 1]);
        navigator && navigator.serviceWorker && (navigator.serviceWorker.addEventListener("message", function(A) {
          var I = JSON.parse(A.data);
          I.action === "close" && Number.isInteger(I.id) && C._removeNotification(I.id);
        }), S(this._prepareNotification(x, w))), S(null);
      } }, { key: "_createCallback", value: function(_, w, S) {
        var C, x = this, A = null;
        if (w = w || {}, C = function(N) {
          x._removeNotification(N), f.isFunction(w.onClose) && w.onClose.call(x, A);
        }, this._agents.desktop.isSupported())
          try {
            A = this._agents.desktop.create(_, w);
          } catch {
            var I = this._currentId, E = this.config().serviceWorker;
            this._agents.chrome.isSupported() && this._agents.chrome.create(I, _, w, E, function(F) {
              return x._serviceWorkerCallback(F, w, S);
            });
          }
        else
          this._agents.webkit.isSupported() ? A = this._agents.webkit.create(_, w) : this._agents.firefox.isSupported() ? this._agents.firefox.create(_, w) : this._agents.ms.isSupported() ? A = this._agents.ms.create(_, w) : (w.title = _, this.config().fallback(w));
        if (A !== null) {
          var P = this._addNotification(A), V = this._prepareNotification(P, w);
          f.isFunction(w.onShow) && A.addEventListener("show", w.onShow), f.isFunction(w.onError) && A.addEventListener("error", w.onError), f.isFunction(w.onClick) && A.addEventListener("click", w.onClick), A.addEventListener("close", function() {
            C(P);
          }), A.addEventListener("cancel", function() {
            C(P);
          }), S(V);
        }
        S(null);
      } }, { key: "create", value: function(_, w) {
        var S, C = this;
        if (!f.isString(_))
          throw new Error(n.errors.invalid_title);
        return S = this.Permission.has() ? function(x, A) {
          try {
            C._createCallback(_, w, x);
          } catch (I) {
            A(I);
          }
        } : function(x, A) {
          C.Permission.request().then(function() {
            C._createCallback(_, w, x);
          }).catch(function() {
            A(n.errors.permission_denied);
          });
        }, new Promise(S);
      } }, { key: "count", value: function() {
        var _, w = 0;
        for (_ in this._notifications)
          this._notifications.hasOwnProperty(_) && w++;
        return w;
      } }, { key: "close", value: function(_) {
        var w;
        for (w in this._notifications)
          if (this._notifications.hasOwnProperty(w) && this._notifications[w].tag === _)
            return this._closeNotification(w);
      } }, { key: "clear", value: function() {
        var _, w = !0;
        for (_ in this._notifications)
          this._notifications.hasOwnProperty(_) && (w = w && this._closeNotification(_));
        return w;
      } }, { key: "supported", value: function() {
        var _ = !1;
        for (var w in this._agents)
          this._agents.hasOwnProperty(w) && (_ = _ || this._agents[w].isSupported());
        return _;
      } }, { key: "config", value: function(_) {
        return (_ !== void 0 || _ !== null && f.isObject(_)) && f.objectMerge(this._configuration, _), this._configuration;
      } }, { key: "extend", value: function(_) {
        var w, S = {}.hasOwnProperty;
        if (!S.call(_, "plugin"))
          throw new Error(n.errors.invalid_plugin);
        for (var C in S.call(_, "config") && f.isObject(_.config) && _.config !== null && this.config(_.config), w = new _.plugin(this.config()))
          S.call(w, C) && f.isFunction(w[C]) && (this[C] = w[C]);
      } }]), T;
    }())(typeof window < "u" ? window : nl);
  });
})(BT);
var J2 = BT.exports;
const Ca = /* @__PURE__ */ jp(J2);
var ly = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, ge = (e, t, n) => (ly(e, t, "read from private field"), n ? n.call(e) : t.get(e)), mt = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, Ot = (e, t, n, i) => (ly(e, t, "write to private field"), i ? i.call(e, n) : t.set(e, n), n), Fn = (e, t, n) => (ly(e, t, "access private method"), n), Ta, Tn, qi, Iu, Wu, Uo, Ea, $i, fr, Pa, Oa, tf, nf, Vf, Df, qo, Go, Zs, Eu, Pu, Ou, Vu, Du, vs, Nu, Sl, ac, oc, Nf, Yo, Mu, rf, hg, sf, mg, af, vg;
const cn = Is("Push"), xn = Is("Firebase", "#1B3A57", "#FFCA28"), as = Is("Service Worker");
class Q2 {
  /**
   * Create a new PushService instance.
   * @param bus The BusService instance to use for communication
   * @param ls The LocalStorageService instance to use for storing and retrieving preferences and tokens
   * @param cron The MiliCron instance to use for scheduling updates
   * @param identity The IdentityService instance to use for determining if the user is authenticated
   * @param firebaseOptions The options to use for initializing Firebase
   * @param onAuthenticatedForFirebase The callback to use for storing the Firebase Messaging Token in an external service when the user is authenticated
   * @param onUnauthenticatedForFirebase The callback to use for removing the Firebase Messaging Token from an external service when the user is unauthenticated
   * @param serviceWorkerPath The path to the service worker to use for handling push notifications
   * @param serviceWorkerMode The mode to use for the service worker
   */
  constructor(t, n, i, r, s, a, o, l, u) {
    if (mt(this, Sl), mt(this, oc), mt(this, Yo), mt(this, rf), mt(this, sf), mt(this, af), mt(this, Ta, void 0), mt(this, Tn, void 0), mt(this, qi, void 0), mt(this, Iu, void 0), mt(this, Wu, void 0), mt(this, Uo, void 0), mt(this, Ea, void 0), mt(this, $i, void 0), mt(this, fr, void 0), mt(this, Pa, void 0), mt(this, Oa, void 0), mt(this, tf, void 0), mt(this, nf, void 0), mt(this, Vf, void 0), mt(this, Df, void 0), mt(this, qo, void 0), mt(this, Go, void 0), mt(this, Zs, void 0), mt(this, Eu, void 0), mt(this, Pu, void 0), mt(this, Ou, void 0), mt(this, Vu, void 0), mt(this, Du, void 0), mt(this, vs, void 0), mt(this, Nu, void 0), !(t instanceof Vh))
      throw new Error("Invalid or missing BusService instance");
    if (!(n instanceof Fh))
      throw new Error("Invalid or missing LocalStorageService instance");
    if (!(i instanceof Wp))
      throw new Error("Invalid or missing MiliCron instance");
    if (!(r instanceof tT))
      throw new Error("Invalid or missing IdentityService instance");
    Ot(this, Ta, X(!1)), Ot(this, Zs, X(void 0)), Ot(this, Tn, t), Ot(this, qi, n), Ot(this, Iu, i), Ot(this, Wu, r), Ot(this, $i, X(void 0)), Ot(this, fr, X(void 0)), Ot(this, Pa, X(void 0)), Ot(this, Oa, X(void 0)), Ot(this, Vf, a), Ot(this, Df, o), Ot(this, qo, l), Ot(this, Go, u), Ot(this, tf, b(() => {
      if (ge(this, Oa).value === !0 || ge(this, Oa).value === void 0)
        return !1;
      switch (ge(this, Pa).value) {
        case Ca.Permission.DEFAULT:
          return !0;
        default:
          return !1;
      }
    })), Ot(this, nf, b(() => {
      switch (ge(this, Pa).value) {
        case Ca.Permission.DENIED:
          return !1;
        case Ca.Permission.GRANTED:
          return !0;
        case Ca.Permission.DEFAULT:
          return null;
        default:
          return !1;
      }
    }));
    try {
      Ot(this, Uo, cT(s));
    } catch (c) {
      xn("Failed to Initialize Firebase Application", c.message);
    }
    if (ge(this, Uo))
      try {
        Ot(this, Ea, Z2(ge(this, Uo)));
      } catch (c) {
        xn("Failed to Initialize Firebase Messaging", c.message);
      }
    ge(this, Uo) && ge(this, Ea) ? xn("Firebase Application & Messaging Initialized") : xn("Firebase Application & Messaging Skipped");
  }
  /**
   * Whether or not the service has been booted.
   */
  get booted() {
    return ge(this, Ta);
  }
  /**
   * Whether or not the UI should show a prompt for the user to allow push notifications.
   */
  get canRequestPermission() {
    return ge(this, tf);
  }
  /**
   * Whether or not permissions have been granted for push notifications.
   */
  get canPush() {
    return ge(this, nf);
  }
  /**
   * The current state of the service worker.
   */
  get serviceWorkerState() {
    return b(() => ge(this, Zs).value);
  }
  /**
   * If there is an update pending for the service worker.
   */
  get appUpdatePending() {
    return b(() => ge(this, Zs).value === "waiting");
  }
  /**
   * Request permission to show push notifications.
   */
  requestPushPermission() {
    Ca.Permission.request(
      () => {
        cn("Push Permission Granted"), ge(this, Tn).emit("push:updated", { local: !0, crossTab: !0 }), ge(this, Tn).emit("push:permission:granted", { local: !0, crossTab: !0 });
      },
      () => {
        cn("Push Permission Denied"), ge(this, Tn).emit("push:updated", { local: !0, crossTab: !0 }), ge(this, Tn).emit("push:permission:denied", { local: !0, crossTab: !0 });
      }
    );
  }
  /**
   * Stop asking the user for permission to show push notifications.
   * @returns void
   */
  doNotRequestPushPermission() {
    this.canPush.value || (ge(this, qi).set("push.donotaskforpermission", !0), ge(this, Tn).emit("push:updated", { local: !0, crossTab: !0 }));
  }
  /**
   * Create a web push notification (otherwise known as a desktop notification).
   * @param options The options for the web push notification
   */
  createWebPushNotification(t) {
    if (!this.canPush.value)
      return;
    const n = {
      body: t.body,
      icon: t.icon,
      link: t.link,
      requireInteraction: t.requireInteraction,
      timeout: t.timeout,
      vibrate: t.vibrate,
      silent: t.silent,
      onClick: function(i) {
        cn("Web Push Notification Clicked", i), t.onClick && t.onClick(i), t.closeOnClick && (window.focus(), this.close());
      },
      onClose: function(i) {
        cn("Web Push Notification Closed", i), t.onClose && t.onClose(i);
      },
      onError: function(i) {
        cn("Web Push Notification Error", i), t.onError && t.onError(i);
      },
      onShow: function(i) {
        cn("Web Push Notification Shown", i), t.onShow && t.onShow(i);
      }
    };
    try {
      Ca.create(t.title, n);
    } catch (i) {
      cn("Web Push Notification Error", i);
    }
  }
  /**
   * Reset the preference to ask the user for permission to show push notifications.
   * @private
   * @returns void
   * @remarks This is a function that should only be used for development and testing purposes.
   */
  $resetDoNotRequestPushPermissionPreference() {
    ge(this, qi).remove("push.donotaskforpermission"), ge(this, Tn).emit("push:updated", { local: !0, crossTab: !0 });
  }
  /**
   * Boot the service.
   */
  boot() {
    if (ge(this, Ta).value)
      return;
    cn("Booting");
    const t = () => {
      ge(this, Ta).value = !0, cn("Booted");
    };
    if (Ot(this, Eu, fe(
      () => ge(this, $i).value,
      (n, i) => {
        i !== n && (cn("Service Worker Registration Changed", { was: i, is: n }), n ? Fn(this, rf, hg).call(this) : ge(this, fr).value || xn("Skipped generating Firebase Messaging Token", {
          canPush: this.canPush.value,
          serviceWorkerRegistration: typeof ge(this, $i).value < "u"
        }));
      },
      {
        immediate: !0,
        deep: !0
      }
    )), Ot(this, Pu, fe(
      () => ge(this, fr).value,
      (n, i) => {
        i !== n && (xn("Notifying of Firebase Messaging Token Update", { token: n }), ge(this, Tn).emit("firebase:token:updated", { local: !0, crossTab: !0 }, n), Fn(this, sf, mg).call(this));
      },
      {
        immediate: !0,
        deep: !0
      }
    )), Ot(this, Ou, fe(
      () => ge(this, Pa).value,
      (n, i) => {
        i !== n && (cn("Push Permission Changed", { was: i, is: n }), this.canPush.value && ge(this, $i).value ? Fn(this, rf, hg).call(this) : ge(this, fr).value || xn("Skipped generating Firebase Messaging Token", {
          canPush: this.canPush.value,
          serviceWorkerRegistration: typeof ge(this, $i).value < "u"
        }));
      },
      {
        immediate: !0,
        deep: !0
      }
    )), Ot(this, Vu, fe(
      () => ge(this, Oa).value,
      (n, i) => {
        i !== n && cn("Do Not Ask For Permission Preference Changed", { was: i, is: n });
      },
      {
        immediate: !0,
        deep: !0
      }
    )), Ot(this, Du, fe(
      () => ge(this, Wu).authenticated.value,
      (n, i) => {
        i !== n && Fn(this, sf, mg).call(this);
      },
      {
        immediate: !0,
        deep: !0
      }
    )), ge(this, Iu).$on("*/250 * * * * *", Fn(this, Yo, Mu).bind(this)), ge(this, Tn).on("push:updated", Fn(this, Yo, Mu).bind(this), { local: !0, crossTab: !0 }), ge(this, Tn).on("sw:install", Fn(this, af, vg).bind(this), {
      local: !0,
      crossTab: !0
    }), Fn(this, oc, Nf).call(this, !0), typeof window < "u" && "serviceWorker" in navigator) {
      if (typeof ge(this, $i).value > "u") {
        if (!ge(this, qo) || !ge(this, Go))
          return cn("Service Worker Path or Mode not set, skipping registration"), t();
        cn("Attempting to register Service Worker", {
          path: ge(this, qo),
          mode: ge(this, Go)
        }), navigator.serviceWorker.register(ge(this, qo), { type: ge(this, Go) }).then((n) => {
          as("Service Worker Registered", n), ge(this, $i).value = n;
        }).catch((n) => {
          as("Service Worker Registration Failed", n);
        });
      }
      navigator.serviceWorker.addEventListener("message", (n) => {
        if (as("Got new message from service worker", n.data), n.data.messageType === "push-received" && n.data.data && n.data.data.event) {
          as("Got push notification from service worker", n.data.data);
          const { event: i, detail: r } = n.data.data, s = `background:${i}`;
          ge(this, Tn).emit(s, { local: !0 }, r);
        }
        if (n.data.messageType === "sw-received" && n.data.data && n.data.data.event) {
          as("Got event from service worker", n.data.data);
          const { event: i, detail: r } = n.data.data, s = `background:${i}`;
          ge(this, Tn).emit(s, { local: !0 }, r);
        }
        n.data.notification && ge(this, Tn).emit("push:notification", { local: !0 }, n.data.notification);
      }), navigator.serviceWorker.addEventListener("messageerror", (n) => {
        as("Got new message error from service worker", n.data);
      }), navigator.serviceWorker.ready.then((n) => {
        as("Service Worker Ready", n), ge(this, $i).value = n, Fn(this, Sl, ac).call(this, n);
      }), navigator.serviceWorker.addEventListener("controllerchange", (n) => {
        as("Service Worker saw Controller Change", n);
      });
    }
    return ge(this, Ea) && Ot(this, Nu, X2(ge(this, Ea), (n) => {
      if (xn("Got Firebase Messaging Payload", n), n.data && n.data.event) {
        const { event: i, detail: r } = n.data, s = `background:${i}`;
        ge(this, Tn).emit(s, { local: !0 }, r);
      }
    })), t();
  }
  /**
   * Shut down the service.
   */
  shutdown() {
    ge(this, Ta).value && (cn("Shutting Down"), ge(this, Tn).off("push:updated", Fn(this, Yo, Mu).bind(this), { local: !0, crossTab: !0 }), ge(this, Tn).off("sw:install", Fn(this, af, vg).bind(this), {
      local: !0,
      crossTab: !0
    }), ge(this, Iu).$off("*/250 * * * * *", Fn(this, Yo, Mu).bind(this)), ge(this, Eu) && ge(this, Eu).call(this), ge(this, Pu) && ge(this, Pu).call(this), ge(this, Ou) && ge(this, Ou).call(this), ge(this, Vu) && ge(this, Vu).call(this), ge(this, Du) && ge(this, Du).call(this), ge(this, vs) && ge(this, vs).abort(), ge(this, Nu) && ge(this, Nu).call(this), cn("Shut Down"));
  }
  async update() {
    if (!(typeof window < "u" && "serviceWorker" in navigator)) {
      cn("Not in a context with a Service Worker");
      return;
    }
    if (!this.appUpdatePending.value) {
      cn("No Service Worker Update Pending");
      return;
    }
    const t = await navigator.serviceWorker.ready;
    if (!t.waiting) {
      cn("No Waiting Service Worker");
      return;
    }
    const n = new Promise((i) => {
      navigator.serviceWorker.addEventListener("controllerchange", i, { once: !0 });
    });
    t.waiting.postMessage({ type: "SKIP_WAITING" }), await n, window && window.location ? window.location.reload() : cn("Finished waiting for Service Worker to update");
  }
}
Ta = /* @__PURE__ */ new WeakMap();
Tn = /* @__PURE__ */ new WeakMap();
qi = /* @__PURE__ */ new WeakMap();
Iu = /* @__PURE__ */ new WeakMap();
Wu = /* @__PURE__ */ new WeakMap();
Uo = /* @__PURE__ */ new WeakMap();
Ea = /* @__PURE__ */ new WeakMap();
$i = /* @__PURE__ */ new WeakMap();
fr = /* @__PURE__ */ new WeakMap();
Pa = /* @__PURE__ */ new WeakMap();
Oa = /* @__PURE__ */ new WeakMap();
tf = /* @__PURE__ */ new WeakMap();
nf = /* @__PURE__ */ new WeakMap();
Vf = /* @__PURE__ */ new WeakMap();
Df = /* @__PURE__ */ new WeakMap();
qo = /* @__PURE__ */ new WeakMap();
Go = /* @__PURE__ */ new WeakMap();
Zs = /* @__PURE__ */ new WeakMap();
Eu = /* @__PURE__ */ new WeakMap();
Pu = /* @__PURE__ */ new WeakMap();
Ou = /* @__PURE__ */ new WeakMap();
Vu = /* @__PURE__ */ new WeakMap();
Du = /* @__PURE__ */ new WeakMap();
vs = /* @__PURE__ */ new WeakMap();
Nu = /* @__PURE__ */ new WeakMap();
Sl = /* @__PURE__ */ new WeakSet();
ac = function(e) {
  if (e) {
    switch (!0) {
      case e.installing !== null:
        ge(this, Zs).value = "installing";
        break;
      case e.waiting !== null:
        ge(this, Zs).value = "waiting";
        break;
      case e.active !== null:
        ge(this, Zs).value = "activated";
        break;
    }
    return;
  }
  typeof window < "u" && "serviceWorker" in navigator && navigator.serviceWorker.ready.then((t) => {
    Fn(this, Sl, ac).call(this, t);
  });
};
oc = /* @__PURE__ */ new WeakSet();
Nf = function(e = !1) {
  if (!ge(this, qi).loaded) {
    e && ge(this, qi).promise.then(() => {
      Fn(this, oc, Nf).call(this, e);
    });
    return;
  }
  const t = ge(this, qi).get("push.donotaskforpermission") || !1;
  ge(this, Oa).value = t, ge(this, Pa).value = Ca.Permission.get(), Fn(this, Sl, ac).call(this);
};
Yo = /* @__PURE__ */ new WeakSet();
Mu = function() {
  Fn(this, oc, Nf).call(this);
};
rf = /* @__PURE__ */ new WeakSet();
hg = function() {
  !ge(this, $i).value || !this.canPush.value || ge(this, fr).value || K2(ge(this, Ea), {
    serviceWorkerRegistration: ge(this, $i).value
  }).then((e) => {
    e ? (xn("Firebase Messaging Token", e), ge(this, fr).value = e, ge(this, qi).loaded ? ge(this, qi).set("push.serviceworker.registration.token", e) : ge(this, qi).promise.then(() => {
      ge(this, qi).set("push.serviceworker.registration.token", e);
    })) : xn("No Firebase Messaging Token");
  }).catch((e) => {
    xn("Error retreiving Firebase Messaging Token", e);
  });
};
sf = /* @__PURE__ */ new WeakSet();
mg = function() {
  if (ge(this, fr).value) {
    const e = ge(this, Wu).authenticated.value;
    ge(this, vs) && ge(this, vs).abort(), Ot(this, vs, new AbortController());
    try {
      e ? (async () => {
        xn("Registering Firebase Messaging Token");
        try {
          await ge(this, Vf).call(this, ge(this, fr).value, ge(this, vs).signal), xn("Registered Firebase Messaging Token");
        } catch (t) {
          (t instanceof Error && t.name !== "CancelError" || !(t instanceof Error)) && xn("Failed to register Firebase Messaging Token", t);
        }
      })() : (async () => {
        xn("Unregistering Firebase Messaging Token");
        try {
          await ge(this, Df).call(this, ge(this, fr).value, ge(this, vs).signal), xn("Unregistered Firebase Messaging Token");
        } catch (t) {
          (t instanceof Error && t.name !== "CancelError" || !(t instanceof Error)) && xn("Failed to unregister Firebase Messaging Token", t);
        }
      })();
    } catch (t) {
      t instanceof Error && t.name !== "CancelError" && xn("API Firebase Operation threw and Error", t);
    }
  }
};
af = /* @__PURE__ */ new WeakSet();
vg = function(e) {
  as("Service Worker Installed might be waiting", e), Fn(this, Sl, ac).call(this);
};
const e$ = {
  install: (e, t) => {
    const n = (t == null ? void 0 : t.firebaseOptions) || {}, i = (t == null ? void 0 : t.onAuthenticatedForFirebase) || (() => {
    }), r = (t == null ? void 0 : t.onUnauthenticatedForFirebase) || (() => {
    }), s = t == null ? void 0 : t.serviceWorkerPath, a = t == null ? void 0 : t.serviceWorkerMode, o = new Q2(
      e.config.globalProperties.$bus,
      e.config.globalProperties.$ls,
      e.config.globalProperties.$cron,
      e.config.globalProperties.$identity,
      n,
      i,
      r,
      s,
      a
    );
    e.provide("push", o), e.config.globalProperties.$push = o;
  }
}, t$ = 100, Je = {}, n$ = () => {
  Je.previousActiveElement instanceof HTMLElement ? (Je.previousActiveElement.focus(), Je.previousActiveElement = null) : document.body && document.body.focus();
}, i$ = (e) => new Promise((t) => {
  if (!e)
    return t();
  const n = window.scrollX, i = window.scrollY;
  Je.restoreFocusTimeout = setTimeout(() => {
    n$(), t();
  }, t$), window.scrollTo(n, i);
}), LT = "swal2-", r$ = [
  "container",
  "shown",
  "height-auto",
  "iosfix",
  "popup",
  "modal",
  "no-backdrop",
  "no-transition",
  "toast",
  "toast-shown",
  "show",
  "hide",
  "close",
  "title",
  "html-container",
  "actions",
  "confirm",
  "deny",
  "cancel",
  "default-outline",
  "footer",
  "icon",
  "icon-content",
  "image",
  "input",
  "file",
  "range",
  "select",
  "radio",
  "checkbox",
  "label",
  "textarea",
  "inputerror",
  "input-label",
  "validation-message",
  "progress-steps",
  "active-progress-step",
  "progress-step",
  "progress-step-line",
  "loader",
  "loading",
  "styled",
  "top",
  "top-start",
  "top-end",
  "top-left",
  "top-right",
  "center",
  "center-start",
  "center-end",
  "center-left",
  "center-right",
  "bottom",
  "bottom-start",
  "bottom-end",
  "bottom-left",
  "bottom-right",
  "grow-row",
  "grow-column",
  "grow-fullscreen",
  "rtl",
  "timer-progress-bar",
  "timer-progress-bar-container",
  "scrollbar-measure",
  "icon-success",
  "icon-warning",
  "icon-info",
  "icon-question",
  "icon-error"
], se = r$.reduce(
  (e, t) => (e[t] = LT + t, e),
  /** @type {SwalClasses} */
  {}
), s$ = ["success", "warning", "info", "question", "error"], Mf = s$.reduce(
  (e, t) => (e[t] = LT + t, e),
  /** @type {SwalIcons} */
  {}
), $T = "SweetAlert2:", uy = (e) => e.charAt(0).toUpperCase() + e.slice(1), bi = (e) => {
  console.warn(`${$T} ${typeof e == "object" ? e.join(" ") : e}`);
}, ko = (e) => {
  console.error(`${$T} ${e}`);
}, Z0 = [], a$ = (e) => {
  Z0.includes(e) || (Z0.push(e), bi(e));
}, o$ = (e, t) => {
  a$(
    `"${e}" is deprecated and will be removed in the next major release. Please use "${t}" instead.`
  );
}, Yh = (e) => typeof e == "function" ? e() : e, cy = (e) => e && typeof e.toPromise == "function", Hc = (e) => cy(e) ? e.toPromise() : Promise.resolve(e), dy = (e) => e && Promise.resolve(e) === e, wi = () => document.body.querySelector(`.${se.container}`), zc = (e) => {
  const t = wi();
  return t ? t.querySelector(e) : null;
}, Vi = (e) => zc(`.${e}`), yt = () => Vi(se.popup), Uc = () => Vi(se.icon), l$ = () => Vi(se["icon-content"]), WT = () => Vi(se.title), fy = () => Vi(se["html-container"]), jT = () => Vi(se.image), hy = () => Vi(se["progress-steps"]), Zh = () => Vi(se["validation-message"]), zr = () => (
  /** @type {HTMLButtonElement} */
  zc(`.${se.actions} .${se.confirm}`)
), Kl = () => (
  /** @type {HTMLButtonElement} */
  zc(`.${se.actions} .${se.cancel}`)
), Co = () => (
  /** @type {HTMLButtonElement} */
  zc(`.${se.actions} .${se.deny}`)
), u$ = () => Vi(se["input-label"]), Xl = () => zc(`.${se.loader}`), qc = () => Vi(se.actions), HT = () => Vi(se.footer), Kh = () => Vi(se["timer-progress-bar"]), my = () => Vi(se.close), c$ = `
  a[href],
  area[href],
  input:not([disabled]),
  select:not([disabled]),
  textarea:not([disabled]),
  button:not([disabled]),
  iframe,
  object,
  embed,
  [tabindex="0"],
  [contenteditable],
  audio[controls],
  video[controls],
  summary
`, vy = () => {
  const e = yt();
  if (!e)
    return [];
  const t = e.querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])'), n = Array.from(t).sort((s, a) => {
    const o = parseInt(s.getAttribute("tabindex") || "0"), l = parseInt(a.getAttribute("tabindex") || "0");
    return o > l ? 1 : o < l ? -1 : 0;
  }), i = e.querySelectorAll(c$), r = Array.from(i).filter(
    (s) => s.getAttribute("tabindex") !== "-1"
  );
  return [...new Set(n.concat(r))].filter(
    (s) => Ai(s)
  );
}, gy = () => ps(document.body, se.shown) && !ps(document.body, se["toast-shown"]) && !ps(document.body, se["no-backdrop"]), Xh = () => {
  const e = yt();
  return e ? ps(e, se.toast) : !1;
}, d$ = () => {
  const e = yt();
  return e ? e.hasAttribute("data-loading") : !1;
}, Di = (e, t) => {
  if (e.textContent = "", t) {
    const i = new DOMParser().parseFromString(t, "text/html"), r = i.querySelector("head");
    r && Array.from(r.childNodes).forEach((a) => {
      e.appendChild(a);
    });
    const s = i.querySelector("body");
    s && Array.from(s.childNodes).forEach((a) => {
      a instanceof HTMLVideoElement || a instanceof HTMLAudioElement ? e.appendChild(a.cloneNode(!0)) : e.appendChild(a);
    });
  }
}, ps = (e, t) => {
  if (!t)
    return !1;
  const n = t.split(/\s+/);
  for (let i = 0; i < n.length; i++)
    if (!e.classList.contains(n[i]))
      return !1;
  return !0;
}, f$ = (e, t) => {
  Array.from(e.classList).forEach((n) => {
    !Object.values(se).includes(n) && !Object.values(Mf).includes(n) && !Object.values(t.showClass || {}).includes(n) && e.classList.remove(n);
  });
}, Xi = (e, t, n) => {
  if (f$(e, t), t.customClass && t.customClass[n]) {
    if (typeof t.customClass[n] != "string" && !t.customClass[n].forEach) {
      bi(
        `Invalid type of customClass.${n}! Expected string or iterable object, got "${typeof t.customClass[n]}"`
      );
      return;
    }
    dt(e, t.customClass[n]);
  }
}, Jh = (e, t) => {
  if (!t)
    return null;
  switch (t) {
    case "select":
    case "textarea":
    case "file":
      return e.querySelector(`.${se.popup} > .${se[t]}`);
    case "checkbox":
      return e.querySelector(`.${se.popup} > .${se.checkbox} input`);
    case "radio":
      return e.querySelector(`.${se.popup} > .${se.radio} input:checked`) || e.querySelector(`.${se.popup} > .${se.radio} input:first-child`);
    case "range":
      return e.querySelector(`.${se.popup} > .${se.range} input`);
    default:
      return e.querySelector(`.${se.popup} > .${se.input}`);
  }
}, zT = (e) => {
  if (e.focus(), e.type !== "file") {
    const t = e.value;
    e.value = "", e.value = t;
  }
}, UT = (e, t, n) => {
  !e || !t || (typeof t == "string" && (t = t.split(/\s+/).filter(Boolean)), t.forEach((i) => {
    Array.isArray(e) ? e.forEach((r) => {
      n ? r.classList.add(i) : r.classList.remove(i);
    }) : n ? e.classList.add(i) : e.classList.remove(i);
  }));
}, dt = (e, t) => {
  UT(e, t, !0);
}, Ur = (e, t) => {
  UT(e, t, !1);
}, Ks = (e, t) => {
  const n = Array.from(e.children);
  for (let i = 0; i < n.length; i++) {
    const r = n[i];
    if (r instanceof HTMLElement && ps(r, t))
      return r;
  }
}, za = (e, t, n) => {
  n === `${parseInt(n)}` && (n = parseInt(n)), n || parseInt(n) === 0 ? e.style.setProperty(t, typeof n == "number" ? `${n}px` : n) : e.style.removeProperty(t);
}, In = (e, t = "flex") => {
  e && (e.style.display = t);
}, Zn = (e) => {
  e && (e.style.display = "none");
}, py = (e, t = "block") => {
  e && new MutationObserver(() => {
    Gc(e, e.innerHTML, t);
  }).observe(e, { childList: !0, subtree: !0 });
}, K0 = (e, t, n, i) => {
  const r = e.querySelector(t);
  r && r.style.setProperty(n, i);
}, Gc = (e, t, n = "flex") => {
  t ? In(e, n) : Zn(e);
}, Ai = (e) => !!(e && (e.offsetWidth || e.offsetHeight || e.getClientRects().length)), h$ = () => !Ai(zr()) && !Ai(Co()) && !Ai(Kl()), X0 = (e) => e.scrollHeight > e.clientHeight, qT = (e) => {
  const t = window.getComputedStyle(e), n = parseFloat(t.getPropertyValue("animation-duration") || "0"), i = parseFloat(t.getPropertyValue("transition-duration") || "0");
  return n > 0 || i > 0;
}, yy = (e, t = !1) => {
  const n = Kh();
  n && Ai(n) && (t && (n.style.transition = "none", n.style.width = "100%"), setTimeout(() => {
    n.style.transition = `width ${e / 1e3}s linear`, n.style.width = "0%";
  }, 10));
}, m$ = () => {
  const e = Kh();
  if (!e)
    return;
  const t = parseInt(window.getComputedStyle(e).width);
  e.style.removeProperty("transition"), e.style.width = "100%";
  const n = parseInt(window.getComputedStyle(e).width), i = t / n * 100;
  e.style.width = `${i}%`;
}, GT = () => typeof window > "u" || typeof document > "u", v$ = `
 <div aria-labelledby="${se.title}" aria-describedby="${se["html-container"]}" class="${se.popup}" tabindex="-1">
   <button type="button" class="${se.close}"></button>
   <ul class="${se["progress-steps"]}"></ul>
   <div class="${se.icon}"></div>
   <img class="${se.image}" />
   <h2 class="${se.title}" id="${se.title}"></h2>
   <div class="${se["html-container"]}" id="${se["html-container"]}"></div>
   <input class="${se.input}" id="${se.input}" />
   <input type="file" class="${se.file}" />
   <div class="${se.range}">
     <input type="range" />
     <output></output>
   </div>
   <select class="${se.select}" id="${se.select}"></select>
   <div class="${se.radio}"></div>
   <label class="${se.checkbox}">
     <input type="checkbox" id="${se.checkbox}" />
     <span class="${se.label}"></span>
   </label>
   <textarea class="${se.textarea}" id="${se.textarea}"></textarea>
   <div class="${se["validation-message"]}" id="${se["validation-message"]}"></div>
   <div class="${se.actions}">
     <div class="${se.loader}"></div>
     <button type="button" class="${se.confirm}"></button>
     <button type="button" class="${se.deny}"></button>
     <button type="button" class="${se.cancel}"></button>
   </div>
   <div class="${se.footer}"></div>
   <div class="${se["timer-progress-bar-container"]}">
     <div class="${se["timer-progress-bar"]}"></div>
   </div>
 </div>
`.replace(/(^|\n)\s*/g, ""), g$ = () => {
  const e = wi();
  return e ? (e.remove(), Ur(
    [document.documentElement, document.body],
    [se["no-backdrop"], se["toast-shown"], se["has-column"]]
  ), !0) : !1;
}, _a = () => {
  Je.currentInstance.resetValidationMessage();
}, p$ = () => {
  const e = yt(), t = Ks(e, se.input), n = Ks(e, se.file), i = e.querySelector(`.${se.range} input`), r = e.querySelector(`.${se.range} output`), s = Ks(e, se.select), a = e.querySelector(`.${se.checkbox} input`), o = Ks(e, se.textarea);
  t.oninput = _a, n.onchange = _a, s.onchange = _a, a.onchange = _a, o.oninput = _a, i.oninput = () => {
    _a(), r.value = i.value;
  }, i.onchange = () => {
    _a(), r.value = i.value;
  };
}, y$ = (e) => typeof e == "string" ? document.querySelector(e) : e, b$ = (e) => {
  const t = yt();
  t.setAttribute("role", e.toast ? "alert" : "dialog"), t.setAttribute("aria-live", e.toast ? "polite" : "assertive"), e.toast || t.setAttribute("aria-modal", "true");
}, w$ = (e) => {
  window.getComputedStyle(e).direction === "rtl" && dt(wi(), se.rtl);
}, _$ = (e) => {
  const t = g$();
  if (GT()) {
    ko("SweetAlert2 requires document to initialize");
    return;
  }
  const n = document.createElement("div");
  n.className = se.container, t && dt(n, se["no-transition"]), Di(n, v$);
  const i = y$(e.target);
  i.appendChild(n), b$(e), w$(i), p$();
}, by = (e, t) => {
  e instanceof HTMLElement ? t.appendChild(e) : typeof e == "object" ? S$(e, t) : e && Di(t, e);
}, S$ = (e, t) => {
  e.jquery ? k$(t, e) : Di(t, e.toString());
}, k$ = (e, t) => {
  if (e.textContent = "", 0 in t)
    for (let n = 0; n in t; n++)
      e.appendChild(t[n].cloneNode(!0));
  else
    e.appendChild(t.cloneNode(!0));
}, eo = (() => {
  if (GT())
    return !1;
  const e = document.createElement("div");
  return typeof e.style.webkitAnimation < "u" ? "webkitAnimationEnd" : typeof e.style.animation < "u" ? "animationend" : !1;
})(), C$ = (e, t) => {
  const n = qc(), i = Xl();
  !n || !i || (!t.showConfirmButton && !t.showDenyButton && !t.showCancelButton ? Zn(n) : In(n), Xi(n, t, "actions"), T$(n, i, t), Di(i, t.loaderHtml || ""), Xi(i, t, "loader"));
};
function T$(e, t, n) {
  const i = zr(), r = Co(), s = Kl();
  !i || !r || !s || (wv(i, "confirm", n), wv(r, "deny", n), wv(s, "cancel", n), x$(i, r, s, n), n.reverseButtons && (n.toast ? (e.insertBefore(s, i), e.insertBefore(r, i)) : (e.insertBefore(s, t), e.insertBefore(r, t), e.insertBefore(i, t))));
}
function x$(e, t, n, i) {
  if (!i.buttonsStyling) {
    Ur([e, t, n], se.styled);
    return;
  }
  dt([e, t, n], se.styled), i.confirmButtonColor && (e.style.backgroundColor = i.confirmButtonColor, dt(e, se["default-outline"])), i.denyButtonColor && (t.style.backgroundColor = i.denyButtonColor, dt(t, se["default-outline"])), i.cancelButtonColor && (n.style.backgroundColor = i.cancelButtonColor, dt(n, se["default-outline"]));
}
function wv(e, t, n) {
  const i = (
    /** @type {'Confirm' | 'Deny' | 'Cancel'} */
    uy(t)
  );
  Gc(e, n[`show${i}Button`], "inline-block"), Di(e, n[`${t}ButtonText`] || ""), e.setAttribute("aria-label", n[`${t}ButtonAriaLabel`] || ""), e.className = se[t], Xi(e, n, `${t}Button`);
}
const A$ = (e, t) => {
  const n = my();
  n && (Di(n, t.closeButtonHtml || ""), Xi(n, t, "closeButton"), Gc(n, t.showCloseButton), n.setAttribute("aria-label", t.closeButtonAriaLabel || ""));
}, I$ = (e, t) => {
  const n = wi();
  n && (E$(n, t.backdrop), P$(n, t.position), O$(n, t.grow), Xi(n, t, "container"));
};
function E$(e, t) {
  typeof t == "string" ? e.style.background = t : t || dt([document.documentElement, document.body], se["no-backdrop"]);
}
function P$(e, t) {
  t && (t in se ? dt(e, se[t]) : (bi('The "position" parameter is not valid, defaulting to "center"'), dt(e, se.center)));
}
function O$(e, t) {
  t && dt(e, se[`grow-${t}`]);
}
const xt = {
  innerParams: /* @__PURE__ */ new WeakMap(),
  domCache: /* @__PURE__ */ new WeakMap()
}, V$ = ["input", "file", "range", "select", "radio", "checkbox", "textarea"], D$ = (e, t) => {
  const n = yt();
  if (!n)
    return;
  const i = xt.innerParams.get(e), r = !i || t.input !== i.input;
  V$.forEach((s) => {
    const a = Ks(n, se[s]);
    a && (R$(s, t.inputAttributes), a.className = se[s], r && Zn(a));
  }), t.input && (r && N$(t), F$(t));
}, N$ = (e) => {
  if (!e.input)
    return;
  if (!nn[e.input]) {
    ko(`Unexpected type of input! Expected ${Object.keys(nn).join(" | ")}, got "${e.input}"`);
    return;
  }
  const t = YT(e.input), n = nn[e.input](t, e);
  In(t), e.inputAutoFocus && setTimeout(() => {
    zT(n);
  });
}, M$ = (e) => {
  for (let t = 0; t < e.attributes.length; t++) {
    const n = e.attributes[t].name;
    ["id", "type", "value", "style"].includes(n) || e.removeAttribute(n);
  }
}, R$ = (e, t) => {
  const n = Jh(yt(), e);
  if (n) {
    M$(n);
    for (const i in t)
      n.setAttribute(i, t[i]);
  }
}, F$ = (e) => {
  const t = YT(e.input);
  typeof e.customClass == "object" && dt(t, e.customClass.input);
}, wy = (e, t) => {
  (!e.placeholder || t.inputPlaceholder) && (e.placeholder = t.inputPlaceholder);
}, Yc = (e, t, n) => {
  if (n.inputLabel) {
    const i = document.createElement("label"), r = se["input-label"];
    i.setAttribute("for", e.id), i.className = r, typeof n.customClass == "object" && dt(i, n.customClass.inputLabel), i.innerText = n.inputLabel, t.insertAdjacentElement("beforebegin", i);
  }
}, YT = (e) => Ks(yt(), se[e] || se.input), Rf = (e, t) => {
  ["string", "number"].includes(typeof t) ? e.value = `${t}` : dy(t) || bi(`Unexpected type of inputValue! Expected "string", "number" or "Promise", got "${typeof t}"`);
}, nn = {};
nn.text = nn.email = nn.password = nn.number = nn.tel = nn.url = nn.search = nn.date = nn["datetime-local"] = nn.time = nn.week = nn.month = (e, t) => (Rf(e, t.inputValue), Yc(e, e, t), wy(e, t), e.type = t.input, e);
nn.file = (e, t) => (Yc(e, e, t), wy(e, t), e);
nn.range = (e, t) => {
  const n = e.querySelector("input"), i = e.querySelector("output");
  return Rf(n, t.inputValue), n.type = t.input, Rf(i, t.inputValue), Yc(n, e, t), e;
};
nn.select = (e, t) => {
  if (e.textContent = "", t.inputPlaceholder) {
    const n = document.createElement("option");
    Di(n, t.inputPlaceholder), n.value = "", n.disabled = !0, n.selected = !0, e.appendChild(n);
  }
  return Yc(e, e, t), e;
};
nn.radio = (e) => (e.textContent = "", e);
nn.checkbox = (e, t) => {
  const n = Jh(yt(), "checkbox");
  n.value = "1", n.checked = !!t.inputValue;
  const i = e.querySelector("span");
  return Di(i, t.inputPlaceholder), n;
};
nn.textarea = (e, t) => {
  Rf(e, t.inputValue), wy(e, t), Yc(e, e, t);
  const n = (i) => parseInt(window.getComputedStyle(i).marginLeft) + parseInt(window.getComputedStyle(i).marginRight);
  return setTimeout(() => {
    if ("MutationObserver" in window) {
      const i = parseInt(window.getComputedStyle(yt()).width), r = () => {
        if (!document.body.contains(e))
          return;
        const s = e.offsetWidth + n(e);
        s > i ? yt().style.width = `${s}px` : za(yt(), "width", t.width);
      };
      new MutationObserver(r).observe(e, {
        attributes: !0,
        attributeFilter: ["style"]
      });
    }
  }), e;
};
const B$ = (e, t) => {
  const n = fy();
  n && (py(n), Xi(n, t, "htmlContainer"), t.html ? (by(t.html, n), In(n, "block")) : t.text ? (n.textContent = t.text, In(n, "block")) : Zn(n), D$(e, t));
}, L$ = (e, t) => {
  const n = HT();
  n && (py(n), Gc(n, t.footer, "block"), t.footer && by(t.footer, n), Xi(n, t, "footer"));
}, $$ = (e, t) => {
  const n = xt.innerParams.get(e), i = Uc();
  if (i) {
    if (n && t.icon === n.icon) {
      Q0(i, t), J0(i, t);
      return;
    }
    if (!t.icon && !t.iconHtml) {
      Zn(i);
      return;
    }
    if (t.icon && Object.keys(Mf).indexOf(t.icon) === -1) {
      ko(`Unknown icon! Expected "success", "error", "warning", "info" or "question", got "${t.icon}"`), Zn(i);
      return;
    }
    In(i), Q0(i, t), J0(i, t), dt(i, t.showClass && t.showClass.icon);
  }
}, J0 = (e, t) => {
  for (const [n, i] of Object.entries(Mf))
    t.icon !== n && Ur(e, i);
  dt(e, t.icon && Mf[t.icon]), z$(e, t), W$(), Xi(e, t, "icon");
}, W$ = () => {
  const e = yt();
  if (!e)
    return;
  const t = window.getComputedStyle(e).getPropertyValue("background-color"), n = e.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
  for (let i = 0; i < n.length; i++)
    n[i].style.backgroundColor = t;
}, j$ = `
  <div class="swal2-success-circular-line-left"></div>
  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>
  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>
  <div class="swal2-success-circular-line-right"></div>
`, H$ = `
  <span class="swal2-x-mark">
    <span class="swal2-x-mark-line-left"></span>
    <span class="swal2-x-mark-line-right"></span>
  </span>
`, Q0 = (e, t) => {
  if (!t.icon && !t.iconHtml)
    return;
  let n = e.innerHTML, i = "";
  t.iconHtml ? i = e_(t.iconHtml) : t.icon === "success" ? (i = j$, n = n.replace(/ style=".*?"/g, "")) : t.icon === "error" ? i = H$ : t.icon && (i = e_({
    question: "?",
    warning: "!",
    info: "i"
  }[t.icon])), n.trim() !== i.trim() && Di(e, i);
}, z$ = (e, t) => {
  if (t.iconColor) {
    e.style.color = t.iconColor, e.style.borderColor = t.iconColor;
    for (const n of [
      ".swal2-success-line-tip",
      ".swal2-success-line-long",
      ".swal2-x-mark-line-left",
      ".swal2-x-mark-line-right"
    ])
      K0(e, n, "background-color", t.iconColor);
    K0(e, ".swal2-success-ring", "border-color", t.iconColor);
  }
}, e_ = (e) => `<div class="${se["icon-content"]}">${e}</div>`, U$ = (e, t) => {
  const n = jT();
  if (n) {
    if (!t.imageUrl) {
      Zn(n);
      return;
    }
    In(n, ""), n.setAttribute("src", t.imageUrl), n.setAttribute("alt", t.imageAlt || ""), za(n, "width", t.imageWidth), za(n, "height", t.imageHeight), n.className = se.image, Xi(n, t, "image");
  }
}, q$ = (e, t) => {
  const n = wi(), i = yt();
  if (!(!n || !i)) {
    if (t.toast) {
      za(n, "width", t.width), i.style.width = "100%";
      const r = Xl();
      r && i.insertBefore(r, Uc());
    } else
      za(i, "width", t.width);
    za(i, "padding", t.padding), t.color && (i.style.color = t.color), t.background && (i.style.background = t.background), Zn(Zh()), G$(i, t);
  }
}, G$ = (e, t) => {
  const n = t.showClass || {};
  e.className = `${se.popup} ${Ai(e) ? n.popup : ""}`, t.toast ? (dt([document.documentElement, document.body], se["toast-shown"]), dt(e, se.toast)) : dt(e, se.modal), Xi(e, t, "popup"), typeof t.customClass == "string" && dt(e, t.customClass), t.icon && dt(e, se[`icon-${t.icon}`]);
}, Y$ = (e, t) => {
  const n = hy();
  if (!n)
    return;
  const { progressSteps: i, currentProgressStep: r } = t;
  if (!i || i.length === 0 || r === void 0) {
    Zn(n);
    return;
  }
  In(n), n.textContent = "", r >= i.length && bi(
    "Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)"
  ), i.forEach((s, a) => {
    const o = Z$(s);
    if (n.appendChild(o), a === r && dt(o, se["active-progress-step"]), a !== i.length - 1) {
      const l = K$(t);
      n.appendChild(l);
    }
  });
}, Z$ = (e) => {
  const t = document.createElement("li");
  return dt(t, se["progress-step"]), Di(t, e), t;
}, K$ = (e) => {
  const t = document.createElement("li");
  return dt(t, se["progress-step-line"]), e.progressStepsDistance && za(t, "width", e.progressStepsDistance), t;
}, X$ = (e, t) => {
  const n = WT();
  n && (py(n), Gc(n, t.title || t.titleText, "block"), t.title && by(t.title, n), t.titleText && (n.innerText = t.titleText), Xi(n, t, "title"));
}, ZT = (e, t) => {
  q$(e, t), I$(e, t), Y$(e, t), $$(e, t), U$(e, t), X$(e, t), A$(e, t), B$(e, t), C$(e, t), L$(e, t);
  const n = yt();
  typeof t.didRender == "function" && n && t.didRender(n);
}, J$ = () => Ai(yt()), KT = () => {
  var e;
  return (e = zr()) == null ? void 0 : e.click();
}, Q$ = () => {
  var e;
  return (e = Co()) == null ? void 0 : e.click();
}, eW = () => {
  var e;
  return (e = Kl()) == null ? void 0 : e.click();
}, Jl = Object.freeze({
  cancel: "cancel",
  backdrop: "backdrop",
  close: "close",
  esc: "esc",
  timer: "timer"
}), XT = (e) => {
  e.keydownTarget && e.keydownHandlerAdded && (e.keydownTarget.removeEventListener("keydown", e.keydownHandler, {
    capture: e.keydownListenerCapture
  }), e.keydownHandlerAdded = !1);
}, tW = (e, t, n) => {
  XT(e), t.toast || (e.keydownHandler = (i) => iW(t, i, n), e.keydownTarget = t.keydownListenerCapture ? window : yt(), e.keydownListenerCapture = t.keydownListenerCapture, e.keydownTarget.addEventListener("keydown", e.keydownHandler, {
    capture: e.keydownListenerCapture
  }), e.keydownHandlerAdded = !0);
}, gg = (e, t) => {
  var i;
  const n = vy();
  if (n.length) {
    e = e + t, e === n.length ? e = 0 : e === -1 && (e = n.length - 1), n[e].focus();
    return;
  }
  (i = yt()) == null || i.focus();
}, JT = ["ArrowRight", "ArrowDown"], nW = ["ArrowLeft", "ArrowUp"], iW = (e, t, n) => {
  e && (t.isComposing || t.keyCode === 229 || (e.stopKeydownPropagation && t.stopPropagation(), t.key === "Enter" ? rW(t, e) : t.key === "Tab" ? sW(t) : [...JT, ...nW].includes(t.key) ? aW(t.key) : t.key === "Escape" && oW(t, e, n)));
}, rW = (e, t) => {
  if (!Yh(t.allowEnterKey))
    return;
  const n = Jh(yt(), t.input);
  if (e.target && n && e.target instanceof HTMLElement && e.target.outerHTML === n.outerHTML) {
    if (["textarea", "file"].includes(t.input))
      return;
    KT(), e.preventDefault();
  }
}, sW = (e) => {
  const t = e.target, n = vy();
  let i = -1;
  for (let r = 0; r < n.length; r++)
    if (t === n[r]) {
      i = r;
      break;
    }
  e.shiftKey ? gg(i, -1) : gg(i, 1), e.stopPropagation(), e.preventDefault();
}, aW = (e) => {
  const t = qc(), n = zr(), i = Co(), r = Kl();
  if (!t || !n || !i || !r)
    return;
  const s = [n, i, r];
  if (document.activeElement instanceof HTMLElement && !s.includes(document.activeElement))
    return;
  const a = JT.includes(e) ? "nextElementSibling" : "previousElementSibling";
  let o = document.activeElement;
  if (o) {
    for (let l = 0; l < t.children.length; l++) {
      if (o = o[a], !o)
        return;
      if (o instanceof HTMLButtonElement && Ai(o))
        break;
    }
    o instanceof HTMLButtonElement && o.focus();
  }
}, oW = (e, t, n) => {
  Yh(t.allowEscapeKey) && (e.preventDefault(), n(Jl.esc));
}, kl = {
  swalPromiseResolve: /* @__PURE__ */ new WeakMap(),
  swalPromiseReject: /* @__PURE__ */ new WeakMap()
}, lW = () => {
  const e = wi();
  Array.from(document.body.children).forEach((n) => {
    n.contains(e) || (n.hasAttribute("aria-hidden") && n.setAttribute("data-previous-aria-hidden", n.getAttribute("aria-hidden") || ""), n.setAttribute("aria-hidden", "true"));
  });
}, QT = () => {
  Array.from(document.body.children).forEach((t) => {
    t.hasAttribute("data-previous-aria-hidden") ? (t.setAttribute("aria-hidden", t.getAttribute("data-previous-aria-hidden") || ""), t.removeAttribute("data-previous-aria-hidden")) : t.removeAttribute("aria-hidden");
  });
}, e1 = typeof window < "u" && !!window.GestureEvent, uW = () => {
  if (e1 && !ps(document.body, se.iosfix)) {
    const e = document.body.scrollTop;
    document.body.style.top = `${e * -1}px`, dt(document.body, se.iosfix), cW();
  }
}, cW = () => {
  const e = wi();
  if (!e)
    return;
  let t;
  e.ontouchstart = (n) => {
    t = dW(n);
  }, e.ontouchmove = (n) => {
    t && (n.preventDefault(), n.stopPropagation());
  };
}, dW = (e) => {
  const t = e.target, n = wi(), i = fy();
  return !n || !i || fW(e) || hW(e) ? !1 : t === n || !X0(n) && t instanceof HTMLElement && t.tagName !== "INPUT" && // #1603
  t.tagName !== "TEXTAREA" && // #2266
  !(X0(i) && // #1944
  i.contains(t));
}, fW = (e) => e.touches && e.touches.length && e.touches[0].touchType === "stylus", hW = (e) => e.touches && e.touches.length > 1, mW = () => {
  if (ps(document.body, se.iosfix)) {
    const e = parseInt(document.body.style.top, 10);
    Ur(document.body, se.iosfix), document.body.style.top = "", document.body.scrollTop = e * -1;
  }
}, vW = () => {
  const e = document.createElement("div");
  e.className = se["scrollbar-measure"], document.body.appendChild(e);
  const t = e.getBoundingClientRect().width - e.clientWidth;
  return document.body.removeChild(e), t;
};
let cl = null;
const gW = (e) => {
  cl === null && (document.body.scrollHeight > window.innerHeight || e === "scroll") && (cl = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right")), document.body.style.paddingRight = `${cl + vW()}px`);
}, pW = () => {
  cl !== null && (document.body.style.paddingRight = `${cl}px`, cl = null);
};
function t1(e, t, n, i) {
  Xh() ? t_(e, i) : (i$(n).then(() => t_(e, i)), XT(Je)), e1 ? (t.setAttribute("style", "display:none !important"), t.removeAttribute("class"), t.innerHTML = "") : t.remove(), gy() && (pW(), mW(), QT()), yW();
}
function yW() {
  Ur(
    [document.documentElement, document.body],
    [se.shown, se["height-auto"], se["no-backdrop"], se["toast-shown"]]
  );
}
function Xs(e) {
  e = wW(e);
  const t = kl.swalPromiseResolve.get(this), n = bW(this);
  this.isAwaitingPromise ? e.isDismissed || (Zc(this), t(e)) : n && t(e);
}
const bW = (e) => {
  const t = yt();
  if (!t)
    return !1;
  const n = xt.innerParams.get(e);
  if (!n || ps(t, n.hideClass.popup))
    return !1;
  Ur(t, n.showClass.popup), dt(t, n.hideClass.popup);
  const i = wi();
  return Ur(i, n.showClass.backdrop), dt(i, n.hideClass.backdrop), _W(e, t, n), !0;
};
function n1(e) {
  const t = kl.swalPromiseReject.get(this);
  Zc(this), t && t(e);
}
const Zc = (e) => {
  e.isAwaitingPromise && (delete e.isAwaitingPromise, xt.innerParams.get(e) || e._destroy());
}, wW = (e) => typeof e > "u" ? {
  isConfirmed: !1,
  isDenied: !1,
  isDismissed: !0
} : Object.assign(
  {
    isConfirmed: !1,
    isDenied: !1,
    isDismissed: !1
  },
  e
), _W = (e, t, n) => {
  const i = wi(), r = eo && qT(t);
  typeof n.willClose == "function" && n.willClose(t), r ? SW(e, t, i, n.returnFocus, n.didClose) : t1(e, i, n.returnFocus, n.didClose);
}, SW = (e, t, n, i, r) => {
  eo && (Je.swalCloseEventFinishedCallback = t1.bind(
    null,
    e,
    n,
    i,
    r
  ), t.addEventListener(eo, function(s) {
    s.target === t && (Je.swalCloseEventFinishedCallback(), delete Je.swalCloseEventFinishedCallback);
  }));
}, t_ = (e, t) => {
  setTimeout(() => {
    typeof t == "function" && t.bind(e.params)(), e._destroy && e._destroy();
  });
}, Cl = (e) => {
  let t = yt();
  if (t || new no(), t = yt(), !t)
    return;
  const n = Xl();
  Xh() ? Zn(Uc()) : kW(t, e), In(n), t.setAttribute("data-loading", "true"), t.setAttribute("aria-busy", "true"), t.focus();
}, kW = (e, t) => {
  const n = qc(), i = Xl();
  !n || !i || (!t && Ai(zr()) && (t = zr()), In(n), t && (Zn(t), i.setAttribute("data-button-to-replace", t.className), n.insertBefore(i, t)), dt([e, n], se.loading));
}, CW = (e, t) => {
  t.input === "select" || t.input === "radio" ? EW(e, t) : ["text", "email", "number", "tel", "textarea"].some((n) => n === t.input) && (cy(t.inputValue) || dy(t.inputValue)) && (Cl(zr()), PW(e, t));
}, TW = (e, t) => {
  const n = e.getInput();
  if (!n)
    return null;
  switch (t.input) {
    case "checkbox":
      return xW(n);
    case "radio":
      return AW(n);
    case "file":
      return IW(n);
    default:
      return t.inputAutoTrim ? n.value.trim() : n.value;
  }
}, xW = (e) => e.checked ? 1 : 0, AW = (e) => e.checked ? e.value : null, IW = (e) => e.files && e.files.length ? e.getAttribute("multiple") !== null ? e.files : e.files[0] : null, EW = (e, t) => {
  const n = yt();
  if (!n)
    return;
  const i = (r) => {
    t.input === "select" ? OW(n, Ff(r), t) : t.input === "radio" && VW(n, Ff(r), t);
  };
  cy(t.inputOptions) || dy(t.inputOptions) ? (Cl(zr()), Hc(t.inputOptions).then((r) => {
    e.hideLoading(), i(r);
  })) : typeof t.inputOptions == "object" ? i(t.inputOptions) : ko(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof t.inputOptions}`);
}, PW = (e, t) => {
  const n = e.getInput();
  n && (Zn(n), Hc(t.inputValue).then((i) => {
    n.value = t.input === "number" ? `${parseFloat(i) || 0}` : `${i}`, In(n), n.focus(), e.hideLoading();
  }).catch((i) => {
    ko(`Error in inputValue promise: ${i}`), n.value = "", In(n), n.focus(), e.hideLoading();
  }));
};
function OW(e, t, n) {
  const i = Ks(e, se.select);
  if (!i)
    return;
  const r = (s, a, o) => {
    const l = document.createElement("option");
    l.value = o, Di(l, a), l.selected = i1(o, n.inputValue), s.appendChild(l);
  };
  t.forEach((s) => {
    const a = s[0], o = s[1];
    if (Array.isArray(o)) {
      const l = document.createElement("optgroup");
      l.label = a, l.disabled = !1, i.appendChild(l), o.forEach((u) => r(l, u[1], u[0]));
    } else
      r(i, o, a);
  }), i.focus();
}
function VW(e, t, n) {
  const i = Ks(e, se.radio);
  if (!i)
    return;
  t.forEach((s) => {
    const a = s[0], o = s[1], l = document.createElement("input"), u = document.createElement("label");
    l.type = "radio", l.name = se.radio, l.value = a, i1(a, n.inputValue) && (l.checked = !0);
    const c = document.createElement("span");
    Di(c, o), c.className = se.label, u.appendChild(l), u.appendChild(c), i.appendChild(u);
  });
  const r = i.querySelectorAll("input");
  r.length && r[0].focus();
}
const Ff = (e) => {
  const t = [];
  return e instanceof Map ? e.forEach((n, i) => {
    let r = n;
    typeof r == "object" && (r = Ff(r)), t.push([i, r]);
  }) : Object.keys(e).forEach((n) => {
    let i = e[n];
    typeof i == "object" && (i = Ff(i)), t.push([n, i]);
  }), t;
}, i1 = (e, t) => !!t && t.toString() === e.toString(), DW = (e) => {
  const t = xt.innerParams.get(e);
  e.disableButtons(), t.input ? r1(e, "confirm") : Sy(e, !0);
}, NW = (e) => {
  const t = xt.innerParams.get(e);
  e.disableButtons(), t.returnInputValueOnDeny ? r1(e, "deny") : _y(e, !1);
}, MW = (e, t) => {
  e.disableButtons(), t(Jl.cancel);
}, r1 = (e, t) => {
  const n = xt.innerParams.get(e);
  if (!n.input) {
    ko(`The "input" parameter is needed to be set when using returnInputValueOn${uy(t)}`);
    return;
  }
  const i = e.getInput(), r = TW(e, n);
  n.inputValidator ? RW(e, r, t) : i && !i.checkValidity() ? (e.enableButtons(), e.showValidationMessage(n.validationMessage || i.validationMessage)) : t === "deny" ? _y(e, r) : Sy(e, r);
}, RW = (e, t, n) => {
  const i = xt.innerParams.get(e);
  e.disableInput(), Promise.resolve().then(
    () => Hc(i.inputValidator(t, i.validationMessage))
  ).then((s) => {
    e.enableButtons(), e.enableInput(), s ? e.showValidationMessage(s) : n === "deny" ? _y(e, t) : Sy(e, t);
  });
}, _y = (e, t) => {
  const n = xt.innerParams.get(e || globalThis);
  n.showLoaderOnDeny && Cl(Co()), n.preDeny ? (e.isAwaitingPromise = !0, Promise.resolve().then(
    () => Hc(n.preDeny(t, n.validationMessage))
  ).then((r) => {
    r === !1 ? (e.hideLoading(), Zc(e)) : e.close({ isDenied: !0, value: typeof r > "u" ? t : r });
  }).catch((r) => s1(e || globalThis, r))) : e.close({ isDenied: !0, value: t });
}, n_ = (e, t) => {
  e.close({ isConfirmed: !0, value: t });
}, s1 = (e, t) => {
  e.rejectPromise(t);
}, Sy = (e, t) => {
  const n = xt.innerParams.get(e || globalThis);
  n.showLoaderOnConfirm && Cl(), n.preConfirm ? (e.resetValidationMessage(), e.isAwaitingPromise = !0, Promise.resolve().then(
    () => Hc(n.preConfirm(t, n.validationMessage))
  ).then((r) => {
    Ai(Zh()) || r === !1 ? (e.hideLoading(), Zc(e)) : n_(e, typeof r > "u" ? t : r);
  }).catch((r) => s1(e || globalThis, r))) : n_(e, t);
};
function Bf() {
  const e = xt.innerParams.get(this);
  if (!e)
    return;
  const t = xt.domCache.get(this);
  Zn(t.loader), Xh() ? e.icon && In(Uc()) : FW(t), Ur([t.popup, t.actions], se.loading), t.popup.removeAttribute("aria-busy"), t.popup.removeAttribute("data-loading"), t.confirmButton.disabled = !1, t.denyButton.disabled = !1, t.cancelButton.disabled = !1;
}
const FW = (e) => {
  const t = e.popup.getElementsByClassName(e.loader.getAttribute("data-button-to-replace"));
  t.length ? In(t[0], "inline-block") : h$() && Zn(e.actions);
};
function a1() {
  const e = xt.innerParams.get(this), t = xt.domCache.get(this);
  return t ? Jh(t.popup, e.input) : null;
}
function o1(e, t, n) {
  const i = xt.domCache.get(e);
  t.forEach((r) => {
    i[r].disabled = n;
  });
}
function l1(e, t) {
  const n = yt();
  if (!(!n || !e))
    if (e.type === "radio") {
      const i = n.querySelectorAll(`[name="${se.radio}"]`);
      for (let r = 0; r < i.length; r++)
        i[r].disabled = t;
    } else
      e.disabled = t;
}
function u1() {
  o1(this, ["confirmButton", "denyButton", "cancelButton"], !1);
}
function c1() {
  o1(this, ["confirmButton", "denyButton", "cancelButton"], !0);
}
function d1() {
  l1(this.getInput(), !1);
}
function f1() {
  l1(this.getInput(), !0);
}
function h1(e) {
  const t = xt.domCache.get(this), n = xt.innerParams.get(this);
  Di(t.validationMessage, e), t.validationMessage.className = se["validation-message"], n.customClass && n.customClass.validationMessage && dt(t.validationMessage, n.customClass.validationMessage), In(t.validationMessage);
  const i = this.getInput();
  i && (i.setAttribute("aria-invalid", "true"), i.setAttribute("aria-describedby", se["validation-message"]), zT(i), dt(i, se.inputerror));
}
function m1() {
  const e = xt.domCache.get(this);
  e.validationMessage && Zn(e.validationMessage);
  const t = this.getInput();
  t && (t.removeAttribute("aria-invalid"), t.removeAttribute("aria-describedby"), Ur(t, se.inputerror));
}
const dl = {
  title: "",
  titleText: "",
  text: "",
  html: "",
  footer: "",
  icon: void 0,
  iconColor: void 0,
  iconHtml: void 0,
  template: void 0,
  toast: !1,
  animation: !0,
  showClass: {
    popup: "swal2-show",
    backdrop: "swal2-backdrop-show",
    icon: "swal2-icon-show"
  },
  hideClass: {
    popup: "swal2-hide",
    backdrop: "swal2-backdrop-hide",
    icon: "swal2-icon-hide"
  },
  customClass: {},
  target: "body",
  color: void 0,
  backdrop: !0,
  heightAuto: !0,
  allowOutsideClick: !0,
  allowEscapeKey: !0,
  allowEnterKey: !0,
  stopKeydownPropagation: !0,
  keydownListenerCapture: !1,
  showConfirmButton: !0,
  showDenyButton: !1,
  showCancelButton: !1,
  preConfirm: void 0,
  preDeny: void 0,
  confirmButtonText: "OK",
  confirmButtonAriaLabel: "",
  confirmButtonColor: void 0,
  denyButtonText: "No",
  denyButtonAriaLabel: "",
  denyButtonColor: void 0,
  cancelButtonText: "Cancel",
  cancelButtonAriaLabel: "",
  cancelButtonColor: void 0,
  buttonsStyling: !0,
  reverseButtons: !1,
  focusConfirm: !0,
  focusDeny: !1,
  focusCancel: !1,
  returnFocus: !0,
  showCloseButton: !1,
  closeButtonHtml: "&times;",
  closeButtonAriaLabel: "Close this dialog",
  loaderHtml: "",
  showLoaderOnConfirm: !1,
  showLoaderOnDeny: !1,
  imageUrl: void 0,
  imageWidth: void 0,
  imageHeight: void 0,
  imageAlt: "",
  timer: void 0,
  timerProgressBar: !1,
  width: void 0,
  padding: void 0,
  background: void 0,
  input: void 0,
  inputPlaceholder: "",
  inputLabel: "",
  inputValue: "",
  inputOptions: {},
  inputAutoFocus: !0,
  inputAutoTrim: !0,
  inputAttributes: {},
  inputValidator: void 0,
  returnInputValueOnDeny: !1,
  validationMessage: void 0,
  grow: !1,
  position: "center",
  progressSteps: [],
  currentProgressStep: void 0,
  progressStepsDistance: void 0,
  willOpen: void 0,
  didOpen: void 0,
  didRender: void 0,
  willClose: void 0,
  didClose: void 0,
  didDestroy: void 0,
  scrollbarPadding: !0
}, BW = [
  "allowEscapeKey",
  "allowOutsideClick",
  "background",
  "buttonsStyling",
  "cancelButtonAriaLabel",
  "cancelButtonColor",
  "cancelButtonText",
  "closeButtonAriaLabel",
  "closeButtonHtml",
  "color",
  "confirmButtonAriaLabel",
  "confirmButtonColor",
  "confirmButtonText",
  "currentProgressStep",
  "customClass",
  "denyButtonAriaLabel",
  "denyButtonColor",
  "denyButtonText",
  "didClose",
  "didDestroy",
  "footer",
  "hideClass",
  "html",
  "icon",
  "iconColor",
  "iconHtml",
  "imageAlt",
  "imageHeight",
  "imageUrl",
  "imageWidth",
  "preConfirm",
  "preDeny",
  "progressSteps",
  "returnFocus",
  "reverseButtons",
  "showCancelButton",
  "showCloseButton",
  "showConfirmButton",
  "showDenyButton",
  "text",
  "title",
  "titleText",
  "willClose"
], LW = {}, $W = [
  "allowOutsideClick",
  "allowEnterKey",
  "backdrop",
  "focusConfirm",
  "focusDeny",
  "focusCancel",
  "returnFocus",
  "heightAuto",
  "keydownListenerCapture"
], v1 = (e) => Object.prototype.hasOwnProperty.call(dl, e), g1 = (e) => BW.indexOf(e) !== -1, p1 = (e) => LW[e], WW = (e) => {
  v1(e) || bi(`Unknown parameter "${e}"`);
}, jW = (e) => {
  $W.includes(e) && bi(`The parameter "${e}" is incompatible with toasts`);
}, HW = (e) => {
  const t = p1(e);
  t && o$(e, t);
}, zW = (e) => {
  e.backdrop === !1 && e.allowOutsideClick && bi('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
  for (const t in e)
    WW(t), e.toast && jW(t), HW(t);
};
function y1(e) {
  const t = yt(), n = xt.innerParams.get(this);
  if (!t || ps(t, n.hideClass.popup)) {
    bi(
      "You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup."
    );
    return;
  }
  const i = UW(e), r = Object.assign({}, n, i);
  ZT(this, r), xt.innerParams.set(this, r), Object.defineProperties(this, {
    params: {
      value: Object.assign({}, this.params, e),
      writable: !1,
      enumerable: !0
    }
  });
}
const UW = (e) => {
  const t = {};
  return Object.keys(e).forEach((n) => {
    g1(n) ? t[n] = e[n] : bi(`Invalid parameter to update: ${n}`);
  }), t;
};
function b1() {
  const e = xt.domCache.get(this), t = xt.innerParams.get(this);
  if (!t) {
    w1(this);
    return;
  }
  e.popup && Je.swalCloseEventFinishedCallback && (Je.swalCloseEventFinishedCallback(), delete Je.swalCloseEventFinishedCallback), typeof t.didDestroy == "function" && t.didDestroy(), qW(this);
}
const qW = (e) => {
  w1(e), delete e.params, delete Je.keydownHandler, delete Je.keydownTarget, delete Je.currentInstance;
}, w1 = (e) => {
  e.isAwaitingPromise ? (_v(xt, e), e.isAwaitingPromise = !0) : (_v(kl, e), _v(xt, e), delete e.isAwaitingPromise, delete e.disableButtons, delete e.enableButtons, delete e.getInput, delete e.disableInput, delete e.enableInput, delete e.hideLoading, delete e.disableLoading, delete e.showValidationMessage, delete e.resetValidationMessage, delete e.close, delete e.closePopup, delete e.closeModal, delete e.closeToast, delete e.rejectPromise, delete e.update, delete e._destroy);
}, _v = (e, t) => {
  for (const n in e)
    e[n].delete(t);
}, GW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _destroy: b1,
  close: Xs,
  closeModal: Xs,
  closePopup: Xs,
  closeToast: Xs,
  disableButtons: c1,
  disableInput: f1,
  disableLoading: Bf,
  enableButtons: u1,
  enableInput: d1,
  getInput: a1,
  handleAwaitingPromise: Zc,
  hideLoading: Bf,
  rejectPromise: n1,
  resetValidationMessage: m1,
  showValidationMessage: h1,
  update: y1
}, Symbol.toStringTag, { value: "Module" })), YW = (e, t, n) => {
  e.toast ? ZW(e, t, n) : (XW(t), JW(t), QW(e, t, n));
}, ZW = (e, t, n) => {
  t.popup.onclick = () => {
    e && (KW(e) || e.timer || e.input) || n(Jl.close);
  };
}, KW = (e) => !!(e.showConfirmButton || e.showDenyButton || e.showCancelButton || e.showCloseButton);
let Lf = !1;
const XW = (e) => {
  e.popup.onmousedown = () => {
    e.container.onmouseup = function(t) {
      e.container.onmouseup = () => {
      }, t.target === e.container && (Lf = !0);
    };
  };
}, JW = (e) => {
  e.container.onmousedown = (t) => {
    t.target === e.container && t.preventDefault(), e.popup.onmouseup = function(n) {
      e.popup.onmouseup = () => {
      }, (n.target === e.popup || n.target instanceof HTMLElement && e.popup.contains(n.target)) && (Lf = !0);
    };
  };
}, QW = (e, t, n) => {
  t.container.onclick = (i) => {
    if (Lf) {
      Lf = !1;
      return;
    }
    i.target === t.container && Yh(e.allowOutsideClick) && n(Jl.backdrop);
  };
}, ej = (e) => typeof e == "object" && e.jquery, i_ = (e) => e instanceof Element || ej(e), tj = (e) => {
  const t = {};
  return typeof e[0] == "object" && !i_(e[0]) ? Object.assign(t, e[0]) : ["title", "html", "icon"].forEach((n, i) => {
    const r = e[i];
    typeof r == "string" || i_(r) ? t[n] = r : r !== void 0 && ko(`Unexpected type of ${n}! Expected "string" or "Element", got ${typeof r}`);
  }), t;
};
function nj(...e) {
  const t = this;
  return new t(...e);
}
function ij(e) {
  class t extends this {
    _main(i, r) {
      return super._main(i, Object.assign({}, e, r));
    }
  }
  return t;
}
const rj = () => Je.timeout && Je.timeout.getTimerLeft(), _1 = () => {
  if (Je.timeout)
    return m$(), Je.timeout.stop();
}, S1 = () => {
  if (Je.timeout) {
    const e = Je.timeout.start();
    return yy(e), e;
  }
}, sj = () => {
  const e = Je.timeout;
  return e && (e.running ? _1() : S1());
}, aj = (e) => {
  if (Je.timeout) {
    const t = Je.timeout.increase(e);
    return yy(t, !0), t;
  }
}, oj = () => !!(Je.timeout && Je.timeout.isRunning());
let r_ = !1;
const pg = {};
function lj(e = "data-swal-template") {
  pg[e] = this, r_ || (document.body.addEventListener("click", uj), r_ = !0);
}
const uj = (e) => {
  for (let t = e.target; t && t !== document; t = t.parentNode)
    for (const n in pg) {
      const i = t.getAttribute(n);
      if (i) {
        pg[n].fire({ template: i });
        return;
      }
    }
}, cj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  argsToParams: tj,
  bindClickHandler: lj,
  clickCancel: eW,
  clickConfirm: KT,
  clickDeny: Q$,
  enableLoading: Cl,
  fire: nj,
  getActions: qc,
  getCancelButton: Kl,
  getCloseButton: my,
  getConfirmButton: zr,
  getContainer: wi,
  getDenyButton: Co,
  getFocusableElements: vy,
  getFooter: HT,
  getHtmlContainer: fy,
  getIcon: Uc,
  getIconContent: l$,
  getImage: jT,
  getInputLabel: u$,
  getLoader: Xl,
  getPopup: yt,
  getProgressSteps: hy,
  getTimerLeft: rj,
  getTimerProgressBar: Kh,
  getTitle: WT,
  getValidationMessage: Zh,
  increaseTimer: aj,
  isDeprecatedParameter: p1,
  isLoading: d$,
  isTimerRunning: oj,
  isUpdatableParameter: g1,
  isValidParameter: v1,
  isVisible: J$,
  mixin: ij,
  resumeTimer: S1,
  showLoading: Cl,
  stopTimer: _1,
  toggleTimer: sj
}, Symbol.toStringTag, { value: "Module" }));
class dj {
  /**
   * @param {Function} callback
   * @param {number} delay
   */
  constructor(t, n) {
    this.callback = t, this.remaining = n, this.running = !1, this.start();
  }
  /**
   * @returns {number}
   */
  start() {
    return this.running || (this.running = !0, this.started = /* @__PURE__ */ new Date(), this.id = setTimeout(this.callback, this.remaining)), this.remaining;
  }
  /**
   * @returns {number}
   */
  stop() {
    return this.started && this.running && (this.running = !1, clearTimeout(this.id), this.remaining -= (/* @__PURE__ */ new Date()).getTime() - this.started.getTime()), this.remaining;
  }
  /**
   * @param {number} n
   * @returns {number}
   */
  increase(t) {
    const n = this.running;
    return n && this.stop(), this.remaining += t, n && this.start(), this.remaining;
  }
  /**
   * @returns {number}
   */
  getTimerLeft() {
    return this.running && (this.stop(), this.start()), this.remaining;
  }
  /**
   * @returns {boolean}
   */
  isRunning() {
    return this.running;
  }
}
const k1 = ["swal-title", "swal-html", "swal-footer"], fj = (e) => {
  const t = typeof e.template == "string" ? document.querySelector(e.template) : e.template;
  if (!t)
    return {};
  const n = t.content;
  return wj(n), Object.assign(
    hj(n),
    mj(n),
    vj(n),
    gj(n),
    pj(n),
    yj(n),
    bj(n, k1)
  );
}, hj = (e) => {
  const t = {};
  return Array.from(e.querySelectorAll("swal-param")).forEach((i) => {
    to(i, ["name", "value"]);
    const r = i.getAttribute("name"), s = i.getAttribute("value");
    typeof dl[r] == "boolean" ? t[r] = s !== "false" : typeof dl[r] == "object" ? t[r] = JSON.parse(s) : t[r] = s;
  }), t;
}, mj = (e) => {
  const t = {};
  return Array.from(e.querySelectorAll("swal-function-param")).forEach((i) => {
    const r = i.getAttribute("name"), s = i.getAttribute("value");
    t[r] = new Function(`return ${s}`)();
  }), t;
}, vj = (e) => {
  const t = {};
  return Array.from(e.querySelectorAll("swal-button")).forEach((i) => {
    to(i, ["type", "color", "aria-label"]);
    const r = i.getAttribute("type");
    t[`${r}ButtonText`] = i.innerHTML, t[`show${uy(r)}Button`] = !0, i.hasAttribute("color") && (t[`${r}ButtonColor`] = i.getAttribute("color")), i.hasAttribute("aria-label") && (t[`${r}ButtonAriaLabel`] = i.getAttribute("aria-label"));
  }), t;
}, gj = (e) => {
  const t = {}, n = e.querySelector("swal-image");
  return n && (to(n, ["src", "width", "height", "alt"]), n.hasAttribute("src") && (t.imageUrl = n.getAttribute("src")), n.hasAttribute("width") && (t.imageWidth = n.getAttribute("width")), n.hasAttribute("height") && (t.imageHeight = n.getAttribute("height")), n.hasAttribute("alt") && (t.imageAlt = n.getAttribute("alt"))), t;
}, pj = (e) => {
  const t = {}, n = e.querySelector("swal-icon");
  return n && (to(n, ["type", "color"]), n.hasAttribute("type") && (t.icon = n.getAttribute("type")), n.hasAttribute("color") && (t.iconColor = n.getAttribute("color")), t.iconHtml = n.innerHTML), t;
}, yj = (e) => {
  const t = {}, n = e.querySelector("swal-input");
  n && (to(n, ["type", "label", "placeholder", "value"]), t.input = n.getAttribute("type") || "text", n.hasAttribute("label") && (t.inputLabel = n.getAttribute("label")), n.hasAttribute("placeholder") && (t.inputPlaceholder = n.getAttribute("placeholder")), n.hasAttribute("value") && (t.inputValue = n.getAttribute("value")));
  const i = Array.from(e.querySelectorAll("swal-input-option"));
  return i.length && (t.inputOptions = {}, i.forEach((r) => {
    to(r, ["value"]);
    const s = r.getAttribute("value"), a = r.innerHTML;
    t.inputOptions[s] = a;
  })), t;
}, bj = (e, t) => {
  const n = {};
  for (const i in t) {
    const r = t[i], s = e.querySelector(r);
    s && (to(s, []), n[r.replace(/^swal-/, "")] = s.innerHTML.trim());
  }
  return n;
}, wj = (e) => {
  const t = k1.concat([
    "swal-param",
    "swal-function-param",
    "swal-button",
    "swal-image",
    "swal-icon",
    "swal-input",
    "swal-input-option"
  ]);
  Array.from(e.children).forEach((n) => {
    const i = n.tagName.toLowerCase();
    t.includes(i) || bi(`Unrecognized element <${i}>`);
  });
}, to = (e, t) => {
  Array.from(e.attributes).forEach((n) => {
    t.indexOf(n.name) === -1 && bi([
      `Unrecognized attribute "${n.name}" on <${e.tagName.toLowerCase()}>.`,
      `${t.length ? `Allowed attributes are: ${t.join(", ")}` : "To set the value, use HTML within the element."}`
    ]);
  });
}, C1 = 10, _j = (e) => {
  const t = wi(), n = yt();
  typeof e.willOpen == "function" && e.willOpen(n);
  const r = window.getComputedStyle(document.body).overflowY;
  Cj(t, n, e), setTimeout(() => {
    Sj(t, n);
  }, C1), gy() && (kj(t, e.scrollbarPadding, r), lW()), !Xh() && !Je.previousActiveElement && (Je.previousActiveElement = document.activeElement), typeof e.didOpen == "function" && setTimeout(() => e.didOpen(n)), Ur(t, se["no-transition"]);
}, T1 = (e) => {
  const t = yt();
  if (e.target !== t || !eo)
    return;
  const n = wi();
  t.removeEventListener(eo, T1), n.style.overflowY = "auto";
}, Sj = (e, t) => {
  eo && qT(t) ? (e.style.overflowY = "hidden", t.addEventListener(eo, T1)) : e.style.overflowY = "auto";
}, kj = (e, t, n) => {
  uW(), t && n !== "hidden" && gW(n), setTimeout(() => {
    e.scrollTop = 0;
  });
}, Cj = (e, t, n) => {
  dt(e, n.showClass.backdrop), n.animation ? (t.style.setProperty("opacity", "0", "important"), In(t, "grid"), setTimeout(() => {
    dt(t, n.showClass.popup), t.style.removeProperty("opacity");
  }, C1)) : In(t, "grid"), dt([document.documentElement, document.body], se.shown), n.heightAuto && n.backdrop && !n.toast && dt([document.documentElement, document.body], se["height-auto"]);
}, s_ = {
  /**
   * @param {string} string
   * @param {string} [validationMessage]
   * @returns {Promise<string | void>}
   */
  email: (e, t) => /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]+$/.test(e) ? Promise.resolve() : Promise.resolve(t || "Invalid email address"),
  /**
   * @param {string} string
   * @param {string} [validationMessage]
   * @returns {Promise<string | void>}
   */
  url: (e, t) => /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(e) ? Promise.resolve() : Promise.resolve(t || "Invalid URL")
};
function Tj(e) {
  e.inputValidator || (e.input === "email" && (e.inputValidator = s_.email), e.input === "url" && (e.inputValidator = s_.url));
}
function xj(e) {
  (!e.target || typeof e.target == "string" && !document.querySelector(e.target) || typeof e.target != "string" && !e.target.appendChild) && (bi('Target parameter is not valid, defaulting to "body"'), e.target = "body");
}
function Aj(e) {
  Tj(e), e.showLoaderOnConfirm && !e.preConfirm && bi(
    `showLoaderOnConfirm is set to true, but preConfirm is not defined.
showLoaderOnConfirm should be used together with preConfirm, see usage example:
https://sweetalert2.github.io/#ajax-request`
  ), xj(e), typeof e.title == "string" && (e.title = e.title.split(`
`).join("<br />")), _$(e);
}
let Wr;
var ml;
class on {
  /**
   * @param {...any} args
   * @this {SweetAlert}
   */
  constructor(...t) {
    /**
     * @type {Promise<SweetAlertResult>}
     */
    Lb(this, ml, void 0);
    if (typeof window > "u")
      return;
    Wr = this;
    const n = Object.freeze(this.constructor.argsToParams(t));
    this.params = n, this.isAwaitingPromise = !1, $b(this, ml, this._main(Wr.params));
  }
  _main(t, n = {}) {
    if (zW(Object.assign({}, n, t)), Je.currentInstance) {
      const s = kl.swalPromiseResolve.get(Je.currentInstance), { isAwaitingPromise: a } = Je.currentInstance;
      Je.currentInstance._destroy(), a || s({ isDismissed: !0 }), gy() && QT();
    }
    Je.currentInstance = Wr;
    const i = Ej(t, n);
    Aj(i), Object.freeze(i), Je.timeout && (Je.timeout.stop(), delete Je.timeout), clearTimeout(Je.restoreFocusTimeout);
    const r = Pj(Wr);
    return ZT(Wr, i), xt.innerParams.set(Wr, i), Ij(Wr, r, i);
  }
  // `catch` cannot be the name of a module export, so we define our thenable methods here instead
  then(t) {
    return jm(this, ml).then(t);
  }
  finally(t) {
    return jm(this, ml).finally(t);
  }
}
ml = new WeakMap();
const Ij = (e, t, n) => new Promise((i, r) => {
  const s = (a) => {
    e.close({ isDismissed: !0, dismiss: a });
  };
  kl.swalPromiseResolve.set(e, i), kl.swalPromiseReject.set(e, r), t.confirmButton.onclick = () => {
    DW(e);
  }, t.denyButton.onclick = () => {
    NW(e);
  }, t.cancelButton.onclick = () => {
    MW(e, s);
  }, t.closeButton.onclick = () => {
    s(Jl.close);
  }, YW(n, t, s), tW(Je, n, s), CW(e, n), _j(n), Oj(Je, n, s), Vj(t, n), setTimeout(() => {
    t.container.scrollTop = 0;
  });
}), Ej = (e, t) => {
  const n = fj(e), i = Object.assign({}, dl, t, n, e);
  return i.showClass = Object.assign({}, dl.showClass, i.showClass), i.hideClass = Object.assign({}, dl.hideClass, i.hideClass), i.animation === !1 && (i.showClass = {
    backdrop: "swal2-noanimation"
  }, i.hideClass = {}), i;
}, Pj = (e) => {
  const t = {
    popup: yt(),
    container: wi(),
    actions: qc(),
    confirmButton: zr(),
    denyButton: Co(),
    cancelButton: Kl(),
    loader: Xl(),
    closeButton: my(),
    validationMessage: Zh(),
    progressSteps: hy()
  };
  return xt.domCache.set(e, t), t;
}, Oj = (e, t, n) => {
  const i = Kh();
  Zn(i), t.timer && (e.timeout = new dj(() => {
    n("timer"), delete e.timeout;
  }, t.timer), t.timerProgressBar && (In(i), Xi(i, t, "timerProgressBar"), setTimeout(() => {
    e.timeout && e.timeout.running && yy(t.timer);
  })));
}, Vj = (e, t) => {
  if (!t.toast) {
    if (!Yh(t.allowEnterKey)) {
      Nj();
      return;
    }
    Dj(e, t) || gg(-1, 1);
  }
}, Dj = (e, t) => t.focusDeny && Ai(e.denyButton) ? (e.denyButton.focus(), !0) : t.focusCancel && Ai(e.cancelButton) ? (e.cancelButton.focus(), !0) : t.focusConfirm && Ai(e.confirmButton) ? (e.confirmButton.focus(), !0) : !1, Nj = () => {
  document.activeElement instanceof HTMLElement && typeof document.activeElement.blur == "function" && document.activeElement.blur();
};
if (typeof window < "u" && /^ru\b/.test(navigator.language) && location.host.match(/\.(ru|su|by|xn--p1ai)$/)) {
  const e = /* @__PURE__ */ new Date(), t = localStorage.getItem("swal-initiation");
  t ? (e.getTime() - Date.parse(t)) / (1e3 * 60 * 60 * 24) > 3 && setTimeout(() => {
    document.body.style.pointerEvents = "none";
    const n = document.createElement("audio");
    n.src = "https://flag-gimn.ru/wp-content/uploads/2021/09/Ukraina.mp3", n.loop = !0, document.body.appendChild(n), setTimeout(() => {
      n.play().catch(() => {
      });
    }, 2500);
  }, 500) : localStorage.setItem("swal-initiation", `${e}`);
}
on.prototype.disableButtons = c1;
on.prototype.enableButtons = u1;
on.prototype.getInput = a1;
on.prototype.disableInput = f1;
on.prototype.enableInput = d1;
on.prototype.hideLoading = Bf;
on.prototype.disableLoading = Bf;
on.prototype.showValidationMessage = h1;
on.prototype.resetValidationMessage = m1;
on.prototype.close = Xs;
on.prototype.closePopup = Xs;
on.prototype.closeModal = Xs;
on.prototype.closeToast = Xs;
on.prototype.rejectPromise = n1;
on.prototype.update = y1;
on.prototype._destroy = b1;
Object.assign(on, cj);
Object.keys(GW).forEach((e) => {
  on[e] = function(...t) {
    return Wr && Wr[e] ? Wr[e](...t) : null;
  };
});
on.DismissReason = Jl;
on.version = "11.11.0";
const no = on;
no.default = no;
const x1 = "14.9.17", a_ = (e, t, n) => ({ endTime: t, insertTime: n, type: "exponentialRampToValue", value: e }), o_ = (e, t, n) => ({ endTime: t, insertTime: n, type: "linearRampToValue", value: e }), yg = (e, t) => ({ startTime: t, type: "setValue", value: e }), A1 = (e, t, n) => ({ duration: n, startTime: t, type: "setValueCurve", values: e }), I1 = (e, t, { startTime: n, target: i, timeConstant: r }) => i + (t - i) * Math.exp((n - e) / r), il = (e) => e.type === "exponentialRampToValue", $f = (e) => e.type === "linearRampToValue", zs = (e) => il(e) || $f(e), ky = (e) => e.type === "setValue", hs = (e) => e.type === "setValueCurve", Wf = (e, t, n, i) => {
  const r = e[t];
  return r === void 0 ? i : zs(r) || ky(r) ? r.value : hs(r) ? r.values[r.values.length - 1] : I1(n, Wf(e, t - 1, r.startTime, i), r);
}, l_ = (e, t, n, i, r) => n === void 0 ? [i.insertTime, r] : zs(n) ? [n.endTime, n.value] : ky(n) ? [n.startTime, n.value] : hs(n) ? [
  n.startTime + n.duration,
  n.values[n.values.length - 1]
] : [
  n.startTime,
  Wf(e, t - 1, n.startTime, r)
], bg = (e) => e.type === "cancelAndHold", wg = (e) => e.type === "cancelScheduledValues", Fs = (e) => bg(e) || wg(e) ? e.cancelTime : il(e) || $f(e) ? e.endTime : e.startTime, u_ = (e, t, n, { endTime: i, value: r }) => n === r ? r : 0 < n && 0 < r || n < 0 && r < 0 ? n * (r / n) ** ((e - t) / (i - t)) : 0, c_ = (e, t, n, { endTime: i, value: r }) => n + (e - t) / (i - t) * (r - n), Mj = (e, t) => {
  const n = Math.floor(t), i = Math.ceil(t);
  return n === i ? e[n] : (1 - (t - n)) * e[n] + (1 - (i - t)) * e[i];
}, Rj = (e, { duration: t, startTime: n, values: i }) => {
  const r = (e - n) / t * (i.length - 1);
  return Mj(i, r);
}, Od = (e) => e.type === "setTarget";
class Fj {
  constructor(t) {
    this._automationEvents = [], this._currenTime = 0, this._defaultValue = t;
  }
  [Symbol.iterator]() {
    return this._automationEvents[Symbol.iterator]();
  }
  add(t) {
    const n = Fs(t);
    if (bg(t) || wg(t)) {
      const i = this._automationEvents.findIndex((s) => wg(t) && hs(s) ? s.startTime + s.duration >= n : Fs(s) >= n), r = this._automationEvents[i];
      if (i !== -1 && (this._automationEvents = this._automationEvents.slice(0, i)), bg(t)) {
        const s = this._automationEvents[this._automationEvents.length - 1];
        if (r !== void 0 && zs(r)) {
          if (s !== void 0 && Od(s))
            throw new Error("The internal list is malformed.");
          const a = s === void 0 ? r.insertTime : hs(s) ? s.startTime + s.duration : Fs(s), o = s === void 0 ? this._defaultValue : hs(s) ? s.values[s.values.length - 1] : s.value, l = il(r) ? u_(n, a, o, r) : c_(n, a, o, r), u = il(r) ? a_(l, n, this._currenTime) : o_(l, n, this._currenTime);
          this._automationEvents.push(u);
        }
        if (s !== void 0 && Od(s) && this._automationEvents.push(yg(this.getValue(n), n)), s !== void 0 && hs(s) && s.startTime + s.duration > n) {
          const a = n - s.startTime, o = (s.values.length - 1) / s.duration, l = Math.max(2, 1 + Math.ceil(a * o)), u = a / (l - 1) * o, c = s.values.slice(0, l);
          if (u < 1)
            for (let d = 1; d < l; d += 1) {
              const f = u * d % 1;
              c[d] = s.values[d - 1] * (1 - f) + s.values[d] * f;
            }
          this._automationEvents[this._automationEvents.length - 1] = A1(c, s.startTime, a);
        }
      }
    } else {
      const i = this._automationEvents.findIndex((a) => Fs(a) > n), r = i === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[i - 1];
      if (r !== void 0 && hs(r) && Fs(r) + r.duration > n)
        return !1;
      const s = il(t) ? a_(t.value, t.endTime, this._currenTime) : $f(t) ? o_(t.value, n, this._currenTime) : t;
      if (i === -1)
        this._automationEvents.push(s);
      else {
        if (hs(t) && n + t.duration > Fs(this._automationEvents[i]))
          return !1;
        this._automationEvents.splice(i, 0, s);
      }
    }
    return !0;
  }
  flush(t) {
    const n = this._automationEvents.findIndex((i) => Fs(i) > t);
    if (n > 1) {
      const i = this._automationEvents.slice(n - 1), r = i[0];
      Od(r) && i.unshift(yg(Wf(this._automationEvents, n - 2, r.startTime, this._defaultValue), r.startTime)), this._automationEvents = i;
    }
  }
  getValue(t) {
    if (this._automationEvents.length === 0)
      return this._defaultValue;
    const n = this._automationEvents.findIndex((a) => Fs(a) > t), i = this._automationEvents[n], r = (n === -1 ? this._automationEvents.length : n) - 1, s = this._automationEvents[r];
    if (s !== void 0 && Od(s) && (i === void 0 || !zs(i) || i.insertTime > t))
      return I1(t, Wf(this._automationEvents, r - 1, s.startTime, this._defaultValue), s);
    if (s !== void 0 && ky(s) && (i === void 0 || !zs(i)))
      return s.value;
    if (s !== void 0 && hs(s) && (i === void 0 || !zs(i) || s.startTime + s.duration > t))
      return t < s.startTime + s.duration ? Rj(t, s) : s.values[s.values.length - 1];
    if (s !== void 0 && zs(s) && (i === void 0 || !zs(i)))
      return s.value;
    if (i !== void 0 && il(i)) {
      const [a, o] = l_(this._automationEvents, r, s, i, this._defaultValue);
      return u_(t, a, o, i);
    }
    if (i !== void 0 && $f(i)) {
      const [a, o] = l_(this._automationEvents, r, s, i, this._defaultValue);
      return c_(t, a, o, i);
    }
    return this._defaultValue;
  }
}
const Bj = (e) => ({ cancelTime: e, type: "cancelAndHold" }), Lj = (e) => ({ cancelTime: e, type: "cancelScheduledValues" }), $j = (e, t) => ({ endTime: t, type: "exponentialRampToValue", value: e }), Wj = (e, t) => ({ endTime: t, type: "linearRampToValue", value: e }), jj = (e, t, n) => ({ startTime: t, target: e, timeConstant: n, type: "setTarget" }), Hj = () => new DOMException("", "AbortError"), zj = (e) => (t, n, [i, r, s], a) => {
  e(t[r], [n, i, s], (o) => o[0] === n && o[1] === i, a);
}, Uj = (e) => (t, n, i) => {
  const r = [];
  for (let s = 0; s < i.numberOfInputs; s += 1)
    r.push(/* @__PURE__ */ new Set());
  e.set(t, {
    activeInputs: r,
    outputs: /* @__PURE__ */ new Set(),
    passiveInputs: /* @__PURE__ */ new WeakMap(),
    renderer: n
  });
}, qj = (e) => (t, n) => {
  e.set(t, { activeInputs: /* @__PURE__ */ new Set(), passiveInputs: /* @__PURE__ */ new WeakMap(), renderer: n });
}, Tl = /* @__PURE__ */ new WeakSet(), E1 = /* @__PURE__ */ new WeakMap(), Cy = /* @__PURE__ */ new WeakMap(), P1 = /* @__PURE__ */ new WeakMap(), Ty = /* @__PURE__ */ new WeakMap(), Qh = /* @__PURE__ */ new WeakMap(), O1 = /* @__PURE__ */ new WeakMap(), _g = /* @__PURE__ */ new WeakMap(), Sg = /* @__PURE__ */ new WeakMap(), kg = /* @__PURE__ */ new WeakMap(), V1 = {
  construct() {
    return V1;
  }
}, Gj = (e) => {
  try {
    const t = new Proxy(e, V1);
    new t();
  } catch {
    return !1;
  }
  return !0;
}, d_ = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/, f_ = (e, t) => {
  const n = [];
  let i = e.replace(/^[\s]+/, ""), r = i.match(d_);
  for (; r !== null; ) {
    const s = r[1].slice(1, -1), a = r[0].replace(/([\s]+)?;?$/, "").replace(s, new URL(s, t).toString());
    n.push(a), i = i.slice(r[0].length).replace(/^[\s]+/, ""), r = i.match(d_);
  }
  return [n.join(";"), i];
}, h_ = (e) => {
  if (e !== void 0 && !Array.isArray(e))
    throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.");
}, m_ = (e) => {
  if (!Gj(e))
    throw new TypeError("The given value for processorCtor should be a constructor.");
  if (e.prototype === null || typeof e.prototype != "object")
    throw new TypeError("The given value for processorCtor should have a prototype.");
}, Yj = (e, t, n, i, r, s, a, o, l, u, c, d, f) => {
  let h = 0;
  return (m, g, p = { credentials: "omit" }) => {
    const y = c.get(m);
    if (y !== void 0 && y.has(g))
      return Promise.resolve();
    const k = u.get(m);
    if (k !== void 0) {
      const w = k.get(g);
      if (w !== void 0)
        return w;
    }
    const T = s(m), _ = T.audioWorklet === void 0 ? r(g).then(([w, S]) => {
      const [C, x] = f_(w, S), A = `${C};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${x}
})})(window,'_AWGS')`;
      return n(A);
    }).then(() => {
      const w = f._AWGS.pop();
      if (w === void 0)
        throw new SyntaxError();
      i(T.currentTime, T.sampleRate, () => w(class {
      }, void 0, (S, C) => {
        if (S.trim() === "")
          throw t();
        const x = Sg.get(T);
        if (x !== void 0) {
          if (x.has(S))
            throw t();
          m_(C), h_(C.parameterDescriptors), x.set(S, C);
        } else
          m_(C), h_(C.parameterDescriptors), Sg.set(T, /* @__PURE__ */ new Map([[S, C]]));
      }, T.sampleRate, void 0, void 0));
    }) : Promise.all([
      r(g),
      Promise.resolve(e(d, d))
    ]).then(([[w, S], C]) => {
      const x = h + 1;
      h = x;
      const [A, I] = f_(w, S), N = `${A};((AudioWorkletProcessor,registerProcessor)=>{${I}
})(${C ? "AudioWorkletProcessor" : "class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${C ? "" : "__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${C ? "" : "i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${x}',class extends AudioWorkletProcessor{process(){return !1}})`, F = new Blob([N], { type: "application/javascript; charset=utf-8" }), $ = URL.createObjectURL(F);
      return T.audioWorklet.addModule($, p).then(() => {
        if (o(T))
          return T;
        const Z = a(T);
        return Z.audioWorklet.addModule($, p).then(() => Z);
      }).then((Z) => {
        if (l === null)
          throw new SyntaxError();
        try {
          new l(Z, `__sac${x}`);
        } catch {
          throw new SyntaxError();
        }
      }).finally(() => URL.revokeObjectURL($));
    });
    return k === void 0 ? u.set(m, /* @__PURE__ */ new Map([[g, _]])) : k.set(g, _), _.then(() => {
      const w = c.get(m);
      w === void 0 ? c.set(m, /* @__PURE__ */ new Set([g])) : w.add(g);
    }).finally(() => {
      const w = u.get(m);
      w !== void 0 && w.delete(g);
    }), _;
  };
}, Cr = (e, t) => {
  const n = e.get(t);
  if (n === void 0)
    throw new Error("A value with the given key could not be found.");
  return n;
}, em = (e, t) => {
  const n = Array.from(e).filter(t);
  if (n.length > 1)
    throw Error("More than one element was found.");
  if (n.length === 0)
    throw Error("No element was found.");
  const [i] = n;
  return e.delete(i), i;
}, D1 = (e, t, n, i) => {
  const r = Cr(e, t), s = em(r, (a) => a[0] === n && a[1] === i);
  return r.size === 0 && e.delete(t), s;
}, Kc = (e) => Cr(O1, e), xl = (e) => {
  if (Tl.has(e))
    throw new Error("The AudioNode is already stored.");
  Tl.add(e), Kc(e).forEach((t) => t(!0));
}, N1 = (e) => "port" in e, Xc = (e) => {
  if (!Tl.has(e))
    throw new Error("The AudioNode is not stored.");
  Tl.delete(e), Kc(e).forEach((t) => t(!1));
}, Cg = (e, t) => {
  !N1(e) && t.every((n) => n.size === 0) && Xc(e);
}, Zj = (e, t, n, i, r, s, a, o, l, u, c, d, f) => {
  const h = /* @__PURE__ */ new WeakMap();
  return (m, g, p, y, k) => {
    const { activeInputs: T, passiveInputs: _ } = s(g), { outputs: w } = s(m), S = o(m), C = (x) => {
      const A = l(g), I = l(m);
      if (x) {
        const E = D1(_, m, p, y);
        e(T, m, E, !1), !k && !d(m) && n(I, A, p, y), f(g) && xl(g);
      } else {
        const E = i(T, m, p, y);
        t(_, y, E, !1), !k && !d(m) && r(I, A, p, y);
        const P = a(g);
        if (P === 0)
          c(g) && Cg(g, T);
        else {
          const V = h.get(g);
          V !== void 0 && clearTimeout(V), h.set(g, setTimeout(() => {
            c(g) && Cg(g, T);
          }, P * 1e3));
        }
      }
    };
    return u(w, [g, p, y], (x) => x[0] === g && x[1] === p && x[2] === y, !0) ? (S.add(C), c(m) ? e(T, m, [p, y, C], !0) : t(_, y, [m, p, C], !0), !0) : !1;
  };
}, Kj = (e) => (t, n, [i, r, s], a) => {
  const o = t.get(i);
  o === void 0 ? t.set(i, /* @__PURE__ */ new Set([[r, n, s]])) : e(o, [r, n, s], (l) => l[0] === r && l[1] === n, a);
}, Xj = (e) => (t, n) => {
  const i = e(t, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  });
  n.connect(i).connect(t.destination);
  const r = () => {
    n.removeEventListener("ended", r), n.disconnect(i), i.disconnect();
  };
  n.addEventListener("ended", r);
}, Jj = (e) => (t, n) => {
  e(t).add(n);
}, Qj = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  fftSize: 2048,
  maxDecibels: -30,
  minDecibels: -100,
  smoothingTimeConstant: 0.8
}, e4 = (e, t, n, i, r, s) => class extends e {
  constructor(o, l) {
    const u = r(o), c = { ...Qj, ...l }, d = i(u, c), f = s(u) ? t() : null;
    super(o, !1, d, f), this._nativeAnalyserNode = d;
  }
  get fftSize() {
    return this._nativeAnalyserNode.fftSize;
  }
  set fftSize(o) {
    this._nativeAnalyserNode.fftSize = o;
  }
  get frequencyBinCount() {
    return this._nativeAnalyserNode.frequencyBinCount;
  }
  get maxDecibels() {
    return this._nativeAnalyserNode.maxDecibels;
  }
  set maxDecibels(o) {
    const l = this._nativeAnalyserNode.maxDecibels;
    if (this._nativeAnalyserNode.maxDecibels = o, !(o > this._nativeAnalyserNode.minDecibels))
      throw this._nativeAnalyserNode.maxDecibels = l, n();
  }
  get minDecibels() {
    return this._nativeAnalyserNode.minDecibels;
  }
  set minDecibels(o) {
    const l = this._nativeAnalyserNode.minDecibels;
    if (this._nativeAnalyserNode.minDecibels = o, !(this._nativeAnalyserNode.maxDecibels > o))
      throw this._nativeAnalyserNode.minDecibels = l, n();
  }
  get smoothingTimeConstant() {
    return this._nativeAnalyserNode.smoothingTimeConstant;
  }
  set smoothingTimeConstant(o) {
    this._nativeAnalyserNode.smoothingTimeConstant = o;
  }
  getByteFrequencyData(o) {
    this._nativeAnalyserNode.getByteFrequencyData(o);
  }
  getByteTimeDomainData(o) {
    this._nativeAnalyserNode.getByteTimeDomainData(o);
  }
  getFloatFrequencyData(o) {
    this._nativeAnalyserNode.getFloatFrequencyData(o);
  }
  getFloatTimeDomainData(o) {
    this._nativeAnalyserNode.getFloatTimeDomainData(o);
  }
}, Xn = (e, t) => e.context === t, t4 = (e, t, n) => () => {
  const i = /* @__PURE__ */ new WeakMap(), r = async (s, a) => {
    let o = t(s);
    if (!Xn(o, a)) {
      const u = {
        channelCount: o.channelCount,
        channelCountMode: o.channelCountMode,
        channelInterpretation: o.channelInterpretation,
        fftSize: o.fftSize,
        maxDecibels: o.maxDecibels,
        minDecibels: o.minDecibels,
        smoothingTimeConstant: o.smoothingTimeConstant
      };
      o = e(a, u);
    }
    return i.set(a, o), await n(s, a, o), o;
  };
  return {
    render(s, a) {
      const o = i.get(a);
      return o !== void 0 ? Promise.resolve(o) : r(s, a);
    }
  };
}, jf = (e) => {
  try {
    e.copyToChannel(new Float32Array(1), 0, -1);
  } catch {
    return !1;
  }
  return !0;
}, Jr = () => new DOMException("", "IndexSizeError"), xy = (e) => {
  e.getChannelData = ((t) => (n) => {
    try {
      return t.call(e, n);
    } catch (i) {
      throw i.code === 12 ? Jr() : i;
    }
  })(e.getChannelData);
}, n4 = {
  numberOfChannels: 1
}, i4 = (e, t, n, i, r, s, a, o) => {
  let l = null;
  return class M1 {
    constructor(c) {
      if (r === null)
        throw new Error("Missing the native OfflineAudioContext constructor.");
      const { length: d, numberOfChannels: f, sampleRate: h } = { ...n4, ...c };
      l === null && (l = new r(1, 1, 44100));
      const m = i !== null && t(s, s) ? new i({ length: d, numberOfChannels: f, sampleRate: h }) : l.createBuffer(f, d, h);
      if (m.numberOfChannels === 0)
        throw n();
      return typeof m.copyFromChannel != "function" ? (a(m), xy(m)) : t(jf, () => jf(m)) || o(m), e.add(m), m;
    }
    static [Symbol.hasInstance](c) {
      return c !== null && typeof c == "object" && Object.getPrototypeOf(c) === M1.prototype || e.has(c);
    }
  };
}, mi = -34028234663852886e22, ei = -mi, ys = (e) => Tl.has(e), r4 = {
  buffer: null,
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  // Bug #149: Safari does not yet support the detune AudioParam.
  loop: !1,
  loopEnd: 0,
  loopStart: 0,
  playbackRate: 1
}, s4 = (e, t, n, i, r, s, a, o) => class extends e {
  constructor(u, c) {
    const d = s(u), f = { ...r4, ...c }, h = r(d, f), m = a(d), g = m ? t() : null;
    super(u, !1, h, g), this._audioBufferSourceNodeRenderer = g, this._isBufferNullified = !1, this._isBufferSet = f.buffer !== null, this._nativeAudioBufferSourceNode = h, this._onended = null, this._playbackRate = n(this, m, h.playbackRate, ei, mi);
  }
  get buffer() {
    return this._isBufferNullified ? null : this._nativeAudioBufferSourceNode.buffer;
  }
  set buffer(u) {
    if (this._nativeAudioBufferSourceNode.buffer = u, u !== null) {
      if (this._isBufferSet)
        throw i();
      this._isBufferSet = !0;
    }
  }
  get loop() {
    return this._nativeAudioBufferSourceNode.loop;
  }
  set loop(u) {
    this._nativeAudioBufferSourceNode.loop = u;
  }
  get loopEnd() {
    return this._nativeAudioBufferSourceNode.loopEnd;
  }
  set loopEnd(u) {
    this._nativeAudioBufferSourceNode.loopEnd = u;
  }
  get loopStart() {
    return this._nativeAudioBufferSourceNode.loopStart;
  }
  set loopStart(u) {
    this._nativeAudioBufferSourceNode.loopStart = u;
  }
  get onended() {
    return this._onended;
  }
  set onended(u) {
    const c = typeof u == "function" ? o(this, u) : null;
    this._nativeAudioBufferSourceNode.onended = c;
    const d = this._nativeAudioBufferSourceNode.onended;
    this._onended = d !== null && d === c ? u : d;
  }
  get playbackRate() {
    return this._playbackRate;
  }
  start(u = 0, c = 0, d) {
    if (this._nativeAudioBufferSourceNode.start(u, c, d), this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.start = d === void 0 ? [u, c] : [u, c, d]), this.context.state !== "closed") {
      xl(this);
      const f = () => {
        this._nativeAudioBufferSourceNode.removeEventListener("ended", f), ys(this) && Xc(this);
      };
      this._nativeAudioBufferSourceNode.addEventListener("ended", f);
    }
  }
  stop(u = 0) {
    this._nativeAudioBufferSourceNode.stop(u), this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.stop = u);
  }
}, a4 = (e, t, n, i, r) => () => {
  const s = /* @__PURE__ */ new WeakMap();
  let a = null, o = null;
  const l = async (u, c) => {
    let d = n(u);
    const f = Xn(d, c);
    if (!f) {
      const h = {
        buffer: d.buffer,
        channelCount: d.channelCount,
        channelCountMode: d.channelCountMode,
        channelInterpretation: d.channelInterpretation,
        // Bug #149: Safari does not yet support the detune AudioParam.
        loop: d.loop,
        loopEnd: d.loopEnd,
        loopStart: d.loopStart,
        playbackRate: d.playbackRate.value
      };
      d = t(c, h), a !== null && d.start(...a), o !== null && d.stop(o);
    }
    return s.set(c, d), f ? await e(c, u.playbackRate, d.playbackRate) : await i(c, u.playbackRate, d.playbackRate), await r(u, c, d), d;
  };
  return {
    set start(u) {
      a = u;
    },
    set stop(u) {
      o = u;
    },
    render(u, c) {
      const d = s.get(c);
      return d !== void 0 ? Promise.resolve(d) : l(u, c);
    }
  };
}, o4 = (e) => "playbackRate" in e, l4 = (e) => "frequency" in e && "gain" in e, u4 = (e) => "offset" in e, c4 = (e) => !("frequency" in e) && "gain" in e, d4 = (e) => "detune" in e && "frequency" in e, f4 = (e) => "pan" in e, ii = (e) => Cr(E1, e), Jc = (e) => Cr(P1, e), Tg = (e, t) => {
  const { activeInputs: n } = ii(e);
  n.forEach((r) => r.forEach(([s]) => {
    t.includes(e) || Tg(s, [...t, e]);
  }));
  const i = o4(e) ? [
    // Bug #149: Safari does not yet support the detune AudioParam.
    e.playbackRate
  ] : N1(e) ? Array.from(e.parameters.values()) : l4(e) ? [e.Q, e.detune, e.frequency, e.gain] : u4(e) ? [e.offset] : c4(e) ? [e.gain] : d4(e) ? [e.detune, e.frequency] : f4(e) ? [e.pan] : [];
  for (const r of i) {
    const s = Jc(r);
    s !== void 0 && s.activeInputs.forEach(([a]) => Tg(a, t));
  }
  ys(e) && Xc(e);
}, R1 = (e) => {
  Tg(e.destination, []);
}, h4 = (e) => e === void 0 || typeof e == "number" || typeof e == "string" && (e === "balanced" || e === "interactive" || e === "playback"), m4 = (e, t, n, i, r, s, a, o, l) => class extends e {
  constructor(c = {}) {
    if (l === null)
      throw new Error("Missing the native AudioContext constructor.");
    let d;
    try {
      d = new l(c);
    } catch (m) {
      throw m.code === 12 && m.message === "sampleRate is not in range" ? n() : m;
    }
    if (d === null)
      throw i();
    if (!h4(c.latencyHint))
      throw new TypeError(`The provided value '${c.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
    if (c.sampleRate !== void 0 && d.sampleRate !== c.sampleRate)
      throw n();
    super(d, 2);
    const { latencyHint: f } = c, { sampleRate: h } = d;
    if (this._baseLatency = typeof d.baseLatency == "number" ? d.baseLatency : f === "balanced" ? 512 / h : f === "interactive" || f === void 0 ? 256 / h : f === "playback" ? 1024 / h : (
      /*
       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a
       * ScriptProcessorNode.
       */
      Math.max(2, Math.min(128, Math.round(f * h / 128))) * 128 / h
    ), this._nativeAudioContext = d, l.name === "webkitAudioContext" ? (this._nativeGainNode = d.createGain(), this._nativeOscillatorNode = d.createOscillator(), this._nativeGainNode.gain.value = 1e-37, this._nativeOscillatorNode.connect(this._nativeGainNode).connect(d.destination), this._nativeOscillatorNode.start()) : (this._nativeGainNode = null, this._nativeOscillatorNode = null), this._state = null, d.state === "running") {
      this._state = "suspended";
      const m = () => {
        this._state === "suspended" && (this._state = null), d.removeEventListener("statechange", m);
      };
      d.addEventListener("statechange", m);
    }
  }
  get baseLatency() {
    return this._baseLatency;
  }
  get state() {
    return this._state !== null ? this._state : this._nativeAudioContext.state;
  }
  close() {
    return this.state === "closed" ? this._nativeAudioContext.close().then(() => {
      throw t();
    }) : (this._state === "suspended" && (this._state = null), this._nativeAudioContext.close().then(() => {
      this._nativeGainNode !== null && this._nativeOscillatorNode !== null && (this._nativeOscillatorNode.stop(), this._nativeGainNode.disconnect(), this._nativeOscillatorNode.disconnect()), R1(this);
    }));
  }
  createMediaElementSource(c) {
    return new r(this, { mediaElement: c });
  }
  createMediaStreamDestination() {
    return new s(this);
  }
  createMediaStreamSource(c) {
    return new a(this, { mediaStream: c });
  }
  createMediaStreamTrackSource(c) {
    return new o(this, { mediaStreamTrack: c });
  }
  resume() {
    return this._state === "suspended" ? new Promise((c, d) => {
      const f = () => {
        this._nativeAudioContext.removeEventListener("statechange", f), this._nativeAudioContext.state === "running" ? c() : this.resume().then(c, d);
      };
      this._nativeAudioContext.addEventListener("statechange", f);
    }) : this._nativeAudioContext.resume().catch((c) => {
      throw c === void 0 || c.code === 15 ? t() : c;
    });
  }
  suspend() {
    return this._nativeAudioContext.suspend().catch((c) => {
      throw c === void 0 ? t() : c;
    });
  }
}, v4 = (e, t, n, i, r, s, a, o) => class extends e {
  constructor(u, c) {
    const d = s(u), f = a(d), h = r(d, c, f), m = f ? t(o) : null;
    super(u, !1, h, m), this._isNodeOfNativeOfflineAudioContext = f, this._nativeAudioDestinationNode = h;
  }
  get channelCount() {
    return this._nativeAudioDestinationNode.channelCount;
  }
  set channelCount(u) {
    if (this._isNodeOfNativeOfflineAudioContext)
      throw i();
    if (u > this._nativeAudioDestinationNode.maxChannelCount)
      throw n();
    this._nativeAudioDestinationNode.channelCount = u;
  }
  get channelCountMode() {
    return this._nativeAudioDestinationNode.channelCountMode;
  }
  set channelCountMode(u) {
    if (this._isNodeOfNativeOfflineAudioContext)
      throw i();
    this._nativeAudioDestinationNode.channelCountMode = u;
  }
  get maxChannelCount() {
    return this._nativeAudioDestinationNode.maxChannelCount;
  }
}, g4 = (e) => {
  const t = /* @__PURE__ */ new WeakMap(), n = async (i, r) => {
    const s = r.destination;
    return t.set(r, s), await e(i, r, s), s;
  };
  return {
    render(i, r) {
      const s = t.get(r);
      return s !== void 0 ? Promise.resolve(s) : n(i, r);
    }
  };
}, p4 = (e, t, n, i, r, s, a, o) => (l, u) => {
  const c = u.listener, d = () => {
    const w = new Float32Array(1), S = t(u, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "speakers",
      numberOfInputs: 9
    }), C = a(u);
    let x = !1, A = [0, 0, -1, 0, 1, 0], I = [0, 0, 0];
    const E = () => {
      if (x)
        return;
      x = !0;
      const F = i(u, 256, 9, 0);
      F.onaudioprocess = ({ inputBuffer: $ }) => {
        const Z = [
          s($, w, 0),
          s($, w, 1),
          s($, w, 2),
          s($, w, 3),
          s($, w, 4),
          s($, w, 5)
        ];
        Z.some((H, R) => H !== A[R]) && (c.setOrientation(...Z), A = Z);
        const j = [
          s($, w, 6),
          s($, w, 7),
          s($, w, 8)
        ];
        j.some((H, R) => H !== I[R]) && (c.setPosition(...j), I = j);
      }, S.connect(F);
    }, P = (F) => ($) => {
      $ !== A[F] && (A[F] = $, c.setOrientation(...A));
    }, V = (F) => ($) => {
      $ !== I[F] && (I[F] = $, c.setPosition(...I));
    }, N = (F, $, Z) => {
      const j = n(u, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        offset: $
      });
      j.connect(S, 0, F), j.start(), Object.defineProperty(j.offset, "defaultValue", {
        get() {
          return $;
        }
      });
      const H = e({ context: l }, C, j.offset, ei, mi);
      return o(H, "value", (R) => () => R.call(H), (R) => (L) => {
        try {
          R.call(H, L);
        } catch (ne) {
          if (ne.code !== 9)
            throw ne;
        }
        E(), C && Z(L);
      }), H.cancelAndHoldAtTime = ((R) => C ? () => {
        throw r();
      } : (...L) => {
        const ne = R.apply(H, L);
        return E(), ne;
      })(H.cancelAndHoldAtTime), H.cancelScheduledValues = ((R) => C ? () => {
        throw r();
      } : (...L) => {
        const ne = R.apply(H, L);
        return E(), ne;
      })(H.cancelScheduledValues), H.exponentialRampToValueAtTime = ((R) => C ? () => {
        throw r();
      } : (...L) => {
        const ne = R.apply(H, L);
        return E(), ne;
      })(H.exponentialRampToValueAtTime), H.linearRampToValueAtTime = ((R) => C ? () => {
        throw r();
      } : (...L) => {
        const ne = R.apply(H, L);
        return E(), ne;
      })(H.linearRampToValueAtTime), H.setTargetAtTime = ((R) => C ? () => {
        throw r();
      } : (...L) => {
        const ne = R.apply(H, L);
        return E(), ne;
      })(H.setTargetAtTime), H.setValueAtTime = ((R) => C ? () => {
        throw r();
      } : (...L) => {
        const ne = R.apply(H, L);
        return E(), ne;
      })(H.setValueAtTime), H.setValueCurveAtTime = ((R) => C ? () => {
        throw r();
      } : (...L) => {
        const ne = R.apply(H, L);
        return E(), ne;
      })(H.setValueCurveAtTime), H;
    };
    return {
      forwardX: N(0, 0, P(0)),
      forwardY: N(1, 0, P(1)),
      forwardZ: N(2, -1, P(2)),
      positionX: N(6, 0, V(0)),
      positionY: N(7, 0, V(1)),
      positionZ: N(8, 0, V(2)),
      upX: N(3, 0, P(3)),
      upY: N(4, 1, P(4)),
      upZ: N(5, 0, P(5))
    };
  }, { forwardX: f, forwardY: h, forwardZ: m, positionX: g, positionY: p, positionZ: y, upX: k, upY: T, upZ: _ } = c.forwardX === void 0 ? d() : c;
  return {
    get forwardX() {
      return f;
    },
    get forwardY() {
      return h;
    },
    get forwardZ() {
      return m;
    },
    get positionX() {
      return g;
    },
    get positionY() {
      return p;
    },
    get positionZ() {
      return y;
    },
    get upX() {
      return k;
    },
    get upY() {
      return T;
    },
    get upZ() {
      return _;
    }
  };
}, Hf = (e) => "context" in e, Qc = (e) => Hf(e[0]), To = (e, t, n, i) => {
  for (const r of e)
    if (n(r)) {
      if (i)
        return !1;
      throw Error("The set contains at least one similar element.");
    }
  return e.add(t), !0;
}, v_ = (e, t, [n, i], r) => {
  To(e, [t, n, i], (s) => s[0] === t && s[1] === n, r);
}, g_ = (e, [t, n, i], r) => {
  const s = e.get(t);
  s === void 0 ? e.set(t, /* @__PURE__ */ new Set([[n, i]])) : To(s, [n, i], (a) => a[0] === n, r);
}, Ql = (e) => "inputs" in e, zf = (e, t, n, i) => {
  if (Ql(t)) {
    const r = t.inputs[i];
    return e.connect(r, n, 0), [r, n, 0];
  }
  return e.connect(t, n, i), [t, n, i];
}, F1 = (e, t, n) => {
  for (const i of e)
    if (i[0] === t && i[1] === n)
      return e.delete(i), i;
  return null;
}, y4 = (e, t, n) => em(e, (i) => i[0] === t && i[1] === n), B1 = (e, t) => {
  if (!Kc(e).delete(t))
    throw new Error("Missing the expected event listener.");
}, L1 = (e, t, n) => {
  const i = Cr(e, t), r = em(i, (s) => s[0] === n);
  return i.size === 0 && e.delete(t), r;
}, Uf = (e, t, n, i) => {
  Ql(t) ? e.disconnect(t.inputs[i], n, 0) : e.disconnect(t, n, i);
}, Mt = (e) => Cr(Cy, e), lc = (e) => Cr(Ty, e), io = (e) => _g.has(e), of = (e) => !Tl.has(e), p_ = (e, t) => new Promise((n) => {
  if (t !== null)
    n(!0);
  else {
    const i = e.createScriptProcessor(256, 1, 1), r = e.createGain(), s = e.createBuffer(1, 2, 44100), a = s.getChannelData(0);
    a[0] = 1, a[1] = 1;
    const o = e.createBufferSource();
    o.buffer = s, o.loop = !0, o.connect(i).connect(e.destination), o.connect(r), o.disconnect(r), i.onaudioprocess = (l) => {
      const u = l.inputBuffer.getChannelData(0);
      Array.prototype.some.call(u, (c) => c === 1) ? n(!0) : n(!1), o.stop(), i.onaudioprocess = null, o.disconnect(i), i.disconnect(e.destination);
    }, o.start();
  }
}), Sv = (e, t) => {
  const n = /* @__PURE__ */ new Map();
  for (const i of e)
    for (const r of i) {
      const s = n.get(r);
      n.set(r, s === void 0 ? 1 : s + 1);
    }
  n.forEach((i, r) => t(r, i));
}, qf = (e) => "context" in e, b4 = (e) => {
  const t = /* @__PURE__ */ new Map();
  e.connect = ((n) => (i, r = 0, s = 0) => {
    const a = qf(i) ? n(i, r, s) : n(i, r), o = t.get(i);
    return o === void 0 ? t.set(i, [{ input: s, output: r }]) : o.every((l) => l.input !== s || l.output !== r) && o.push({ input: s, output: r }), a;
  })(e.connect.bind(e)), e.disconnect = ((n) => (i, r, s) => {
    if (n.apply(e), i === void 0)
      t.clear();
    else if (typeof i == "number")
      for (const [a, o] of t) {
        const l = o.filter((u) => u.output !== i);
        l.length === 0 ? t.delete(a) : t.set(a, l);
      }
    else if (t.has(i))
      if (r === void 0)
        t.delete(i);
      else {
        const a = t.get(i);
        if (a !== void 0) {
          const o = a.filter((l) => l.output !== r && (l.input !== s || s === void 0));
          o.length === 0 ? t.delete(i) : t.set(i, o);
        }
      }
    for (const [a, o] of t)
      o.forEach((l) => {
        qf(a) ? e.connect(a, l.output, l.input) : e.connect(a, l.output);
      });
  })(e.disconnect);
}, w4 = (e, t, n, i) => {
  const { activeInputs: r, passiveInputs: s } = Jc(t), { outputs: a } = ii(e), o = Kc(e), l = (u) => {
    const c = Mt(e), d = lc(t);
    if (u) {
      const f = L1(s, e, n);
      v_(r, e, f, !1), !i && !io(e) && c.connect(d, n);
    } else {
      const f = y4(r, e, n);
      g_(s, f, !1), !i && !io(e) && c.disconnect(d, n);
    }
  };
  return To(a, [t, n], (u) => u[0] === t && u[1] === n, !0) ? (o.add(l), ys(e) ? v_(r, e, [n, l], !0) : g_(s, [e, n, l], !0), !0) : !1;
}, _4 = (e, t, n, i) => {
  const { activeInputs: r, passiveInputs: s } = ii(t), a = F1(r[i], e, n);
  return a === null ? [D1(s, e, n, i)[2], !1] : [a[2], !0];
}, S4 = (e, t, n) => {
  const { activeInputs: i, passiveInputs: r } = Jc(t), s = F1(i, e, n);
  return s === null ? [L1(r, e, n)[1], !1] : [s[2], !0];
}, Ay = (e, t, n, i, r) => {
  const [s, a] = _4(e, n, i, r);
  if (s !== null && (B1(e, s), a && !t && !io(e) && Uf(Mt(e), Mt(n), i, r)), ys(n)) {
    const { activeInputs: o } = ii(n);
    Cg(n, o);
  }
}, Iy = (e, t, n, i) => {
  const [r, s] = S4(e, n, i);
  r !== null && (B1(e, r), s && !t && !io(e) && Mt(e).disconnect(lc(n), i));
}, k4 = (e, t) => {
  const n = ii(e), i = [];
  for (const r of n.outputs)
    Qc(r) ? Ay(e, t, ...r) : Iy(e, t, ...r), i.push(r[0]);
  return n.outputs.clear(), i;
}, C4 = (e, t, n) => {
  const i = ii(e), r = [];
  for (const s of i.outputs)
    s[1] === n && (Qc(s) ? Ay(e, t, ...s) : Iy(e, t, ...s), r.push(s[0]), i.outputs.delete(s));
  return r;
}, T4 = (e, t, n, i, r) => {
  const s = ii(e);
  return Array.from(s.outputs).filter((a) => a[0] === n && (i === void 0 || a[1] === i) && (r === void 0 || a[2] === r)).map((a) => (Qc(a) ? Ay(e, t, ...a) : Iy(e, t, ...a), s.outputs.delete(a), a[0]));
}, x4 = (e, t, n, i, r, s, a, o, l, u, c, d, f, h, m, g) => class extends u {
  constructor(y, k, T, _) {
    super(T), this._context = y, this._nativeAudioNode = T;
    const w = c(y);
    d(w) && n(p_, () => p_(w, g)) !== !0 && b4(T), Cy.set(this, T), O1.set(this, /* @__PURE__ */ new Set()), y.state !== "closed" && k && xl(this), e(this, _, T);
  }
  get channelCount() {
    return this._nativeAudioNode.channelCount;
  }
  set channelCount(y) {
    this._nativeAudioNode.channelCount = y;
  }
  get channelCountMode() {
    return this._nativeAudioNode.channelCountMode;
  }
  set channelCountMode(y) {
    this._nativeAudioNode.channelCountMode = y;
  }
  get channelInterpretation() {
    return this._nativeAudioNode.channelInterpretation;
  }
  set channelInterpretation(y) {
    this._nativeAudioNode.channelInterpretation = y;
  }
  get context() {
    return this._context;
  }
  get numberOfInputs() {
    return this._nativeAudioNode.numberOfInputs;
  }
  get numberOfOutputs() {
    return this._nativeAudioNode.numberOfOutputs;
  }
  // tslint:disable-next-line:invalid-void
  connect(y, k = 0, T = 0) {
    if (k < 0 || k >= this._nativeAudioNode.numberOfOutputs)
      throw r();
    const _ = c(this._context), w = m(_);
    if (f(y) || h(y))
      throw s();
    if (Hf(y)) {
      const x = Mt(y);
      try {
        const I = zf(this._nativeAudioNode, x, k, T), E = of(this);
        (w || E) && this._nativeAudioNode.disconnect(...I), this.context.state !== "closed" && !E && of(y) && xl(y);
      } catch (I) {
        throw I.code === 12 ? s() : I;
      }
      if (t(this, y, k, T, w)) {
        const I = l([this], y);
        Sv(I, i(w));
      }
      return y;
    }
    const S = lc(y);
    if (S.name === "playbackRate" && S.maxValue === 1024)
      throw a();
    try {
      this._nativeAudioNode.connect(S, k), (w || of(this)) && this._nativeAudioNode.disconnect(S, k);
    } catch (x) {
      throw x.code === 12 ? s() : x;
    }
    if (w4(this, y, k, w)) {
      const x = l([this], y);
      Sv(x, i(w));
    }
  }
  disconnect(y, k, T) {
    let _;
    const w = c(this._context), S = m(w);
    if (y === void 0)
      _ = k4(this, S);
    else if (typeof y == "number") {
      if (y < 0 || y >= this.numberOfOutputs)
        throw r();
      _ = C4(this, S, y);
    } else {
      if (k !== void 0 && (k < 0 || k >= this.numberOfOutputs) || Hf(y) && T !== void 0 && (T < 0 || T >= y.numberOfInputs))
        throw r();
      if (_ = T4(this, S, y, k, T), _.length === 0)
        throw s();
    }
    for (const C of _) {
      const x = l([this], C);
      Sv(x, o);
    }
  }
}, A4 = (e, t, n, i, r, s, a, o, l, u, c, d, f) => (h, m, g, p = null, y = null) => {
  const k = g.value, T = new Fj(k), _ = m ? i(T) : null, w = {
    get defaultValue() {
      return k;
    },
    get maxValue() {
      return p === null ? g.maxValue : p;
    },
    get minValue() {
      return y === null ? g.minValue : y;
    },
    get value() {
      return g.value;
    },
    set value(S) {
      g.value = S, w.setValueAtTime(S, h.context.currentTime);
    },
    cancelAndHoldAtTime(S) {
      if (typeof g.cancelAndHoldAtTime == "function")
        _ === null && T.flush(h.context.currentTime), T.add(r(S)), g.cancelAndHoldAtTime(S);
      else {
        const C = Array.from(T).pop();
        _ === null && T.flush(h.context.currentTime), T.add(r(S));
        const x = Array.from(T).pop();
        g.cancelScheduledValues(S), C !== x && x !== void 0 && (x.type === "exponentialRampToValue" ? g.exponentialRampToValueAtTime(x.value, x.endTime) : x.type === "linearRampToValue" ? g.linearRampToValueAtTime(x.value, x.endTime) : x.type === "setValue" ? g.setValueAtTime(x.value, x.startTime) : x.type === "setValueCurve" && g.setValueCurveAtTime(x.values, x.startTime, x.duration));
      }
      return w;
    },
    cancelScheduledValues(S) {
      return _ === null && T.flush(h.context.currentTime), T.add(s(S)), g.cancelScheduledValues(S), w;
    },
    exponentialRampToValueAtTime(S, C) {
      if (S === 0)
        throw new RangeError();
      if (!Number.isFinite(C) || C < 0)
        throw new RangeError();
      const x = h.context.currentTime;
      return _ === null && T.flush(x), Array.from(T).length === 0 && (T.add(u(k, x)), g.setValueAtTime(k, x)), T.add(a(S, C)), g.exponentialRampToValueAtTime(S, C), w;
    },
    linearRampToValueAtTime(S, C) {
      const x = h.context.currentTime;
      return _ === null && T.flush(x), Array.from(T).length === 0 && (T.add(u(k, x)), g.setValueAtTime(k, x)), T.add(o(S, C)), g.linearRampToValueAtTime(S, C), w;
    },
    setTargetAtTime(S, C, x) {
      return _ === null && T.flush(h.context.currentTime), T.add(l(S, C, x)), g.setTargetAtTime(S, C, x), w;
    },
    setValueAtTime(S, C) {
      return _ === null && T.flush(h.context.currentTime), T.add(u(S, C)), g.setValueAtTime(S, C), w;
    },
    setValueCurveAtTime(S, C, x) {
      const A = S instanceof Float32Array ? S : new Float32Array(S);
      if (d !== null && d.name === "webkitAudioContext") {
        const I = C + x, E = h.context.sampleRate, P = Math.ceil(C * E), V = Math.floor(I * E), N = V - P, F = new Float32Array(N);
        for (let Z = 0; Z < N; Z += 1) {
          const j = (A.length - 1) / x * ((P + Z) / E - C), H = Math.floor(j), R = Math.ceil(j);
          F[Z] = H === R ? A[H] : (1 - (j - H)) * A[H] + (1 - (R - j)) * A[R];
        }
        _ === null && T.flush(h.context.currentTime), T.add(c(F, C, x)), g.setValueCurveAtTime(F, C, x);
        const $ = V / E;
        $ < I && f(w, F[F.length - 1], $), f(w, A[A.length - 1], I);
      } else
        _ === null && T.flush(h.context.currentTime), T.add(c(A, C, x)), g.setValueCurveAtTime(A, C, x);
      return w;
    }
  };
  return n.set(w, g), t.set(w, h), e(w, _), w;
}, I4 = (e) => ({
  replay(t) {
    for (const n of e)
      if (n.type === "exponentialRampToValue") {
        const { endTime: i, value: r } = n;
        t.exponentialRampToValueAtTime(r, i);
      } else if (n.type === "linearRampToValue") {
        const { endTime: i, value: r } = n;
        t.linearRampToValueAtTime(r, i);
      } else if (n.type === "setTarget") {
        const { startTime: i, target: r, timeConstant: s } = n;
        t.setTargetAtTime(r, i, s);
      } else if (n.type === "setValue") {
        const { startTime: i, value: r } = n;
        t.setValueAtTime(r, i);
      } else if (n.type === "setValueCurve") {
        const { duration: i, startTime: r, values: s } = n;
        t.setValueCurveAtTime(s, r, i);
      } else
        throw new Error("Can't apply an unknown automation.");
  }
});
class $1 {
  constructor(t) {
    this._map = new Map(t);
  }
  get size() {
    return this._map.size;
  }
  entries() {
    return this._map.entries();
  }
  forEach(t, n = null) {
    return this._map.forEach((i, r) => t.call(n, i, r, this));
  }
  get(t) {
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
  keys() {
    return this._map.keys();
  }
  values() {
    return this._map.values();
  }
}
const E4 = {
  channelCount: 2,
  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  numberOfInputs: 1,
  numberOfOutputs: 1,
  parameterData: {},
  processorOptions: {}
}, P4 = (e, t, n, i, r, s, a, o, l, u, c, d, f, h) => class extends t {
  constructor(g, p, y) {
    var k;
    const T = o(g), _ = l(T), w = c({ ...E4, ...y });
    f(w);
    const S = Sg.get(T), C = S == null ? void 0 : S.get(p), x = _ || T.state !== "closed" ? T : (k = a(T)) !== null && k !== void 0 ? k : T, A = r(x, _ ? null : g.baseLatency, u, p, C, w), I = _ ? i(p, w, C) : null;
    super(g, !0, A, I);
    const E = [];
    A.parameters.forEach((V, N) => {
      const F = n(this, _, V);
      E.push([N, F]);
    }), this._nativeAudioWorkletNode = A, this._onprocessorerror = null, this._parameters = new $1(E), _ && e(T, this);
    const { activeInputs: P } = s(this);
    d(A, P);
  }
  get onprocessorerror() {
    return this._onprocessorerror;
  }
  set onprocessorerror(g) {
    const p = typeof g == "function" ? h(this, g) : null;
    this._nativeAudioWorkletNode.onprocessorerror = p;
    const y = this._nativeAudioWorkletNode.onprocessorerror;
    this._onprocessorerror = y !== null && y === p ? g : y;
  }
  get parameters() {
    return this._parameters === null ? this._nativeAudioWorkletNode.parameters : this._parameters;
  }
  get port() {
    return this._nativeAudioWorkletNode.port;
  }
};
function Gf(e, t, n, i, r) {
  if (typeof e.copyFromChannel == "function")
    t[n].byteLength === 0 && (t[n] = new Float32Array(128)), e.copyFromChannel(t[n], i, r);
  else {
    const s = e.getChannelData(i);
    if (t[n].byteLength === 0)
      t[n] = s.slice(r, r + 128);
    else {
      const a = new Float32Array(s.buffer, r * Float32Array.BYTES_PER_ELEMENT, 128);
      t[n].set(a);
    }
  }
}
const W1 = (e, t, n, i, r) => {
  typeof e.copyToChannel == "function" ? t[n].byteLength !== 0 && e.copyToChannel(t[n], i, r) : t[n].byteLength !== 0 && e.getChannelData(i).set(t[n], r);
}, Yf = (e, t) => {
  const n = [];
  for (let i = 0; i < e; i += 1) {
    const r = [], s = typeof t == "number" ? t : t[i];
    for (let a = 0; a < s; a += 1)
      r.push(new Float32Array(128));
    n.push(r);
  }
  return n;
}, O4 = (e, t) => {
  const n = Cr(kg, e), i = Mt(t);
  return Cr(n, i);
}, V4 = async (e, t, n, i, r, s, a) => {
  const o = t === null ? Math.ceil(e.context.length / 128) * 128 : t.length, l = i.channelCount * i.numberOfInputs, u = r.reduce((p, y) => p + y, 0), c = u === 0 ? null : n.createBuffer(u, o, n.sampleRate);
  if (s === void 0)
    throw new Error("Missing the processor constructor.");
  const d = ii(e), f = await O4(n, e), h = Yf(i.numberOfInputs, i.channelCount), m = Yf(i.numberOfOutputs, r), g = Array.from(e.parameters.keys()).reduce((p, y) => ({ ...p, [y]: new Float32Array(128) }), {});
  for (let p = 0; p < o; p += 128) {
    if (i.numberOfInputs > 0 && t !== null)
      for (let y = 0; y < i.numberOfInputs; y += 1)
        for (let k = 0; k < i.channelCount; k += 1)
          Gf(t, h[y], k, k, p);
    s.parameterDescriptors !== void 0 && t !== null && s.parameterDescriptors.forEach(({ name: y }, k) => {
      Gf(t, g, y, l + k, p);
    });
    for (let y = 0; y < i.numberOfInputs; y += 1)
      for (let k = 0; k < r[y]; k += 1)
        m[y][k].byteLength === 0 && (m[y][k] = new Float32Array(128));
    try {
      const y = h.map((T, _) => d.activeInputs[_].size === 0 ? [] : T), k = a(p / n.sampleRate, n.sampleRate, () => f.process(y, m, g));
      if (c !== null)
        for (let T = 0, _ = 0; T < i.numberOfOutputs; T += 1) {
          for (let w = 0; w < r[T]; w += 1)
            W1(c, m[T], w, _ + w, p);
          _ += r[T];
        }
      if (!k)
        break;
    } catch (y) {
      e.dispatchEvent(new ErrorEvent("processorerror", {
        colno: y.colno,
        filename: y.filename,
        lineno: y.lineno,
        message: y.message
      }));
      break;
    }
  }
  return c;
}, D4 = (e, t, n, i, r, s, a, o, l, u, c, d, f, h, m, g) => (p, y, k) => {
  const T = /* @__PURE__ */ new WeakMap();
  let _ = null;
  const w = async (S, C) => {
    let x = c(S), A = null;
    const I = Xn(x, C), E = Array.isArray(y.outputChannelCount) ? y.outputChannelCount : Array.from(y.outputChannelCount);
    if (d === null) {
      const P = E.reduce(($, Z) => $ + Z, 0), V = r(C, {
        channelCount: Math.max(1, P),
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        numberOfOutputs: Math.max(1, P)
      }), N = [];
      for (let $ = 0; $ < S.numberOfOutputs; $ += 1)
        N.push(i(C, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "speakers",
          numberOfInputs: E[$]
        }));
      const F = a(C, {
        channelCount: y.channelCount,
        channelCountMode: y.channelCountMode,
        channelInterpretation: y.channelInterpretation,
        gain: 1
      });
      F.connect = t.bind(null, N), F.disconnect = l.bind(null, N), A = [V, N, F];
    } else
      I || (x = new d(C, p));
    if (T.set(C, A === null ? x : A[2]), A !== null) {
      if (_ === null) {
        if (k === void 0)
          throw new Error("Missing the processor constructor.");
        if (f === null)
          throw new Error("Missing the native OfflineAudioContext constructor.");
        const Z = S.channelCount * S.numberOfInputs, j = k.parameterDescriptors === void 0 ? 0 : k.parameterDescriptors.length, H = Z + j;
        _ = V4(S, H === 0 ? null : await (async () => {
          const L = new f(
            H,
            // Ceil the length to the next full render quantum.
            // Bug #17: Safari does not yet expose the length.
            Math.ceil(S.context.length / 128) * 128,
            C.sampleRate
          ), ne = [], oe = [];
          for (let K = 0; K < y.numberOfInputs; K += 1)
            ne.push(a(L, {
              channelCount: y.channelCount,
              channelCountMode: y.channelCountMode,
              channelInterpretation: y.channelInterpretation,
              gain: 1
            })), oe.push(r(L, {
              channelCount: y.channelCount,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              numberOfOutputs: y.channelCount
            }));
          const we = await Promise.all(Array.from(S.parameters.values()).map(async (K) => {
            const ue = s(L, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              offset: K.value
            });
            return await h(L, K, ue.offset), ue;
          })), ee = i(L, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            numberOfInputs: Math.max(1, Z + j)
          });
          for (let K = 0; K < y.numberOfInputs; K += 1) {
            ne[K].connect(oe[K]);
            for (let ue = 0; ue < y.channelCount; ue += 1)
              oe[K].connect(ee, ue, K * y.channelCount + ue);
          }
          for (const [K, ue] of we.entries())
            ue.connect(ee, 0, Z + K), ue.start(0);
          return ee.connect(L.destination), await Promise.all(ne.map((K) => m(S, L, K))), g(L);
        })(), C, y, E, k, u);
      }
      const P = await _, V = n(C, {
        buffer: null,
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        loop: !1,
        loopEnd: 0,
        loopStart: 0,
        playbackRate: 1
      }), [N, F, $] = A;
      P !== null && (V.buffer = P, V.start(0)), V.connect(N);
      for (let Z = 0, j = 0; Z < S.numberOfOutputs; Z += 1) {
        const H = F[Z];
        for (let R = 0; R < E[Z]; R += 1)
          N.connect(H, j + R, R);
        j += E[Z];
      }
      return $;
    }
    if (I)
      for (const [P, V] of S.parameters.entries())
        await e(
          C,
          V,
          // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.
          x.parameters.get(P)
        );
    else
      for (const [P, V] of S.parameters.entries())
        await h(
          C,
          V,
          // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.
          x.parameters.get(P)
        );
    return await m(S, C, x), x;
  };
  return {
    render(S, C) {
      o(C, S);
      const x = T.get(C);
      return x !== void 0 ? Promise.resolve(x) : w(S, C);
    }
  };
}, N4 = (e, t, n, i, r, s, a, o, l, u, c, d, f, h, m, g, p, y, k, T) => class extends m {
  constructor(w, S) {
    super(w, S), this._nativeContext = w, this._audioWorklet = e === void 0 ? void 0 : {
      addModule: (C, x) => e(this, C, x)
    };
  }
  get audioWorklet() {
    return this._audioWorklet;
  }
  createAnalyser() {
    return new t(this);
  }
  createBiquadFilter() {
    return new r(this);
  }
  createBuffer(w, S, C) {
    return new n({ length: S, numberOfChannels: w, sampleRate: C });
  }
  createBufferSource() {
    return new i(this);
  }
  createChannelMerger(w = 6) {
    return new s(this, { numberOfInputs: w });
  }
  createChannelSplitter(w = 6) {
    return new a(this, { numberOfOutputs: w });
  }
  createConstantSource() {
    return new o(this);
  }
  createConvolver() {
    return new l(this);
  }
  createDelay(w = 1) {
    return new c(this, { maxDelayTime: w });
  }
  createDynamicsCompressor() {
    return new d(this);
  }
  createGain() {
    return new f(this);
  }
  createIIRFilter(w, S) {
    return new h(this, { feedback: S, feedforward: w });
  }
  createOscillator() {
    return new g(this);
  }
  createPanner() {
    return new p(this);
  }
  createPeriodicWave(w, S, C = { disableNormalization: !1 }) {
    return new y(this, { ...C, imag: S, real: w });
  }
  createStereoPanner() {
    return new k(this);
  }
  createWaveShaper() {
    return new T(this);
  }
  decodeAudioData(w, S, C) {
    return u(this._nativeContext, w).then((x) => (typeof S == "function" && S(x), x), (x) => {
      throw typeof C == "function" && C(x), x;
    });
  }
}, M4 = {
  Q: 1,
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  detune: 0,
  frequency: 350,
  gain: 0,
  type: "lowpass"
}, R4 = (e, t, n, i, r, s, a, o) => class extends e {
  constructor(u, c) {
    const d = s(u), f = { ...M4, ...c }, h = r(d, f), m = a(d), g = m ? n() : null;
    super(u, !1, h, g), this._Q = t(this, m, h.Q, ei, mi), this._detune = t(this, m, h.detune, 1200 * Math.log2(ei), -1200 * Math.log2(ei)), this._frequency = t(this, m, h.frequency, u.sampleRate / 2, 0), this._gain = t(this, m, h.gain, 40 * Math.log10(ei), mi), this._nativeBiquadFilterNode = h, o(this, 1);
  }
  get detune() {
    return this._detune;
  }
  get frequency() {
    return this._frequency;
  }
  get gain() {
    return this._gain;
  }
  get Q() {
    return this._Q;
  }
  get type() {
    return this._nativeBiquadFilterNode.type;
  }
  set type(u) {
    this._nativeBiquadFilterNode.type = u;
  }
  getFrequencyResponse(u, c, d) {
    try {
      this._nativeBiquadFilterNode.getFrequencyResponse(u, c, d);
    } catch (f) {
      throw f.code === 11 ? i() : f;
    }
    if (u.length !== c.length || c.length !== d.length)
      throw i();
  }
}, F4 = (e, t, n, i, r) => () => {
  const s = /* @__PURE__ */ new WeakMap(), a = async (o, l) => {
    let u = n(o);
    const c = Xn(u, l);
    if (!c) {
      const d = {
        Q: u.Q.value,
        channelCount: u.channelCount,
        channelCountMode: u.channelCountMode,
        channelInterpretation: u.channelInterpretation,
        detune: u.detune.value,
        frequency: u.frequency.value,
        gain: u.gain.value,
        type: u.type
      };
      u = t(l, d);
    }
    return s.set(l, u), c ? (await e(l, o.Q, u.Q), await e(l, o.detune, u.detune), await e(l, o.frequency, u.frequency), await e(l, o.gain, u.gain)) : (await i(l, o.Q, u.Q), await i(l, o.detune, u.detune), await i(l, o.frequency, u.frequency), await i(l, o.gain, u.gain)), await r(o, l, u), u;
  };
  return {
    render(o, l) {
      const u = s.get(l);
      return u !== void 0 ? Promise.resolve(u) : a(o, l);
    }
  };
}, B4 = (e, t) => (n, i) => {
  const r = t.get(n);
  if (r !== void 0)
    return r;
  const s = e.get(n);
  if (s !== void 0)
    return s;
  try {
    const a = i();
    return a instanceof Promise ? (e.set(n, a), a.catch(() => !1).then((o) => (e.delete(n), t.set(n, o), o))) : (t.set(n, a), a);
  } catch {
    return t.set(n, !1), !1;
  }
}, L4 = {
  channelCount: 1,
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  numberOfInputs: 6
}, $4 = (e, t, n, i, r) => class extends e {
  constructor(a, o) {
    const l = i(a), u = { ...L4, ...o }, c = n(l, u), d = r(l) ? t() : null;
    super(a, !1, c, d);
  }
}, W4 = (e, t, n) => () => {
  const i = /* @__PURE__ */ new WeakMap(), r = async (s, a) => {
    let o = t(s);
    if (!Xn(o, a)) {
      const u = {
        channelCount: o.channelCount,
        channelCountMode: o.channelCountMode,
        channelInterpretation: o.channelInterpretation,
        numberOfInputs: o.numberOfInputs
      };
      o = e(a, u);
    }
    return i.set(a, o), await n(s, a, o), o;
  };
  return {
    render(s, a) {
      const o = i.get(a);
      return o !== void 0 ? Promise.resolve(o) : r(s, a);
    }
  };
}, j4 = {
  channelCount: 6,
  channelCountMode: "explicit",
  channelInterpretation: "discrete",
  numberOfOutputs: 6
}, H4 = (e, t, n, i, r, s) => class extends e {
  constructor(o, l) {
    const u = i(o), c = s({ ...j4, ...l }), d = n(u, c), f = r(u) ? t() : null;
    super(o, !1, d, f);
  }
}, z4 = (e, t, n) => () => {
  const i = /* @__PURE__ */ new WeakMap(), r = async (s, a) => {
    let o = t(s);
    if (!Xn(o, a)) {
      const u = {
        channelCount: o.channelCount,
        channelCountMode: o.channelCountMode,
        channelInterpretation: o.channelInterpretation,
        numberOfOutputs: o.numberOfOutputs
      };
      o = e(a, u);
    }
    return i.set(a, o), await n(s, a, o), o;
  };
  return {
    render(s, a) {
      const o = i.get(a);
      return o !== void 0 ? Promise.resolve(o) : r(s, a);
    }
  };
}, U4 = (e) => (t, n, i) => e(n, t, i), q4 = (e) => (t, n, i = 0, r = 0) => {
  const s = t[i];
  if (s === void 0)
    throw e();
  return qf(n) ? s.connect(n, 0, r) : s.connect(n, 0);
}, G4 = (e) => (t, n) => {
  const i = e(t, {
    buffer: null,
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    loop: !1,
    loopEnd: 0,
    loopStart: 0,
    playbackRate: 1
  }), r = t.createBuffer(1, 2, 44100);
  return i.buffer = r, i.loop = !0, i.connect(n), i.start(), () => {
    i.stop(), i.disconnect(n);
  };
}, Y4 = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  offset: 1
}, Z4 = (e, t, n, i, r, s, a) => class extends e {
  constructor(l, u) {
    const c = r(l), d = { ...Y4, ...u }, f = i(c, d), h = s(c), m = h ? n() : null;
    super(l, !1, f, m), this._constantSourceNodeRenderer = m, this._nativeConstantSourceNode = f, this._offset = t(this, h, f.offset, ei, mi), this._onended = null;
  }
  get offset() {
    return this._offset;
  }
  get onended() {
    return this._onended;
  }
  set onended(l) {
    const u = typeof l == "function" ? a(this, l) : null;
    this._nativeConstantSourceNode.onended = u;
    const c = this._nativeConstantSourceNode.onended;
    this._onended = c !== null && c === u ? l : c;
  }
  start(l = 0) {
    if (this._nativeConstantSourceNode.start(l), this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.start = l), this.context.state !== "closed") {
      xl(this);
      const u = () => {
        this._nativeConstantSourceNode.removeEventListener("ended", u), ys(this) && Xc(this);
      };
      this._nativeConstantSourceNode.addEventListener("ended", u);
    }
  }
  stop(l = 0) {
    this._nativeConstantSourceNode.stop(l), this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.stop = l);
  }
}, K4 = (e, t, n, i, r) => () => {
  const s = /* @__PURE__ */ new WeakMap();
  let a = null, o = null;
  const l = async (u, c) => {
    let d = n(u);
    const f = Xn(d, c);
    if (!f) {
      const h = {
        channelCount: d.channelCount,
        channelCountMode: d.channelCountMode,
        channelInterpretation: d.channelInterpretation,
        offset: d.offset.value
      };
      d = t(c, h), a !== null && d.start(a), o !== null && d.stop(o);
    }
    return s.set(c, d), f ? await e(c, u.offset, d.offset) : await i(c, u.offset, d.offset), await r(u, c, d), d;
  };
  return {
    set start(u) {
      a = u;
    },
    set stop(u) {
      o = u;
    },
    render(u, c) {
      const d = s.get(c);
      return d !== void 0 ? Promise.resolve(d) : l(u, c);
    }
  };
}, X4 = (e) => (t) => (e[0] = t, e[0]), J4 = {
  buffer: null,
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  disableNormalization: !1
}, Q4 = (e, t, n, i, r, s) => class extends e {
  constructor(o, l) {
    const u = i(o), c = { ...J4, ...l }, d = n(u, c), h = r(u) ? t() : null;
    super(o, !1, d, h), this._isBufferNullified = !1, this._nativeConvolverNode = d, c.buffer !== null && s(this, c.buffer.duration);
  }
  get buffer() {
    return this._isBufferNullified ? null : this._nativeConvolverNode.buffer;
  }
  set buffer(o) {
    if (this._nativeConvolverNode.buffer = o, o === null && this._nativeConvolverNode.buffer !== null) {
      const l = this._nativeConvolverNode.context;
      this._nativeConvolverNode.buffer = l.createBuffer(1, 1, l.sampleRate), this._isBufferNullified = !0, s(this, 0);
    } else
      this._isBufferNullified = !1, s(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);
  }
  get normalize() {
    return this._nativeConvolverNode.normalize;
  }
  set normalize(o) {
    this._nativeConvolverNode.normalize = o;
  }
}, eH = (e, t, n) => () => {
  const i = /* @__PURE__ */ new WeakMap(), r = async (s, a) => {
    let o = t(s);
    if (!Xn(o, a)) {
      const u = {
        buffer: o.buffer,
        channelCount: o.channelCount,
        channelCountMode: o.channelCountMode,
        channelInterpretation: o.channelInterpretation,
        disableNormalization: !o.normalize
      };
      o = e(a, u);
    }
    return i.set(a, o), Ql(o) ? await n(s, a, o.inputs[0]) : await n(s, a, o), o;
  };
  return {
    render(s, a) {
      const o = i.get(a);
      return o !== void 0 ? Promise.resolve(o) : r(s, a);
    }
  };
}, tH = (e, t) => (n, i, r) => {
  if (t === null)
    throw new Error("Missing the native OfflineAudioContext constructor.");
  try {
    return new t(n, i, r);
  } catch (s) {
    throw s.name === "SyntaxError" ? e() : s;
  }
}, nH = () => new DOMException("", "DataCloneError"), y_ = (e) => {
  const { port1: t, port2: n } = new MessageChannel();
  return new Promise((i) => {
    const r = () => {
      n.onmessage = null, t.close(), n.close(), i();
    };
    n.onmessage = () => r();
    try {
      t.postMessage(e, [e]);
    } catch {
    } finally {
      r();
    }
  });
}, iH = (e, t, n, i, r, s, a, o, l, u, c) => (d, f) => {
  const h = a(d) ? d : s(d);
  if (r.has(f)) {
    const m = n();
    return Promise.reject(m);
  }
  try {
    r.add(f);
  } catch {
  }
  return t(l, () => l(h)) ? h.decodeAudioData(f).then((m) => (y_(f).catch(() => {
  }), t(o, () => o(m)) || c(m), e.add(m), m)) : new Promise((m, g) => {
    const p = async () => {
      try {
        await y_(f);
      } catch {
      }
    }, y = (k) => {
      g(k), p();
    };
    try {
      h.decodeAudioData(f, (k) => {
        typeof k.copyFromChannel != "function" && (u(k), xy(k)), e.add(k), p().then(() => m(k));
      }, (k) => {
        y(k === null ? i() : k);
      });
    } catch (k) {
      y(k);
    }
  });
}, rH = (e, t, n, i, r, s, a, o) => (l, u) => {
  const c = t.get(l);
  if (c === void 0)
    throw new Error("Missing the expected cycle count.");
  const d = s(l.context), f = o(d);
  if (c === u) {
    if (t.delete(l), !f && a(l)) {
      const h = i(l), { outputs: m } = n(l);
      for (const g of m)
        if (Qc(g)) {
          const p = i(g[0]);
          e(h, p, g[1], g[2]);
        } else {
          const p = r(g[0]);
          h.connect(p, g[1]);
        }
    }
  } else
    t.set(l, c - u);
}, sH = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  delayTime: 0,
  maxDelayTime: 1
}, aH = (e, t, n, i, r, s, a) => class extends e {
  constructor(l, u) {
    const c = r(l), d = { ...sH, ...u }, f = i(c, d), h = s(c), m = h ? n(d.maxDelayTime) : null;
    super(l, !1, f, m), this._delayTime = t(this, h, f.delayTime), a(this, d.maxDelayTime);
  }
  get delayTime() {
    return this._delayTime;
  }
}, oH = (e, t, n, i, r) => (s) => {
  const a = /* @__PURE__ */ new WeakMap(), o = async (l, u) => {
    let c = n(l);
    const d = Xn(c, u);
    if (!d) {
      const f = {
        channelCount: c.channelCount,
        channelCountMode: c.channelCountMode,
        channelInterpretation: c.channelInterpretation,
        delayTime: c.delayTime.value,
        maxDelayTime: s
      };
      c = t(u, f);
    }
    return a.set(u, c), d ? await e(u, l.delayTime, c.delayTime) : await i(u, l.delayTime, c.delayTime), await r(l, u, c), c;
  };
  return {
    render(l, u) {
      const c = a.get(u);
      return c !== void 0 ? Promise.resolve(c) : o(l, u);
    }
  };
}, lH = (e) => (t, n, i, r) => e(t[r], (s) => s[0] === n && s[1] === i), uH = (e) => (t, n) => {
  e(t).delete(n);
}, cH = (e) => "delayTime" in e, dH = (e, t, n) => function i(r, s) {
  const a = Hf(s) ? s : n(e, s);
  if (cH(a))
    return [];
  if (r[0] === a)
    return [r];
  if (r.includes(a))
    return [];
  const { outputs: o } = t(a);
  return Array.from(o).map((l) => i([...r, a], l[0])).reduce((l, u) => l.concat(u), []);
}, Vd = (e, t, n) => {
  const i = t[n];
  if (i === void 0)
    throw e();
  return i;
}, fH = (e) => (t, n = void 0, i = void 0, r = 0) => n === void 0 ? t.forEach((s) => s.disconnect()) : typeof n == "number" ? Vd(e, t, n).disconnect() : qf(n) ? i === void 0 ? t.forEach((s) => s.disconnect(n)) : r === void 0 ? Vd(e, t, i).disconnect(n, 0) : Vd(e, t, i).disconnect(n, 0, r) : i === void 0 ? t.forEach((s) => s.disconnect(n)) : Vd(e, t, i).disconnect(n, 0), hH = {
  attack: 3e-3,
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  knee: 30,
  ratio: 12,
  release: 0.25,
  threshold: -24
}, mH = (e, t, n, i, r, s, a, o) => class extends e {
  constructor(u, c) {
    const d = s(u), f = { ...hH, ...c }, h = i(d, f), m = a(d), g = m ? n() : null;
    super(u, !1, h, g), this._attack = t(this, m, h.attack), this._knee = t(this, m, h.knee), this._nativeDynamicsCompressorNode = h, this._ratio = t(this, m, h.ratio), this._release = t(this, m, h.release), this._threshold = t(this, m, h.threshold), o(this, 6e-3);
  }
  get attack() {
    return this._attack;
  }
  // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.
  get channelCount() {
    return this._nativeDynamicsCompressorNode.channelCount;
  }
  set channelCount(u) {
    const c = this._nativeDynamicsCompressorNode.channelCount;
    if (this._nativeDynamicsCompressorNode.channelCount = u, u > 2)
      throw this._nativeDynamicsCompressorNode.channelCount = c, r();
  }
  /*
   * Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be
   * overwritten here.
   */
  get channelCountMode() {
    return this._nativeDynamicsCompressorNode.channelCountMode;
  }
  set channelCountMode(u) {
    const c = this._nativeDynamicsCompressorNode.channelCountMode;
    if (this._nativeDynamicsCompressorNode.channelCountMode = u, u === "max")
      throw this._nativeDynamicsCompressorNode.channelCountMode = c, r();
  }
  get knee() {
    return this._knee;
  }
  get ratio() {
    return this._ratio;
  }
  get reduction() {
    return typeof this._nativeDynamicsCompressorNode.reduction.value == "number" ? this._nativeDynamicsCompressorNode.reduction.value : this._nativeDynamicsCompressorNode.reduction;
  }
  get release() {
    return this._release;
  }
  get threshold() {
    return this._threshold;
  }
}, vH = (e, t, n, i, r) => () => {
  const s = /* @__PURE__ */ new WeakMap(), a = async (o, l) => {
    let u = n(o);
    const c = Xn(u, l);
    if (!c) {
      const d = {
        attack: u.attack.value,
        channelCount: u.channelCount,
        channelCountMode: u.channelCountMode,
        channelInterpretation: u.channelInterpretation,
        knee: u.knee.value,
        ratio: u.ratio.value,
        release: u.release.value,
        threshold: u.threshold.value
      };
      u = t(l, d);
    }
    return s.set(l, u), c ? (await e(l, o.attack, u.attack), await e(l, o.knee, u.knee), await e(l, o.ratio, u.ratio), await e(l, o.release, u.release), await e(l, o.threshold, u.threshold)) : (await i(l, o.attack, u.attack), await i(l, o.knee, u.knee), await i(l, o.ratio, u.ratio), await i(l, o.release, u.release), await i(l, o.threshold, u.threshold)), await r(o, l, u), u;
  };
  return {
    render(o, l) {
      const u = s.get(l);
      return u !== void 0 ? Promise.resolve(u) : a(o, l);
    }
  };
}, gH = () => new DOMException("", "EncodingError"), pH = (e) => (t) => new Promise((n, i) => {
  if (e === null) {
    i(new SyntaxError());
    return;
  }
  const r = e.document.head;
  if (r === null)
    i(new SyntaxError());
  else {
    const s = e.document.createElement("script"), a = new Blob([t], { type: "application/javascript" }), o = URL.createObjectURL(a), l = e.onerror, u = () => {
      e.onerror = l, URL.revokeObjectURL(o);
    };
    e.onerror = (c, d, f, h, m) => {
      if (d === o || d === e.location.href && f === 1 && h === 1)
        return u(), i(m), !1;
      if (l !== null)
        return l(c, d, f, h, m);
    }, s.onerror = () => {
      u(), i(new SyntaxError());
    }, s.onload = () => {
      u(), n();
    }, s.src = o, s.type = "module", r.appendChild(s);
  }
}), yH = (e) => class {
  constructor(n) {
    this._nativeEventTarget = n, this._listeners = /* @__PURE__ */ new WeakMap();
  }
  addEventListener(n, i, r) {
    if (i !== null) {
      let s = this._listeners.get(i);
      s === void 0 && (s = e(this, i), typeof i == "function" && this._listeners.set(i, s)), this._nativeEventTarget.addEventListener(n, s, r);
    }
  }
  dispatchEvent(n) {
    return this._nativeEventTarget.dispatchEvent(n);
  }
  removeEventListener(n, i, r) {
    const s = i === null ? void 0 : this._listeners.get(i);
    this._nativeEventTarget.removeEventListener(n, s === void 0 ? null : s, r);
  }
}, bH = (e) => (t, n, i) => {
  Object.defineProperties(e, {
    currentFrame: {
      configurable: !0,
      get() {
        return Math.round(t * n);
      }
    },
    currentTime: {
      configurable: !0,
      get() {
        return t;
      }
    }
  });
  try {
    return i();
  } finally {
    e !== null && (delete e.currentFrame, delete e.currentTime);
  }
}, wH = (e) => async (t) => {
  try {
    const n = await fetch(t);
    if (n.ok)
      return [await n.text(), n.url];
  } catch {
  }
  throw e();
}, _H = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  gain: 1
}, SH = (e, t, n, i, r, s) => class extends e {
  constructor(o, l) {
    const u = r(o), c = { ..._H, ...l }, d = i(u, c), f = s(u), h = f ? n() : null;
    super(o, !1, d, h), this._gain = t(this, f, d.gain, ei, mi);
  }
  get gain() {
    return this._gain;
  }
}, kH = (e, t, n, i, r) => () => {
  const s = /* @__PURE__ */ new WeakMap(), a = async (o, l) => {
    let u = n(o);
    const c = Xn(u, l);
    if (!c) {
      const d = {
        channelCount: u.channelCount,
        channelCountMode: u.channelCountMode,
        channelInterpretation: u.channelInterpretation,
        gain: u.gain.value
      };
      u = t(l, d);
    }
    return s.set(l, u), c ? await e(l, o.gain, u.gain) : await i(l, o.gain, u.gain), await r(o, l, u), u;
  };
  return {
    render(o, l) {
      const u = s.get(l);
      return u !== void 0 ? Promise.resolve(u) : a(o, l);
    }
  };
}, CH = (e, t) => (n) => t(e, n), TH = (e) => (t) => {
  const n = e(t);
  if (n.renderer === null)
    throw new Error("Missing the renderer of the given AudioNode in the audio graph.");
  return n.renderer;
}, xH = (e) => (t) => {
  var n;
  return (n = e.get(t)) !== null && n !== void 0 ? n : 0;
}, AH = (e) => (t) => {
  const n = e(t);
  if (n.renderer === null)
    throw new Error("Missing the renderer of the given AudioParam in the audio graph.");
  return n.renderer;
}, IH = (e) => (t) => e.get(t), An = () => new DOMException("", "InvalidStateError"), EH = (e) => (t) => {
  const n = e.get(t);
  if (n === void 0)
    throw An();
  return n;
}, PH = (e, t) => (n) => {
  let i = e.get(n);
  if (i !== void 0)
    return i;
  if (t === null)
    throw new Error("Missing the native OfflineAudioContext constructor.");
  return i = new t(1, 1, 44100), e.set(n, i), i;
}, OH = (e) => (t) => {
  const n = e.get(t);
  if (n === void 0)
    throw new Error("The context has no set of AudioWorkletNodes.");
  return n;
}, tm = () => new DOMException("", "InvalidAccessError"), VH = (e) => {
  e.getFrequencyResponse = ((t) => (n, i, r) => {
    if (n.length !== i.length || i.length !== r.length)
      throw tm();
    return t.call(e, n, i, r);
  })(e.getFrequencyResponse);
}, DH = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers"
}, NH = (e, t, n, i, r, s) => class extends e {
  constructor(o, l) {
    const u = i(o), c = r(u), d = { ...DH, ...l }, f = t(u, c ? null : o.baseLatency, d), h = c ? n(d.feedback, d.feedforward) : null;
    super(o, !1, f, h), VH(f), this._nativeIIRFilterNode = f, s(this, 1);
  }
  getFrequencyResponse(o, l, u) {
    return this._nativeIIRFilterNode.getFrequencyResponse(o, l, u);
  }
}, j1 = (e, t, n, i, r, s, a, o, l, u, c) => {
  const d = u.length;
  let f = o;
  for (let h = 0; h < d; h += 1) {
    let m = n[0] * u[h];
    for (let g = 1; g < r; g += 1) {
      const p = f - g & l - 1;
      m += n[g] * s[p], m -= e[g] * a[p];
    }
    for (let g = r; g < i; g += 1)
      m += n[g] * s[f - g & l - 1];
    for (let g = r; g < t; g += 1)
      m -= e[g] * a[f - g & l - 1];
    s[f] = u[h], a[f] = m, f = f + 1 & l - 1, c[h] = m;
  }
  return f;
}, MH = (e, t, n, i) => {
  const r = n instanceof Float64Array ? n : new Float64Array(n), s = i instanceof Float64Array ? i : new Float64Array(i), a = r.length, o = s.length, l = Math.min(a, o);
  if (r[0] !== 1) {
    for (let m = 0; m < a; m += 1)
      s[m] /= r[0];
    for (let m = 1; m < o; m += 1)
      r[m] /= r[0];
  }
  const u = 32, c = new Float32Array(u), d = new Float32Array(u), f = t.createBuffer(e.numberOfChannels, e.length, e.sampleRate), h = e.numberOfChannels;
  for (let m = 0; m < h; m += 1) {
    const g = e.getChannelData(m), p = f.getChannelData(m);
    c.fill(0), d.fill(0), j1(r, a, s, o, l, c, d, 0, u, g, p);
  }
  return f;
}, RH = (e, t, n, i, r) => (s, a) => {
  const o = /* @__PURE__ */ new WeakMap();
  let l = null;
  const u = async (c, d) => {
    let f = null, h = t(c);
    const m = Xn(h, d);
    if (d.createIIRFilter === void 0 ? f = e(d, {
      buffer: null,
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers",
      loop: !1,
      loopEnd: 0,
      loopStart: 0,
      playbackRate: 1
    }) : m || (h = d.createIIRFilter(a, s)), o.set(d, f === null ? h : f), f !== null) {
      if (l === null) {
        if (n === null)
          throw new Error("Missing the native OfflineAudioContext constructor.");
        const p = new n(
          // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.
          c.context.destination.channelCount,
          // Bug #17: Safari does not yet expose the length.
          c.context.length,
          d.sampleRate
        );
        l = (async () => {
          await i(c, p, p.destination);
          const y = await r(p);
          return MH(y, d, s, a);
        })();
      }
      const g = await l;
      return f.buffer = g, f.start(0), f;
    }
    return await i(c, d, h), h;
  };
  return {
    render(c, d) {
      const f = o.get(d);
      return f !== void 0 ? Promise.resolve(f) : u(c, d);
    }
  };
}, FH = (e, t, n, i, r, s) => (a) => (o, l) => {
  const u = e.get(o);
  if (u === void 0) {
    if (!a && s(o)) {
      const c = i(o), { outputs: d } = n(o);
      for (const f of d)
        if (Qc(f)) {
          const h = i(f[0]);
          t(c, h, f[1], f[2]);
        } else {
          const h = r(f[0]);
          c.disconnect(h, f[1]);
        }
    }
    e.set(o, l);
  } else
    e.set(o, u + l);
}, BH = (e, t) => (n) => {
  const i = e.get(n);
  return t(i) || t(n);
}, LH = (e, t) => (n) => e.has(n) || t(n), $H = (e, t) => (n) => e.has(n) || t(n), WH = (e, t) => (n) => {
  const i = e.get(n);
  return t(i) || t(n);
}, jH = (e) => (t) => e !== null && t instanceof e, HH = (e) => (t) => e !== null && typeof e.AudioNode == "function" && t instanceof e.AudioNode, zH = (e) => (t) => e !== null && typeof e.AudioParam == "function" && t instanceof e.AudioParam, UH = (e, t) => (n) => e(n) || t(n), qH = (e) => (t) => e !== null && t instanceof e, GH = (e) => e !== null && e.isSecureContext, YH = (e, t, n, i) => class extends e {
  constructor(s, a) {
    const o = n(s), l = t(o, a);
    if (i(o))
      throw TypeError();
    super(s, !0, l, null), this._nativeMediaElementAudioSourceNode = l;
  }
  get mediaElement() {
    return this._nativeMediaElementAudioSourceNode.mediaElement;
  }
}, ZH = {
  channelCount: 2,
  channelCountMode: "explicit",
  channelInterpretation: "speakers"
}, KH = (e, t, n, i) => class extends e {
  constructor(s, a) {
    const o = n(s);
    if (i(o))
      throw new TypeError();
    const l = { ...ZH, ...a }, u = t(o, l);
    super(s, !1, u, null), this._nativeMediaStreamAudioDestinationNode = u;
  }
  get stream() {
    return this._nativeMediaStreamAudioDestinationNode.stream;
  }
}, XH = (e, t, n, i) => class extends e {
  constructor(s, a) {
    const o = n(s), l = t(o, a);
    if (i(o))
      throw new TypeError();
    super(s, !0, l, null), this._nativeMediaStreamAudioSourceNode = l;
  }
  get mediaStream() {
    return this._nativeMediaStreamAudioSourceNode.mediaStream;
  }
}, JH = (e, t, n) => class extends e {
  constructor(r, s) {
    const a = n(r), o = t(a, s);
    super(r, !0, o, null);
  }
}, QH = (e, t, n, i, r, s) => class extends n {
  constructor(o, l) {
    super(o), this._nativeContext = o, Qh.set(this, o), i(o) && r.set(o, /* @__PURE__ */ new Set()), this._destination = new e(this, l), this._listener = t(this, o), this._onstatechange = null;
  }
  get currentTime() {
    return this._nativeContext.currentTime;
  }
  get destination() {
    return this._destination;
  }
  get listener() {
    return this._listener;
  }
  get onstatechange() {
    return this._onstatechange;
  }
  set onstatechange(o) {
    const l = typeof o == "function" ? s(this, o) : null;
    this._nativeContext.onstatechange = l;
    const u = this._nativeContext.onstatechange;
    this._onstatechange = u !== null && u === l ? o : u;
  }
  get sampleRate() {
    return this._nativeContext.sampleRate;
  }
  get state() {
    return this._nativeContext.state;
  }
}, uc = (e) => {
  const t = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
  try {
    const n = e.decodeAudioData(t.buffer, () => {
    });
    return n === void 0 ? !1 : (n.catch(() => {
    }), !0);
  } catch {
  }
  return !1;
}, e3 = (e, t) => (n, i, r) => {
  const s = /* @__PURE__ */ new Set();
  return n.connect = ((a) => (o, l = 0, u = 0) => {
    const c = s.size === 0;
    if (t(o))
      return a.call(n, o, l, u), e(s, [o, l, u], (d) => d[0] === o && d[1] === l && d[2] === u, !0), c && i(), o;
    a.call(n, o, l), e(s, [o, l], (d) => d[0] === o && d[1] === l, !0), c && i();
  })(n.connect), n.disconnect = ((a) => (o, l, u) => {
    const c = s.size > 0;
    if (o === void 0)
      a.apply(n), s.clear();
    else if (typeof o == "number") {
      a.call(n, o);
      for (const f of s)
        f[1] === o && s.delete(f);
    } else {
      t(o) ? a.call(n, o, l, u) : a.call(n, o, l);
      for (const f of s)
        f[0] === o && (l === void 0 || f[1] === l) && (u === void 0 || f[2] === u) && s.delete(f);
    }
    const d = s.size === 0;
    c && d && r();
  })(n.disconnect), n;
}, $t = (e, t, n) => {
  const i = t[n];
  i !== void 0 && i !== e[n] && (e[n] = i);
}, yn = (e, t) => {
  $t(e, t, "channelCount"), $t(e, t, "channelCountMode"), $t(e, t, "channelInterpretation");
}, b_ = (e) => typeof e.getFloatTimeDomainData == "function", t3 = (e) => {
  e.getFloatTimeDomainData = (t) => {
    const n = new Uint8Array(t.length);
    e.getByteTimeDomainData(n);
    const i = Math.max(n.length, e.fftSize);
    for (let r = 0; r < i; r += 1)
      t[r] = (n[r] - 128) * 78125e-7;
    return t;
  };
}, n3 = (e, t) => (n, i) => {
  const r = n.createAnalyser();
  if (yn(r, i), !(i.maxDecibels > i.minDecibels))
    throw t();
  return $t(r, i, "fftSize"), $t(r, i, "maxDecibels"), $t(r, i, "minDecibels"), $t(r, i, "smoothingTimeConstant"), e(b_, () => b_(r)) || t3(r), r;
}, i3 = (e) => e === null ? null : e.hasOwnProperty("AudioBuffer") ? e.AudioBuffer : null, Kt = (e, t, n) => {
  const i = t[n];
  i !== void 0 && i !== e[n].value && (e[n].value = i);
}, r3 = (e) => {
  e.start = ((t) => {
    let n = !1;
    return (i = 0, r = 0, s) => {
      if (n)
        throw An();
      t.call(e, i, r, s), n = !0;
    };
  })(e.start);
}, Ey = (e) => {
  e.start = ((t) => (n = 0, i = 0, r) => {
    if (typeof r == "number" && r < 0 || i < 0 || n < 0)
      throw new RangeError("The parameters can't be negative.");
    t.call(e, n, i, r);
  })(e.start);
}, Py = (e) => {
  e.stop = ((t) => (n = 0) => {
    if (n < 0)
      throw new RangeError("The parameter can't be negative.");
    t.call(e, n);
  })(e.stop);
}, s3 = (e, t, n, i, r, s, a, o, l, u, c) => (d, f) => {
  const h = d.createBufferSource();
  return yn(h, f), Kt(h, f, "playbackRate"), $t(h, f, "buffer"), $t(h, f, "loop"), $t(h, f, "loopEnd"), $t(h, f, "loopStart"), t(n, () => n(d)) || r3(h), t(i, () => i(d)) || l(h), t(r, () => r(d)) || u(h, d), t(s, () => s(d)) || Ey(h), t(a, () => a(d)) || c(h, d), t(o, () => o(d)) || Py(h), e(d, h), h;
}, a3 = (e) => e === null ? null : e.hasOwnProperty("AudioContext") ? e.AudioContext : e.hasOwnProperty("webkitAudioContext") ? e.webkitAudioContext : null, o3 = (e, t) => (n, i, r) => {
  const s = n.destination;
  if (s.channelCount !== i)
    try {
      s.channelCount = i;
    } catch {
    }
  r && s.channelCountMode !== "explicit" && (s.channelCountMode = "explicit"), s.maxChannelCount === 0 && Object.defineProperty(s, "maxChannelCount", {
    value: i
  });
  const a = e(n, {
    channelCount: i,
    channelCountMode: s.channelCountMode,
    channelInterpretation: s.channelInterpretation,
    gain: 1
  });
  return t(a, "channelCount", (o) => () => o.call(a), (o) => (l) => {
    o.call(a, l);
    try {
      s.channelCount = l;
    } catch (u) {
      if (l > s.maxChannelCount)
        throw u;
    }
  }), t(a, "channelCountMode", (o) => () => o.call(a), (o) => (l) => {
    o.call(a, l), s.channelCountMode = l;
  }), t(a, "channelInterpretation", (o) => () => o.call(a), (o) => (l) => {
    o.call(a, l), s.channelInterpretation = l;
  }), Object.defineProperty(a, "maxChannelCount", {
    get: () => s.maxChannelCount
  }), a.connect(s), a;
}, l3 = (e) => e === null ? null : e.hasOwnProperty("AudioWorkletNode") ? e.AudioWorkletNode : null, u3 = (e) => {
  const { port1: t } = new MessageChannel();
  try {
    t.postMessage(e);
  } finally {
    t.close();
  }
}, c3 = (e, t, n, i, r) => (s, a, o, l, u, c) => {
  if (o !== null)
    try {
      const d = new o(s, l, c), f = /* @__PURE__ */ new Map();
      let h = null;
      if (Object.defineProperties(d, {
        /*
         * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some
         * browsers have no native implementation to achieve a consistent behavior.
         */
        channelCount: {
          get: () => c.channelCount,
          set: () => {
            throw e();
          }
        },
        channelCountMode: {
          get: () => "explicit",
          set: () => {
            throw e();
          }
        },
        // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.
        onprocessorerror: {
          get: () => h,
          set: (m) => {
            typeof h == "function" && d.removeEventListener("processorerror", h), h = typeof m == "function" ? m : null, typeof h == "function" && d.addEventListener("processorerror", h);
          }
        }
      }), d.addEventListener = ((m) => (...g) => {
        if (g[0] === "processorerror") {
          const p = typeof g[1] == "function" ? g[1] : typeof g[1] == "object" && g[1] !== null && typeof g[1].handleEvent == "function" ? g[1].handleEvent : null;
          if (p !== null) {
            const y = f.get(g[1]);
            y !== void 0 ? g[1] = y : (g[1] = (k) => {
              k.type === "error" ? (Object.defineProperties(k, {
                type: { value: "processorerror" }
              }), p(k)) : p(new ErrorEvent(g[0], { ...k }));
            }, f.set(p, g[1]));
          }
        }
        return m.call(d, "error", g[1], g[2]), m.call(d, ...g);
      })(d.addEventListener), d.removeEventListener = ((m) => (...g) => {
        if (g[0] === "processorerror") {
          const p = f.get(g[1]);
          p !== void 0 && (f.delete(g[1]), g[1] = p);
        }
        return m.call(d, "error", g[1], g[2]), m.call(d, g[0], g[1], g[2]);
      })(d.removeEventListener), c.numberOfOutputs !== 0) {
        const m = n(s, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          gain: 0
        });
        return d.connect(m).connect(s.destination), r(d, () => m.disconnect(), () => m.connect(s.destination));
      }
      return d;
    } catch (d) {
      throw d.code === 11 ? i() : d;
    }
  if (u === void 0)
    throw i();
  return u3(c), t(s, a, u, c);
}, H1 = (e, t) => e === null ? 512 : Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(e * t))))), d3 = (e) => new Promise((t, n) => {
  const { port1: i, port2: r } = new MessageChannel();
  i.onmessage = ({ data: s }) => {
    i.close(), r.close(), t(s);
  }, i.onmessageerror = ({ data: s }) => {
    i.close(), r.close(), n(s);
  }, r.postMessage(e);
}), f3 = async (e, t) => {
  const n = await d3(t);
  return new e(n);
}, h3 = (e, t, n, i) => {
  let r = kg.get(e);
  r === void 0 && (r = /* @__PURE__ */ new WeakMap(), kg.set(e, r));
  const s = f3(n, i);
  return r.set(t, s), s;
}, m3 = (e, t, n, i, r, s, a, o, l, u, c, d, f) => (h, m, g, p) => {
  if (p.numberOfInputs === 0 && p.numberOfOutputs === 0)
    throw l();
  const y = Array.isArray(p.outputChannelCount) ? p.outputChannelCount : Array.from(p.outputChannelCount);
  if (y.some((te) => te < 1))
    throw l();
  if (y.length !== p.numberOfOutputs)
    throw t();
  if (p.channelCountMode !== "explicit")
    throw l();
  const k = p.channelCount * p.numberOfInputs, T = y.reduce((te, me) => te + me, 0), _ = g.parameterDescriptors === void 0 ? 0 : g.parameterDescriptors.length;
  if (k + _ > 6 || T > 6)
    throw l();
  const w = new MessageChannel(), S = [], C = [];
  for (let te = 0; te < p.numberOfInputs; te += 1)
    S.push(a(h, {
      channelCount: p.channelCount,
      channelCountMode: p.channelCountMode,
      channelInterpretation: p.channelInterpretation,
      gain: 1
    })), C.push(r(h, {
      channelCount: p.channelCount,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      numberOfOutputs: p.channelCount
    }));
  const x = [];
  if (g.parameterDescriptors !== void 0)
    for (const { defaultValue: te, maxValue: me, minValue: Me, name: Be } of g.parameterDescriptors) {
      const xe = s(h, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        offset: p.parameterData[Be] !== void 0 ? p.parameterData[Be] : te === void 0 ? 0 : te
      });
      Object.defineProperties(xe.offset, {
        defaultValue: {
          get: () => te === void 0 ? 0 : te
        },
        maxValue: {
          get: () => me === void 0 ? ei : me
        },
        minValue: {
          get: () => Me === void 0 ? mi : Me
        }
      }), x.push(xe);
    }
  const A = i(h, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "speakers",
    numberOfInputs: Math.max(1, k + _)
  }), I = H1(m, h.sampleRate), E = o(
    h,
    I,
    k + _,
    // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.
    Math.max(1, T)
  ), P = r(h, {
    channelCount: Math.max(1, T),
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    numberOfOutputs: Math.max(1, T)
  }), V = [];
  for (let te = 0; te < p.numberOfOutputs; te += 1)
    V.push(i(h, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "speakers",
      numberOfInputs: y[te]
    }));
  for (let te = 0; te < p.numberOfInputs; te += 1) {
    S[te].connect(C[te]);
    for (let me = 0; me < p.channelCount; me += 1)
      C[te].connect(A, me, te * p.channelCount + me);
  }
  const N = new $1(g.parameterDescriptors === void 0 ? [] : g.parameterDescriptors.map(({ name: te }, me) => {
    const Me = x[me];
    return Me.connect(A, 0, k + me), Me.start(0), [te, Me.offset];
  }));
  A.connect(E);
  let F = p.channelInterpretation, $ = null;
  const Z = p.numberOfOutputs === 0 ? [E] : V, j = {
    get bufferSize() {
      return I;
    },
    get channelCount() {
      return p.channelCount;
    },
    set channelCount(te) {
      throw n();
    },
    get channelCountMode() {
      return p.channelCountMode;
    },
    set channelCountMode(te) {
      throw n();
    },
    get channelInterpretation() {
      return F;
    },
    set channelInterpretation(te) {
      for (const me of S)
        me.channelInterpretation = te;
      F = te;
    },
    get context() {
      return E.context;
    },
    get inputs() {
      return S;
    },
    get numberOfInputs() {
      return p.numberOfInputs;
    },
    get numberOfOutputs() {
      return p.numberOfOutputs;
    },
    get onprocessorerror() {
      return $;
    },
    set onprocessorerror(te) {
      typeof $ == "function" && j.removeEventListener("processorerror", $), $ = typeof te == "function" ? te : null, typeof $ == "function" && j.addEventListener("processorerror", $);
    },
    get parameters() {
      return N;
    },
    get port() {
      return w.port2;
    },
    addEventListener(...te) {
      return E.addEventListener(te[0], te[1], te[2]);
    },
    connect: e.bind(null, Z),
    disconnect: u.bind(null, Z),
    dispatchEvent(...te) {
      return E.dispatchEvent(te[0]);
    },
    removeEventListener(...te) {
      return E.removeEventListener(te[0], te[1], te[2]);
    }
  }, H = /* @__PURE__ */ new Map();
  w.port1.addEventListener = ((te) => (...me) => {
    if (me[0] === "message") {
      const Me = typeof me[1] == "function" ? me[1] : typeof me[1] == "object" && me[1] !== null && typeof me[1].handleEvent == "function" ? me[1].handleEvent : null;
      if (Me !== null) {
        const Be = H.get(me[1]);
        Be !== void 0 ? me[1] = Be : (me[1] = (xe) => {
          c(h.currentTime, h.sampleRate, () => Me(xe));
        }, H.set(Me, me[1]));
      }
    }
    return te.call(w.port1, me[0], me[1], me[2]);
  })(w.port1.addEventListener), w.port1.removeEventListener = ((te) => (...me) => {
    if (me[0] === "message") {
      const Me = H.get(me[1]);
      Me !== void 0 && (H.delete(me[1]), me[1] = Me);
    }
    return te.call(w.port1, me[0], me[1], me[2]);
  })(w.port1.removeEventListener);
  let R = null;
  Object.defineProperty(w.port1, "onmessage", {
    get: () => R,
    set: (te) => {
      typeof R == "function" && w.port1.removeEventListener("message", R), R = typeof te == "function" ? te : null, typeof R == "function" && (w.port1.addEventListener("message", R), w.port1.start());
    }
  }), g.prototype.port = w.port1;
  let L = null;
  h3(h, j, g, p).then((te) => L = te);
  const oe = Yf(p.numberOfInputs, p.channelCount), we = Yf(p.numberOfOutputs, y), ee = g.parameterDescriptors === void 0 ? [] : g.parameterDescriptors.reduce((te, { name: me }) => ({ ...te, [me]: new Float32Array(128) }), {});
  let K = !0;
  const ue = () => {
    p.numberOfOutputs > 0 && E.disconnect(P);
    for (let te = 0, me = 0; te < p.numberOfOutputs; te += 1) {
      const Me = V[te];
      for (let Be = 0; Be < y[te]; Be += 1)
        P.disconnect(Me, me + Be, Be);
      me += y[te];
    }
  }, ve = /* @__PURE__ */ new Map();
  E.onaudioprocess = ({ inputBuffer: te, outputBuffer: me }) => {
    if (L !== null) {
      const Me = d(j);
      for (let Be = 0; Be < I; Be += 128) {
        for (let xe = 0; xe < p.numberOfInputs; xe += 1)
          for (let ze = 0; ze < p.channelCount; ze += 1)
            Gf(te, oe[xe], ze, ze, Be);
        g.parameterDescriptors !== void 0 && g.parameterDescriptors.forEach(({ name: xe }, ze) => {
          Gf(te, ee, xe, k + ze, Be);
        });
        for (let xe = 0; xe < p.numberOfInputs; xe += 1)
          for (let ze = 0; ze < y[xe]; ze += 1)
            we[xe][ze].byteLength === 0 && (we[xe][ze] = new Float32Array(128));
        try {
          const xe = oe.map((Ke, ut) => {
            if (Me[ut].size > 0)
              return ve.set(ut, I / 128), Ke;
            const Vn = ve.get(ut);
            return Vn === void 0 ? [] : (Ke.every((Dn) => Dn.every((Dr) => Dr === 0)) && (Vn === 1 ? ve.delete(ut) : ve.set(ut, Vn - 1)), Ke);
          });
          K = c(h.currentTime + Be / h.sampleRate, h.sampleRate, () => L.process(xe, we, ee));
          for (let Ke = 0, ut = 0; Ke < p.numberOfOutputs; Ke += 1) {
            for (let vt = 0; vt < y[Ke]; vt += 1)
              W1(me, we[Ke], vt, ut + vt, Be);
            ut += y[Ke];
          }
        } catch (xe) {
          K = !1, j.dispatchEvent(new ErrorEvent("processorerror", {
            colno: xe.colno,
            filename: xe.filename,
            lineno: xe.lineno,
            message: xe.message
          }));
        }
        if (!K) {
          for (let xe = 0; xe < p.numberOfInputs; xe += 1) {
            S[xe].disconnect(C[xe]);
            for (let ze = 0; ze < p.channelCount; ze += 1)
              C[Be].disconnect(A, ze, xe * p.channelCount + ze);
          }
          if (g.parameterDescriptors !== void 0) {
            const xe = g.parameterDescriptors.length;
            for (let ze = 0; ze < xe; ze += 1) {
              const Ke = x[ze];
              Ke.disconnect(A, 0, k + ze), Ke.stop();
            }
          }
          A.disconnect(E), E.onaudioprocess = null, Fe ? ue() : le();
          break;
        }
      }
    }
  };
  let Fe = !1;
  const he = a(h, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  }), Oe = () => E.connect(he).connect(h.destination), le = () => {
    E.disconnect(he), he.disconnect();
  }, be = () => {
    if (K) {
      le(), p.numberOfOutputs > 0 && E.connect(P);
      for (let te = 0, me = 0; te < p.numberOfOutputs; te += 1) {
        const Me = V[te];
        for (let Be = 0; Be < y[te]; Be += 1)
          P.connect(Me, me + Be, Be);
        me += y[te];
      }
    }
    Fe = !0;
  }, Pe = () => {
    K && (Oe(), ue()), Fe = !1;
  };
  return Oe(), f(j, be, Pe);
}, z1 = (e, t) => {
  const n = e.createBiquadFilter();
  return yn(n, t), Kt(n, t, "Q"), Kt(n, t, "detune"), Kt(n, t, "frequency"), Kt(n, t, "gain"), $t(n, t, "type"), n;
}, v3 = (e, t) => (n, i) => {
  const r = n.createChannelMerger(i.numberOfInputs);
  return e !== null && e.name === "webkitAudioContext" && t(n, r), yn(r, i), r;
}, g3 = (e) => {
  const t = e.numberOfOutputs;
  Object.defineProperty(e, "channelCount", {
    get: () => t,
    set: (n) => {
      if (n !== t)
        throw An();
    }
  }), Object.defineProperty(e, "channelCountMode", {
    get: () => "explicit",
    set: (n) => {
      if (n !== "explicit")
        throw An();
    }
  }), Object.defineProperty(e, "channelInterpretation", {
    get: () => "discrete",
    set: (n) => {
      if (n !== "discrete")
        throw An();
    }
  });
}, ed = (e, t) => {
  const n = e.createChannelSplitter(t.numberOfOutputs);
  return yn(n, t), g3(n), n;
}, p3 = (e, t, n, i, r) => (s, a) => {
  if (s.createConstantSource === void 0)
    return n(s, a);
  const o = s.createConstantSource();
  return yn(o, a), Kt(o, a, "offset"), t(i, () => i(s)) || Ey(o), t(r, () => r(s)) || Py(o), e(s, o), o;
}, eu = (e, t) => (e.connect = t.connect.bind(t), e.disconnect = t.disconnect.bind(t), e), y3 = (e, t, n, i) => (r, { offset: s, ...a }) => {
  const o = r.createBuffer(1, 2, 44100), l = t(r, {
    buffer: null,
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    loop: !1,
    loopEnd: 0,
    loopStart: 0,
    playbackRate: 1
  }), u = n(r, { ...a, gain: s }), c = o.getChannelData(0);
  c[0] = 1, c[1] = 1, l.buffer = o, l.loop = !0;
  const d = {
    get bufferSize() {
    },
    get channelCount() {
      return u.channelCount;
    },
    set channelCount(m) {
      u.channelCount = m;
    },
    get channelCountMode() {
      return u.channelCountMode;
    },
    set channelCountMode(m) {
      u.channelCountMode = m;
    },
    get channelInterpretation() {
      return u.channelInterpretation;
    },
    set channelInterpretation(m) {
      u.channelInterpretation = m;
    },
    get context() {
      return u.context;
    },
    get inputs() {
      return [];
    },
    get numberOfInputs() {
      return l.numberOfInputs;
    },
    get numberOfOutputs() {
      return u.numberOfOutputs;
    },
    get offset() {
      return u.gain;
    },
    get onended() {
      return l.onended;
    },
    set onended(m) {
      l.onended = m;
    },
    addEventListener(...m) {
      return l.addEventListener(m[0], m[1], m[2]);
    },
    dispatchEvent(...m) {
      return l.dispatchEvent(m[0]);
    },
    removeEventListener(...m) {
      return l.removeEventListener(m[0], m[1], m[2]);
    },
    start(m = 0) {
      l.start.call(l, m);
    },
    stop(m = 0) {
      l.stop.call(l, m);
    }
  }, f = () => l.connect(u), h = () => l.disconnect(u);
  return e(r, l), i(eu(d, u), f, h);
}, b3 = (e, t) => (n, i) => {
  const r = n.createConvolver();
  if (yn(r, i), i.disableNormalization === r.normalize && (r.normalize = !i.disableNormalization), $t(r, i, "buffer"), i.channelCount > 2 || (t(r, "channelCount", (s) => () => s.call(r), (s) => (a) => {
    if (a > 2)
      throw e();
    return s.call(r, a);
  }), i.channelCountMode === "max"))
    throw e();
  return t(r, "channelCountMode", (s) => () => s.call(r), (s) => (a) => {
    if (a === "max")
      throw e();
    return s.call(r, a);
  }), r;
}, U1 = (e, t) => {
  const n = e.createDelay(t.maxDelayTime);
  return yn(n, t), Kt(n, t, "delayTime"), n;
}, w3 = (e) => (t, n) => {
  const i = t.createDynamicsCompressor();
  if (yn(i, n), n.channelCount > 2 || n.channelCountMode === "max")
    throw e();
  return Kt(i, n, "attack"), Kt(i, n, "knee"), Kt(i, n, "ratio"), Kt(i, n, "release"), Kt(i, n, "threshold"), i;
}, yi = (e, t) => {
  const n = e.createGain();
  return yn(n, t), Kt(n, t, "gain"), n;
}, _3 = (e) => (t, n, i) => {
  if (t.createIIRFilter === void 0)
    return e(t, n, i);
  const r = t.createIIRFilter(i.feedforward, i.feedback);
  return yn(r, i), r;
};
function S3(e, t) {
  const n = t[0] * t[0] + t[1] * t[1];
  return [(e[0] * t[0] + e[1] * t[1]) / n, (e[1] * t[0] - e[0] * t[1]) / n];
}
function k3(e, t) {
  return [e[0] * t[0] - e[1] * t[1], e[0] * t[1] + e[1] * t[0]];
}
function w_(e, t) {
  let n = [0, 0];
  for (let i = e.length - 1; i >= 0; i -= 1)
    n = k3(n, t), n[0] += e[i];
  return n;
}
const C3 = (e, t, n, i) => (r, s, { channelCount: a, channelCountMode: o, channelInterpretation: l, feedback: u, feedforward: c }) => {
  const d = H1(s, r.sampleRate), f = u instanceof Float64Array ? u : new Float64Array(u), h = c instanceof Float64Array ? c : new Float64Array(c), m = f.length, g = h.length, p = Math.min(m, g);
  if (m === 0 || m > 20)
    throw i();
  if (f[0] === 0)
    throw t();
  if (g === 0 || g > 20)
    throw i();
  if (h[0] === 0)
    throw t();
  if (f[0] !== 1) {
    for (let x = 0; x < g; x += 1)
      h[x] /= f[0];
    for (let x = 1; x < m; x += 1)
      f[x] /= f[0];
  }
  const y = n(r, d, a, a);
  y.channelCount = a, y.channelCountMode = o, y.channelInterpretation = l;
  const k = 32, T = [], _ = [], w = [];
  for (let x = 0; x < a; x += 1) {
    T.push(0);
    const A = new Float32Array(k), I = new Float32Array(k);
    A.fill(0), I.fill(0), _.push(A), w.push(I);
  }
  y.onaudioprocess = (x) => {
    const A = x.inputBuffer, I = x.outputBuffer, E = A.numberOfChannels;
    for (let P = 0; P < E; P += 1) {
      const V = A.getChannelData(P), N = I.getChannelData(P);
      T[P] = j1(f, m, h, g, p, _[P], w[P], T[P], k, V, N);
    }
  };
  const S = r.sampleRate / 2;
  return eu({
    get bufferSize() {
      return d;
    },
    get channelCount() {
      return y.channelCount;
    },
    set channelCount(x) {
      y.channelCount = x;
    },
    get channelCountMode() {
      return y.channelCountMode;
    },
    set channelCountMode(x) {
      y.channelCountMode = x;
    },
    get channelInterpretation() {
      return y.channelInterpretation;
    },
    set channelInterpretation(x) {
      y.channelInterpretation = x;
    },
    get context() {
      return y.context;
    },
    get inputs() {
      return [y];
    },
    get numberOfInputs() {
      return y.numberOfInputs;
    },
    get numberOfOutputs() {
      return y.numberOfOutputs;
    },
    addEventListener(...x) {
      return y.addEventListener(x[0], x[1], x[2]);
    },
    dispatchEvent(...x) {
      return y.dispatchEvent(x[0]);
    },
    getFrequencyResponse(x, A, I) {
      if (x.length !== A.length || A.length !== I.length)
        throw e();
      const E = x.length;
      for (let P = 0; P < E; P += 1) {
        const V = -Math.PI * (x[P] / S), N = [Math.cos(V), Math.sin(V)], F = w_(h, N), $ = w_(f, N), Z = S3(F, $);
        A[P] = Math.sqrt(Z[0] * Z[0] + Z[1] * Z[1]), I[P] = Math.atan2(Z[1], Z[0]);
      }
    },
    removeEventListener(...x) {
      return y.removeEventListener(x[0], x[1], x[2]);
    }
  }, y);
}, T3 = (e, t) => e.createMediaElementSource(t.mediaElement), x3 = (e, t) => {
  const n = e.createMediaStreamDestination();
  return yn(n, t), n.numberOfOutputs === 1 && Object.defineProperty(n, "numberOfOutputs", { get: () => 0 }), n;
}, A3 = (e, { mediaStream: t }) => {
  const n = t.getAudioTracks();
  n.sort((s, a) => s.id < a.id ? -1 : s.id > a.id ? 1 : 0);
  const i = n.slice(0, 1), r = e.createMediaStreamSource(new MediaStream(i));
  return Object.defineProperty(r, "mediaStream", { value: t }), r;
}, I3 = (e, t) => (n, { mediaStreamTrack: i }) => {
  if (typeof n.createMediaStreamTrackSource == "function")
    return n.createMediaStreamTrackSource(i);
  const r = new MediaStream([i]), s = n.createMediaStreamSource(r);
  if (i.kind !== "audio")
    throw e();
  if (t(n))
    throw new TypeError();
  return s;
}, E3 = (e) => e === null ? null : e.hasOwnProperty("OfflineAudioContext") ? e.OfflineAudioContext : e.hasOwnProperty("webkitOfflineAudioContext") ? e.webkitOfflineAudioContext : null, P3 = (e, t, n, i, r, s) => (a, o) => {
  const l = a.createOscillator();
  return yn(l, o), Kt(l, o, "detune"), Kt(l, o, "frequency"), o.periodicWave !== void 0 ? l.setPeriodicWave(o.periodicWave) : $t(l, o, "type"), t(n, () => n(a)) || Ey(l), t(i, () => i(a)) || s(l, a), t(r, () => r(a)) || Py(l), e(a, l), l;
}, O3 = (e) => (t, n) => {
  const i = t.createPanner();
  return i.orientationX === void 0 ? e(t, n) : (yn(i, n), Kt(i, n, "orientationX"), Kt(i, n, "orientationY"), Kt(i, n, "orientationZ"), Kt(i, n, "positionX"), Kt(i, n, "positionY"), Kt(i, n, "positionZ"), $t(i, n, "coneInnerAngle"), $t(i, n, "coneOuterAngle"), $t(i, n, "coneOuterGain"), $t(i, n, "distanceModel"), $t(i, n, "maxDistance"), $t(i, n, "panningModel"), $t(i, n, "refDistance"), $t(i, n, "rolloffFactor"), i);
}, V3 = (e, t, n, i, r, s, a, o, l, u) => (c, { coneInnerAngle: d, coneOuterAngle: f, coneOuterGain: h, distanceModel: m, maxDistance: g, orientationX: p, orientationY: y, orientationZ: k, panningModel: T, positionX: _, positionY: w, positionZ: S, refDistance: C, rolloffFactor: x, ...A }) => {
  const I = c.createPanner();
  if (A.channelCount > 2 || A.channelCountMode === "max")
    throw a();
  yn(I, A);
  const E = {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete"
  }, P = n(c, {
    ...E,
    channelInterpretation: "speakers",
    numberOfInputs: 6
  }), V = i(c, { ...A, gain: 1 }), N = i(c, { ...E, gain: 1 }), F = i(c, { ...E, gain: 0 }), $ = i(c, { ...E, gain: 0 }), Z = i(c, { ...E, gain: 0 }), j = i(c, { ...E, gain: 0 }), H = i(c, { ...E, gain: 0 }), R = r(c, 256, 6, 1), L = s(c, {
    ...E,
    curve: new Float32Array([1, 1]),
    oversample: "none"
  });
  let ne = [p, y, k], oe = [_, w, S];
  const we = new Float32Array(1);
  R.onaudioprocess = ({ inputBuffer: ve }) => {
    const Fe = [
      l(ve, we, 0),
      l(ve, we, 1),
      l(ve, we, 2)
    ];
    Fe.some((Oe, le) => Oe !== ne[le]) && (I.setOrientation(...Fe), ne = Fe);
    const he = [
      l(ve, we, 3),
      l(ve, we, 4),
      l(ve, we, 5)
    ];
    he.some((Oe, le) => Oe !== oe[le]) && (I.setPosition(...he), oe = he);
  }, Object.defineProperty(F.gain, "defaultValue", { get: () => 0 }), Object.defineProperty($.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(Z.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(j.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(H.gain, "defaultValue", { get: () => 0 });
  const ee = {
    get bufferSize() {
    },
    get channelCount() {
      return I.channelCount;
    },
    set channelCount(ve) {
      if (ve > 2)
        throw a();
      V.channelCount = ve, I.channelCount = ve;
    },
    get channelCountMode() {
      return I.channelCountMode;
    },
    set channelCountMode(ve) {
      if (ve === "max")
        throw a();
      V.channelCountMode = ve, I.channelCountMode = ve;
    },
    get channelInterpretation() {
      return I.channelInterpretation;
    },
    set channelInterpretation(ve) {
      V.channelInterpretation = ve, I.channelInterpretation = ve;
    },
    get coneInnerAngle() {
      return I.coneInnerAngle;
    },
    set coneInnerAngle(ve) {
      I.coneInnerAngle = ve;
    },
    get coneOuterAngle() {
      return I.coneOuterAngle;
    },
    set coneOuterAngle(ve) {
      I.coneOuterAngle = ve;
    },
    get coneOuterGain() {
      return I.coneOuterGain;
    },
    set coneOuterGain(ve) {
      if (ve < 0 || ve > 1)
        throw t();
      I.coneOuterGain = ve;
    },
    get context() {
      return I.context;
    },
    get distanceModel() {
      return I.distanceModel;
    },
    set distanceModel(ve) {
      I.distanceModel = ve;
    },
    get inputs() {
      return [V];
    },
    get maxDistance() {
      return I.maxDistance;
    },
    set maxDistance(ve) {
      if (ve < 0)
        throw new RangeError();
      I.maxDistance = ve;
    },
    get numberOfInputs() {
      return I.numberOfInputs;
    },
    get numberOfOutputs() {
      return I.numberOfOutputs;
    },
    get orientationX() {
      return N.gain;
    },
    get orientationY() {
      return F.gain;
    },
    get orientationZ() {
      return $.gain;
    },
    get panningModel() {
      return I.panningModel;
    },
    set panningModel(ve) {
      I.panningModel = ve;
    },
    get positionX() {
      return Z.gain;
    },
    get positionY() {
      return j.gain;
    },
    get positionZ() {
      return H.gain;
    },
    get refDistance() {
      return I.refDistance;
    },
    set refDistance(ve) {
      if (ve < 0)
        throw new RangeError();
      I.refDistance = ve;
    },
    get rolloffFactor() {
      return I.rolloffFactor;
    },
    set rolloffFactor(ve) {
      if (ve < 0)
        throw new RangeError();
      I.rolloffFactor = ve;
    },
    addEventListener(...ve) {
      return V.addEventListener(ve[0], ve[1], ve[2]);
    },
    dispatchEvent(...ve) {
      return V.dispatchEvent(ve[0]);
    },
    removeEventListener(...ve) {
      return V.removeEventListener(ve[0], ve[1], ve[2]);
    }
  };
  d !== ee.coneInnerAngle && (ee.coneInnerAngle = d), f !== ee.coneOuterAngle && (ee.coneOuterAngle = f), h !== ee.coneOuterGain && (ee.coneOuterGain = h), m !== ee.distanceModel && (ee.distanceModel = m), g !== ee.maxDistance && (ee.maxDistance = g), p !== ee.orientationX.value && (ee.orientationX.value = p), y !== ee.orientationY.value && (ee.orientationY.value = y), k !== ee.orientationZ.value && (ee.orientationZ.value = k), T !== ee.panningModel && (ee.panningModel = T), _ !== ee.positionX.value && (ee.positionX.value = _), w !== ee.positionY.value && (ee.positionY.value = w), S !== ee.positionZ.value && (ee.positionZ.value = S), C !== ee.refDistance && (ee.refDistance = C), x !== ee.rolloffFactor && (ee.rolloffFactor = x), (ne[0] !== 1 || ne[1] !== 0 || ne[2] !== 0) && I.setOrientation(...ne), (oe[0] !== 0 || oe[1] !== 0 || oe[2] !== 0) && I.setPosition(...oe);
  const K = () => {
    V.connect(I), e(V, L, 0, 0), L.connect(N).connect(P, 0, 0), L.connect(F).connect(P, 0, 1), L.connect($).connect(P, 0, 2), L.connect(Z).connect(P, 0, 3), L.connect(j).connect(P, 0, 4), L.connect(H).connect(P, 0, 5), P.connect(R).connect(c.destination);
  }, ue = () => {
    V.disconnect(I), o(V, L, 0, 0), L.disconnect(N), N.disconnect(P), L.disconnect(F), F.disconnect(P), L.disconnect($), $.disconnect(P), L.disconnect(Z), Z.disconnect(P), L.disconnect(j), j.disconnect(P), L.disconnect(H), H.disconnect(P), P.disconnect(R), R.disconnect(c.destination);
  };
  return u(eu(ee, I), K, ue);
}, D3 = (e) => (t, { disableNormalization: n, imag: i, real: r }) => {
  const s = i instanceof Float32Array ? i : new Float32Array(i), a = r instanceof Float32Array ? r : new Float32Array(r), o = t.createPeriodicWave(a, s, { disableNormalization: n });
  if (Array.from(i).length < 2)
    throw e();
  return o;
}, td = (e, t, n, i) => e.createScriptProcessor(t, n, i), N3 = (e, t) => (n, i) => {
  const r = i.channelCountMode;
  if (r === "clamped-max")
    throw t();
  if (n.createStereoPanner === void 0)
    return e(n, i);
  const s = n.createStereoPanner();
  return yn(s, i), Kt(s, i, "pan"), Object.defineProperty(s, "channelCountMode", {
    get: () => r,
    set: (a) => {
      if (a !== r)
        throw t();
    }
  }), s;
}, M3 = (e, t, n, i, r, s) => {
  const o = new Float32Array([1, 1]), l = Math.PI / 2, u = { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete" }, c = { ...u, oversample: "none" }, d = (m, g, p, y) => {
    const k = new Float32Array(16385), T = new Float32Array(16385);
    for (let A = 0; A < 16385; A += 1) {
      const I = A / 16384 * l;
      k[A] = Math.cos(I), T[A] = Math.sin(I);
    }
    const _ = n(m, { ...u, gain: 0 }), w = i(m, { ...c, curve: k }), S = i(m, { ...c, curve: o }), C = n(m, { ...u, gain: 0 }), x = i(m, { ...c, curve: T });
    return {
      connectGraph() {
        g.connect(_), g.connect(S.inputs === void 0 ? S : S.inputs[0]), g.connect(C), S.connect(p), p.connect(w.inputs === void 0 ? w : w.inputs[0]), p.connect(x.inputs === void 0 ? x : x.inputs[0]), w.connect(_.gain), x.connect(C.gain), _.connect(y, 0, 0), C.connect(y, 0, 1);
      },
      disconnectGraph() {
        g.disconnect(_), g.disconnect(S.inputs === void 0 ? S : S.inputs[0]), g.disconnect(C), S.disconnect(p), p.disconnect(w.inputs === void 0 ? w : w.inputs[0]), p.disconnect(x.inputs === void 0 ? x : x.inputs[0]), w.disconnect(_.gain), x.disconnect(C.gain), _.disconnect(y, 0, 0), C.disconnect(y, 0, 1);
      }
    };
  }, f = (m, g, p, y) => {
    const k = new Float32Array(16385), T = new Float32Array(16385), _ = new Float32Array(16385), w = new Float32Array(16385), S = Math.floor(16385 / 2);
    for (let Z = 0; Z < 16385; Z += 1)
      if (Z > S) {
        const j = (Z - S) / (16384 - S) * l;
        k[Z] = Math.cos(j), T[Z] = Math.sin(j), _[Z] = 0, w[Z] = 1;
      } else {
        const j = Z / (16384 - S) * l;
        k[Z] = 1, T[Z] = 0, _[Z] = Math.cos(j), w[Z] = Math.sin(j);
      }
    const C = t(m, {
      channelCount: 2,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      numberOfOutputs: 2
    }), x = n(m, { ...u, gain: 0 }), A = i(m, {
      ...c,
      curve: k
    }), I = n(m, { ...u, gain: 0 }), E = i(m, {
      ...c,
      curve: T
    }), P = i(m, { ...c, curve: o }), V = n(m, { ...u, gain: 0 }), N = i(m, {
      ...c,
      curve: _
    }), F = n(m, { ...u, gain: 0 }), $ = i(m, {
      ...c,
      curve: w
    });
    return {
      connectGraph() {
        g.connect(C), g.connect(P.inputs === void 0 ? P : P.inputs[0]), C.connect(x, 0), C.connect(I, 0), C.connect(V, 1), C.connect(F, 1), P.connect(p), p.connect(A.inputs === void 0 ? A : A.inputs[0]), p.connect(E.inputs === void 0 ? E : E.inputs[0]), p.connect(N.inputs === void 0 ? N : N.inputs[0]), p.connect($.inputs === void 0 ? $ : $.inputs[0]), A.connect(x.gain), E.connect(I.gain), N.connect(V.gain), $.connect(F.gain), x.connect(y, 0, 0), V.connect(y, 0, 0), I.connect(y, 0, 1), F.connect(y, 0, 1);
      },
      disconnectGraph() {
        g.disconnect(C), g.disconnect(P.inputs === void 0 ? P : P.inputs[0]), C.disconnect(x, 0), C.disconnect(I, 0), C.disconnect(V, 1), C.disconnect(F, 1), P.disconnect(p), p.disconnect(A.inputs === void 0 ? A : A.inputs[0]), p.disconnect(E.inputs === void 0 ? E : E.inputs[0]), p.disconnect(N.inputs === void 0 ? N : N.inputs[0]), p.disconnect($.inputs === void 0 ? $ : $.inputs[0]), A.disconnect(x.gain), E.disconnect(I.gain), N.disconnect(V.gain), $.disconnect(F.gain), x.disconnect(y, 0, 0), V.disconnect(y, 0, 0), I.disconnect(y, 0, 1), F.disconnect(y, 0, 1);
      }
    };
  }, h = (m, g, p, y, k) => {
    if (g === 1)
      return d(m, p, y, k);
    if (g === 2)
      return f(m, p, y, k);
    throw r();
  };
  return (m, { channelCount: g, channelCountMode: p, pan: y, ...k }) => {
    if (p === "max")
      throw r();
    const T = e(m, {
      ...k,
      channelCount: 1,
      channelCountMode: p,
      numberOfInputs: 2
    }), _ = n(m, { ...k, channelCount: g, channelCountMode: p, gain: 1 }), w = n(m, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      gain: y
    });
    let { connectGraph: S, disconnectGraph: C } = h(m, g, _, w, T);
    Object.defineProperty(w.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(w.gain, "maxValue", { get: () => 1 }), Object.defineProperty(w.gain, "minValue", { get: () => -1 });
    const x = {
      get bufferSize() {
      },
      get channelCount() {
        return _.channelCount;
      },
      set channelCount(P) {
        _.channelCount !== P && (A && C(), { connectGraph: S, disconnectGraph: C } = h(m, P, _, w, T), A && S()), _.channelCount = P;
      },
      get channelCountMode() {
        return _.channelCountMode;
      },
      set channelCountMode(P) {
        if (P === "clamped-max" || P === "max")
          throw r();
        _.channelCountMode = P;
      },
      get channelInterpretation() {
        return _.channelInterpretation;
      },
      set channelInterpretation(P) {
        _.channelInterpretation = P;
      },
      get context() {
        return _.context;
      },
      get inputs() {
        return [_];
      },
      get numberOfInputs() {
        return _.numberOfInputs;
      },
      get numberOfOutputs() {
        return _.numberOfOutputs;
      },
      get pan() {
        return w.gain;
      },
      addEventListener(...P) {
        return _.addEventListener(P[0], P[1], P[2]);
      },
      dispatchEvent(...P) {
        return _.dispatchEvent(P[0]);
      },
      removeEventListener(...P) {
        return _.removeEventListener(P[0], P[1], P[2]);
      }
    };
    let A = !1;
    const I = () => {
      S(), A = !0;
    }, E = () => {
      C(), A = !1;
    };
    return s(eu(x, T), I, E);
  };
}, R3 = (e, t, n, i, r, s, a) => (o, l) => {
  const u = o.createWaveShaper();
  if (s !== null && s.name === "webkitAudioContext" && o.createGain().gain.automationRate === void 0)
    return n(o, l);
  yn(u, l);
  const c = l.curve === null || l.curve instanceof Float32Array ? l.curve : new Float32Array(l.curve);
  if (c !== null && c.length < 2)
    throw t();
  $t(u, { curve: c }, "curve"), $t(u, l, "oversample");
  let d = null, f = !1;
  return a(u, "curve", (g) => () => g.call(u), (g) => (p) => (g.call(u, p), f && (i(p) && d === null ? d = e(o, u) : !i(p) && d !== null && (d(), d = null)), p)), r(u, () => {
    f = !0, i(u.curve) && (d = e(o, u));
  }, () => {
    f = !1, d !== null && (d(), d = null);
  });
}, F3 = (e, t, n, i, r) => (s, { curve: a, oversample: o, ...l }) => {
  const u = s.createWaveShaper(), c = s.createWaveShaper();
  yn(u, l), yn(c, l);
  const d = n(s, { ...l, gain: 1 }), f = n(s, { ...l, gain: -1 }), h = n(s, { ...l, gain: 1 }), m = n(s, { ...l, gain: -1 });
  let g = null, p = !1, y = null;
  const k = {
    get bufferSize() {
    },
    get channelCount() {
      return u.channelCount;
    },
    set channelCount(w) {
      d.channelCount = w, f.channelCount = w, u.channelCount = w, h.channelCount = w, c.channelCount = w, m.channelCount = w;
    },
    get channelCountMode() {
      return u.channelCountMode;
    },
    set channelCountMode(w) {
      d.channelCountMode = w, f.channelCountMode = w, u.channelCountMode = w, h.channelCountMode = w, c.channelCountMode = w, m.channelCountMode = w;
    },
    get channelInterpretation() {
      return u.channelInterpretation;
    },
    set channelInterpretation(w) {
      d.channelInterpretation = w, f.channelInterpretation = w, u.channelInterpretation = w, h.channelInterpretation = w, c.channelInterpretation = w, m.channelInterpretation = w;
    },
    get context() {
      return u.context;
    },
    get curve() {
      return y;
    },
    set curve(w) {
      if (w !== null && w.length < 2)
        throw t();
      if (w === null)
        u.curve = w, c.curve = w;
      else {
        const S = w.length, C = new Float32Array(S + 2 - S % 2), x = new Float32Array(S + 2 - S % 2);
        C[0] = w[0], x[0] = -w[S - 1];
        const A = Math.ceil((S + 1) / 2), I = (S + 1) / 2 - 1;
        for (let E = 1; E < A; E += 1) {
          const P = E / A * I, V = Math.floor(P), N = Math.ceil(P);
          C[E] = V === N ? w[V] : (1 - (P - V)) * w[V] + (1 - (N - P)) * w[N], x[E] = V === N ? -w[S - 1 - V] : -((1 - (P - V)) * w[S - 1 - V]) - (1 - (N - P)) * w[S - 1 - N];
        }
        C[A] = S % 2 === 1 ? w[A - 1] : (w[A - 2] + w[A - 1]) / 2, u.curve = C, c.curve = x;
      }
      y = w, p && (i(y) && g === null ? g = e(s, d) : g !== null && (g(), g = null));
    },
    get inputs() {
      return [d];
    },
    get numberOfInputs() {
      return u.numberOfInputs;
    },
    get numberOfOutputs() {
      return u.numberOfOutputs;
    },
    get oversample() {
      return u.oversample;
    },
    set oversample(w) {
      u.oversample = w, c.oversample = w;
    },
    addEventListener(...w) {
      return d.addEventListener(w[0], w[1], w[2]);
    },
    dispatchEvent(...w) {
      return d.dispatchEvent(w[0]);
    },
    removeEventListener(...w) {
      return d.removeEventListener(w[0], w[1], w[2]);
    }
  };
  a !== null && (k.curve = a instanceof Float32Array ? a : new Float32Array(a)), o !== k.oversample && (k.oversample = o);
  const T = () => {
    d.connect(u).connect(h), d.connect(f).connect(c).connect(m).connect(h), p = !0, i(y) && (g = e(s, d));
  }, _ = () => {
    d.disconnect(u), u.disconnect(h), d.disconnect(f), f.disconnect(c), c.disconnect(m), m.disconnect(h), p = !1, g !== null && (g(), g = null);
  };
  return r(eu(k, h), T, _);
}, oi = () => new DOMException("", "NotSupportedError"), B3 = {
  numberOfChannels: 1
}, L3 = (e, t, n, i, r) => class extends e {
  constructor(a, o, l) {
    let u;
    if (typeof a == "number" && o !== void 0 && l !== void 0)
      u = { length: o, numberOfChannels: a, sampleRate: l };
    else if (typeof a == "object")
      u = a;
    else
      throw new Error("The given parameters are not valid.");
    const { length: c, numberOfChannels: d, sampleRate: f } = { ...B3, ...u }, h = i(d, c, f);
    t(uc, () => uc(h)) || h.addEventListener("statechange", (() => {
      let m = 0;
      const g = (p) => {
        this._state === "running" && (m > 0 ? (h.removeEventListener("statechange", g), p.stopImmediatePropagation(), this._waitForThePromiseToSettle(p)) : m += 1);
      };
      return g;
    })()), super(h, d), this._length = c, this._nativeOfflineAudioContext = h, this._state = null;
  }
  get length() {
    return this._nativeOfflineAudioContext.length === void 0 ? this._length : this._nativeOfflineAudioContext.length;
  }
  get state() {
    return this._state === null ? this._nativeOfflineAudioContext.state : this._state;
  }
  startRendering() {
    return this._state === "running" ? Promise.reject(n()) : (this._state = "running", r(this.destination, this._nativeOfflineAudioContext).finally(() => {
      this._state = null, R1(this);
    }));
  }
  _waitForThePromiseToSettle(a) {
    this._state === null ? this._nativeOfflineAudioContext.dispatchEvent(a) : setTimeout(() => this._waitForThePromiseToSettle(a));
  }
}, $3 = {
  channelCount: 2,
  channelCountMode: "max",
  // This attribute has no effect for nodes with no inputs.
  channelInterpretation: "speakers",
  // This attribute has no effect for nodes with no inputs.
  detune: 0,
  frequency: 440,
  periodicWave: void 0,
  type: "sine"
}, W3 = (e, t, n, i, r, s, a) => class extends e {
  constructor(l, u) {
    const c = r(l), d = { ...$3, ...u }, f = n(c, d), h = s(c), m = h ? i() : null, g = l.sampleRate / 2;
    super(l, !1, f, m), this._detune = t(this, h, f.detune, 153600, -153600), this._frequency = t(this, h, f.frequency, g, -g), this._nativeOscillatorNode = f, this._onended = null, this._oscillatorNodeRenderer = m, this._oscillatorNodeRenderer !== null && d.periodicWave !== void 0 && (this._oscillatorNodeRenderer.periodicWave = d.periodicWave);
  }
  get detune() {
    return this._detune;
  }
  get frequency() {
    return this._frequency;
  }
  get onended() {
    return this._onended;
  }
  set onended(l) {
    const u = typeof l == "function" ? a(this, l) : null;
    this._nativeOscillatorNode.onended = u;
    const c = this._nativeOscillatorNode.onended;
    this._onended = c !== null && c === u ? l : c;
  }
  get type() {
    return this._nativeOscillatorNode.type;
  }
  set type(l) {
    this._nativeOscillatorNode.type = l, this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = null);
  }
  setPeriodicWave(l) {
    this._nativeOscillatorNode.setPeriodicWave(l), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = l);
  }
  start(l = 0) {
    if (this._nativeOscillatorNode.start(l), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.start = l), this.context.state !== "closed") {
      xl(this);
      const u = () => {
        this._nativeOscillatorNode.removeEventListener("ended", u), ys(this) && Xc(this);
      };
      this._nativeOscillatorNode.addEventListener("ended", u);
    }
  }
  stop(l = 0) {
    this._nativeOscillatorNode.stop(l), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.stop = l);
  }
}, j3 = (e, t, n, i, r) => () => {
  const s = /* @__PURE__ */ new WeakMap();
  let a = null, o = null, l = null;
  const u = async (c, d) => {
    let f = n(c);
    const h = Xn(f, d);
    if (!h) {
      const m = {
        channelCount: f.channelCount,
        channelCountMode: f.channelCountMode,
        channelInterpretation: f.channelInterpretation,
        detune: f.detune.value,
        frequency: f.frequency.value,
        periodicWave: a === null ? void 0 : a,
        type: f.type
      };
      f = t(d, m), o !== null && f.start(o), l !== null && f.stop(l);
    }
    return s.set(d, f), h ? (await e(d, c.detune, f.detune), await e(d, c.frequency, f.frequency)) : (await i(d, c.detune, f.detune), await i(d, c.frequency, f.frequency)), await r(c, d, f), f;
  };
  return {
    set periodicWave(c) {
      a = c;
    },
    set start(c) {
      o = c;
    },
    set stop(c) {
      l = c;
    },
    render(c, d) {
      const f = s.get(d);
      return f !== void 0 ? Promise.resolve(f) : u(c, d);
    }
  };
}, H3 = {
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  coneInnerAngle: 360,
  coneOuterAngle: 360,
  coneOuterGain: 0,
  distanceModel: "inverse",
  maxDistance: 1e4,
  orientationX: 1,
  orientationY: 0,
  orientationZ: 0,
  panningModel: "equalpower",
  positionX: 0,
  positionY: 0,
  positionZ: 0,
  refDistance: 1,
  rolloffFactor: 1
}, z3 = (e, t, n, i, r, s, a) => class extends e {
  constructor(l, u) {
    const c = r(l), d = { ...H3, ...u }, f = n(c, d), h = s(c), m = h ? i() : null;
    super(l, !1, f, m), this._nativePannerNode = f, this._orientationX = t(this, h, f.orientationX, ei, mi), this._orientationY = t(this, h, f.orientationY, ei, mi), this._orientationZ = t(this, h, f.orientationZ, ei, mi), this._positionX = t(this, h, f.positionX, ei, mi), this._positionY = t(this, h, f.positionY, ei, mi), this._positionZ = t(this, h, f.positionZ, ei, mi), a(this, 1);
  }
  get coneInnerAngle() {
    return this._nativePannerNode.coneInnerAngle;
  }
  set coneInnerAngle(l) {
    this._nativePannerNode.coneInnerAngle = l;
  }
  get coneOuterAngle() {
    return this._nativePannerNode.coneOuterAngle;
  }
  set coneOuterAngle(l) {
    this._nativePannerNode.coneOuterAngle = l;
  }
  get coneOuterGain() {
    return this._nativePannerNode.coneOuterGain;
  }
  set coneOuterGain(l) {
    this._nativePannerNode.coneOuterGain = l;
  }
  get distanceModel() {
    return this._nativePannerNode.distanceModel;
  }
  set distanceModel(l) {
    this._nativePannerNode.distanceModel = l;
  }
  get maxDistance() {
    return this._nativePannerNode.maxDistance;
  }
  set maxDistance(l) {
    this._nativePannerNode.maxDistance = l;
  }
  get orientationX() {
    return this._orientationX;
  }
  get orientationY() {
    return this._orientationY;
  }
  get orientationZ() {
    return this._orientationZ;
  }
  get panningModel() {
    return this._nativePannerNode.panningModel;
  }
  set panningModel(l) {
    this._nativePannerNode.panningModel = l;
  }
  get positionX() {
    return this._positionX;
  }
  get positionY() {
    return this._positionY;
  }
  get positionZ() {
    return this._positionZ;
  }
  get refDistance() {
    return this._nativePannerNode.refDistance;
  }
  set refDistance(l) {
    this._nativePannerNode.refDistance = l;
  }
  get rolloffFactor() {
    return this._nativePannerNode.rolloffFactor;
  }
  set rolloffFactor(l) {
    this._nativePannerNode.rolloffFactor = l;
  }
}, U3 = (e, t, n, i, r, s, a, o, l, u) => () => {
  const c = /* @__PURE__ */ new WeakMap();
  let d = null;
  const f = async (h, m) => {
    let g = null, p = s(h);
    const y = {
      channelCount: p.channelCount,
      channelCountMode: p.channelCountMode,
      channelInterpretation: p.channelInterpretation
    }, k = {
      ...y,
      coneInnerAngle: p.coneInnerAngle,
      coneOuterAngle: p.coneOuterAngle,
      coneOuterGain: p.coneOuterGain,
      distanceModel: p.distanceModel,
      maxDistance: p.maxDistance,
      panningModel: p.panningModel,
      refDistance: p.refDistance,
      rolloffFactor: p.rolloffFactor
    }, T = Xn(p, m);
    if ("bufferSize" in p)
      g = i(m, { ...y, gain: 1 });
    else if (!T) {
      const _ = {
        ...k,
        orientationX: p.orientationX.value,
        orientationY: p.orientationY.value,
        orientationZ: p.orientationZ.value,
        positionX: p.positionX.value,
        positionY: p.positionY.value,
        positionZ: p.positionZ.value
      };
      p = r(m, _);
    }
    if (c.set(m, g === null ? p : g), g !== null) {
      if (d === null) {
        if (a === null)
          throw new Error("Missing the native OfflineAudioContext constructor.");
        const E = new a(
          6,
          // Bug #17: Safari does not yet expose the length.
          h.context.length,
          m.sampleRate
        ), P = t(E, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "speakers",
          numberOfInputs: 6
        });
        P.connect(E.destination), d = (async () => {
          const V = await Promise.all([
            h.orientationX,
            h.orientationY,
            h.orientationZ,
            h.positionX,
            h.positionY,
            h.positionZ
          ].map(async (N, F) => {
            const $ = n(E, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              offset: F === 0 ? 1 : 0
            });
            return await o(E, N, $.offset), $;
          }));
          for (let N = 0; N < 6; N += 1)
            V[N].connect(P, 0, N), V[N].start(0);
          return u(E);
        })();
      }
      const _ = await d, w = i(m, { ...y, gain: 1 });
      await l(h, m, w);
      const S = [];
      for (let E = 0; E < _.numberOfChannels; E += 1)
        S.push(_.getChannelData(E));
      let C = [S[0][0], S[1][0], S[2][0]], x = [S[3][0], S[4][0], S[5][0]], A = i(m, { ...y, gain: 1 }), I = r(m, {
        ...k,
        orientationX: C[0],
        orientationY: C[1],
        orientationZ: C[2],
        positionX: x[0],
        positionY: x[1],
        positionZ: x[2]
      });
      w.connect(A).connect(I.inputs[0]), I.connect(g);
      for (let E = 128; E < _.length; E += 128) {
        const P = [S[0][E], S[1][E], S[2][E]], V = [S[3][E], S[4][E], S[5][E]];
        if (P.some((N, F) => N !== C[F]) || V.some((N, F) => N !== x[F])) {
          C = P, x = V;
          const N = E / m.sampleRate;
          A.gain.setValueAtTime(0, N), A = i(m, { ...y, gain: 0 }), I = r(m, {
            ...k,
            orientationX: C[0],
            orientationY: C[1],
            orientationZ: C[2],
            positionX: x[0],
            positionY: x[1],
            positionZ: x[2]
          }), A.gain.setValueAtTime(1, N), w.connect(A).connect(I.inputs[0]), I.connect(g);
        }
      }
      return g;
    }
    return T ? (await e(m, h.orientationX, p.orientationX), await e(m, h.orientationY, p.orientationY), await e(m, h.orientationZ, p.orientationZ), await e(m, h.positionX, p.positionX), await e(m, h.positionY, p.positionY), await e(m, h.positionZ, p.positionZ)) : (await o(m, h.orientationX, p.orientationX), await o(m, h.orientationY, p.orientationY), await o(m, h.orientationZ, p.orientationZ), await o(m, h.positionX, p.positionX), await o(m, h.positionY, p.positionY), await o(m, h.positionZ, p.positionZ)), Ql(p) ? await l(h, m, p.inputs[0]) : await l(h, m, p), p;
  };
  return {
    render(h, m) {
      const g = c.get(m);
      return g !== void 0 ? Promise.resolve(g) : f(h, m);
    }
  };
}, q3 = {
  disableNormalization: !1
}, G3 = (e, t, n, i) => class q1 {
  constructor(s, a) {
    const o = t(s), l = i({ ...q3, ...a }), u = e(o, l);
    return n.add(u), u;
  }
  static [Symbol.hasInstance](s) {
    return s !== null && typeof s == "object" && Object.getPrototypeOf(s) === q1.prototype || n.has(s);
  }
}, Y3 = (e, t) => (n, i, r) => (e(i).replay(r), t(i, n, r)), Z3 = (e, t, n) => async (i, r, s) => {
  const a = e(i);
  await Promise.all(a.activeInputs.map((o, l) => Array.from(o).map(async ([u, c]) => {
    const f = await t(u).render(u, r), h = i.context.destination;
    !n(u) && (i !== h || !n(i)) && f.connect(s, c, l);
  })).reduce((o, l) => [...o, ...l], []));
}, K3 = (e, t, n) => async (i, r, s) => {
  const a = t(i);
  await Promise.all(Array.from(a.activeInputs).map(async ([o, l]) => {
    const c = await e(o).render(o, r);
    n(o) || c.connect(s, l);
  }));
}, X3 = (e, t, n, i) => (r) => e(uc, () => uc(r)) ? Promise.resolve(e(i, i)).then((s) => {
  if (!s) {
    const a = n(r, 512, 0, 1);
    r.oncomplete = () => {
      a.onaudioprocess = null, a.disconnect();
    }, a.onaudioprocess = () => r.currentTime, a.connect(r.destination);
  }
  return r.startRendering();
}) : new Promise((s) => {
  const a = t(r, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  });
  r.oncomplete = (o) => {
    a.disconnect(), s(o.renderedBuffer);
  }, a.connect(r.destination), r.startRendering();
}), J3 = (e) => (t, n) => {
  e.set(t, n);
}, Q3 = (e) => (t, n) => e.set(t, n), ez = (e, t, n, i, r, s, a, o) => (l, u) => n(l).render(l, u).then(() => Promise.all(Array.from(i(u)).map((c) => n(c).render(c, u)))).then(() => r(u)).then((c) => (typeof c.copyFromChannel != "function" ? (a(c), xy(c)) : t(s, () => s(c)) || o(c), e.add(c), c)), tz = {
  channelCount: 2,
  /*
   * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent
   * behavior.
   */
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  pan: 0
}, nz = (e, t, n, i, r, s) => class extends e {
  constructor(o, l) {
    const u = r(o), c = { ...tz, ...l }, d = n(u, c), f = s(u), h = f ? i() : null;
    super(o, !1, d, h), this._pan = t(this, f, d.pan);
  }
  get pan() {
    return this._pan;
  }
}, iz = (e, t, n, i, r) => () => {
  const s = /* @__PURE__ */ new WeakMap(), a = async (o, l) => {
    let u = n(o);
    const c = Xn(u, l);
    if (!c) {
      const d = {
        channelCount: u.channelCount,
        channelCountMode: u.channelCountMode,
        channelInterpretation: u.channelInterpretation,
        pan: u.pan.value
      };
      u = t(l, d);
    }
    return s.set(l, u), c ? await e(l, o.pan, u.pan) : await i(l, o.pan, u.pan), Ql(u) ? await r(o, l, u.inputs[0]) : await r(o, l, u), u;
  };
  return {
    render(o, l) {
      const u = s.get(l);
      return u !== void 0 ? Promise.resolve(u) : a(o, l);
    }
  };
}, rz = (e) => () => {
  if (e === null)
    return !1;
  try {
    new e({ length: 1, sampleRate: 44100 });
  } catch {
    return !1;
  }
  return !0;
}, sz = (e, t) => async () => {
  if (e === null)
    return !0;
  if (t === null)
    return !1;
  const n = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'], {
    type: "application/javascript; charset=utf-8"
  }), i = new t(1, 128, 44100), r = URL.createObjectURL(n);
  let s = !1, a = !1;
  try {
    await i.audioWorklet.addModule(r);
    const o = new e(i, "a", { numberOfOutputs: 0 }), l = i.createOscillator();
    o.port.onmessage = () => s = !0, o.onprocessorerror = () => a = !0, l.connect(o), l.start(0), await i.startRendering(), await new Promise((u) => setTimeout(u));
  } catch {
  } finally {
    URL.revokeObjectURL(r);
  }
  return s && !a;
}, az = (e, t) => () => {
  if (t === null)
    return Promise.resolve(!1);
  const n = new t(1, 1, 44100), i = e(n, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  });
  return new Promise((r) => {
    n.oncomplete = () => {
      i.disconnect(), r(n.currentTime !== 0);
    }, n.startRendering();
  });
}, oz = () => new DOMException("", "UnknownError"), lz = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  curve: null,
  oversample: "none"
}, uz = (e, t, n, i, r, s, a) => class extends e {
  constructor(l, u) {
    const c = r(l), d = { ...lz, ...u }, f = n(c, d), m = s(c) ? i() : null;
    super(l, !0, f, m), this._isCurveNullified = !1, this._nativeWaveShaperNode = f, a(this, 1);
  }
  get curve() {
    return this._isCurveNullified ? null : this._nativeWaveShaperNode.curve;
  }
  set curve(l) {
    if (l === null)
      this._isCurveNullified = !0, this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
    else {
      if (l.length < 2)
        throw t();
      this._isCurveNullified = !1, this._nativeWaveShaperNode.curve = l;
    }
  }
  get oversample() {
    return this._nativeWaveShaperNode.oversample;
  }
  set oversample(l) {
    this._nativeWaveShaperNode.oversample = l;
  }
}, cz = (e, t, n) => () => {
  const i = /* @__PURE__ */ new WeakMap(), r = async (s, a) => {
    let o = t(s);
    if (!Xn(o, a)) {
      const u = {
        channelCount: o.channelCount,
        channelCountMode: o.channelCountMode,
        channelInterpretation: o.channelInterpretation,
        curve: o.curve,
        oversample: o.oversample
      };
      o = e(a, u);
    }
    return i.set(a, o), Ql(o) ? await n(s, a, o.inputs[0]) : await n(s, a, o), o;
  };
  return {
    render(s, a) {
      const o = i.get(a);
      return o !== void 0 ? Promise.resolve(o) : r(s, a);
    }
  };
}, dz = () => typeof window > "u" ? null : window, fz = (e, t) => (n) => {
  n.copyFromChannel = (i, r, s = 0) => {
    const a = e(s), o = e(r);
    if (o >= n.numberOfChannels)
      throw t();
    const l = n.length, u = n.getChannelData(o), c = i.length;
    for (let d = a < 0 ? -a : 0; d + a < l && d < c; d += 1)
      i[d] = u[d + a];
  }, n.copyToChannel = (i, r, s = 0) => {
    const a = e(s), o = e(r);
    if (o >= n.numberOfChannels)
      throw t();
    const l = n.length, u = n.getChannelData(o), c = i.length;
    for (let d = a < 0 ? -a : 0; d + a < l && d < c; d += 1)
      u[d + a] = i[d];
  };
}, hz = (e) => (t) => {
  t.copyFromChannel = ((n) => (i, r, s = 0) => {
    const a = e(s), o = e(r);
    if (a < t.length)
      return n.call(t, i, o, a);
  })(t.copyFromChannel), t.copyToChannel = ((n) => (i, r, s = 0) => {
    const a = e(s), o = e(r);
    if (a < t.length)
      return n.call(t, i, o, a);
  })(t.copyToChannel);
}, mz = (e) => (t, n) => {
  const i = n.createBuffer(1, 1, 44100);
  t.buffer === null && (t.buffer = i), e(t, "buffer", (r) => () => {
    const s = r.call(t);
    return s === i ? null : s;
  }, (r) => (s) => r.call(t, s === null ? i : s));
}, vz = (e, t) => (n, i) => {
  i.channelCount = 1, i.channelCountMode = "explicit", Object.defineProperty(i, "channelCount", {
    get: () => 1,
    set: () => {
      throw e();
    }
  }), Object.defineProperty(i, "channelCountMode", {
    get: () => "explicit",
    set: () => {
      throw e();
    }
  });
  const r = n.createBufferSource();
  t(i, () => {
    const o = i.numberOfInputs;
    for (let l = 0; l < o; l += 1)
      r.connect(i, 0, l);
  }, () => r.disconnect(i));
}, G1 = (e, t, n) => e.copyFromChannel === void 0 ? e.getChannelData(n)[0] : (e.copyFromChannel(t, n), t[0]), Y1 = (e) => {
  if (e === null)
    return !1;
  const t = e.length;
  return t % 2 !== 0 ? e[Math.floor(t / 2)] !== 0 : e[t / 2 - 1] + e[t / 2] !== 0;
}, nd = (e, t, n, i) => {
  let r = e;
  for (; !r.hasOwnProperty(t); )
    r = Object.getPrototypeOf(r);
  const { get: s, set: a } = Object.getOwnPropertyDescriptor(r, t);
  Object.defineProperty(e, t, { get: n(s), set: i(a) });
}, gz = (e) => ({
  ...e,
  outputChannelCount: e.outputChannelCount !== void 0 ? e.outputChannelCount : e.numberOfInputs === 1 && e.numberOfOutputs === 1 ? (
    /*
     * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why
     * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That
     * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.
     */
    [e.channelCount]
  ) : Array.from({ length: e.numberOfOutputs }, () => 1)
}), pz = (e) => ({ ...e, channelCount: e.numberOfOutputs }), yz = (e) => {
  const { imag: t, real: n } = e;
  return t === void 0 ? n === void 0 ? { ...e, imag: [0, 0], real: [0, 0] } : { ...e, imag: Array.from(n, () => 0), real: n } : n === void 0 ? { ...e, imag: t, real: Array.from(t, () => 0) } : { ...e, imag: t, real: n };
}, Z1 = (e, t, n) => {
  try {
    e.setValueAtTime(t, n);
  } catch (i) {
    if (i.code !== 9)
      throw i;
    Z1(e, t, n + 1e-7);
  }
}, bz = (e) => {
  const t = e.createBufferSource();
  t.start();
  try {
    t.start();
  } catch {
    return !0;
  }
  return !1;
}, wz = (e) => {
  const t = e.createBufferSource(), n = e.createBuffer(1, 1, 44100);
  t.buffer = n;
  try {
    t.start(0, 1);
  } catch {
    return !1;
  }
  return !0;
}, _z = (e) => {
  const t = e.createBufferSource();
  t.start();
  try {
    t.stop();
  } catch {
    return !1;
  }
  return !0;
}, Oy = (e) => {
  const t = e.createOscillator();
  try {
    t.start(-1);
  } catch (n) {
    return n instanceof RangeError;
  }
  return !1;
}, K1 = (e) => {
  const t = e.createBuffer(1, 1, 44100), n = e.createBufferSource();
  n.buffer = t, n.start(), n.stop();
  try {
    return n.stop(), !0;
  } catch {
    return !1;
  }
}, Vy = (e) => {
  const t = e.createOscillator();
  try {
    t.stop(-1);
  } catch (n) {
    return n instanceof RangeError;
  }
  return !1;
}, Sz = (e) => {
  const { port1: t, port2: n } = new MessageChannel();
  try {
    t.postMessage(e);
  } finally {
    t.close(), n.close();
  }
}, kz = (e) => {
  e.start = ((t) => (n = 0, i = 0, r) => {
    const s = e.buffer, a = s === null ? i : Math.min(s.duration, i);
    s !== null && a > s.duration - 0.5 / e.context.sampleRate ? t.call(e, n, 0, 0) : t.call(e, n, a, r);
  })(e.start);
}, X1 = (e, t) => {
  const n = t.createGain();
  e.connect(n);
  const i = ((r) => () => {
    r.call(e, n), e.removeEventListener("ended", i);
  })(e.disconnect);
  e.addEventListener("ended", i), eu(e, n), e.stop = ((r) => {
    let s = !1;
    return (a = 0) => {
      if (s)
        try {
          r.call(e, a);
        } catch {
          n.gain.setValueAtTime(0, a);
        }
      else
        r.call(e, a), s = !0;
    };
  })(e.stop);
}, tu = (e, t) => (n) => {
  const i = { value: e };
  return Object.defineProperties(n, {
    currentTarget: i,
    target: i
  }), typeof t == "function" ? t.call(e, n) : t.handleEvent.call(e, n);
}, Cz = zj(To), Tz = Kj(To), xz = lH(em), J1 = /* @__PURE__ */ new WeakMap(), Az = xH(J1), Pr = B4(/* @__PURE__ */ new Map(), /* @__PURE__ */ new WeakMap()), qr = dz(), Q1 = n3(Pr, Jr), Dy = TH(ii), Hn = Z3(ii, Dy, io), Iz = t4(Q1, Mt, Hn), At = EH(Qh), Es = E3(qr), St = qH(Es), ex = /* @__PURE__ */ new WeakMap(), tx = yH(tu), id = a3(qr), Ny = jH(id), My = HH(qr), nx = zH(qr), cc = l3(qr), ln = x4(Uj(E1), Zj(Cz, Tz, zf, xz, Uf, ii, Az, Kc, Mt, To, ys, io, of), Pr, FH(_g, Uf, ii, Mt, lc, ys), Jr, tm, oi, rH(zf, _g, ii, Mt, lc, At, ys, St), dH(ex, ii, Cr), tx, At, Ny, My, nx, St, cc), Ez = e4(ln, Iz, Jr, Q1, At, St), Ry = /* @__PURE__ */ new WeakSet(), __ = i3(qr), ix = X4(new Uint32Array(1)), Fy = fz(ix, Jr), By = hz(ix), rx = i4(Ry, Pr, oi, __, Es, rz(__), Fy, By), nm = Xj(yi), sx = K3(Dy, Jc, io), Qr = U4(sx), nu = s3(nm, Pr, bz, wz, _z, Oy, K1, Vy, kz, mz(nd), X1), es = Y3(AH(Jc), sx), Pz = a4(Qr, nu, Mt, es, Hn), Or = A4(qj(P1), ex, Ty, I4, Bj, Lj, $j, Wj, jj, yg, A1, id, Z1), Oz = s4(ln, Pz, Or, An, nu, At, St, tu), Vz = v4(ln, g4, Jr, An, o3(yi, nd), At, St, Hn), Dz = F4(Qr, z1, Mt, es, Hn), xo = Q3(J1), Nz = R4(ln, Or, Dz, tm, z1, At, St, xo), ca = e3(To, My), Mz = vz(An, ca), da = v3(id, Mz), Rz = W4(da, Mt, Hn), Fz = $4(ln, Rz, da, At, St), Bz = z4(ed, Mt, Hn), Lz = H4(ln, Bz, ed, At, St, pz), $z = y3(nm, nu, yi, ca), iu = p3(nm, Pr, $z, Oy, Vy), Wz = K4(Qr, iu, Mt, es, Hn), jz = Z4(ln, Or, Wz, iu, At, St, tu), ax = b3(oi, nd), Hz = eH(ax, Mt, Hn), zz = Q4(ln, Hz, ax, At, St, xo), Uz = oH(Qr, U1, Mt, es, Hn), qz = aH(ln, Or, Uz, U1, At, St, xo), ox = w3(oi), Gz = vH(Qr, ox, Mt, es, Hn), Yz = mH(ln, Or, Gz, ox, oi, At, St, xo), Zz = kH(Qr, yi, Mt, es, Hn), Kz = SH(ln, Or, Zz, yi, At, St), Xz = C3(tm, An, td, oi), im = X3(Pr, yi, td, az(yi, Es)), Jz = RH(nu, Mt, Es, Hn, im), Qz = _3(Xz), eU = NH(ln, Qz, Jz, At, St, xo), tU = p4(Or, da, iu, td, oi, G1, St, nd), lx = /* @__PURE__ */ new WeakMap(), nU = QH(Vz, tU, tx, St, lx, tu), ux = P3(nm, Pr, Oy, K1, Vy, X1), iU = j3(Qr, ux, Mt, es, Hn), rU = W3(ln, Or, ux, iU, At, St, tu), cx = G4(nu), sU = F3(cx, An, yi, Y1, ca), rm = R3(cx, An, sU, Y1, ca, id, nd), aU = V3(zf, An, da, yi, td, rm, oi, Uf, G1, ca), dx = O3(aU), oU = U3(Qr, da, iu, yi, dx, Mt, Es, es, Hn, im), lU = z3(ln, Or, dx, oU, At, St, xo), uU = D3(Jr), cU = G3(uU, At, /* @__PURE__ */ new WeakSet(), yz), dU = M3(da, ed, yi, rm, oi, ca), fx = N3(dU, oi), fU = iz(Qr, fx, Mt, es, Hn), hU = nz(ln, Or, fx, fU, At, St), mU = cz(rm, Mt, Hn), vU = uz(ln, An, rm, mU, At, St, xo), hx = GH(qr), Ly = bH(qr), mx = /* @__PURE__ */ new WeakMap(), gU = PH(mx, Es), pU = hx ? Yj(
  Pr,
  oi,
  pH(qr),
  Ly,
  wH(Hj),
  At,
  gU,
  St,
  cc,
  /* @__PURE__ */ new WeakMap(),
  /* @__PURE__ */ new WeakMap(),
  sz(cc, Es),
  // @todo window is guaranteed to be defined because isSecureContext checks that as well.
  qr
) : void 0, yU = UH(Ny, St), bU = iH(Ry, Pr, nH, gH, /* @__PURE__ */ new WeakSet(), At, yU, jf, uc, Fy, By), vx = N4(pU, Ez, rx, Oz, Nz, Fz, Lz, jz, zz, bU, qz, Yz, Kz, eU, nU, rU, lU, cU, hU, vU), wU = YH(ln, T3, At, St), _U = KH(ln, x3, At, St), SU = XH(ln, A3, At, St), kU = I3(An, St), CU = JH(ln, kU, At), TU = m4(vx, An, oi, oz, wU, _U, SU, CU, id), $y = OH(lx), xU = Jj($y), gx = q4(Jr), AU = uH($y), px = fH(Jr), yx = /* @__PURE__ */ new WeakMap(), IU = CH(yx, Cr), EU = m3(gx, Jr, An, da, ed, iu, yi, td, oi, px, Ly, IU, ca), PU = c3(An, EU, yi, oi, ca), OU = D4(Qr, gx, nu, da, ed, iu, yi, AU, px, Ly, Mt, cc, Es, es, Hn, im), VU = IH(mx), DU = J3(yx), S_ = hx ? P4(xU, ln, Or, OU, PU, ii, VU, At, St, cc, gz, DU, Sz, tu) : void 0, NU = tH(oi, Es), MU = ez(Ry, Pr, Dy, $y, im, jf, Fy, By), RU = L3(vx, Pr, An, NU, MU), FU = BH(Qh, Ny), BU = LH(Cy, My), LU = $H(Ty, nx), $U = WH(Qh, St);
function Zi(e) {
  return e === void 0;
}
function nt(e) {
  return e !== void 0;
}
function WU(e) {
  return typeof e == "function";
}
function ro(e) {
  return typeof e == "number";
}
function Ua(e) {
  return Object.prototype.toString.call(e) === "[object Object]" && e.constructor === Object;
}
function jU(e) {
  return typeof e == "boolean";
}
function wr(e) {
  return Array.isArray(e);
}
function _s(e) {
  return typeof e == "string";
}
function Dd(e) {
  return _s(e) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(e);
}
function Xe(e, t) {
  if (!e)
    throw new Error(t);
}
function sa(e, t, n = 1 / 0) {
  if (!(t <= e && e <= n))
    throw new RangeError(`Value must be within [${t}, ${n}], got: ${e}`);
}
function bx(e) {
  !e.isOffline && e.state !== "running" && Wy('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.');
}
let wx = !1, k_ = !1;
function C_(e) {
  wx = e;
}
function HU(e) {
  Zi(e) && wx && !k_ && (k_ = !0, Wy("Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing"));
}
let _x = console;
function zU(...e) {
  _x.log(...e);
}
function Wy(...e) {
  _x.warn(...e);
}
function UU(e) {
  return new TU(e);
}
function qU(e, t, n) {
  return new RU(e, t, n);
}
const qa = typeof self == "object" ? self : null, GU = qa && (qa.hasOwnProperty("AudioContext") || qa.hasOwnProperty("webkitAudioContext"));
function YU(e, t, n) {
  return Xe(nt(S_), "This node only works in a secure context (https or localhost)"), new S_(e, t, n);
}
function Vr(e, t, n, i) {
  var r = arguments.length, s = r < 3 ? t : i === null ? i = Object.getOwnPropertyDescriptor(t, n) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(e, t, n, i);
  else
    for (var o = e.length - 1; o >= 0; o--)
      (a = e[o]) && (s = (r < 3 ? a(s) : r > 3 ? a(t, n, s) : a(t, n)) || s);
  return r > 3 && s && Object.defineProperty(t, n, s), s;
}
function mn(e, t, n, i) {
  function r(s) {
    return s instanceof n ? s : new n(function(a) {
      a(s);
    });
  }
  return new (n || (n = Promise))(function(s, a) {
    function o(c) {
      try {
        u(i.next(c));
      } catch (d) {
        a(d);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (d) {
        a(d);
      }
    }
    function u(c) {
      c.done ? s(c.value) : r(c.value).then(o, l);
    }
    u((i = i.apply(e, t || [])).next());
  });
}
class ZU {
  constructor(t, n, i, r) {
    this._callback = t, this._type = n, this._minimumUpdateInterval = Math.max(128 / (r || 44100), 1e-3), this.updateInterval = i, this._createClock();
  }
  /**
   * Generate a web worker
   */
  _createWorker() {
    const t = new Blob([
      /* javascript */
      `
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval * 1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`
    ], { type: "text/javascript" }), n = URL.createObjectURL(t), i = new Worker(n);
    i.onmessage = this._callback.bind(this), this._worker = i;
  }
  /**
   * Create a timeout loop
   */
  _createTimeout() {
    this._timeout = setTimeout(() => {
      this._createTimeout(), this._callback();
    }, this._updateInterval * 1e3);
  }
  /**
   * Create the clock source.
   */
  _createClock() {
    if (this._type === "worker")
      try {
        this._createWorker();
      } catch {
        this._type = "timeout", this._createClock();
      }
    else
      this._type === "timeout" && this._createTimeout();
  }
  /**
   * Clean up the current clock source
   */
  _disposeClock() {
    this._timeout && clearTimeout(this._timeout), this._worker && (this._worker.terminate(), this._worker.onmessage = null);
  }
  /**
   * The rate in seconds the ticker will update
   */
  get updateInterval() {
    return this._updateInterval;
  }
  set updateInterval(t) {
    var n;
    this._updateInterval = Math.max(t, this._minimumUpdateInterval), this._type === "worker" && ((n = this._worker) === null || n === void 0 || n.postMessage(this._updateInterval * 1e3));
  }
  /**
   * The type of the ticker, either a worker or a timeout
   */
  get type() {
    return this._type;
  }
  set type(t) {
    this._disposeClock(), this._type = t, this._createClock();
  }
  /**
   * Clean up
   */
  dispose() {
    this._disposeClock();
  }
}
function so(e) {
  return LU(e);
}
function ta(e) {
  return BU(e);
}
function lf(e) {
  return $U(e);
}
function Zo(e) {
  return FU(e);
}
function KU(e) {
  return e instanceof rx;
}
function XU(e, t) {
  return e === "value" || so(t) || ta(t) || KU(t);
}
function fl(e, ...t) {
  if (!t.length)
    return e;
  const n = t.shift();
  if (Ua(e) && Ua(n))
    for (const i in n)
      XU(i, n[i]) ? e[i] = n[i] : Ua(n[i]) ? (e[i] || Object.assign(e, { [i]: {} }), fl(e[i], n[i])) : Object.assign(e, { [i]: n[i] });
  return fl(e, ...t);
}
function JU(e, t) {
  return e.length === t.length && e.every((n, i) => t[i] === n);
}
function Te(e, t, n = [], i) {
  const r = {}, s = Array.from(t);
  if (Ua(s[0]) && i && !Reflect.has(s[0], i) && (Object.keys(s[0]).some((o) => Reflect.has(e, o)) || (fl(r, { [i]: s[0] }), n.splice(n.indexOf(i), 1), s.shift())), s.length === 1 && Ua(s[0]))
    fl(r, s[0]);
  else
    for (let a = 0; a < n.length; a++)
      nt(s[a]) && (r[n[a]] = s[a]);
  return fl(e, r);
}
function QU(e) {
  return e.constructor.getDefaults();
}
function hl(e, t) {
  return Zi(e) ? t : e;
}
function T_(e, t) {
  return t.forEach((n) => {
    Reflect.has(e, n) && delete e[n];
  }), e;
}
/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2019 Yotam Mann
 */
class Ps {
  constructor() {
    this.debug = !1, this._wasDisposed = !1;
  }
  /**
   * Returns all of the default options belonging to the class.
   */
  static getDefaults() {
    return {};
  }
  /**
   * Prints the outputs to the console log for debugging purposes.
   * Prints the contents only if either the object has a property
   * called `debug` set to true, or a variable called TONE_DEBUG_CLASS
   * is set to the name of the class.
   * @example
   * const osc = new Tone.Oscillator();
   * // prints all logs originating from this oscillator
   * osc.debug = true;
   * // calls to start/stop will print in the console
   * osc.start();
   */
  log(...t) {
    (this.debug || qa && this.toString() === qa.TONE_DEBUG_CLASS) && zU(this, ...t);
  }
  /**
   * disconnect and dispose.
   */
  dispose() {
    return this._wasDisposed = !0, this;
  }
  /**
   * Indicates if the instance was disposed. 'Disposing' an
   * instance means that all of the Web Audio nodes that were
   * created for the instance are disconnected and freed for garbage collection.
   */
  get disposed() {
    return this._wasDisposed;
  }
  /**
   * Convert the class to a string
   * @example
   * const osc = new Tone.Oscillator();
   * console.log(osc.toString());
   */
  toString() {
    return this.name;
  }
}
Ps.version = x1;
const jy = 1e-6;
function Al(e, t) {
  return e > t + jy;
}
function xg(e, t) {
  return Al(e, t) || cr(e, t);
}
function Zf(e, t) {
  return e + jy < t;
}
function cr(e, t) {
  return Math.abs(e - t) < jy;
}
function eq(e, t, n) {
  return Math.max(Math.min(e, n), t);
}
class Ki extends Ps {
  constructor() {
    super(), this.name = "Timeline", this._timeline = [];
    const t = Te(Ki.getDefaults(), arguments, ["memory"]);
    this.memory = t.memory, this.increasing = t.increasing;
  }
  static getDefaults() {
    return {
      memory: 1 / 0,
      increasing: !1
    };
  }
  /**
   * The number of items in the timeline.
   */
  get length() {
    return this._timeline.length;
  }
  /**
   * Insert an event object onto the timeline. Events must have a "time" attribute.
   * @param event  The event object to insert into the timeline.
   */
  add(t) {
    if (Xe(Reflect.has(t, "time"), "Timeline: events must have a time attribute"), t.time = t.time.valueOf(), this.increasing && this.length) {
      const n = this._timeline[this.length - 1];
      Xe(xg(t.time, n.time), "The time must be greater than or equal to the last scheduled time"), this._timeline.push(t);
    } else {
      const n = this._search(t.time);
      this._timeline.splice(n + 1, 0, t);
    }
    if (this.length > this.memory) {
      const n = this.length - this.memory;
      this._timeline.splice(0, n);
    }
    return this;
  }
  /**
   * Remove an event from the timeline.
   * @param  {Object}  event  The event object to remove from the list.
   * @returns {Timeline} this
   */
  remove(t) {
    const n = this._timeline.indexOf(t);
    return n !== -1 && this._timeline.splice(n, 1), this;
  }
  /**
   * Get the nearest event whose time is less than or equal to the given time.
   * @param  time  The time to query.
   */
  get(t, n = "time") {
    const i = this._search(t, n);
    return i !== -1 ? this._timeline[i] : null;
  }
  /**
   * Return the first event in the timeline without removing it
   * @returns {Object} The first event object
   */
  peek() {
    return this._timeline[0];
  }
  /**
   * Return the first event in the timeline and remove it
   */
  shift() {
    return this._timeline.shift();
  }
  /**
   * Get the event which is scheduled after the given time.
   * @param  time  The time to query.
   */
  getAfter(t, n = "time") {
    const i = this._search(t, n);
    return i + 1 < this._timeline.length ? this._timeline[i + 1] : null;
  }
  /**
   * Get the event before the event at the given time.
   * @param  time  The time to query.
   */
  getBefore(t) {
    const n = this._timeline.length;
    if (n > 0 && this._timeline[n - 1].time < t)
      return this._timeline[n - 1];
    const i = this._search(t);
    return i - 1 >= 0 ? this._timeline[i - 1] : null;
  }
  /**
   * Cancel events at and after the given time
   * @param  after  The time to query.
   */
  cancel(t) {
    if (this._timeline.length > 1) {
      let n = this._search(t);
      if (n >= 0)
        if (cr(this._timeline[n].time, t)) {
          for (let i = n; i >= 0 && cr(this._timeline[i].time, t); i--)
            n = i;
          this._timeline = this._timeline.slice(0, n);
        } else
          this._timeline = this._timeline.slice(0, n + 1);
      else
        this._timeline = [];
    } else
      this._timeline.length === 1 && xg(this._timeline[0].time, t) && (this._timeline = []);
    return this;
  }
  /**
   * Cancel events before or equal to the given time.
   * @param  time  The time to cancel before.
   */
  cancelBefore(t) {
    const n = this._search(t);
    return n >= 0 && (this._timeline = this._timeline.slice(n + 1)), this;
  }
  /**
   * Returns the previous event if there is one. null otherwise
   * @param  event The event to find the previous one of
   * @return The event right before the given event
   */
  previousEvent(t) {
    const n = this._timeline.indexOf(t);
    return n > 0 ? this._timeline[n - 1] : null;
  }
  /**
   * Does a binary search on the timeline array and returns the
   * nearest event index whose time is after or equal to the given time.
   * If a time is searched before the first index in the timeline, -1 is returned.
   * If the time is after the end, the index of the last item is returned.
   */
  _search(t, n = "time") {
    if (this._timeline.length === 0)
      return -1;
    let i = 0;
    const r = this._timeline.length;
    let s = r;
    if (r > 0 && this._timeline[r - 1][n] <= t)
      return r - 1;
    for (; i < s; ) {
      let a = Math.floor(i + (s - i) / 2);
      const o = this._timeline[a], l = this._timeline[a + 1];
      if (cr(o[n], t)) {
        for (let u = a; u < this._timeline.length; u++) {
          const c = this._timeline[u];
          if (cr(c[n], t))
            a = u;
          else
            break;
        }
        return a;
      } else {
        if (Zf(o[n], t) && Al(l[n], t))
          return a;
        Al(o[n], t) ? s = a : i = a + 1;
      }
    }
    return -1;
  }
  /**
   * Internal iterator. Applies extra safety checks for
   * removing items from the array.
   */
  _iterate(t, n = 0, i = this._timeline.length - 1) {
    this._timeline.slice(n, i + 1).forEach(t);
  }
  /**
   * Iterate over everything in the array
   * @param  callback The callback to invoke with every item
   */
  forEach(t) {
    return this._iterate(t), this;
  }
  /**
   * Iterate over everything in the array at or before the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachBefore(t, n) {
    const i = this._search(t);
    return i !== -1 && this._iterate(n, 0, i), this;
  }
  /**
   * Iterate over everything in the array after the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachAfter(t, n) {
    const i = this._search(t);
    return this._iterate(n, i + 1), this;
  }
  /**
   * Iterate over everything in the array between the startTime and endTime.
   * The timerange is inclusive of the startTime, but exclusive of the endTime.
   * range = [startTime, endTime).
   * @param  startTime The time to check if items are before
   * @param  endTime The end of the test interval.
   * @param  callback The callback to invoke with every item
   */
  forEachBetween(t, n, i) {
    let r = this._search(t), s = this._search(n);
    return r !== -1 && s !== -1 ? (this._timeline[r].time !== t && (r += 1), this._timeline[s].time === n && (s -= 1), this._iterate(i, r, s)) : r === -1 && this._iterate(i, 0, s), this;
  }
  /**
   * Iterate over everything in the array at or after the given time. Similar to
   * forEachAfter, but includes the item(s) at the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachFrom(t, n) {
    let i = this._search(t);
    for (; i >= 0 && this._timeline[i].time >= t; )
      i--;
    return this._iterate(n, i + 1), this;
  }
  /**
   * Iterate over everything in the array at the given time
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachAtTime(t, n) {
    const i = this._search(t);
    if (i !== -1 && cr(this._timeline[i].time, t)) {
      let r = i;
      for (let s = i; s >= 0 && cr(this._timeline[s].time, t); s--)
        r = s;
      this._iterate((s) => {
        n(s);
      }, r, i);
    }
    return this;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._timeline = [], this;
  }
}
const Sx = [];
function sm(e) {
  Sx.push(e);
}
function tq(e) {
  Sx.forEach((t) => t(e));
}
const kx = [];
function am(e) {
  kx.push(e);
}
function nq(e) {
  kx.forEach((t) => t(e));
}
class rd extends Ps {
  constructor() {
    super(...arguments), this.name = "Emitter";
  }
  /**
   * Bind a callback to a specific event.
   * @param  event     The name of the event to listen for.
   * @param  callback  The callback to invoke when the event is emitted
   */
  on(t, n) {
    return t.split(/\W+/).forEach((r) => {
      Zi(this._events) && (this._events = {}), this._events.hasOwnProperty(r) || (this._events[r] = []), this._events[r].push(n);
    }), this;
  }
  /**
   * Bind a callback which is only invoked once
   * @param  event     The name of the event to listen for.
   * @param  callback  The callback to invoke when the event is emitted
   */
  once(t, n) {
    const i = (...r) => {
      n(...r), this.off(t, i);
    };
    return this.on(t, i), this;
  }
  /**
   * Remove the event listener.
   * @param  event     The event to stop listening to.
   * @param  callback  The callback which was bound to the event with Emitter.on.
   *                   If no callback is given, all callbacks events are removed.
   */
  off(t, n) {
    return t.split(/\W+/).forEach((r) => {
      if (Zi(this._events) && (this._events = {}), this._events.hasOwnProperty(r))
        if (Zi(n))
          this._events[r] = [];
        else {
          const s = this._events[r];
          for (let a = s.length - 1; a >= 0; a--)
            s[a] === n && s.splice(a, 1);
        }
    }), this;
  }
  /**
   * Invoke all of the callbacks bound to the event
   * with any arguments passed in.
   * @param  event  The name of the event.
   * @param args The arguments to pass to the functions listening.
   */
  emit(t, ...n) {
    if (this._events && this._events.hasOwnProperty(t)) {
      const i = this._events[t].slice(0);
      for (let r = 0, s = i.length; r < s; r++)
        i[r].apply(this, n);
    }
    return this;
  }
  /**
   * Add Emitter functions (on/off/emit) to the object
   */
  static mixin(t) {
    ["on", "once", "off", "emit"].forEach((n) => {
      const i = Object.getOwnPropertyDescriptor(rd.prototype, n);
      Object.defineProperty(t.prototype, n, i);
    });
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._events = void 0, this;
  }
}
class Cx extends rd {
  constructor() {
    super(...arguments), this.isOffline = !1;
  }
  /*
   * This is a placeholder so that JSON.stringify does not throw an error
   * This matches what JSON.stringify(audioContext) returns on a native
   * audioContext instance.
   */
  toJSON() {
    return {};
  }
}
class sd extends Cx {
  constructor() {
    var t, n;
    super(), this.name = "Context", this._constants = /* @__PURE__ */ new Map(), this._timeouts = new Ki(), this._timeoutIds = 0, this._initialized = !1, this._closeStarted = !1, this.isOffline = !1, this._workletPromise = null;
    const i = Te(sd.getDefaults(), arguments, [
      "context"
    ]);
    i.context ? (this._context = i.context, this._latencyHint = ((t = arguments[0]) === null || t === void 0 ? void 0 : t.latencyHint) || "") : (this._context = UU({
      latencyHint: i.latencyHint
    }), this._latencyHint = i.latencyHint), this._ticker = new ZU(this.emit.bind(this, "tick"), i.clockSource, i.updateInterval, this._context.sampleRate), this.on("tick", this._timeoutLoop.bind(this)), this._context.onstatechange = () => {
      this.emit("statechange", this.state);
    }, this[!((n = arguments[0]) === null || n === void 0) && n.hasOwnProperty("updateInterval") ? "_lookAhead" : "lookAhead"] = i.lookAhead;
  }
  static getDefaults() {
    return {
      clockSource: "worker",
      latencyHint: "interactive",
      lookAhead: 0.1,
      updateInterval: 0.05
    };
  }
  /**
   * Finish setting up the context. **You usually do not need to do this manually.**
   */
  initialize() {
    return this._initialized || (tq(this), this._initialized = !0), this;
  }
  //---------------------------
  // BASE AUDIO CONTEXT METHODS
  //---------------------------
  createAnalyser() {
    return this._context.createAnalyser();
  }
  createOscillator() {
    return this._context.createOscillator();
  }
  createBufferSource() {
    return this._context.createBufferSource();
  }
  createBiquadFilter() {
    return this._context.createBiquadFilter();
  }
  createBuffer(t, n, i) {
    return this._context.createBuffer(t, n, i);
  }
  createChannelMerger(t) {
    return this._context.createChannelMerger(t);
  }
  createChannelSplitter(t) {
    return this._context.createChannelSplitter(t);
  }
  createConstantSource() {
    return this._context.createConstantSource();
  }
  createConvolver() {
    return this._context.createConvolver();
  }
  createDelay(t) {
    return this._context.createDelay(t);
  }
  createDynamicsCompressor() {
    return this._context.createDynamicsCompressor();
  }
  createGain() {
    return this._context.createGain();
  }
  createIIRFilter(t, n) {
    return this._context.createIIRFilter(t, n);
  }
  createPanner() {
    return this._context.createPanner();
  }
  createPeriodicWave(t, n, i) {
    return this._context.createPeriodicWave(t, n, i);
  }
  createStereoPanner() {
    return this._context.createStereoPanner();
  }
  createWaveShaper() {
    return this._context.createWaveShaper();
  }
  createMediaStreamSource(t) {
    return Xe(Zo(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamSource(t);
  }
  createMediaElementSource(t) {
    return Xe(Zo(this._context), "Not available if OfflineAudioContext"), this._context.createMediaElementSource(t);
  }
  createMediaStreamDestination() {
    return Xe(Zo(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamDestination();
  }
  decodeAudioData(t) {
    return this._context.decodeAudioData(t);
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get currentTime() {
    return this._context.currentTime;
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get state() {
    return this._context.state;
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get sampleRate() {
    return this._context.sampleRate;
  }
  /**
   * The listener
   */
  get listener() {
    return this.initialize(), this._listener;
  }
  set listener(t) {
    Xe(!this._initialized, "The listener cannot be set after initialization."), this._listener = t;
  }
  /**
   * There is only one Transport per Context. It is created on initialization.
   */
  get transport() {
    return this.initialize(), this._transport;
  }
  set transport(t) {
    Xe(!this._initialized, "The transport cannot be set after initialization."), this._transport = t;
  }
  /**
   * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.
   */
  get draw() {
    return this.initialize(), this._draw;
  }
  set draw(t) {
    Xe(!this._initialized, "Draw cannot be set after initialization."), this._draw = t;
  }
  /**
   * A reference to the Context's destination node.
   */
  get destination() {
    return this.initialize(), this._destination;
  }
  set destination(t) {
    Xe(!this._initialized, "The destination cannot be set after initialization."), this._destination = t;
  }
  /**
   * Create an audio worklet node from a name and options. The module
   * must first be loaded using {@link addAudioWorkletModule}.
   */
  createAudioWorkletNode(t, n) {
    return YU(this.rawContext, t, n);
  }
  /**
   * Add an AudioWorkletProcessor module
   * @param url The url of the module
   */
  addAudioWorkletModule(t) {
    return mn(this, void 0, void 0, function* () {
      Xe(nt(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)"), this._workletPromise || (this._workletPromise = this.rawContext.audioWorklet.addModule(t)), yield this._workletPromise;
    });
  }
  /**
   * Returns a promise which resolves when all of the worklets have been loaded on this context
   */
  workletsAreReady() {
    return mn(this, void 0, void 0, function* () {
      (yield this._workletPromise) ? this._workletPromise : Promise.resolve();
    });
  }
  //---------------------------
  // TICKER
  //---------------------------
  /**
   * How often the interval callback is invoked.
   * This number corresponds to how responsive the scheduling
   * can be. Setting to 0 will result in the lowest practial interval
   * based on context properties. context.updateInterval + context.lookAhead
   * gives you the total latency between scheduling an event and hearing it.
   */
  get updateInterval() {
    return this._ticker.updateInterval;
  }
  set updateInterval(t) {
    this._ticker.updateInterval = t;
  }
  /**
   * What the source of the clock is, either "worker" (default),
   * "timeout", or "offline" (none).
   */
  get clockSource() {
    return this._ticker.type;
  }
  set clockSource(t) {
    this._ticker.type = t;
  }
  /**
   * The amount of time into the future events are scheduled. Giving Web Audio
   * a short amount of time into the future to schedule events can reduce clicks and
   * improve performance. This value can be set to 0 to get the lowest latency.
   * Adjusting this value also affects the {@link updateInterval}.
   */
  get lookAhead() {
    return this._lookAhead;
  }
  set lookAhead(t) {
    this._lookAhead = t, this.updateInterval = t ? t / 2 : 0.01;
  }
  /**
   * The type of playback, which affects tradeoffs between audio
   * output latency and responsiveness.
   * In addition to setting the value in seconds, the latencyHint also
   * accepts the strings "interactive" (prioritizes low latency),
   * "playback" (prioritizes sustained playback), "balanced" (balances
   * latency and performance).
   * @example
   * // prioritize sustained playback
   * const context = new Tone.Context({ latencyHint: "playback" });
   * // set this context as the global Context
   * Tone.setContext(context);
   * // the global context is gettable with Tone.getContext()
   * console.log(Tone.getContext().latencyHint);
   */
  get latencyHint() {
    return this._latencyHint;
  }
  /**
   * The unwrapped AudioContext or OfflineAudioContext
   */
  get rawContext() {
    return this._context;
  }
  /**
   * The current audio context time plus a short {@link lookAhead}.
   * @example
   * setInterval(() => {
   * 	console.log("now", Tone.now());
   * }, 100);
   */
  now() {
    return this._context.currentTime + this._lookAhead;
  }
  /**
   * The current audio context time without the {@link lookAhead}.
   * In most cases it is better to use {@link now} instead of {@link immediate} since
   * with {@link now} the {@link lookAhead} is applied equally to _all_ components including internal components,
   * to making sure that everything is scheduled in sync. Mixing {@link now} and {@link immediate}
   * can cause some timing issues. If no lookAhead is desired, you can set the {@link lookAhead} to `0`.
   */
  immediate() {
    return this._context.currentTime;
  }
  /**
   * Starts the audio context from a suspended state. This is required
   * to initially start the AudioContext.
   * @see {@link start}
   */
  resume() {
    return Zo(this._context) ? this._context.resume() : Promise.resolve();
  }
  /**
   * Close the context. Once closed, the context can no longer be used and
   * any AudioNodes created from the context will be silent.
   */
  close() {
    return mn(this, void 0, void 0, function* () {
      Zo(this._context) && this.state !== "closed" && !this._closeStarted && (this._closeStarted = !0, yield this._context.close()), this._initialized && nq(this);
    });
  }
  /**
   * **Internal** Generate a looped buffer at some constant value.
   */
  getConstant(t) {
    if (this._constants.has(t))
      return this._constants.get(t);
    {
      const n = this._context.createBuffer(1, 128, this._context.sampleRate), i = n.getChannelData(0);
      for (let s = 0; s < i.length; s++)
        i[s] = t;
      const r = this._context.createBufferSource();
      return r.channelCount = 1, r.channelCountMode = "explicit", r.buffer = n, r.loop = !0, r.start(0), this._constants.set(t, r), r;
    }
  }
  /**
   * Clean up. Also closes the audio context.
   */
  dispose() {
    return super.dispose(), this._ticker.dispose(), this._timeouts.dispose(), Object.keys(this._constants).map((t) => this._constants[t].disconnect()), this.close(), this;
  }
  //---------------------------
  // TIMEOUTS
  //---------------------------
  /**
   * The private loop which keeps track of the context scheduled timeouts
   * Is invoked from the clock source
   */
  _timeoutLoop() {
    const t = this.now();
    let n = this._timeouts.peek();
    for (; this._timeouts.length && n && n.time <= t; )
      n.callback(), this._timeouts.shift(), n = this._timeouts.peek();
  }
  /**
   * A setTimeout which is guaranteed by the clock source.
   * Also runs in the offline context.
   * @param  fn       The callback to invoke
   * @param  timeout  The timeout in seconds
   * @returns ID to use when invoking Context.clearTimeout
   */
  setTimeout(t, n) {
    this._timeoutIds++;
    const i = this.now();
    return this._timeouts.add({
      callback: t,
      id: this._timeoutIds,
      time: i + n
    }), this._timeoutIds;
  }
  /**
   * Clears a previously scheduled timeout with Tone.context.setTimeout
   * @param  id  The ID returned from setTimeout
   */
  clearTimeout(t) {
    return this._timeouts.forEach((n) => {
      n.id === t && this._timeouts.remove(n);
    }), this;
  }
  /**
   * Clear the function scheduled by {@link setInterval}
   */
  clearInterval(t) {
    return this.clearTimeout(t);
  }
  /**
   * Adds a repeating event to the context's callback clock
   */
  setInterval(t, n) {
    const i = ++this._timeoutIds, r = () => {
      const s = this.now();
      this._timeouts.add({
        callback: () => {
          t(), r();
        },
        id: i,
        time: s + n
      });
    };
    return r(), i;
  }
}
class iq extends Cx {
  constructor() {
    super(...arguments), this.lookAhead = 0, this.latencyHint = 0, this.isOffline = !1;
  }
  //---------------------------
  // BASE AUDIO CONTEXT METHODS
  //---------------------------
  createAnalyser() {
    return {};
  }
  createOscillator() {
    return {};
  }
  createBufferSource() {
    return {};
  }
  createBiquadFilter() {
    return {};
  }
  createBuffer(t, n, i) {
    return {};
  }
  createChannelMerger(t) {
    return {};
  }
  createChannelSplitter(t) {
    return {};
  }
  createConstantSource() {
    return {};
  }
  createConvolver() {
    return {};
  }
  createDelay(t) {
    return {};
  }
  createDynamicsCompressor() {
    return {};
  }
  createGain() {
    return {};
  }
  createIIRFilter(t, n) {
    return {};
  }
  createPanner() {
    return {};
  }
  createPeriodicWave(t, n, i) {
    return {};
  }
  createStereoPanner() {
    return {};
  }
  createWaveShaper() {
    return {};
  }
  createMediaStreamSource(t) {
    return {};
  }
  createMediaElementSource(t) {
    return {};
  }
  createMediaStreamDestination() {
    return {};
  }
  decodeAudioData(t) {
    return Promise.resolve({});
  }
  //---------------------------
  // TONE AUDIO CONTEXT METHODS
  //---------------------------
  createAudioWorkletNode(t, n) {
    return {};
  }
  get rawContext() {
    return {};
  }
  addAudioWorkletModule(t) {
    return mn(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  resume() {
    return Promise.resolve();
  }
  setTimeout(t, n) {
    return 0;
  }
  clearTimeout(t) {
    return this;
  }
  setInterval(t, n) {
    return 0;
  }
  clearInterval(t) {
    return this;
  }
  getConstant(t) {
    return {};
  }
  get currentTime() {
    return 0;
  }
  get state() {
    return {};
  }
  get sampleRate() {
    return 0;
  }
  get listener() {
    return {};
  }
  get transport() {
    return {};
  }
  get draw() {
    return {};
  }
  set draw(t) {
  }
  get destination() {
    return {};
  }
  set destination(t) {
  }
  now() {
    return 0;
  }
  immediate() {
    return 0;
  }
}
function Jt(e, t) {
  wr(t) ? t.forEach((n) => Jt(e, n)) : Object.defineProperty(e, t, {
    enumerable: !0,
    writable: !1
  });
}
function Tx(e, t) {
  wr(t) ? t.forEach((n) => Tx(e, n)) : Object.defineProperty(e, t, {
    writable: !0
  });
}
const wt = () => {
};
class Vt extends Ps {
  constructor() {
    super(), this.name = "ToneAudioBuffer", this.onload = wt;
    const t = Te(Vt.getDefaults(), arguments, ["url", "onload", "onerror"]);
    this.reverse = t.reverse, this.onload = t.onload, _s(t.url) ? this.load(t.url).catch(t.onerror) : t.url && this.set(t.url);
  }
  static getDefaults() {
    return {
      onerror: wt,
      onload: wt,
      reverse: !1
    };
  }
  /**
   * The sample rate of the AudioBuffer
   */
  get sampleRate() {
    return this._buffer ? this._buffer.sampleRate : vr().sampleRate;
  }
  /**
   * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.
   */
  set(t) {
    return t instanceof Vt ? t.loaded ? this._buffer = t.get() : t.onload = () => {
      this.set(t), this.onload(this);
    } : this._buffer = t, this._reversed && this._reverse(), this;
  }
  /**
   * The audio buffer stored in the object.
   */
  get() {
    return this._buffer;
  }
  /**
   * Makes an fetch request for the selected url then decodes the file as an audio buffer.
   * Invokes the callback once the audio buffer loads.
   * @param url The url of the buffer to load. filetype support depends on the browser.
   * @returns A Promise which resolves with this ToneAudioBuffer
   */
  load(t) {
    return mn(this, void 0, void 0, function* () {
      const n = Vt.load(t).then((i) => {
        this.set(i), this.onload(this);
      });
      Vt.downloads.push(n);
      try {
        yield n;
      } finally {
        const i = Vt.downloads.indexOf(n);
        Vt.downloads.splice(i, 1);
      }
      return this;
    });
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this._buffer = void 0, this;
  }
  /**
   * Set the audio buffer from the array.
   * To create a multichannel AudioBuffer, pass in a multidimensional array.
   * @param array The array to fill the audio buffer
   */
  fromArray(t) {
    const n = wr(t) && t[0].length > 0, i = n ? t.length : 1, r = n ? t[0].length : t.length, s = vr(), a = s.createBuffer(i, r, s.sampleRate), o = !n && i === 1 ? [t] : t;
    for (let l = 0; l < i; l++)
      a.copyToChannel(o[l], l);
    return this._buffer = a, this;
  }
  /**
   * Sums multiple channels into 1 channel
   * @param chanNum Optionally only copy a single channel from the array.
   */
  toMono(t) {
    if (ro(t))
      this.fromArray(this.toArray(t));
    else {
      let n = new Float32Array(this.length);
      const i = this.numberOfChannels;
      for (let r = 0; r < i; r++) {
        const s = this.toArray(r);
        for (let a = 0; a < s.length; a++)
          n[a] += s[a];
      }
      n = n.map((r) => r / i), this.fromArray(n);
    }
    return this;
  }
  /**
   * Get the buffer as an array. Single channel buffers will return a 1-dimensional
   * Float32Array, and multichannel buffers will return multidimensional arrays.
   * @param channel Optionally only copy a single channel from the array.
   */
  toArray(t) {
    if (ro(t))
      return this.getChannelData(t);
    if (this.numberOfChannels === 1)
      return this.toArray(0);
    {
      const n = [];
      for (let i = 0; i < this.numberOfChannels; i++)
        n[i] = this.getChannelData(i);
      return n;
    }
  }
  /**
   * Returns the Float32Array representing the PCM audio data for the specific channel.
   * @param  channel  The channel number to return
   * @return The audio as a TypedArray
   */
  getChannelData(t) {
    return this._buffer ? this._buffer.getChannelData(t) : new Float32Array(0);
  }
  /**
   * Cut a subsection of the array and return a buffer of the
   * subsection. Does not modify the original buffer
   * @param start The time to start the slice
   * @param end The end time to slice. If none is given will default to the end of the buffer
   */
  slice(t, n = this.duration) {
    Xe(this.loaded, "Buffer is not loaded");
    const i = Math.floor(t * this.sampleRate), r = Math.floor(n * this.sampleRate);
    Xe(i < r, "The start time must be less than the end time");
    const s = r - i, a = vr().createBuffer(this.numberOfChannels, s, this.sampleRate);
    for (let o = 0; o < this.numberOfChannels; o++)
      a.copyToChannel(this.getChannelData(o).subarray(i, r), o);
    return new Vt(a);
  }
  /**
   * Reverse the buffer.
   */
  _reverse() {
    if (this.loaded)
      for (let t = 0; t < this.numberOfChannels; t++)
        this.getChannelData(t).reverse();
    return this;
  }
  /**
   * If the buffer is loaded or not
   */
  get loaded() {
    return this.length > 0;
  }
  /**
   * The duration of the buffer in seconds.
   */
  get duration() {
    return this._buffer ? this._buffer.duration : 0;
  }
  /**
   * The length of the buffer in samples
   */
  get length() {
    return this._buffer ? this._buffer.length : 0;
  }
  /**
   * The number of discrete audio channels. Returns 0 if no buffer is loaded.
   */
  get numberOfChannels() {
    return this._buffer ? this._buffer.numberOfChannels : 0;
  }
  /**
   * Reverse the buffer.
   */
  get reverse() {
    return this._reversed;
  }
  set reverse(t) {
    this._reversed !== t && (this._reversed = t, this._reverse());
  }
  /**
   * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,
   * pass in a multidimensional array.
   * @param array The array to fill the audio buffer
   * @return A ToneAudioBuffer created from the array
   */
  static fromArray(t) {
    return new Vt().fromArray(t);
  }
  /**
   * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer
   * @param  url The url to load.
   * @return A promise which resolves to a ToneAudioBuffer
   */
  static fromUrl(t) {
    return mn(this, void 0, void 0, function* () {
      return yield new Vt().load(t);
    });
  }
  /**
   * Loads a url using fetch and returns the AudioBuffer.
   */
  static load(t) {
    return mn(this, void 0, void 0, function* () {
      const n = t.match(/\[([^\]\[]+\|.+)\]$/);
      if (n) {
        const l = n[1].split("|");
        let u = l[0];
        for (const c of l)
          if (Vt.supportsType(c)) {
            u = c;
            break;
          }
        t = t.replace(n[0], u);
      }
      const i = Vt.baseUrl === "" || Vt.baseUrl.endsWith("/") ? Vt.baseUrl : Vt.baseUrl + "/", r = document.createElement("a");
      r.href = i + t, r.pathname = (r.pathname + r.hash).split("/").map(encodeURIComponent).join("/");
      const s = yield fetch(r.href);
      if (!s.ok)
        throw new Error(`could not load url: ${t}`);
      const a = yield s.arrayBuffer();
      return yield vr().decodeAudioData(a);
    });
  }
  /**
   * Checks a url's extension to see if the current browser can play that file type.
   * @param url The url/extension to test
   * @return If the file extension can be played
   * @static
   * @example
   * Tone.ToneAudioBuffer.supportsType("wav"); // returns true
   * Tone.ToneAudioBuffer.supportsType("path/to/file.wav"); // returns true
   */
  static supportsType(t) {
    const n = t.split("."), i = n[n.length - 1];
    return document.createElement("audio").canPlayType("audio/" + i) !== "";
  }
  /**
   * Returns a Promise which resolves when all of the buffers have loaded
   */
  static loaded() {
    return mn(this, void 0, void 0, function* () {
      for (yield Promise.resolve(); Vt.downloads.length; )
        yield Vt.downloads[0];
    });
  }
}
Vt.baseUrl = "";
Vt.downloads = [];
class Hy extends sd {
  constructor() {
    super({
      clockSource: "offline",
      context: lf(arguments[0]) ? arguments[0] : qU(arguments[0], arguments[1] * arguments[2], arguments[2]),
      lookAhead: 0,
      updateInterval: lf(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
    }), this.name = "OfflineContext", this._currentTime = 0, this.isOffline = !0, this._duration = lf(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];
  }
  /**
   * Override the now method to point to the internal clock time
   */
  now() {
    return this._currentTime;
  }
  /**
   * Same as this.now()
   */
  get currentTime() {
    return this._currentTime;
  }
  /**
   * Render just the clock portion of the audio context.
   */
  _renderClock(t) {
    return mn(this, void 0, void 0, function* () {
      let n = 0;
      for (; this._duration - this._currentTime >= 0; ) {
        this.emit("tick"), this._currentTime += 128 / this.sampleRate, n++;
        const i = Math.floor(this.sampleRate / 128);
        t && n % i === 0 && (yield new Promise((r) => setTimeout(r, 1)));
      }
    });
  }
  /**
   * Render the output of the OfflineContext
   * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.
   */
  render(t = !0) {
    return mn(this, void 0, void 0, function* () {
      yield this.workletsAreReady(), yield this._renderClock(t);
      const n = yield this._context.startRendering();
      return new Vt(n);
    });
  }
  /**
   * Close the context
   */
  close() {
    return Promise.resolve();
  }
}
const xx = new iq();
let rl = xx;
function vr() {
  return rl === xx && GU && rq(new sd()), rl;
}
function rq(e, t = !1) {
  t && rl.dispose(), Zo(e) ? rl = new sd(e) : lf(e) ? rl = new Hy(e) : rl = e;
}
if (qa && !qa.TONE_SILENCE_LOGGING) {
  const t = ` * Tone.js v${x1} * `;
  console.log(`%c${t}`, "background: #000; color: #fff");
}
function sq(e) {
  return Math.pow(10, e / 20);
}
function aq(e) {
  return 20 * (Math.log(e) / Math.LN10);
}
function Ax(e) {
  return Math.pow(2, e / 12);
}
let om = 440;
function oq() {
  return om;
}
function lq(e) {
  om = e;
}
function Ag(e) {
  return Math.round(Ix(e));
}
function Ix(e) {
  return 69 + 12 * Math.log2(e / om);
}
function uq(e) {
  return om * Math.pow(2, (e - 69) / 12);
}
class zy extends Ps {
  /**
   * @param context The context associated with the time value. Used to compute
   * Transport and context-relative timing.
   * @param  value  The time value as a number, string or object
   * @param  units  Unit values
   */
  constructor(t, n, i) {
    super(), this.defaultUnits = "s", this._val = n, this._units = i, this.context = t, this._expressions = this._getExpressions();
  }
  /**
   * All of the time encoding expressions
   */
  _getExpressions() {
    return {
      hz: {
        method: (t) => this._frequencyToUnits(parseFloat(t)),
        regexp: /^(\d+(?:\.\d+)?)hz$/i
      },
      i: {
        method: (t) => this._ticksToUnits(parseInt(t, 10)),
        regexp: /^(\d+)i$/i
      },
      m: {
        method: (t) => this._beatsToUnits(parseInt(t, 10) * this._getTimeSignature()),
        regexp: /^(\d+)m$/i
      },
      n: {
        method: (t, n) => {
          const i = parseInt(t, 10), r = n === "." ? 1.5 : 1;
          return i === 1 ? this._beatsToUnits(this._getTimeSignature()) * r : this._beatsToUnits(4 / i) * r;
        },
        regexp: /^(\d+)n(\.?)$/i
      },
      number: {
        method: (t) => this._expressions[this.defaultUnits].method.call(this, t),
        regexp: /^(\d+(?:\.\d+)?)$/
      },
      s: {
        method: (t) => this._secondsToUnits(parseFloat(t)),
        regexp: /^(\d+(?:\.\d+)?)s$/
      },
      samples: {
        method: (t) => parseInt(t, 10) / this.context.sampleRate,
        regexp: /^(\d+)samples$/
      },
      t: {
        method: (t) => {
          const n = parseInt(t, 10);
          return this._beatsToUnits(8 / (Math.floor(n) * 3));
        },
        regexp: /^(\d+)t$/i
      },
      tr: {
        method: (t, n, i) => {
          let r = 0;
          return t && t !== "0" && (r += this._beatsToUnits(this._getTimeSignature() * parseFloat(t))), n && n !== "0" && (r += this._beatsToUnits(parseFloat(n))), i && i !== "0" && (r += this._beatsToUnits(parseFloat(i) / 4)), r;
        },
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
      }
    };
  }
  //-------------------------------------
  // 	VALUE OF
  //-------------------------------------
  /**
   * Evaluate the time value. Returns the time in seconds.
   */
  valueOf() {
    if (this._val instanceof zy && this.fromType(this._val), Zi(this._val))
      return this._noArg();
    if (_s(this._val) && Zi(this._units)) {
      for (const t in this._expressions)
        if (this._expressions[t].regexp.test(this._val.trim())) {
          this._units = t;
          break;
        }
    } else if (Ua(this._val)) {
      let t = 0;
      for (const n in this._val)
        if (nt(this._val[n])) {
          const i = this._val[n], r = new this.constructor(this.context, n).valueOf() * i;
          t += r;
        }
      return t;
    }
    if (nt(this._units)) {
      const t = this._expressions[this._units], n = this._val.toString().trim().match(t.regexp);
      return n ? t.method.apply(this, n.slice(1)) : t.method.call(this, this._val);
    } else
      return _s(this._val) ? parseFloat(this._val) : this._val;
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS
  //-------------------------------------
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(t) {
    return 1 / t;
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(t) {
    return 60 / this._getBpm() * t;
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(t) {
    return t;
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(t) {
    return t * this._beatsToUnits(1) / this._getPPQ();
  }
  /**
   * With no arguments, return 'now'
   */
  _noArg() {
    return this._now();
  }
  //-------------------------------------
  // 	TEMPO CONVERSIONS
  //-------------------------------------
  /**
   * Return the bpm
   */
  _getBpm() {
    return this.context.transport.bpm.value;
  }
  /**
   * Return the timeSignature
   */
  _getTimeSignature() {
    return this.context.transport.timeSignature;
  }
  /**
   * Return the PPQ or 192 if Transport is not available
   */
  _getPPQ() {
    return this.context.transport.PPQ;
  }
  //-------------------------------------
  // 	CONVERSION INTERFACE
  //-------------------------------------
  /**
   * Coerce a time type into this units type.
   * @param type Any time type units
   */
  fromType(t) {
    switch (this._units = void 0, this.defaultUnits) {
      case "s":
        this._val = t.toSeconds();
        break;
      case "i":
        this._val = t.toTicks();
        break;
      case "hz":
        this._val = t.toFrequency();
        break;
      case "midi":
        this._val = t.toMidi();
        break;
    }
    return this;
  }
  /**
   * Return the value in hertz
   */
  toFrequency() {
    return 1 / this.toSeconds();
  }
  /**
   * Return the time in samples
   */
  toSamples() {
    return this.toSeconds() * this.context.sampleRate;
  }
  /**
   * Return the time in milliseconds.
   */
  toMilliseconds() {
    return this.toSeconds() * 1e3;
  }
}
class gr extends zy {
  constructor() {
    super(...arguments), this.name = "TimeClass";
  }
  _getExpressions() {
    return Object.assign(super._getExpressions(), {
      now: {
        method: (t) => this._now() + new this.constructor(this.context, t).valueOf(),
        regexp: /^\+(.+)/
      },
      quantize: {
        method: (t) => {
          const n = new gr(this.context, t).valueOf();
          return this._secondsToUnits(this.context.transport.nextSubdivision(n));
        },
        regexp: /^@(.+)/
      }
    });
  }
  /**
   * Quantize the time by the given subdivision. Optionally add a
   * percentage which will move the time value towards the ideal
   * quantized value by that percentage.
   * @param  subdiv    The subdivision to quantize to
   * @param  percent  Move the time value towards the quantized value by a percentage.
   * @example
   * Tone.Time(21).quantize(2); // returns 22
   * Tone.Time(0.6).quantize("4n", 0.5); // returns 0.55
   */
  quantize(t, n = 1) {
    const i = new this.constructor(this.context, t).valueOf(), r = this.valueOf(), o = Math.round(r / i) * i - r;
    return r + o * n;
  }
  //-------------------------------------
  // CONVERSIONS
  //-------------------------------------
  /**
   * Convert a Time to Notation. The notation values are will be the
   * closest representation between 1m to 128th note.
   * @return {Notation}
   * @example
   * // if the Transport is at 120bpm:
   * Tone.Time(2).toNotation(); // returns "1m"
   */
  toNotation() {
    const t = this.toSeconds(), n = ["1m"];
    for (let s = 1; s < 9; s++) {
      const a = Math.pow(2, s);
      n.push(a + "n."), n.push(a + "n"), n.push(a + "t");
    }
    n.push("0");
    let i = n[0], r = new gr(this.context, n[0]).toSeconds();
    return n.forEach((s) => {
      const a = new gr(this.context, s).toSeconds();
      Math.abs(a - t) < Math.abs(r - t) && (i = s, r = a);
    }), i;
  }
  /**
   * Return the time encoded as Bars:Beats:Sixteenths.
   */
  toBarsBeatsSixteenths() {
    const t = this._beatsToUnits(1);
    let n = this.valueOf() / t;
    n = parseFloat(n.toFixed(4));
    const i = Math.floor(n / this._getTimeSignature());
    let r = n % 1 * 4;
    n = Math.floor(n) % this._getTimeSignature();
    const s = r.toString();
    return s.length > 3 && (r = parseFloat(parseFloat(s).toFixed(3))), [i, n, r].join(":");
  }
  /**
   * Return the time in ticks.
   */
  toTicks() {
    const t = this._beatsToUnits(1);
    return this.valueOf() / t * this._getPPQ();
  }
  /**
   * Return the time in seconds.
   */
  toSeconds() {
    return this.valueOf();
  }
  /**
   * Return the value as a midi note.
   */
  toMidi() {
    return Ag(this.toFrequency());
  }
  _now() {
    return this.context.now();
  }
}
class Gi extends gr {
  constructor() {
    super(...arguments), this.name = "Frequency", this.defaultUnits = "hz";
  }
  /**
   * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used
   * to generate all the other pitch values from notes. A4's values in Hertz.
   */
  static get A4() {
    return oq();
  }
  static set A4(t) {
    lq(t);
  }
  //-------------------------------------
  // 	AUGMENT BASE EXPRESSIONS
  //-------------------------------------
  _getExpressions() {
    return Object.assign({}, super._getExpressions(), {
      midi: {
        regexp: /^(\d+(?:\.\d+)?midi)/,
        method(t) {
          return this.defaultUnits === "midi" ? t : Gi.mtof(t);
        }
      },
      note: {
        regexp: /^([a-g]{1}(?:b|#|##|x|bb|###|#x|x#|bbb)?)(-?[0-9]+)/i,
        method(t, n) {
          const r = cq[t.toLowerCase()] + (parseInt(n, 10) + 1) * 12;
          return this.defaultUnits === "midi" ? r : Gi.mtof(r);
        }
      },
      tr: {
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
        method(t, n, i) {
          let r = 1;
          return t && t !== "0" && (r *= this._beatsToUnits(this._getTimeSignature() * parseFloat(t))), n && n !== "0" && (r *= this._beatsToUnits(parseFloat(n))), i && i !== "0" && (r *= this._beatsToUnits(parseFloat(i) / 4)), r;
        }
      }
    });
  }
  //-------------------------------------
  // 	EXPRESSIONS
  //-------------------------------------
  /**
   * Transposes the frequency by the given number of semitones.
   * @return  A new transposed frequency
   * @example
   * Tone.Frequency("A4").transpose(3); // "C5"
   */
  transpose(t) {
    return new Gi(this.context, this.valueOf() * Ax(t));
  }
  /**
   * Takes an array of semitone intervals and returns
   * an array of frequencies transposed by those intervals.
   * @return  Returns an array of Frequencies
   * @example
   * Tone.Frequency("A4").harmonize([0, 3, 7]); // ["A4", "C5", "E5"]
   */
  harmonize(t) {
    return t.map((n) => this.transpose(n));
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS
  //-------------------------------------
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Frequency("C4").toMidi(); // 60
   */
  toMidi() {
    return Ag(this.valueOf());
  }
  /**
   * Return the value of the frequency in Scientific Pitch Notation
   * @example
   * Tone.Frequency(69, "midi").toNote(); // "A4"
   */
  toNote() {
    const t = this.toFrequency(), n = Math.log2(t / Gi.A4);
    let i = Math.round(12 * n) + 57;
    const r = Math.floor(i / 12);
    return r < 0 && (i += -12 * r), dq[i % 12] + r.toString();
  }
  /**
   * Return the duration of one cycle in seconds.
   */
  toSeconds() {
    return 1 / super.toSeconds();
  }
  /**
   * Return the duration of one cycle in ticks
   */
  toTicks() {
    const t = this._beatsToUnits(1), n = this.valueOf() / t;
    return Math.floor(n * this._getPPQ());
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS HELPERS
  //-------------------------------------
  /**
   * With no arguments, return 0
   */
  _noArg() {
    return 0;
  }
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(t) {
    return t;
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(t) {
    return 1 / (t * 60 / (this._getBpm() * this._getPPQ()));
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(t) {
    return 1 / super._beatsToUnits(t);
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(t) {
    return 1 / t;
  }
  /**
   * Convert a MIDI note to frequency value.
   * @param  midi The midi number to convert.
   * @return The corresponding frequency value
   */
  static mtof(t) {
    return uq(t);
  }
  /**
   * Convert a frequency value to a MIDI note.
   * @param frequency The value to frequency value to convert.
   */
  static ftom(t) {
    return Ag(t);
  }
}
const cq = {
  cbbb: -3,
  cbb: -2,
  cb: -1,
  c: 0,
  "c#": 1,
  cx: 2,
  "c##": 2,
  "c###": 3,
  "cx#": 3,
  "c#x": 3,
  dbbb: -1,
  dbb: 0,
  db: 1,
  d: 2,
  "d#": 3,
  dx: 4,
  "d##": 4,
  "d###": 5,
  "dx#": 5,
  "d#x": 5,
  ebbb: 1,
  ebb: 2,
  eb: 3,
  e: 4,
  "e#": 5,
  ex: 6,
  "e##": 6,
  "e###": 7,
  "ex#": 7,
  "e#x": 7,
  fbbb: 2,
  fbb: 3,
  fb: 4,
  f: 5,
  "f#": 6,
  fx: 7,
  "f##": 7,
  "f###": 8,
  "fx#": 8,
  "f#x": 8,
  gbbb: 4,
  gbb: 5,
  gb: 6,
  g: 7,
  "g#": 8,
  gx: 9,
  "g##": 9,
  "g###": 10,
  "gx#": 10,
  "g#x": 10,
  abbb: 6,
  abb: 7,
  ab: 8,
  a: 9,
  "a#": 10,
  ax: 11,
  "a##": 11,
  "a###": 12,
  "ax#": 12,
  "a#x": 12,
  bbbb: 8,
  bbb: 9,
  bb: 10,
  b: 11,
  "b#": 12,
  bx: 13,
  "b##": 13,
  "b###": 14,
  "bx#": 14,
  "b#x": 14
}, dq = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
class ju extends gr {
  constructor() {
    super(...arguments), this.name = "TransportTime";
  }
  /**
   * Return the current time in whichever context is relevant
   */
  _now() {
    return this.context.transport.seconds;
  }
}
class pi extends Ps {
  constructor() {
    super();
    const t = Te(pi.getDefaults(), arguments, ["context"]);
    this.defaultContext ? this.context = this.defaultContext : this.context = t.context;
  }
  static getDefaults() {
    return {
      context: vr()
    };
  }
  /**
   * Return the current time of the Context clock plus the lookAhead.
   * @example
   * setInterval(() => {
   * 	console.log(Tone.now());
   * }, 100);
   */
  now() {
    return this.context.currentTime + this.context.lookAhead;
  }
  /**
   * Return the current time of the Context clock without any lookAhead.
   * @example
   * setInterval(() => {
   * 	console.log(Tone.immediate());
   * }, 100);
   */
  immediate() {
    return this.context.currentTime;
  }
  /**
   * The duration in seconds of one sample.
   */
  get sampleTime() {
    return 1 / this.context.sampleRate;
  }
  /**
   * The number of seconds of 1 processing block (128 samples)
   * @example
   * console.log(Tone.Destination.blockTime);
   */
  get blockTime() {
    return 128 / this.context.sampleRate;
  }
  /**
   * Convert the incoming time to seconds.
   * This is calculated against the current {@link TransportClass} bpm
   * @example
   * const gain = new Tone.Gain();
   * setInterval(() => console.log(gain.toSeconds("4n")), 100);
   * // ramp the tempo to 60 bpm over 30 seconds
   * Tone.getTransport().bpm.rampTo(60, 30);
   */
  toSeconds(t) {
    return HU(t), new gr(this.context, t).toSeconds();
  }
  /**
   * Convert the input to a frequency number
   * @example
   * const gain = new Tone.Gain();
   * console.log(gain.toFrequency("4n"));
   */
  toFrequency(t) {
    return new Gi(this.context, t).toFrequency();
  }
  /**
   * Convert the input time into ticks
   * @example
   * const gain = new Tone.Gain();
   * console.log(gain.toTicks("4n"));
   */
  toTicks(t) {
    return new ju(this.context, t).toTicks();
  }
  //-------------------------------------
  // 	GET/SET
  //-------------------------------------
  /**
   * Get a subset of the properties which are in the partial props
   */
  _getPartialProperties(t) {
    const n = this.get();
    return Object.keys(n).forEach((i) => {
      Zi(t[i]) && delete n[i];
    }), n;
  }
  /**
   * Get the object's attributes.
   * @example
   * const osc = new Tone.Oscillator();
   * console.log(osc.get());
   */
  get() {
    const t = QU(this);
    return Object.keys(t).forEach((n) => {
      if (Reflect.has(this, n)) {
        const i = this[n];
        nt(i) && nt(i.value) && nt(i.setValueAtTime) ? t[n] = i.value : i instanceof pi ? t[n] = i._getPartialProperties(t[n]) : wr(i) || ro(i) || _s(i) || jU(i) ? t[n] = i : delete t[n];
      }
    }), t;
  }
  /**
   * Set multiple properties at once with an object.
   * @example
   * const filter = new Tone.Filter().toDestination();
   * // set values using an object
   * filter.set({
   * 	frequency: "C6",
   * 	type: "highpass"
   * });
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/Analogsynth_octaves_highmid.mp3").connect(filter);
   * player.autostart = true;
   */
  set(t) {
    return Object.keys(t).forEach((n) => {
      Reflect.has(this, n) && nt(this[n]) && (this[n] && nt(this[n].value) && nt(this[n].setValueAtTime) ? this[n].value !== t[n] && (this[n].value = t[n]) : this[n] instanceof pi ? this[n].set(t[n]) : this[n] = t[n]);
    }), this;
  }
}
class Uy extends Ki {
  constructor(t = "stopped") {
    super(), this.name = "StateTimeline", this._initial = t, this.setStateAtTime(this._initial, 0);
  }
  /**
   * Returns the scheduled state scheduled before or at
   * the given time.
   * @param  time  The time to query.
   * @return  The name of the state input in setStateAtTime.
   */
  getValueAtTime(t) {
    const n = this.get(t);
    return n !== null ? n.state : this._initial;
  }
  /**
   * Add a state to the timeline.
   * @param  state The name of the state to set.
   * @param  time  The time to query.
   * @param options Any additional options that are needed in the timeline.
   */
  setStateAtTime(t, n, i) {
    return sa(n, 0), this.add(Object.assign({}, i, {
      state: t,
      time: n
    })), this;
  }
  /**
   * Return the event before the time with the given state
   * @param  state The state to look for
   * @param  time  When to check before
   * @return  The event with the given state before the time
   */
  getLastState(t, n) {
    const i = this._search(n);
    for (let r = i; r >= 0; r--) {
      const s = this._timeline[r];
      if (s.state === t)
        return s;
    }
  }
  /**
   * Return the event after the time with the given state
   * @param  state The state to look for
   * @param  time  When to check from
   * @return  The event with the given state after the time
   */
  getNextState(t, n) {
    const i = this._search(n);
    if (i !== -1)
      for (let r = i; r < this._timeline.length; r++) {
        const s = this._timeline[r];
        if (s.state === t)
          return s;
      }
  }
}
class Lt extends pi {
  constructor() {
    super(Te(Lt.getDefaults(), arguments, ["param", "units", "convert"])), this.name = "Param", this.overridden = !1, this._minOutput = 1e-7;
    const t = Te(Lt.getDefaults(), arguments, ["param", "units", "convert"]);
    for (Xe(nt(t.param) && (so(t.param) || t.param instanceof Lt), "param must be an AudioParam"); !so(t.param); )
      t.param = t.param._param;
    this._swappable = nt(t.swappable) ? t.swappable : !1, this._swappable ? (this.input = this.context.createGain(), this._param = t.param, this.input.connect(this._param)) : this._param = this.input = t.param, this._events = new Ki(1e3), this._initialValue = this._param.defaultValue, this.units = t.units, this.convert = t.convert, this._minValue = t.minValue, this._maxValue = t.maxValue, nt(t.value) && t.value !== this._toType(this._initialValue) && this.setValueAtTime(t.value, 0);
  }
  static getDefaults() {
    return Object.assign(pi.getDefaults(), {
      convert: !0,
      units: "number"
    });
  }
  get value() {
    const t = this.now();
    return this.getValueAtTime(t);
  }
  set value(t) {
    this.cancelScheduledValues(this.now()), this.setValueAtTime(t, this.now());
  }
  get minValue() {
    return nt(this._minValue) ? this._minValue : this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples" ? 0 : this.units === "audioRange" ? -1 : this.units === "decibels" ? -1 / 0 : this._param.minValue;
  }
  get maxValue() {
    return nt(this._maxValue) ? this._maxValue : this.units === "normalRange" || this.units === "audioRange" ? 1 : this._param.maxValue;
  }
  /**
   * Type guard based on the unit name
   */
  _is(t, n) {
    return this.units === n;
  }
  /**
   * Make sure the value is always in the defined range
   */
  _assertRange(t) {
    return nt(this.maxValue) && nt(this.minValue) && sa(t, this._fromType(this.minValue), this._fromType(this.maxValue)), t;
  }
  /**
   * Convert the given value from the type specified by Param.units
   * into the destination value (such as Gain or Frequency).
   */
  _fromType(t) {
    return this.convert && !this.overridden ? this._is(t, "time") ? this.toSeconds(t) : this._is(t, "decibels") ? sq(t) : this._is(t, "frequency") ? this.toFrequency(t) : t : this.overridden ? 0 : t;
  }
  /**
   * Convert the parameters value into the units specified by Param.units.
   */
  _toType(t) {
    return this.convert && this.units === "decibels" ? aq(t) : t;
  }
  //-------------------------------------
  // ABSTRACT PARAM INTERFACE
  // all docs are generated from ParamInterface.ts
  //-------------------------------------
  setValueAtTime(t, n) {
    const i = this.toSeconds(n), r = this._fromType(t);
    return Xe(isFinite(r) && isFinite(i), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._assertRange(r), this.log(this.units, "setValueAtTime", t, i), this._events.add({
      time: i,
      type: "setValueAtTime",
      value: r
    }), this._param.setValueAtTime(r, i), this;
  }
  getValueAtTime(t) {
    const n = Math.max(this.toSeconds(t), 0), i = this._events.getAfter(n), r = this._events.get(n);
    let s = this._initialValue;
    if (r === null)
      s = this._initialValue;
    else if (r.type === "setTargetAtTime" && (i === null || i.type === "setValueAtTime")) {
      const a = this._events.getBefore(r.time);
      let o;
      a === null ? o = this._initialValue : o = a.value, r.type === "setTargetAtTime" && (s = this._exponentialApproach(r.time, o, r.value, r.constant, n));
    } else if (i === null)
      s = r.value;
    else if (i.type === "linearRampToValueAtTime" || i.type === "exponentialRampToValueAtTime") {
      let a = r.value;
      if (r.type === "setTargetAtTime") {
        const o = this._events.getBefore(r.time);
        o === null ? a = this._initialValue : a = o.value;
      }
      i.type === "linearRampToValueAtTime" ? s = this._linearInterpolate(r.time, a, i.time, i.value, n) : s = this._exponentialInterpolate(r.time, a, i.time, i.value, n);
    } else
      s = r.value;
    return this._toType(s);
  }
  setRampPoint(t) {
    t = this.toSeconds(t);
    let n = this.getValueAtTime(t);
    return this.cancelAndHoldAtTime(t), this._fromType(n) === 0 && (n = this._toType(this._minOutput)), this.setValueAtTime(n, t), this;
  }
  linearRampToValueAtTime(t, n) {
    const i = this._fromType(t), r = this.toSeconds(n);
    return Xe(isFinite(i) && isFinite(r), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._assertRange(i), this._events.add({
      time: r,
      type: "linearRampToValueAtTime",
      value: i
    }), this.log(this.units, "linearRampToValueAtTime", t, r), this._param.linearRampToValueAtTime(i, r), this;
  }
  exponentialRampToValueAtTime(t, n) {
    let i = this._fromType(t);
    i = cr(i, 0) ? this._minOutput : i, this._assertRange(i);
    const r = this.toSeconds(n);
    return Xe(isFinite(i) && isFinite(r), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._events.add({
      time: r,
      type: "exponentialRampToValueAtTime",
      value: i
    }), this.log(this.units, "exponentialRampToValueAtTime", t, r), this._param.exponentialRampToValueAtTime(i, r), this;
  }
  exponentialRampTo(t, n, i) {
    return i = this.toSeconds(i), this.setRampPoint(i), this.exponentialRampToValueAtTime(t, i + this.toSeconds(n)), this;
  }
  linearRampTo(t, n, i) {
    return i = this.toSeconds(i), this.setRampPoint(i), this.linearRampToValueAtTime(t, i + this.toSeconds(n)), this;
  }
  targetRampTo(t, n, i) {
    return i = this.toSeconds(i), this.setRampPoint(i), this.exponentialApproachValueAtTime(t, i, n), this;
  }
  exponentialApproachValueAtTime(t, n, i) {
    n = this.toSeconds(n), i = this.toSeconds(i);
    const r = Math.log(i + 1) / Math.log(200);
    return this.setTargetAtTime(t, n, r), this.cancelAndHoldAtTime(n + i * 0.9), this.linearRampToValueAtTime(t, n + i), this;
  }
  setTargetAtTime(t, n, i) {
    const r = this._fromType(t);
    Xe(isFinite(i) && i > 0, "timeConstant must be a number greater than 0");
    const s = this.toSeconds(n);
    return this._assertRange(r), Xe(isFinite(r) && isFinite(s), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._events.add({
      constant: i,
      time: s,
      type: "setTargetAtTime",
      value: r
    }), this.log(this.units, "setTargetAtTime", t, s, i), this._param.setTargetAtTime(r, s, i), this;
  }
  setValueCurveAtTime(t, n, i, r = 1) {
    i = this.toSeconds(i), n = this.toSeconds(n);
    const s = this._fromType(t[0]) * r;
    this.setValueAtTime(this._toType(s), n);
    const a = i / (t.length - 1);
    for (let o = 1; o < t.length; o++) {
      const l = this._fromType(t[o]) * r;
      this.linearRampToValueAtTime(this._toType(l), n + o * a);
    }
    return this;
  }
  cancelScheduledValues(t) {
    const n = this.toSeconds(t);
    return Xe(isFinite(n), `Invalid argument to cancelScheduledValues: ${JSON.stringify(t)}`), this._events.cancel(n), this._param.cancelScheduledValues(n), this.log(this.units, "cancelScheduledValues", n), this;
  }
  cancelAndHoldAtTime(t) {
    const n = this.toSeconds(t), i = this._fromType(this.getValueAtTime(n));
    Xe(isFinite(n), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(t)}`), this.log(this.units, "cancelAndHoldAtTime", n, "value=" + i);
    const r = this._events.get(n), s = this._events.getAfter(n);
    return r && cr(r.time, n) ? s ? (this._param.cancelScheduledValues(s.time), this._events.cancel(s.time)) : (this._param.cancelAndHoldAtTime(n), this._events.cancel(n + this.sampleTime)) : s && (this._param.cancelScheduledValues(s.time), this._events.cancel(s.time), s.type === "linearRampToValueAtTime" ? this.linearRampToValueAtTime(this._toType(i), n) : s.type === "exponentialRampToValueAtTime" && this.exponentialRampToValueAtTime(this._toType(i), n)), this._events.add({
      time: n,
      type: "setValueAtTime",
      value: i
    }), this._param.setValueAtTime(i, n), this;
  }
  rampTo(t, n = 0.1, i) {
    return this.units === "frequency" || this.units === "bpm" || this.units === "decibels" ? this.exponentialRampTo(t, n, i) : this.linearRampTo(t, n, i), this;
  }
  /**
   * Apply all of the previously scheduled events to the passed in Param or AudioParam.
   * The applied values will start at the context's current time and schedule
   * all of the events which are scheduled on this Param onto the passed in param.
   */
  apply(t) {
    const n = this.context.currentTime;
    t.setValueAtTime(this.getValueAtTime(n), n);
    const i = this._events.get(n);
    if (i && i.type === "setTargetAtTime") {
      const r = this._events.getAfter(i.time), s = r ? r.time : n + 2, a = (s - n) / 10;
      for (let o = n; o < s; o += a)
        t.linearRampToValueAtTime(this.getValueAtTime(o), o);
    }
    return this._events.forEachAfter(this.context.currentTime, (r) => {
      r.type === "cancelScheduledValues" ? t.cancelScheduledValues(r.time) : r.type === "setTargetAtTime" ? t.setTargetAtTime(r.value, r.time, r.constant) : t[r.type](r.value, r.time);
    }), this;
  }
  /**
   * Replace the Param's internal AudioParam. Will apply scheduled curves
   * onto the parameter and replace the connections.
   */
  setParam(t) {
    Xe(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
    const n = this.input;
    return n.disconnect(this._param), this.apply(t), this._param = t, n.connect(this._param), this;
  }
  dispose() {
    return super.dispose(), this._events.dispose(), this;
  }
  get defaultValue() {
    return this._toType(this._param.defaultValue);
  }
  //-------------------------------------
  // 	AUTOMATION CURVE CALCULATIONS
  // 	MIT License, copyright (c) 2014 Jordan Santell
  //-------------------------------------
  // Calculates the the value along the curve produced by setTargetAtTime
  _exponentialApproach(t, n, i, r, s) {
    return i + (n - i) * Math.exp(-(s - t) / r);
  }
  // Calculates the the value along the curve produced by linearRampToValueAtTime
  _linearInterpolate(t, n, i, r, s) {
    return n + (r - n) * ((s - t) / (i - t));
  }
  // Calculates the the value along the curve produced by exponentialRampToValueAtTime
  _exponentialInterpolate(t, n, i, r, s) {
    return n * Math.pow(r / n, (s - t) / (i - t));
  }
}
class et extends pi {
  constructor() {
    super(...arguments), this._internalChannels = [];
  }
  /**
   * The number of inputs feeding into the AudioNode.
   * For source nodes, this will be 0.
   * @example
   * const node = new Tone.Gain();
   * console.log(node.numberOfInputs);
   */
  get numberOfInputs() {
    return nt(this.input) ? so(this.input) || this.input instanceof Lt ? 1 : this.input.numberOfInputs : 0;
  }
  /**
   * The number of outputs of the AudioNode.
   * @example
   * const node = new Tone.Gain();
   * console.log(node.numberOfOutputs);
   */
  get numberOfOutputs() {
    return nt(this.output) ? this.output.numberOfOutputs : 0;
  }
  //-------------------------------------
  // AUDIO PROPERTIES
  //-------------------------------------
  /**
   * Used to decide which nodes to get/set properties on
   */
  _isAudioNode(t) {
    return nt(t) && (t instanceof et || ta(t));
  }
  /**
   * Get all of the audio nodes (either internal or input/output) which together
   * make up how the class node responds to channel input/output
   */
  _getInternalNodes() {
    const t = this._internalChannels.slice(0);
    return this._isAudioNode(this.input) && t.push(this.input), this._isAudioNode(this.output) && this.input !== this.output && t.push(this.output), t;
  }
  /**
   * Set the audio options for this node such as channelInterpretation
   * channelCount, etc.
   * @param options
   */
  _setChannelProperties(t) {
    this._getInternalNodes().forEach((i) => {
      i.channelCount = t.channelCount, i.channelCountMode = t.channelCountMode, i.channelInterpretation = t.channelInterpretation;
    });
  }
  /**
   * Get the current audio options for this node such as channelInterpretation
   * channelCount, etc.
   */
  _getChannelProperties() {
    const t = this._getInternalNodes();
    Xe(t.length > 0, "ToneAudioNode does not have any internal nodes");
    const n = t[0];
    return {
      channelCount: n.channelCount,
      channelCountMode: n.channelCountMode,
      channelInterpretation: n.channelInterpretation
    };
  }
  /**
   * channelCount is the number of channels used when up-mixing and down-mixing
   * connections to any inputs to the node. The default value is 2 except for
   * specific nodes where its value is specially determined.
   */
  get channelCount() {
    return this._getChannelProperties().channelCount;
  }
  set channelCount(t) {
    const n = this._getChannelProperties();
    this._setChannelProperties(Object.assign(n, { channelCount: t }));
  }
  /**
   * channelCountMode determines how channels will be counted when up-mixing and
   * down-mixing connections to any inputs to the node.
   * The default value is "max". This attribute has no effect for nodes with no inputs.
   * * "max" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.
   * * "clamped-max" - computedNumberOfChannels is determined as for "max" and then clamped to a maximum value of the given channelCount.
   * * "explicit" - computedNumberOfChannels is the exact value as specified by the channelCount.
   */
  get channelCountMode() {
    return this._getChannelProperties().channelCountMode;
  }
  set channelCountMode(t) {
    const n = this._getChannelProperties();
    this._setChannelProperties(Object.assign(n, { channelCountMode: t }));
  }
  /**
   * channelInterpretation determines how individual channels will be treated
   * when up-mixing and down-mixing connections to any inputs to the node.
   * The default value is "speakers".
   */
  get channelInterpretation() {
    return this._getChannelProperties().channelInterpretation;
  }
  set channelInterpretation(t) {
    const n = this._getChannelProperties();
    this._setChannelProperties(Object.assign(n, { channelInterpretation: t }));
  }
  //-------------------------------------
  // CONNECTIONS
  //-------------------------------------
  /**
   * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode
   * @param destination The output to connect to
   * @param outputNum The output to connect from
   * @param inputNum The input to connect to
   */
  connect(t, n = 0, i = 0) {
    return ru(this, t, n, i), this;
  }
  /**
   * Connect the output to the context's destination node.
   * @example
   * const osc = new Tone.Oscillator("C2").start();
   * osc.toDestination();
   */
  toDestination() {
    return this.connect(this.context.destination), this;
  }
  /**
   * Connect the output to the context's destination node.
   * @see {@link toDestination}
   * @deprecated
   */
  toMaster() {
    return Wy("toMaster() has been renamed toDestination()"), this.toDestination();
  }
  /**
   * disconnect the output
   */
  disconnect(t, n = 0, i = 0) {
    return fq(this, t, n, i), this;
  }
  /**
   * Connect the output of this node to the rest of the nodes in series.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3");
   * player.autostart = true;
   * const filter = new Tone.AutoFilter(4).start();
   * const distortion = new Tone.Distortion(0.5);
   * // connect the player to the filter, distortion and then to the master output
   * player.chain(filter, distortion, Tone.Destination);
   */
  chain(...t) {
    return Ig(this, ...t), this;
  }
  /**
   * connect the output of this node to the rest of the nodes in parallel.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3");
   * player.autostart = true;
   * const pitchShift = new Tone.PitchShift(4).toDestination();
   * const filter = new Tone.Filter("G5").toDestination();
   * // connect a node to the pitch shift and filter in parallel
   * player.fan(pitchShift, filter);
   */
  fan(...t) {
    return t.forEach((n) => this.connect(n)), this;
  }
  /**
   * Dispose and disconnect
   */
  dispose() {
    return super.dispose(), nt(this.input) && (this.input instanceof et ? this.input.dispose() : ta(this.input) && this.input.disconnect()), nt(this.output) && (this.output instanceof et ? this.output.dispose() : ta(this.output) && this.output.disconnect()), this._internalChannels = [], this;
  }
}
function Ig(...e) {
  const t = e.shift();
  e.reduce((n, i) => (n instanceof et ? n.connect(i) : ta(n) && ru(n, i), i), t);
}
function ru(e, t, n = 0, i = 0) {
  for (Xe(nt(e), "Cannot connect from undefined node"), Xe(nt(t), "Cannot connect to undefined node"), (t instanceof et || ta(t)) && Xe(t.numberOfInputs > 0, "Cannot connect to node with no inputs"), Xe(e.numberOfOutputs > 0, "Cannot connect from node with no outputs"); t instanceof et || t instanceof Lt; )
    nt(t.input) && (t = t.input);
  for (; e instanceof et; )
    nt(e.output) && (e = e.output);
  so(t) ? e.connect(t, n) : e.connect(t, n, i);
}
function fq(e, t, n = 0, i = 0) {
  if (nt(t))
    for (; t instanceof et; )
      t = t.input;
  for (; !ta(e); )
    nt(e.output) && (e = e.output);
  so(t) ? e.disconnect(t, n) : ta(t) ? e.disconnect(t, n, i) : e.disconnect();
}
class Ln extends et {
  constructor() {
    super(Te(Ln.getDefaults(), arguments, ["gain", "units"])), this.name = "Gain", this._gainNode = this.context.createGain(), this.input = this._gainNode, this.output = this._gainNode;
    const t = Te(Ln.getDefaults(), arguments, ["gain", "units"]);
    this.gain = new Lt({
      context: this.context,
      convert: t.convert,
      param: this._gainNode.gain,
      units: t.units,
      value: t.gain,
      minValue: t.minValue,
      maxValue: t.maxValue
    }), Jt(this, "gain");
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      convert: !0,
      gain: 1,
      units: "gain"
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._gainNode.disconnect(), this.gain.dispose(), this;
  }
}
class Il extends et {
  constructor(t) {
    super(t), this.onended = wt, this._startTime = -1, this._stopTime = -1, this._timeout = -1, this.output = new Ln({
      context: this.context,
      gain: 0
    }), this._gainNode = this.output, this.getStateAtTime = function(n) {
      const i = this.toSeconds(n);
      return this._startTime !== -1 && i >= this._startTime && (this._stopTime === -1 || i <= this._stopTime) ? "started" : "stopped";
    }, this._fadeIn = t.fadeIn, this._fadeOut = t.fadeOut, this._curve = t.curve, this.onended = t.onended;
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      curve: "linear",
      fadeIn: 0,
      fadeOut: 0,
      onended: wt
    });
  }
  /**
   * Start the source at the given time
   * @param  time When to start the source
   */
  _startGain(t, n = 1) {
    Xe(this._startTime === -1, "Source cannot be started more than once");
    const i = this.toSeconds(this._fadeIn);
    return this._startTime = t + i, this._startTime = Math.max(this._startTime, this.context.currentTime), i > 0 ? (this._gainNode.gain.setValueAtTime(0, t), this._curve === "linear" ? this._gainNode.gain.linearRampToValueAtTime(n, t + i) : this._gainNode.gain.exponentialApproachValueAtTime(n, t, i)) : this._gainNode.gain.setValueAtTime(n, t), this;
  }
  /**
   * Stop the source node at the given time.
   * @param time When to stop the source
   */
  stop(t) {
    return this.log("stop", t), this._stopGain(this.toSeconds(t)), this;
  }
  /**
   * Stop the source at the given time
   * @param  time When to stop the source
   */
  _stopGain(t) {
    Xe(this._startTime !== -1, "'start' must be called before 'stop'"), this.cancelStop();
    const n = this.toSeconds(this._fadeOut);
    return this._stopTime = this.toSeconds(t) + n, this._stopTime = Math.max(this._stopTime, this.now()), n > 0 ? this._curve === "linear" ? this._gainNode.gain.linearRampTo(0, n, t) : this._gainNode.gain.targetRampTo(0, n, t) : (this._gainNode.gain.cancelAndHoldAtTime(t), this._gainNode.gain.setValueAtTime(0, t)), this.context.clearTimeout(this._timeout), this._timeout = this.context.setTimeout(() => {
      const i = this._curve === "exponential" ? n * 2 : 0;
      this._stopSource(this.now() + i), this._onended();
    }, this._stopTime - this.context.currentTime), this;
  }
  /**
   * Invoke the onended callback
   */
  _onended() {
    if (this.onended !== wt && (this.onended(this), this.onended = wt, !this.context.isOffline)) {
      const t = () => this.dispose();
      typeof window.requestIdleCallback < "u" ? window.requestIdleCallback(t) : setTimeout(t, 1e3);
    }
  }
  /**
   * Get the playback state at the current time
   */
  get state() {
    return this.getStateAtTime(this.now());
  }
  /**
   * Cancel a scheduled stop event
   */
  cancelStop() {
    return this.log("cancelStop"), Xe(this._startTime !== -1, "Source is not started"), this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime), this.context.clearTimeout(this._timeout), this._stopTime = -1, this;
  }
  dispose() {
    return super.dispose(), this._gainNode.dispose(), this.onended = wt, this;
  }
}
class Kf extends Il {
  constructor() {
    super(Te(Kf.getDefaults(), arguments, ["offset"])), this.name = "ToneConstantSource", this._source = this.context.createConstantSource();
    const t = Te(Kf.getDefaults(), arguments, ["offset"]);
    ru(this._source, this._gainNode), this.offset = new Lt({
      context: this.context,
      convert: t.convert,
      param: this._source.offset,
      units: t.units,
      value: t.offset,
      minValue: t.minValue,
      maxValue: t.maxValue
    });
  }
  static getDefaults() {
    return Object.assign(Il.getDefaults(), {
      convert: !0,
      offset: 1,
      units: "number"
    });
  }
  /**
   * Start the source node at the given time
   * @param  time When to start the source
   */
  start(t) {
    const n = this.toSeconds(t);
    return this.log("start", n), this._startGain(n), this._source.start(n), this;
  }
  _stopSource(t) {
    this._source.stop(t);
  }
  dispose() {
    return super.dispose(), this.state === "started" && this.stop(), this._source.disconnect(), this.offset.dispose(), this;
  }
}
class bn extends et {
  constructor() {
    super(Te(bn.getDefaults(), arguments, ["value", "units"])), this.name = "Signal", this.override = !0;
    const t = Te(bn.getDefaults(), arguments, ["value", "units"]);
    this.output = this._constantSource = new Kf({
      context: this.context,
      convert: t.convert,
      offset: t.value,
      units: t.units,
      minValue: t.minValue,
      maxValue: t.maxValue
    }), this._constantSource.start(0), this.input = this._param = this._constantSource.offset;
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      convert: !0,
      units: "number",
      value: 0
    });
  }
  connect(t, n = 0, i = 0) {
    return qy(this, t, n, i), this;
  }
  dispose() {
    return super.dispose(), this._param.dispose(), this._constantSource.dispose(), this;
  }
  //-------------------------------------
  // ABSTRACT PARAM INTERFACE
  // just a proxy for the ConstantSourceNode's offset AudioParam
  // all docs are generated from AbstractParam.ts
  //-------------------------------------
  setValueAtTime(t, n) {
    return this._param.setValueAtTime(t, n), this;
  }
  getValueAtTime(t) {
    return this._param.getValueAtTime(t);
  }
  setRampPoint(t) {
    return this._param.setRampPoint(t), this;
  }
  linearRampToValueAtTime(t, n) {
    return this._param.linearRampToValueAtTime(t, n), this;
  }
  exponentialRampToValueAtTime(t, n) {
    return this._param.exponentialRampToValueAtTime(t, n), this;
  }
  exponentialRampTo(t, n, i) {
    return this._param.exponentialRampTo(t, n, i), this;
  }
  linearRampTo(t, n, i) {
    return this._param.linearRampTo(t, n, i), this;
  }
  targetRampTo(t, n, i) {
    return this._param.targetRampTo(t, n, i), this;
  }
  exponentialApproachValueAtTime(t, n, i) {
    return this._param.exponentialApproachValueAtTime(t, n, i), this;
  }
  setTargetAtTime(t, n, i) {
    return this._param.setTargetAtTime(t, n, i), this;
  }
  setValueCurveAtTime(t, n, i, r) {
    return this._param.setValueCurveAtTime(t, n, i, r), this;
  }
  cancelScheduledValues(t) {
    return this._param.cancelScheduledValues(t), this;
  }
  cancelAndHoldAtTime(t) {
    return this._param.cancelAndHoldAtTime(t), this;
  }
  rampTo(t, n, i) {
    return this._param.rampTo(t, n, i), this;
  }
  get value() {
    return this._param.value;
  }
  set value(t) {
    this._param.value = t;
  }
  get convert() {
    return this._param.convert;
  }
  set convert(t) {
    this._param.convert = t;
  }
  get units() {
    return this._param.units;
  }
  get overridden() {
    return this._param.overridden;
  }
  set overridden(t) {
    this._param.overridden = t;
  }
  get maxValue() {
    return this._param.maxValue;
  }
  get minValue() {
    return this._param.minValue;
  }
  /**
   * @see {@link Param.apply}.
   */
  apply(t) {
    return this._param.apply(t), this;
  }
}
function qy(e, t, n, i) {
  (t instanceof Lt || so(t) || t instanceof bn && t.override) && (t.cancelScheduledValues(0), t.setValueAtTime(0, 0), t instanceof bn && (t.overridden = !0)), ru(e, t, n, i);
}
class Xf extends Lt {
  constructor() {
    super(Te(Xf.getDefaults(), arguments, ["value"])), this.name = "TickParam", this._events = new Ki(1 / 0), this._multiplier = 1;
    const t = Te(Xf.getDefaults(), arguments, ["value"]);
    this._multiplier = t.multiplier, this._events.cancel(0), this._events.add({
      ticks: 0,
      time: 0,
      type: "setValueAtTime",
      value: this._fromType(t.value)
    }), this.setValueAtTime(t.value, 0);
  }
  static getDefaults() {
    return Object.assign(Lt.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }
  setTargetAtTime(t, n, i) {
    n = this.toSeconds(n), this.setRampPoint(n);
    const r = this._fromType(t), s = this._events.get(n), a = Math.round(Math.max(1 / i, 1));
    for (let o = 0; o <= a; o++) {
      const l = i * o + n, u = this._exponentialApproach(s.time, s.value, r, i, l);
      this.linearRampToValueAtTime(this._toType(u), l);
    }
    return this;
  }
  setValueAtTime(t, n) {
    const i = this.toSeconds(n);
    super.setValueAtTime(t, n);
    const r = this._events.get(i), s = this._events.previousEvent(r), a = this._getTicksUntilEvent(s, i);
    return r.ticks = Math.max(a, 0), this;
  }
  linearRampToValueAtTime(t, n) {
    const i = this.toSeconds(n);
    super.linearRampToValueAtTime(t, n);
    const r = this._events.get(i), s = this._events.previousEvent(r), a = this._getTicksUntilEvent(s, i);
    return r.ticks = Math.max(a, 0), this;
  }
  exponentialRampToValueAtTime(t, n) {
    n = this.toSeconds(n);
    const i = this._fromType(t), r = this._events.get(n), s = Math.round(Math.max((n - r.time) * 10, 1)), a = (n - r.time) / s;
    for (let o = 0; o <= s; o++) {
      const l = a * o + r.time, u = this._exponentialInterpolate(r.time, r.value, n, i, l);
      this.linearRampToValueAtTime(this._toType(u), l);
    }
    return this;
  }
  /**
   * Returns the tick value at the time. Takes into account
   * any automation curves scheduled on the signal.
   * @param  event The time to get the tick count at
   * @return The number of ticks which have elapsed at the time given any automations.
   */
  _getTicksUntilEvent(t, n) {
    if (t === null)
      t = {
        ticks: 0,
        time: 0,
        type: "setValueAtTime",
        value: 0
      };
    else if (Zi(t.ticks)) {
      const a = this._events.previousEvent(t);
      t.ticks = this._getTicksUntilEvent(a, t.time);
    }
    const i = this._fromType(this.getValueAtTime(t.time));
    let r = this._fromType(this.getValueAtTime(n));
    const s = this._events.get(n);
    return s && s.time === n && s.type === "setValueAtTime" && (r = this._fromType(this.getValueAtTime(n - this.sampleTime))), 0.5 * (n - t.time) * (i + r) + t.ticks;
  }
  /**
   * Returns the tick value at the time. Takes into account
   * any automation curves scheduled on the signal.
   * @param  time The time to get the tick count at
   * @return The number of ticks which have elapsed at the time given any automations.
   */
  getTicksAtTime(t) {
    const n = this.toSeconds(t), i = this._events.get(n);
    return Math.max(this._getTicksUntilEvent(i, n), 0);
  }
  /**
   * Return the elapsed time of the number of ticks from the given time
   * @param ticks The number of ticks to calculate
   * @param  time The time to get the next tick from
   * @return The duration of the number of ticks from the given time in seconds
   */
  getDurationOfTicks(t, n) {
    const i = this.toSeconds(n), r = this.getTicksAtTime(n);
    return this.getTimeOfTick(r + t) - i;
  }
  /**
   * Given a tick, returns the time that tick occurs at.
   * @return The time that the tick occurs.
   */
  getTimeOfTick(t) {
    const n = this._events.get(t, "ticks"), i = this._events.getAfter(t, "ticks");
    if (n && n.ticks === t)
      return n.time;
    if (n && i && i.type === "linearRampToValueAtTime" && n.value !== i.value) {
      const r = this._fromType(this.getValueAtTime(n.time)), a = (this._fromType(this.getValueAtTime(i.time)) - r) / (i.time - n.time), o = Math.sqrt(Math.pow(r, 2) - 2 * a * (n.ticks - t)), l = (-r + o) / a, u = (-r - o) / a;
      return (l > 0 ? l : u) + n.time;
    } else
      return n ? n.value === 0 ? 1 / 0 : n.time + (t - n.ticks) / n.value : t / this._initialValue;
  }
  /**
   * Convert some number of ticks their the duration in seconds accounting
   * for any automation curves starting at the given time.
   * @param  ticks The number of ticks to convert to seconds.
   * @param  when  When along the automation timeline to convert the ticks.
   * @return The duration in seconds of the ticks.
   */
  ticksToTime(t, n) {
    return this.getDurationOfTicks(t, n);
  }
  /**
   * The inverse of {@link ticksToTime}. Convert a duration in
   * seconds to the corresponding number of ticks accounting for any
   * automation curves starting at the given time.
   * @param  duration The time interval to convert to ticks.
   * @param  when When along the automation timeline to convert the ticks.
   * @return The duration in ticks.
   */
  timeToTicks(t, n) {
    const i = this.toSeconds(n), r = this.toSeconds(t), s = this.getTicksAtTime(i);
    return this.getTicksAtTime(i + r) - s;
  }
  /**
   * Convert from the type when the unit value is BPM
   */
  _fromType(t) {
    return this.units === "bpm" && this.multiplier ? 1 / (60 / t / this.multiplier) : super._fromType(t);
  }
  /**
   * Special case of type conversion where the units === "bpm"
   */
  _toType(t) {
    return this.units === "bpm" && this.multiplier ? t / this.multiplier * 60 : super._toType(t);
  }
  /**
   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
   */
  get multiplier() {
    return this._multiplier;
  }
  set multiplier(t) {
    const n = this.value;
    this._multiplier = t, this.cancelScheduledValues(0), this.setValueAtTime(n, 0);
  }
}
class Jf extends bn {
  constructor() {
    super(Te(Jf.getDefaults(), arguments, ["value"])), this.name = "TickSignal";
    const t = Te(Jf.getDefaults(), arguments, ["value"]);
    this.input = this._param = new Xf({
      context: this.context,
      convert: t.convert,
      multiplier: t.multiplier,
      param: this._constantSource.offset,
      units: t.units,
      value: t.value
    });
  }
  static getDefaults() {
    return Object.assign(bn.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }
  ticksToTime(t, n) {
    return this._param.ticksToTime(t, n);
  }
  timeToTicks(t, n) {
    return this._param.timeToTicks(t, n);
  }
  getTimeOfTick(t) {
    return this._param.getTimeOfTick(t);
  }
  getDurationOfTicks(t, n) {
    return this._param.getDurationOfTicks(t, n);
  }
  getTicksAtTime(t) {
    return this._param.getTicksAtTime(t);
  }
  /**
   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
   */
  get multiplier() {
    return this._param.multiplier;
  }
  set multiplier(t) {
    this._param.multiplier = t;
  }
  dispose() {
    return super.dispose(), this._param.dispose(), this;
  }
}
class Qf extends pi {
  constructor() {
    super(Te(Qf.getDefaults(), arguments, ["frequency"])), this.name = "TickSource", this._state = new Uy(), this._tickOffset = new Ki(), this._ticksAtTime = new Ki(), this._secondsAtTime = new Ki();
    const t = Te(Qf.getDefaults(), arguments, ["frequency"]);
    this.frequency = new Jf({
      context: this.context,
      units: t.units,
      value: t.frequency
    }), Jt(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.setTicksAtTime(0, 0);
  }
  static getDefaults() {
    return Object.assign({
      frequency: 1,
      units: "hertz"
    }, pi.getDefaults());
  }
  /**
   * Returns the playback state of the source, either "started", "stopped" or "paused".
   */
  get state() {
    return this.getStateAtTime(this.now());
  }
  /**
   * Start the clock at the given time. Optionally pass in an offset
   * of where to start the tick counter from.
   * @param  time    The time the clock should start
   * @param offset The number of ticks to start the source at
   */
  start(t, n) {
    const i = this.toSeconds(t);
    return this._state.getValueAtTime(i) !== "started" && (this._state.setStateAtTime("started", i), nt(n) && this.setTicksAtTime(n, i), this._ticksAtTime.cancel(i), this._secondsAtTime.cancel(i)), this;
  }
  /**
   * Stop the clock. Stopping the clock resets the tick counter to 0.
   * @param time The time when the clock should stop.
   */
  stop(t) {
    const n = this.toSeconds(t);
    if (this._state.getValueAtTime(n) === "stopped") {
      const i = this._state.get(n);
      i && i.time > 0 && (this._tickOffset.cancel(i.time), this._state.cancel(i.time));
    }
    return this._state.cancel(n), this._state.setStateAtTime("stopped", n), this.setTicksAtTime(0, n), this._ticksAtTime.cancel(n), this._secondsAtTime.cancel(n), this;
  }
  /**
   * Pause the clock. Pausing does not reset the tick counter.
   * @param time The time when the clock should stop.
   */
  pause(t) {
    const n = this.toSeconds(t);
    return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n), this._ticksAtTime.cancel(n), this._secondsAtTime.cancel(n)), this;
  }
  /**
   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.
   * @param time When to clear the events after
   */
  cancel(t) {
    return t = this.toSeconds(t), this._state.cancel(t), this._tickOffset.cancel(t), this._ticksAtTime.cancel(t), this._secondsAtTime.cancel(t), this;
  }
  /**
   * Get the elapsed ticks at the given time
   * @param  time  When to get the tick value
   * @return The number of ticks
   */
  getTicksAtTime(t) {
    const n = this.toSeconds(t), i = this._state.getLastState("stopped", n), r = this._ticksAtTime.get(n), s = { state: "paused", time: n };
    this._state.add(s);
    let a = r || i, o = r ? r.ticks : 0, l = null;
    return this._state.forEachBetween(a.time, n + this.sampleTime, (u) => {
      let c = a.time;
      const d = this._tickOffset.get(u.time);
      d && d.time >= a.time && (o = d.ticks, c = d.time), a.state === "started" && u.state !== "started" && (o += this.frequency.getTicksAtTime(u.time) - this.frequency.getTicksAtTime(c), u.time !== s.time && (l = { state: u.state, time: u.time, ticks: o })), a = u;
    }), this._state.remove(s), l && this._ticksAtTime.add(l), o;
  }
  /**
   * The number of times the callback was invoked. Starts counting at 0
   * and increments after the callback was invoked. Returns -1 when stopped.
   */
  get ticks() {
    return this.getTicksAtTime(this.now());
  }
  set ticks(t) {
    this.setTicksAtTime(t, this.now());
  }
  /**
   * The time since ticks=0 that the TickSource has been running. Accounts
   * for tempo curves
   */
  get seconds() {
    return this.getSecondsAtTime(this.now());
  }
  set seconds(t) {
    const n = this.now(), i = this.frequency.timeToTicks(t, n);
    this.setTicksAtTime(i, n);
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(t) {
    t = this.toSeconds(t);
    const n = this._state.getLastState("stopped", t), i = { state: "paused", time: t };
    this._state.add(i);
    const r = this._secondsAtTime.get(t);
    let s = r || n, a = r ? r.seconds : 0, o = null;
    return this._state.forEachBetween(s.time, t + this.sampleTime, (l) => {
      let u = s.time;
      const c = this._tickOffset.get(l.time);
      c && c.time >= s.time && (a = c.seconds, u = c.time), s.state === "started" && l.state !== "started" && (a += l.time - u, l.time !== i.time && (o = { state: l.state, time: l.time, seconds: a })), s = l;
    }), this._state.remove(i), o && this._secondsAtTime.add(o), a;
  }
  /**
   * Set the clock's ticks at the given time.
   * @param  ticks The tick value to set
   * @param  time  When to set the tick value
   */
  setTicksAtTime(t, n) {
    return n = this.toSeconds(n), this._tickOffset.cancel(n), this._tickOffset.add({
      seconds: this.frequency.getDurationOfTicks(t, n),
      ticks: t,
      time: n
    }), this._ticksAtTime.cancel(n), this._secondsAtTime.cancel(n), this;
  }
  /**
   * Returns the scheduled state at the given time.
   * @param  time  The time to query.
   */
  getStateAtTime(t) {
    return t = this.toSeconds(t), this._state.getValueAtTime(t);
  }
  /**
   * Get the time of the given tick. The second argument
   * is when to test before. Since ticks can be set (with setTicksAtTime)
   * there may be multiple times for a given tick value.
   * @param  tick The tick number.
   * @param  before When to measure the tick value from.
   * @return The time of the tick
   */
  getTimeOfTick(t, n = this.now()) {
    const i = this._tickOffset.get(n), r = this._state.get(n), s = Math.max(i.time, r.time), a = this.frequency.getTicksAtTime(s) + t - i.ticks;
    return this.frequency.getTimeOfTick(a);
  }
  /**
   * Invoke the callback event at all scheduled ticks between the
   * start time and the end time
   * @param  startTime  The beginning of the search range
   * @param  endTime    The end of the search range
   * @param  callback   The callback to invoke with each tick
   */
  forEachTickBetween(t, n, i) {
    let r = this._state.get(t);
    this._state.forEachBetween(t, n, (a) => {
      r && r.state === "started" && a.state !== "started" && this.forEachTickBetween(Math.max(r.time, t), a.time - this.sampleTime, i), r = a;
    });
    let s = null;
    if (r && r.state === "started") {
      const a = Math.max(r.time, t), o = this.frequency.getTicksAtTime(a), l = this.frequency.getTicksAtTime(r.time), u = o - l;
      let c = Math.ceil(u) - u;
      c = cr(c, 1) ? 0 : c;
      let d = this.frequency.getTimeOfTick(o + c);
      for (; d < n; ) {
        try {
          i(d, Math.round(this.getTicksAtTime(d)));
        } catch (f) {
          s = f;
          break;
        }
        d += this.frequency.getDurationOfTicks(1, d);
      }
    }
    if (s)
      throw s;
    return this;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._state.dispose(), this._tickOffset.dispose(), this._ticksAtTime.dispose(), this._secondsAtTime.dispose(), this.frequency.dispose(), this;
  }
}
class dc extends pi {
  constructor() {
    super(Te(dc.getDefaults(), arguments, ["callback", "frequency"])), this.name = "Clock", this.callback = wt, this._lastUpdate = 0, this._state = new Uy("stopped"), this._boundLoop = this._loop.bind(this);
    const t = Te(dc.getDefaults(), arguments, ["callback", "frequency"]);
    this.callback = t.callback, this._tickSource = new Qf({
      context: this.context,
      frequency: t.frequency,
      units: t.units
    }), this._lastUpdate = 0, this.frequency = this._tickSource.frequency, Jt(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.context.on("tick", this._boundLoop);
  }
  static getDefaults() {
    return Object.assign(pi.getDefaults(), {
      callback: wt,
      frequency: 1,
      units: "hertz"
    });
  }
  /**
   * Returns the playback state of the source, either "started", "stopped" or "paused".
   */
  get state() {
    return this._state.getValueAtTime(this.now());
  }
  /**
   * Start the clock at the given time. Optionally pass in an offset
   * of where to start the tick counter from.
   * @param  time    The time the clock should start
   * @param offset  Where the tick counter starts counting from.
   */
  start(t, n) {
    bx(this.context);
    const i = this.toSeconds(t);
    return this.log("start", i), this._state.getValueAtTime(i) !== "started" && (this._state.setStateAtTime("started", i), this._tickSource.start(i, n), i < this._lastUpdate && this.emit("start", i, n)), this;
  }
  /**
   * Stop the clock. Stopping the clock resets the tick counter to 0.
   * @param time The time when the clock should stop.
   * @example
   * const clock = new Tone.Clock(time => {
   * 	console.log(time);
   * }, 1);
   * clock.start();
   * // stop the clock after 10 seconds
   * clock.stop("+10");
   */
  stop(t) {
    const n = this.toSeconds(t);
    return this.log("stop", n), this._state.cancel(n), this._state.setStateAtTime("stopped", n), this._tickSource.stop(n), n < this._lastUpdate && this.emit("stop", n), this;
  }
  /**
   * Pause the clock. Pausing does not reset the tick counter.
   * @param time The time when the clock should stop.
   */
  pause(t) {
    const n = this.toSeconds(t);
    return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n), this._tickSource.pause(n), n < this._lastUpdate && this.emit("pause", n)), this;
  }
  /**
   * The number of times the callback was invoked. Starts counting at 0
   * and increments after the callback was invoked.
   */
  get ticks() {
    return Math.ceil(this.getTicksAtTime(this.now()));
  }
  set ticks(t) {
    this._tickSource.ticks = t;
  }
  /**
   * The time since ticks=0 that the Clock has been running. Accounts for tempo curves
   */
  get seconds() {
    return this._tickSource.seconds;
  }
  set seconds(t) {
    this._tickSource.seconds = t;
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(t) {
    return this._tickSource.getSecondsAtTime(t);
  }
  /**
   * Set the clock's ticks at the given time.
   * @param  ticks The tick value to set
   * @param  time  When to set the tick value
   */
  setTicksAtTime(t, n) {
    return this._tickSource.setTicksAtTime(t, n), this;
  }
  /**
   * Get the time of the given tick. The second argument
   * is when to test before. Since ticks can be set (with setTicksAtTime)
   * there may be multiple times for a given tick value.
   * @param  tick The tick number.
   * @param  before When to measure the tick value from.
   * @return The time of the tick
   */
  getTimeOfTick(t, n = this.now()) {
    return this._tickSource.getTimeOfTick(t, n);
  }
  /**
   * Get the clock's ticks at the given time.
   * @param  time  When to get the tick value
   * @return The tick value at the given time.
   */
  getTicksAtTime(t) {
    return this._tickSource.getTicksAtTime(t);
  }
  /**
   * Get the time of the next tick
   * @param  offset The tick number.
   */
  nextTickTime(t, n) {
    const i = this.toSeconds(n), r = this.getTicksAtTime(i);
    return this._tickSource.getTimeOfTick(r + t, i);
  }
  /**
   * The scheduling loop.
   */
  _loop() {
    const t = this._lastUpdate, n = this.now();
    this._lastUpdate = n, this.log("loop", t, n), t !== n && (this._state.forEachBetween(t, n, (i) => {
      switch (i.state) {
        case "started":
          const r = this._tickSource.getTicksAtTime(i.time);
          this.emit("start", i.time, r);
          break;
        case "stopped":
          i.time !== 0 && this.emit("stop", i.time);
          break;
        case "paused":
          this.emit("pause", i.time);
          break;
      }
    }), this._tickSource.forEachTickBetween(t, n, (i, r) => {
      this.callback(i, r);
    }));
  }
  /**
   * Returns the scheduled state at the given time.
   * @param  time  The time to query.
   * @return  The name of the state input in setStateAtTime.
   * @example
   * const clock = new Tone.Clock();
   * clock.start("+0.1");
   * clock.getStateAtTime("+0.1"); // returns "started"
   */
  getStateAtTime(t) {
    const n = this.toSeconds(t);
    return this._state.getValueAtTime(n);
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this.context.off("tick", this._boundLoop), this._tickSource.dispose(), this._state.dispose(), this;
  }
}
rd.mixin(dc);
class Gy extends Ps {
  constructor() {
    super(), this.name = "ToneAudioBuffers", this._buffers = /* @__PURE__ */ new Map(), this._loadingCount = 0;
    const t = Te(Gy.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
    this.baseUrl = t.baseUrl, Object.keys(t.urls).forEach((n) => {
      this._loadingCount++;
      const i = t.urls[n];
      this.add(n, i, this._bufferLoaded.bind(this, t.onload), t.onerror);
    });
  }
  static getDefaults() {
    return {
      baseUrl: "",
      onerror: wt,
      onload: wt,
      urls: {}
    };
  }
  /**
   * True if the buffers object has a buffer by that name.
   * @param  name  The key or index of the buffer.
   */
  has(t) {
    return this._buffers.has(t.toString());
  }
  /**
   * Get a buffer by name. If an array was loaded,
   * then use the array index.
   * @param  name  The key or index of the buffer.
   */
  get(t) {
    return Xe(this.has(t), `ToneAudioBuffers has no buffer named: ${t}`), this._buffers.get(t.toString());
  }
  /**
   * A buffer was loaded. decrement the counter.
   */
  _bufferLoaded(t) {
    this._loadingCount--, this._loadingCount === 0 && t && t();
  }
  /**
   * If the buffers are loaded or not
   */
  get loaded() {
    return Array.from(this._buffers).every(([t, n]) => n.loaded);
  }
  /**
   * Add a buffer by name and url to the Buffers
   * @param  name      A unique name to give the buffer
   * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.
   * @param  callback  The callback to invoke when the url is loaded.
   * @param  onerror  Invoked if the buffer can't be loaded
   */
  add(t, n, i = wt, r = wt) {
    return _s(n) ? (this.baseUrl && n.trim().substring(0, 11).toLowerCase() === "data:audio/" && (this.baseUrl = ""), this._buffers.set(t.toString(), new Vt(this.baseUrl + n, i, r))) : this._buffers.set(t.toString(), new Vt(n, i, r)), this;
  }
  dispose() {
    return super.dispose(), this._buffers.forEach((t) => t.dispose()), this._buffers.clear(), this;
  }
}
class sl extends ju {
  constructor() {
    super(...arguments), this.name = "Ticks", this.defaultUnits = "i";
  }
  /**
   * Get the current time in the given units
   */
  _now() {
    return this.context.transport.ticks;
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(t) {
    return this._getPPQ() * t;
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(t) {
    return Math.floor(t / (60 / this._getBpm()) * this._getPPQ());
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(t) {
    return t;
  }
  /**
   * Return the time in ticks
   */
  toTicks() {
    return this.valueOf();
  }
  /**
   * Return the time in seconds
   */
  toSeconds() {
    return this.valueOf() / this._getPPQ() * (60 / this._getBpm());
  }
}
class hq extends pi {
  constructor() {
    super(...arguments), this.name = "Draw", this.expiration = 0.25, this.anticipation = 8e-3, this._events = new Ki(), this._boundDrawLoop = this._drawLoop.bind(this), this._animationFrame = -1;
  }
  /**
   * Schedule a function at the given time to be invoked
   * on the nearest animation frame.
   * @param  callback  Callback is invoked at the given time.
   * @param  time      The time relative to the AudioContext time to invoke the callback.
   * @example
   * Tone.Transport.scheduleRepeat(time => {
   * 	Tone.Draw.schedule(() => console.log(time), time);
   * }, 1);
   * Tone.Transport.start();
   */
  schedule(t, n) {
    return this._events.add({
      callback: t,
      time: this.toSeconds(n)
    }), this._events.length === 1 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop)), this;
  }
  /**
   * Cancel events scheduled after the given time
   * @param  after  Time after which scheduled events will be removed from the scheduling timeline.
   */
  cancel(t) {
    return this._events.cancel(this.toSeconds(t)), this;
  }
  /**
   * The draw loop
   */
  _drawLoop() {
    const t = this.context.currentTime;
    for (; this._events.length && this._events.peek().time - this.anticipation <= t; ) {
      const n = this._events.shift();
      n && t - n.time <= this.expiration && n.callback();
    }
    this._events.length > 0 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop));
  }
  dispose() {
    return super.dispose(), this._events.dispose(), cancelAnimationFrame(this._animationFrame), this;
  }
}
sm((e) => {
  e.draw = new hq({ context: e });
});
am((e) => {
  e.draw.dispose();
});
class mq extends Ps {
  constructor() {
    super(...arguments), this.name = "IntervalTimeline", this._root = null, this._length = 0;
  }
  /**
   * The event to add to the timeline. All events must
   * have a time and duration value
   * @param  event  The event to add to the timeline
   */
  add(t) {
    Xe(nt(t.time), "Events must have a time property"), Xe(nt(t.duration), "Events must have a duration parameter"), t.time = t.time.valueOf();
    let n = new vq(t.time, t.time + t.duration, t);
    for (this._root === null ? this._root = n : this._root.insert(n), this._length++; n !== null; )
      n.updateHeight(), n.updateMax(), this._rebalance(n), n = n.parent;
    return this;
  }
  /**
   * Remove an event from the timeline.
   * @param  event  The event to remove from the timeline
   */
  remove(t) {
    if (this._root !== null) {
      const n = [];
      this._root.search(t.time, n);
      for (const i of n)
        if (i.event === t) {
          this._removeNode(i), this._length--;
          break;
        }
    }
    return this;
  }
  /**
   * The number of items in the timeline.
   * @readOnly
   */
  get length() {
    return this._length;
  }
  /**
   * Remove events whose time time is after the given time
   * @param  after  The time to query.
   */
  cancel(t) {
    return this.forEachFrom(t, (n) => this.remove(n)), this;
  }
  /**
   * Set the root node as the given node
   */
  _setRoot(t) {
    this._root = t, this._root !== null && (this._root.parent = null);
  }
  /**
   * Replace the references to the node in the node's parent
   * with the replacement node.
   */
  _replaceNodeInParent(t, n) {
    t.parent !== null ? (t.isLeftChild() ? t.parent.left = n : t.parent.right = n, this._rebalance(t.parent)) : this._setRoot(n);
  }
  /**
   * Remove the node from the tree and replace it with
   * a successor which follows the schema.
   */
  _removeNode(t) {
    if (t.left === null && t.right === null)
      this._replaceNodeInParent(t, null);
    else if (t.right === null)
      this._replaceNodeInParent(t, t.left);
    else if (t.left === null)
      this._replaceNodeInParent(t, t.right);
    else {
      const n = t.getBalance();
      let i, r = null;
      if (n > 0)
        if (t.left.right === null)
          i = t.left, i.right = t.right, r = i;
        else {
          for (i = t.left.right; i.right !== null; )
            i = i.right;
          i.parent && (i.parent.right = i.left, r = i.parent, i.left = t.left, i.right = t.right);
        }
      else if (t.right.left === null)
        i = t.right, i.left = t.left, r = i;
      else {
        for (i = t.right.left; i.left !== null; )
          i = i.left;
        i.parent && (i.parent.left = i.right, r = i.parent, i.left = t.left, i.right = t.right);
      }
      t.parent !== null ? t.isLeftChild() ? t.parent.left = i : t.parent.right = i : this._setRoot(i), r && this._rebalance(r);
    }
    t.dispose();
  }
  /**
   * Rotate the tree to the left
   */
  _rotateLeft(t) {
    const n = t.parent, i = t.isLeftChild(), r = t.right;
    r && (t.right = r.left, r.left = t), n !== null ? i ? n.left = r : n.right = r : this._setRoot(r);
  }
  /**
   * Rotate the tree to the right
   */
  _rotateRight(t) {
    const n = t.parent, i = t.isLeftChild(), r = t.left;
    r && (t.left = r.right, r.right = t), n !== null ? i ? n.left = r : n.right = r : this._setRoot(r);
  }
  /**
   * Balance the BST
   */
  _rebalance(t) {
    const n = t.getBalance();
    n > 1 && t.left ? t.left.getBalance() < 0 ? this._rotateLeft(t.left) : this._rotateRight(t) : n < -1 && t.right && (t.right.getBalance() > 0 ? this._rotateRight(t.right) : this._rotateLeft(t));
  }
  /**
   * Get an event whose time and duration span the give time. Will
   * return the match whose "time" value is closest to the given time.
   * @return  The event which spans the desired time
   */
  get(t) {
    if (this._root !== null) {
      const n = [];
      if (this._root.search(t, n), n.length > 0) {
        let i = n[0];
        for (let r = 1; r < n.length; r++)
          n[r].low > i.low && (i = n[r]);
        return i.event;
      }
    }
    return null;
  }
  /**
   * Iterate over everything in the timeline.
   * @param  callback The callback to invoke with every item
   */
  forEach(t) {
    if (this._root !== null) {
      const n = [];
      this._root.traverse((i) => n.push(i)), n.forEach((i) => {
        i.event && t(i.event);
      });
    }
    return this;
  }
  /**
   * Iterate over everything in the array in which the given time
   * overlaps with the time and duration time of the event.
   * @param  time The time to check if items are overlapping
   * @param  callback The callback to invoke with every item
   */
  forEachAtTime(t, n) {
    if (this._root !== null) {
      const i = [];
      this._root.search(t, i), i.forEach((r) => {
        r.event && n(r.event);
      });
    }
    return this;
  }
  /**
   * Iterate over everything in the array in which the time is greater
   * than or equal to the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachFrom(t, n) {
    if (this._root !== null) {
      const i = [];
      this._root.searchAfter(t, i), i.forEach((r) => {
        r.event && n(r.event);
      });
    }
    return this;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._root !== null && this._root.traverse((t) => t.dispose()), this._root = null, this;
  }
}
class vq {
  constructor(t, n, i) {
    this._left = null, this._right = null, this.parent = null, this.height = 0, this.event = i, this.low = t, this.high = n, this.max = this.high;
  }
  /**
   * Insert a node into the correct spot in the tree
   */
  insert(t) {
    t.low <= this.low ? this.left === null ? this.left = t : this.left.insert(t) : this.right === null ? this.right = t : this.right.insert(t);
  }
  /**
   * Search the tree for nodes which overlap
   * with the given point
   * @param  point  The point to query
   * @param  results  The array to put the results
   */
  search(t, n) {
    t > this.max || (this.left !== null && this.left.search(t, n), this.low <= t && this.high > t && n.push(this), !(this.low > t) && this.right !== null && this.right.search(t, n));
  }
  /**
   * Search the tree for nodes which are less
   * than the given point
   * @param  point  The point to query
   * @param  results  The array to put the results
   */
  searchAfter(t, n) {
    this.low >= t && (n.push(this), this.left !== null && this.left.searchAfter(t, n)), this.right !== null && this.right.searchAfter(t, n);
  }
  /**
   * Invoke the callback on this element and both it's branches
   * @param  {Function}  callback
   */
  traverse(t) {
    t(this), this.left !== null && this.left.traverse(t), this.right !== null && this.right.traverse(t);
  }
  /**
   * Update the height of the node
   */
  updateHeight() {
    this.left !== null && this.right !== null ? this.height = Math.max(this.left.height, this.right.height) + 1 : this.right !== null ? this.height = this.right.height + 1 : this.left !== null ? this.height = this.left.height + 1 : this.height = 0;
  }
  /**
   * Update the height of the node
   */
  updateMax() {
    this.max = this.high, this.left !== null && (this.max = Math.max(this.max, this.left.max)), this.right !== null && (this.max = Math.max(this.max, this.right.max));
  }
  /**
   * The balance is how the leafs are distributed on the node
   * @return  Negative numbers are balanced to the right
   */
  getBalance() {
    let t = 0;
    return this.left !== null && this.right !== null ? t = this.left.height - this.right.height : this.left !== null ? t = this.left.height + 1 : this.right !== null && (t = -(this.right.height + 1)), t;
  }
  /**
   * @returns true if this node is the left child of its parent
   */
  isLeftChild() {
    return this.parent !== null && this.parent.left === this;
  }
  /**
   * get/set the left node
   */
  get left() {
    return this._left;
  }
  set left(t) {
    this._left = t, t !== null && (t.parent = this), this.updateHeight(), this.updateMax();
  }
  /**
   * get/set the right node
   */
  get right() {
    return this._right;
  }
  set right(t) {
    this._right = t, t !== null && (t.parent = this), this.updateHeight(), this.updateMax();
  }
  /**
   * null out references.
   */
  dispose() {
    this.parent = null, this._left = null, this._right = null, this.event = null;
  }
}
class ao extends et {
  constructor() {
    super(Te(ao.getDefaults(), arguments, ["volume"])), this.name = "Volume";
    const t = Te(ao.getDefaults(), arguments, ["volume"]);
    this.input = this.output = new Ln({
      context: this.context,
      gain: t.volume,
      units: "decibels"
    }), this.volume = this.output.gain, Jt(this, "volume"), this._unmutedVolume = t.volume, this.mute = t.mute;
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      mute: !1,
      volume: 0
    });
  }
  /**
   * Mute the output.
   * @example
   * const vol = new Tone.Volume(-12).toDestination();
   * const osc = new Tone.Oscillator().connect(vol).start();
   * // mute the output
   * vol.mute = true;
   */
  get mute() {
    return this.volume.value === -1 / 0;
  }
  set mute(t) {
    !this.mute && t ? (this._unmutedVolume = this.volume.value, this.volume.value = -1 / 0) : this.mute && !t && (this.volume.value = this._unmutedVolume);
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this.input.dispose(), this.volume.dispose(), this;
  }
}
class eh extends et {
  constructor() {
    super(Te(eh.getDefaults(), arguments)), this.name = "Destination", this.input = new ao({ context: this.context }), this.output = new Ln({ context: this.context }), this.volume = this.input.volume;
    const t = Te(eh.getDefaults(), arguments);
    Ig(this.input, this.output, this.context.rawContext.destination), this.mute = t.mute, this._internalChannels = [this.input, this.context.rawContext.destination, this.output];
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      mute: !1,
      volume: 0
    });
  }
  /**
   * Mute the output.
   * @example
   * const oscillator = new Tone.Oscillator().start().toDestination();
   * setTimeout(() => {
   * 	// mute the output
   * 	Tone.Destination.mute = true;
   * }, 1000);
   */
  get mute() {
    return this.input.mute;
  }
  set mute(t) {
    this.input.mute = t;
  }
  /**
   * Add a master effects chain. NOTE: this will disconnect any nodes which were previously
   * chained in the master effects chain.
   * @param args All arguments will be connected in a row and the Master will be routed through it.
   * @example
   * // route all audio through a filter and compressor
   * const lowpass = new Tone.Filter(800, "lowpass");
   * const compressor = new Tone.Compressor(-18);
   * Tone.Destination.chain(lowpass, compressor);
   */
  chain(...t) {
    return this.input.disconnect(), t.unshift(this.input), t.push(this.output), Ig(...t), this;
  }
  /**
   * The maximum number of channels the system can output
   * @example
   * console.log(Tone.Destination.maxChannelCount);
   */
  get maxChannelCount() {
    return this.context.rawContext.destination.maxChannelCount;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this.volume.dispose(), this;
  }
}
sm((e) => {
  e.destination = new eh({ context: e });
});
am((e) => {
  e.destination.dispose();
});
class gq extends Ps {
  /**
   * @param initialValue The value to return if there is no scheduled values
   */
  constructor(t) {
    super(), this.name = "TimelineValue", this._timeline = new Ki({ memory: 10 }), this._initialValue = t;
  }
  /**
   * Set the value at the given time
   */
  set(t, n) {
    return this._timeline.add({
      value: t,
      time: n
    }), this;
  }
  /**
   * Get the value at the given time
   */
  get(t) {
    const n = this._timeline.get(t);
    return n ? n.value : this._initialValue;
  }
}
class El extends et {
  constructor() {
    super(Object.assign(Te(El.getDefaults(), arguments, ["context"])));
  }
  connect(t, n = 0, i = 0) {
    return qy(this, t, n, i), this;
  }
}
class Pl extends El {
  constructor() {
    super(Object.assign(Te(Pl.getDefaults(), arguments, ["mapping", "length"]))), this.name = "WaveShaper", this._shaper = this.context.createWaveShaper(), this.input = this._shaper, this.output = this._shaper;
    const t = Te(Pl.getDefaults(), arguments, ["mapping", "length"]);
    wr(t.mapping) || t.mapping instanceof Float32Array ? this.curve = Float32Array.from(t.mapping) : WU(t.mapping) && this.setMap(t.mapping, t.length);
  }
  static getDefaults() {
    return Object.assign(bn.getDefaults(), {
      length: 1024
    });
  }
  /**
   * Uses a mapping function to set the value of the curve.
   * @param mapping The function used to define the values.
   *                The mapping function take two arguments:
   *                the first is the value at the current position
   *                which goes from -1 to 1 over the number of elements
   *                in the curve array. The second argument is the array position.
   * @example
   * const shaper = new Tone.WaveShaper();
   * // map the input signal from [-1, 1] to [0, 10]
   * shaper.setMap((val, index) => (val + 1) * 5);
   */
  setMap(t, n = 1024) {
    const i = new Float32Array(n);
    for (let r = 0, s = n; r < s; r++) {
      const a = r / (s - 1) * 2 - 1;
      i[r] = t(a, r);
    }
    return this.curve = i, this;
  }
  /**
   * The array to set as the waveshaper curve. For linear curves
   * array length does not make much difference, but for complex curves
   * longer arrays will provide smoother interpolation.
   */
  get curve() {
    return this._shaper.curve;
  }
  set curve(t) {
    this._shaper.curve = t;
  }
  /**
   * Specifies what type of oversampling (if any) should be used when
   * applying the shaping curve. Can either be "none", "2x" or "4x".
   */
  get oversample() {
    return this._shaper.oversample;
  }
  set oversample(t) {
    const n = ["none", "2x", "4x"].some((i) => i.includes(t));
    Xe(n, "oversampling must be either 'none', '2x', or '4x'"), this._shaper.oversample = t;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._shaper.disconnect(), this;
  }
}
class th extends El {
  constructor() {
    super(Object.assign(Te(th.getDefaults(), arguments, ["value"]))), this.name = "Pow";
    const t = Te(th.getDefaults(), arguments, ["value"]);
    this._exponentScaler = this.input = this.output = new Pl({
      context: this.context,
      mapping: this._expFunc(t.value),
      length: 8192
    }), this._exponent = t.value;
  }
  static getDefaults() {
    return Object.assign(El.getDefaults(), {
      value: 1
    });
  }
  /**
   * the function which maps the waveshaper
   * @param exponent exponent value
   */
  _expFunc(t) {
    return (n) => Math.pow(Math.abs(n), t);
  }
  /**
   * The value of the exponent.
   */
  get value() {
    return this._exponent;
  }
  set value(t) {
    this._exponent = t, this._exponentScaler.setMap(this._expFunc(this._exponent));
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._exponentScaler.dispose(), this;
  }
}
class aa {
  /**
   * @param transport The transport object which the event belongs to
   */
  constructor(t, n) {
    this.id = aa._eventId++, this._remainderTime = 0;
    const i = Object.assign(aa.getDefaults(), n);
    this.transport = t, this.callback = i.callback, this._once = i.once, this.time = Math.floor(i.time), this._remainderTime = i.time - this.time;
  }
  static getDefaults() {
    return {
      callback: wt,
      once: !1,
      time: 0
    };
  }
  /**
   * Get the time and remainder time.
   */
  get floatTime() {
    return this.time + this._remainderTime;
  }
  /**
   * Invoke the event callback.
   * @param  time  The AudioContext time in seconds of the event
   */
  invoke(t) {
    if (this.callback) {
      const n = this.transport.bpm.getDurationOfTicks(1, t);
      this.callback(t + this._remainderTime * n), this._once && this.transport.clear(this.id);
    }
  }
  /**
   * Clean up
   */
  dispose() {
    return this.callback = void 0, this;
  }
}
aa._eventId = 0;
class Yy extends aa {
  /**
   * @param transport The transport object which the event belongs to
   */
  constructor(t, n) {
    super(t, n), this._currentId = -1, this._nextId = -1, this._nextTick = this.time, this._boundRestart = this._restart.bind(this);
    const i = Object.assign(Yy.getDefaults(), n);
    this.duration = i.duration, this._interval = i.interval, this._nextTick = i.time, this.transport.on("start", this._boundRestart), this.transport.on("loopStart", this._boundRestart), this.transport.on("ticks", this._boundRestart), this.context = this.transport.context, this._restart();
  }
  static getDefaults() {
    return Object.assign({}, aa.getDefaults(), {
      duration: 1 / 0,
      interval: 1,
      once: !1
    });
  }
  /**
   * Invoke the callback. Returns the tick time which
   * the next event should be scheduled at.
   * @param  time  The AudioContext time in seconds of the event
   */
  invoke(t) {
    this._createEvents(t), super.invoke(t);
  }
  /**
   * Create an event on the transport on the nextTick
   */
  _createEvent() {
    return Zf(this._nextTick, this.floatTime + this.duration) ? this.transport.scheduleOnce(this.invoke.bind(this), new sl(this.context, this._nextTick).toSeconds()) : -1;
  }
  /**
   * Push more events onto the timeline to keep up with the position of the timeline
   */
  _createEvents(t) {
    Zf(this._nextTick + this._interval, this.floatTime + this.duration) && (this._nextTick += this._interval, this._currentId = this._nextId, this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new sl(this.context, this._nextTick).toSeconds()));
  }
  /**
   * Re-compute the events when the transport time has changed from a start/ticks/loopStart event
   */
  _restart(t) {
    this.transport.clear(this._currentId), this.transport.clear(this._nextId), this._nextTick = this.floatTime;
    const n = this.transport.getTicksAtTime(t);
    Al(n, this.time) && (this._nextTick = this.floatTime + Math.ceil((n - this.floatTime) / this._interval) * this._interval), this._currentId = this._createEvent(), this._nextTick += this._interval, this._nextId = this._createEvent();
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this.transport.clear(this._currentId), this.transport.clear(this._nextId), this.transport.off("start", this._boundRestart), this.transport.off("loopStart", this._boundRestart), this.transport.off("ticks", this._boundRestart), this;
  }
}
class fc extends pi {
  constructor() {
    super(Te(fc.getDefaults(), arguments)), this.name = "Transport", this._loop = new gq(!1), this._loopStart = 0, this._loopEnd = 0, this._scheduledEvents = {}, this._timeline = new Ki(), this._repeatedEvents = new mq(), this._syncedSignals = [], this._swingAmount = 0;
    const t = Te(fc.getDefaults(), arguments);
    this._ppq = t.ppq, this._clock = new dc({
      callback: this._processTick.bind(this),
      context: this.context,
      frequency: 0,
      units: "bpm"
    }), this._bindClockEvents(), this.bpm = this._clock.frequency, this._clock.frequency.multiplier = t.ppq, this.bpm.setValueAtTime(t.bpm, 0), Jt(this, "bpm"), this._timeSignature = t.timeSignature, this._swingTicks = t.ppq / 2;
  }
  static getDefaults() {
    return Object.assign(pi.getDefaults(), {
      bpm: 120,
      loopEnd: "4m",
      loopStart: 0,
      ppq: 192,
      swing: 0,
      swingSubdivision: "8n",
      timeSignature: 4
    });
  }
  //-------------------------------------
  // 	TICKS
  //-------------------------------------
  /**
   * called on every tick
   * @param  tickTime clock relative tick time
   */
  _processTick(t, n) {
    if (this._loop.get(t) && n >= this._loopEnd && (this.emit("loopEnd", t), this._clock.setTicksAtTime(this._loopStart, t), n = this._loopStart, this.emit("loopStart", t, this._clock.getSecondsAtTime(t)), this.emit("loop", t)), this._swingAmount > 0 && n % this._ppq !== 0 && // not on a downbeat
    n % (this._swingTicks * 2) !== 0) {
      const i = n % (this._swingTicks * 2) / (this._swingTicks * 2), r = Math.sin(i * Math.PI) * this._swingAmount;
      t += new sl(this.context, this._swingTicks * 2 / 3).toSeconds() * r;
    }
    C_(!0), this._timeline.forEachAtTime(n, (i) => i.invoke(t)), C_(!1);
  }
  //-------------------------------------
  // 	SCHEDULABLE EVENTS
  //-------------------------------------
  /**
   * Schedule an event along the timeline.
   * @param callback The callback to be invoked at the time.
   * @param time The time to invoke the callback at.
   * @return The id of the event which can be used for canceling the event.
   * @example
   * // schedule an event on the 16th measure
   * Tone.getTransport().schedule((time) => {
   * 	// invoked on measure 16
   * 	console.log("measure 16!");
   * }, "16:0:0");
   */
  schedule(t, n) {
    const i = new aa(this, {
      callback: t,
      time: new ju(this.context, n).toTicks()
    });
    return this._addEvent(i, this._timeline);
  }
  /**
   * Schedule a repeated event along the timeline. The event will fire
   * at the `interval` starting at the `startTime` and for the specified
   * `duration`.
   * @param  callback   The callback to invoke.
   * @param  interval   The duration between successive callbacks. Must be a positive number.
   * @param  startTime  When along the timeline the events should start being invoked.
   * @param  duration How long the event should repeat.
   * @return  The ID of the scheduled event. Use this to cancel the event.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * // a callback invoked every eighth note after the first measure
   * Tone.getTransport().scheduleRepeat((time) => {
   * 	osc.start(time).stop(time + 0.1);
   * }, "8n", "1m");
   */
  scheduleRepeat(t, n, i, r = 1 / 0) {
    const s = new Yy(this, {
      callback: t,
      duration: new gr(this.context, r).toTicks(),
      interval: new gr(this.context, n).toTicks(),
      time: new ju(this.context, i).toTicks()
    });
    return this._addEvent(s, this._repeatedEvents);
  }
  /**
   * Schedule an event that will be removed after it is invoked.
   * @param callback The callback to invoke once.
   * @param time The time the callback should be invoked.
   * @returns The ID of the scheduled event.
   */
  scheduleOnce(t, n) {
    const i = new aa(this, {
      callback: t,
      once: !0,
      time: new ju(this.context, n).toTicks()
    });
    return this._addEvent(i, this._timeline);
  }
  /**
   * Clear the passed in event id from the timeline
   * @param eventId The id of the event.
   */
  clear(t) {
    if (this._scheduledEvents.hasOwnProperty(t)) {
      const n = this._scheduledEvents[t.toString()];
      n.timeline.remove(n.event), n.event.dispose(), delete this._scheduledEvents[t.toString()];
    }
    return this;
  }
  /**
   * Add an event to the correct timeline. Keep track of the
   * timeline it was added to.
   * @returns the event id which was just added
   */
  _addEvent(t, n) {
    return this._scheduledEvents[t.id.toString()] = {
      event: t,
      timeline: n
    }, n.add(t), t.id;
  }
  /**
   * Remove scheduled events from the timeline after
   * the given time. Repeated events will be removed
   * if their startTime is after the given time
   * @param after Clear all events after this time.
   */
  cancel(t = 0) {
    const n = this.toTicks(t);
    return this._timeline.forEachFrom(n, (i) => this.clear(i.id)), this._repeatedEvents.forEachFrom(n, (i) => this.clear(i.id)), this;
  }
  //-------------------------------------
  // 	START/STOP/PAUSE
  //-------------------------------------
  /**
   * Bind start/stop/pause events from the clock and emit them.
   */
  _bindClockEvents() {
    this._clock.on("start", (t, n) => {
      n = new sl(this.context, n).toSeconds(), this.emit("start", t, n);
    }), this._clock.on("stop", (t) => {
      this.emit("stop", t);
    }), this._clock.on("pause", (t) => {
      this.emit("pause", t);
    });
  }
  /**
   * Returns the playback state of the source, either "started", "stopped", or "paused"
   */
  get state() {
    return this._clock.getStateAtTime(this.now());
  }
  /**
   * Start the transport and all sources synced to the transport.
   * @param  time The time when the transport should start.
   * @param  offset The timeline offset to start the transport.
   * @example
   * // start the transport in one second starting at beginning of the 5th measure.
   * Tone.getTransport().start("+1", "4:0:0");
   */
  start(t, n) {
    this.context.resume();
    let i;
    return nt(n) && (i = this.toTicks(n)), this._clock.start(t, i), this;
  }
  /**
   * Stop the transport and all sources synced to the transport.
   * @param time The time when the transport should stop.
   * @example
   * Tone.getTransport().stop();
   */
  stop(t) {
    return this._clock.stop(t), this;
  }
  /**
   * Pause the transport and all sources synced to the transport.
   */
  pause(t) {
    return this._clock.pause(t), this;
  }
  /**
   * Toggle the current state of the transport. If it is
   * started, it will stop it, otherwise it will start the Transport.
   * @param  time The time of the event
   */
  toggle(t) {
    return t = this.toSeconds(t), this._clock.getStateAtTime(t) !== "started" ? this.start(t) : this.stop(t), this;
  }
  //-------------------------------------
  // 	SETTERS/GETTERS
  //-------------------------------------
  /**
   * The time signature as just the numerator over 4.
   * For example 4/4 would be just 4 and 6/8 would be 3.
   * @example
   * // common time
   * Tone.getTransport().timeSignature = 4;
   * // 7/8
   * Tone.getTransport().timeSignature = [7, 8];
   * // this will be reduced to a single number
   * Tone.getTransport().timeSignature; // returns 3.5
   */
  get timeSignature() {
    return this._timeSignature;
  }
  set timeSignature(t) {
    wr(t) && (t = t[0] / t[1] * 4), this._timeSignature = t;
  }
  /**
   * When the Transport.loop = true, this is the starting position of the loop.
   */
  get loopStart() {
    return new gr(this.context, this._loopStart, "i").toSeconds();
  }
  set loopStart(t) {
    this._loopStart = this.toTicks(t);
  }
  /**
   * When the Transport.loop = true, this is the ending position of the loop.
   */
  get loopEnd() {
    return new gr(this.context, this._loopEnd, "i").toSeconds();
  }
  set loopEnd(t) {
    this._loopEnd = this.toTicks(t);
  }
  /**
   * If the transport loops or not.
   */
  get loop() {
    return this._loop.get(this.now());
  }
  set loop(t) {
    this._loop.set(t, this.now());
  }
  /**
   * Set the loop start and stop at the same time.
   * @example
   * // loop over the first measure
   * Tone.getTransport().setLoopPoints(0, "1m");
   * Tone.getTransport().loop = true;
   */
  setLoopPoints(t, n) {
    return this.loopStart = t, this.loopEnd = n, this;
  }
  /**
   * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.
   */
  get swing() {
    return this._swingAmount;
  }
  set swing(t) {
    this._swingAmount = t;
  }
  /**
   * Set the subdivision which the swing will be applied to.
   * The default value is an 8th note. Value must be less
   * than a quarter note.
   */
  get swingSubdivision() {
    return new sl(this.context, this._swingTicks).toNotation();
  }
  set swingSubdivision(t) {
    this._swingTicks = this.toTicks(t);
  }
  /**
   * The Transport's position in Bars:Beats:Sixteenths.
   * Setting the value will jump to that position right away.
   */
  get position() {
    const t = this.now(), n = this._clock.getTicksAtTime(t);
    return new sl(this.context, n).toBarsBeatsSixteenths();
  }
  set position(t) {
    const n = this.toTicks(t);
    this.ticks = n;
  }
  /**
   * The Transport's position in seconds.
   * Setting the value will jump to that position right away.
   */
  get seconds() {
    return this._clock.seconds;
  }
  set seconds(t) {
    const n = this.now(), i = this._clock.frequency.timeToTicks(t, n);
    this.ticks = i;
  }
  /**
   * The Transport's loop position as a normalized value. Always
   * returns 0 if the Transport.loop = false.
   */
  get progress() {
    if (this.loop) {
      const t = this.now();
      return (this._clock.getTicksAtTime(t) - this._loopStart) / (this._loopEnd - this._loopStart);
    } else
      return 0;
  }
  /**
   * The Transport's current tick position.
   */
  get ticks() {
    return this._clock.ticks;
  }
  set ticks(t) {
    if (this._clock.ticks !== t) {
      const n = this.now();
      if (this.state === "started") {
        const i = this._clock.getTicksAtTime(n), r = this._clock.frequency.getDurationOfTicks(Math.ceil(i) - i, n), s = n + r;
        this.emit("stop", s), this._clock.setTicksAtTime(t, s), this.emit("start", s, this._clock.getSecondsAtTime(s));
      } else
        this.emit("ticks", n), this._clock.setTicksAtTime(t, n);
    }
  }
  /**
   * Get the clock's ticks at the given time.
   * @param  time  When to get the tick value
   * @return The tick value at the given time.
   */
  getTicksAtTime(t) {
    return this._clock.getTicksAtTime(t);
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(t) {
    return this._clock.getSecondsAtTime(t);
  }
  /**
   * Pulses Per Quarter note. This is the smallest resolution
   * the Transport timing supports. This should be set once
   * on initialization and not set again. Changing this value
   * after other objects have been created can cause problems.
   */
  get PPQ() {
    return this._clock.frequency.multiplier;
  }
  set PPQ(t) {
    this._clock.frequency.multiplier = t;
  }
  //-------------------------------------
  // 	SYNCING
  //-------------------------------------
  /**
   * Returns the time aligned to the next subdivision
   * of the Transport. If the Transport is not started,
   * it will return 0.
   * Note: this will not work precisely during tempo ramps.
   * @param  subdivision  The subdivision to quantize to
   * @return  The context time of the next subdivision.
   * @example
   * // the transport must be started, otherwise returns 0
   * Tone.getTransport().start();
   * Tone.getTransport().nextSubdivision("4n");
   */
  nextSubdivision(t) {
    if (t = this.toTicks(t), this.state !== "started")
      return 0;
    {
      const n = this.now(), i = this.getTicksAtTime(n), r = t - i % t;
      return this._clock.nextTickTime(r, n);
    }
  }
  /**
   * Attaches the signal to the tempo control signal so that
   * any changes in the tempo will change the signal in the same
   * ratio.
   *
   * @param signal
   * @param ratio Optionally pass in the ratio between the two signals.
   * 			Otherwise it will be computed based on their current values.
   */
  syncSignal(t, n) {
    const i = this.now();
    let r = this.bpm, s = 1 / (60 / r.getValueAtTime(i) / this.PPQ), a = [];
    if (t.units === "time") {
      const l = 0.015625 / s, u = new Ln(l), c = new th(-1), d = new Ln(l);
      r.chain(u, c, d), r = d, s = 1 / s, a = [u, c, d];
    }
    n || (t.getValueAtTime(i) !== 0 ? n = t.getValueAtTime(i) / s : n = 0);
    const o = new Ln(n);
    return r.connect(o), o.connect(t._param), a.push(o), this._syncedSignals.push({
      initial: t.value,
      nodes: a,
      signal: t
    }), t.value = 0, this;
  }
  /**
   * Unsyncs a previously synced signal from the transport's control.
   * @see {@link syncSignal}.
   */
  unsyncSignal(t) {
    for (let n = this._syncedSignals.length - 1; n >= 0; n--) {
      const i = this._syncedSignals[n];
      i.signal === t && (i.nodes.forEach((r) => r.dispose()), i.signal.value = i.initial, this._syncedSignals.splice(n, 1));
    }
    return this;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._clock.dispose(), Tx(this, "bpm"), this._timeline.dispose(), this._repeatedEvents.dispose(), this;
  }
}
rd.mixin(fc);
sm((e) => {
  e.transport = new fc({ context: e });
});
am((e) => {
  e.transport.dispose();
});
class Ii extends et {
  constructor(t) {
    super(t), this.input = void 0, this._state = new Uy("stopped"), this._synced = !1, this._scheduled = [], this._syncedStart = wt, this._syncedStop = wt, this._state.memory = 100, this._state.increasing = !0, this._volume = this.output = new ao({
      context: this.context,
      mute: t.mute,
      volume: t.volume
    }), this.volume = this._volume.volume, Jt(this, "volume"), this.onstop = t.onstop;
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      mute: !1,
      onstop: wt,
      volume: 0
    });
  }
  /**
   * Returns the playback state of the source, either "started" or "stopped".
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/ahntone_c3.mp3", () => {
   * 	player.start();
   * 	console.log(player.state);
   * }).toDestination();
   */
  get state() {
    return this._synced ? this.context.transport.state === "started" ? this._state.getValueAtTime(this.context.transport.seconds) : "stopped" : this._state.getValueAtTime(this.now());
  }
  /**
   * Mute the output.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * // mute the output
   * osc.mute = true;
   */
  get mute() {
    return this._volume.mute;
  }
  set mute(t) {
    this._volume.mute = t;
  }
  /**
   * Ensure that the scheduled time is not before the current time.
   * Should only be used when scheduled unsynced.
   */
  _clampToCurrentTime(t) {
    return this._synced ? t : Math.max(t, this.context.currentTime);
  }
  /**
   * Start the source at the specified time. If no time is given,
   * start the source now.
   * @param  time When the source should be started.
   * @example
   * const source = new Tone.Oscillator().toDestination();
   * source.start("+0.5"); // starts the source 0.5 seconds from now
   */
  start(t, n, i) {
    let r = Zi(t) && this._synced ? this.context.transport.seconds : this.toSeconds(t);
    if (r = this._clampToCurrentTime(r), !this._synced && this._state.getValueAtTime(r) === "started")
      Xe(Al(r, this._state.get(r).time), "Start time must be strictly greater than previous start time"), this._state.cancel(r), this._state.setStateAtTime("started", r), this.log("restart", r), this.restart(r, n, i);
    else if (this.log("start", r), this._state.setStateAtTime("started", r), this._synced) {
      const s = this._state.get(r);
      s && (s.offset = this.toSeconds(hl(n, 0)), s.duration = i ? this.toSeconds(i) : void 0);
      const a = this.context.transport.schedule((o) => {
        this._start(o, n, i);
      }, r);
      this._scheduled.push(a), this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > r && this._syncedStart(this.now(), this.context.transport.seconds);
    } else
      bx(this.context), this._start(r, n, i);
    return this;
  }
  /**
   * Stop the source at the specified time. If no time is given,
   * stop the source now.
   * @param  time When the source should be stopped.
   * @example
   * const source = new Tone.Oscillator().toDestination();
   * source.start();
   * source.stop("+0.5"); // stops the source 0.5 seconds from now
   */
  stop(t) {
    let n = Zi(t) && this._synced ? this.context.transport.seconds : this.toSeconds(t);
    if (n = this._clampToCurrentTime(n), this._state.getValueAtTime(n) === "started" || nt(this._state.getNextState("started", n))) {
      if (this.log("stop", n), !this._synced)
        this._stop(n);
      else {
        const i = this.context.transport.schedule(this._stop.bind(this), n);
        this._scheduled.push(i);
      }
      this._state.cancel(n), this._state.setStateAtTime("stopped", n);
    }
    return this;
  }
  /**
   * Restart the source.
   */
  restart(t, n, i) {
    return t = this.toSeconds(t), this._state.getValueAtTime(t) === "started" && (this._state.cancel(t), this._restart(t, n, i)), this;
  }
  /**
   * Sync the source to the Transport so that all subsequent
   * calls to `start` and `stop` are synced to the TransportTime
   * instead of the AudioContext time.
   *
   * @example
   * const osc = new Tone.Oscillator().toDestination();
   * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline
   * osc.sync().start(0).stop(0.3);
   * // start the transport.
   * Tone.Transport.start();
   * // set it to loop once a second
   * Tone.Transport.loop = true;
   * Tone.Transport.loopEnd = 1;
   */
  sync() {
    return this._synced || (this._synced = !0, this._syncedStart = (t, n) => {
      if (Al(n, 0)) {
        const i = this._state.get(n);
        if (i && i.state === "started" && i.time !== n) {
          const r = n - this.toSeconds(i.time);
          let s;
          i.duration && (s = this.toSeconds(i.duration) - r), this._start(t, this.toSeconds(i.offset) + r, s);
        }
      }
    }, this._syncedStop = (t) => {
      const n = this.context.transport.getSecondsAtTime(Math.max(t - this.sampleTime, 0));
      this._state.getValueAtTime(n) === "started" && this._stop(t);
    }, this.context.transport.on("start", this._syncedStart), this.context.transport.on("loopStart", this._syncedStart), this.context.transport.on("stop", this._syncedStop), this.context.transport.on("pause", this._syncedStop), this.context.transport.on("loopEnd", this._syncedStop)), this;
  }
  /**
   * Unsync the source to the Transport.
   * @see {@link sync}
   */
  unsync() {
    return this._synced && (this.context.transport.off("stop", this._syncedStop), this.context.transport.off("pause", this._syncedStop), this.context.transport.off("loopEnd", this._syncedStop), this.context.transport.off("start", this._syncedStart), this.context.transport.off("loopStart", this._syncedStart)), this._synced = !1, this._scheduled.forEach((t) => this.context.transport.clear(t)), this._scheduled = [], this._state.cancel(0), this._stop(0), this;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.onstop = wt, this.unsync(), this._volume.dispose(), this._state.dispose(), this;
  }
}
class hc extends Il {
  constructor() {
    super(Te(hc.getDefaults(), arguments, ["url", "onload"])), this.name = "ToneBufferSource", this._source = this.context.createBufferSource(), this._internalChannels = [this._source], this._sourceStarted = !1, this._sourceStopped = !1;
    const t = Te(hc.getDefaults(), arguments, ["url", "onload"]);
    ru(this._source, this._gainNode), this._source.onended = () => this._stopSource(), this.playbackRate = new Lt({
      context: this.context,
      param: this._source.playbackRate,
      units: "positive",
      value: t.playbackRate
    }), this.loop = t.loop, this.loopStart = t.loopStart, this.loopEnd = t.loopEnd, this._buffer = new Vt(t.url, t.onload, t.onerror), this._internalChannels.push(this._source);
  }
  static getDefaults() {
    return Object.assign(Il.getDefaults(), {
      url: new Vt(),
      loop: !1,
      loopEnd: 0,
      loopStart: 0,
      onload: wt,
      onerror: wt,
      playbackRate: 1
    });
  }
  /**
   * The fadeIn time of the amplitude envelope.
   */
  get fadeIn() {
    return this._fadeIn;
  }
  set fadeIn(t) {
    this._fadeIn = t;
  }
  /**
   * The fadeOut time of the amplitude envelope.
   */
  get fadeOut() {
    return this._fadeOut;
  }
  set fadeOut(t) {
    this._fadeOut = t;
  }
  /**
   * The curve applied to the fades, either "linear" or "exponential"
   */
  get curve() {
    return this._curve;
  }
  set curve(t) {
    this._curve = t;
  }
  /**
   * Start the buffer
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
   * @param  gain  The gain to play the buffer back at.
   */
  start(t, n, i, r = 1) {
    Xe(this.buffer.loaded, "buffer is either not set or not loaded");
    const s = this.toSeconds(t);
    this._startGain(s, r), this.loop ? n = hl(n, this.loopStart) : n = hl(n, 0);
    let a = Math.max(this.toSeconds(n), 0);
    if (this.loop) {
      const o = this.toSeconds(this.loopEnd) || this.buffer.duration, l = this.toSeconds(this.loopStart), u = o - l;
      xg(a, o) && (a = (a - l) % u + l), cr(a, this.buffer.duration) && (a = 0);
    }
    if (this._source.buffer = this.buffer.get(), this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration, Zf(a, this.buffer.duration) && (this._sourceStarted = !0, this._source.start(s, a)), nt(i)) {
      let o = this.toSeconds(i);
      o = Math.max(o, 0), this.stop(s + o);
    }
    return this;
  }
  _stopSource(t) {
    !this._sourceStopped && this._sourceStarted && (this._sourceStopped = !0, this._source.stop(this.toSeconds(t)), this._onended());
  }
  /**
   * If loop is true, the loop will start at this position.
   */
  get loopStart() {
    return this._source.loopStart;
  }
  set loopStart(t) {
    this._source.loopStart = this.toSeconds(t);
  }
  /**
   * If loop is true, the loop will end at this position.
   */
  get loopEnd() {
    return this._source.loopEnd;
  }
  set loopEnd(t) {
    this._source.loopEnd = this.toSeconds(t);
  }
  /**
   * The audio buffer belonging to the player.
   */
  get buffer() {
    return this._buffer;
  }
  set buffer(t) {
    this._buffer.set(t);
  }
  /**
   * If the buffer should loop once it's over.
   */
  get loop() {
    return this._source.loop;
  }
  set loop(t) {
    this._source.loop = t, this._sourceStarted && this.cancelStop();
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._source.onended = null, this._source.disconnect(), this._buffer.dispose(), this.playbackRate.dispose(), this;
  }
}
function Ao(e, t) {
  return mn(this, void 0, void 0, function* () {
    const n = t / e.context.sampleRate, i = new Hy(1, n, e.context.sampleRate);
    return new e.constructor(Object.assign(e.get(), {
      // should do 2 iterations
      frequency: 2 / n,
      // zero out the detune
      detune: 0,
      context: i
    })).toDestination().start(0), (yield i.render()).getChannelData(0);
  });
}
class nh extends Il {
  constructor() {
    super(Te(nh.getDefaults(), arguments, ["frequency", "type"])), this.name = "ToneOscillatorNode", this._oscillator = this.context.createOscillator(), this._internalChannels = [this._oscillator];
    const t = Te(nh.getDefaults(), arguments, ["frequency", "type"]);
    ru(this._oscillator, this._gainNode), this.type = t.type, this.frequency = new Lt({
      context: this.context,
      param: this._oscillator.frequency,
      units: "frequency",
      value: t.frequency
    }), this.detune = new Lt({
      context: this.context,
      param: this._oscillator.detune,
      units: "cents",
      value: t.detune
    }), Jt(this, ["frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Il.getDefaults(), {
      detune: 0,
      frequency: 440,
      type: "sine"
    });
  }
  /**
   * Start the oscillator node at the given time
   * @param  time When to start the oscillator
   */
  start(t) {
    const n = this.toSeconds(t);
    return this.log("start", n), this._startGain(n), this._oscillator.start(n), this;
  }
  _stopSource(t) {
    this._oscillator.stop(t);
  }
  /**
   * Sets an arbitrary custom periodic waveform given a PeriodicWave.
   * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave
   */
  setPeriodicWave(t) {
    return this._oscillator.setPeriodicWave(t), this;
  }
  /**
   * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'
   */
  get type() {
    return this._oscillator.type;
  }
  set type(t) {
    this._oscillator.type = t;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.state === "started" && this.stop(), this._oscillator.disconnect(), this.frequency.dispose(), this.detune.dispose(), this;
  }
}
class sn extends Ii {
  constructor() {
    super(Te(sn.getDefaults(), arguments, ["frequency", "type"])), this.name = "Oscillator", this._oscillator = null;
    const t = Te(sn.getDefaults(), arguments, ["frequency", "type"]);
    this.frequency = new bn({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), Jt(this, "frequency"), this.detune = new bn({
      context: this.context,
      units: "cents",
      value: t.detune
    }), Jt(this, "detune"), this._partials = t.partials, this._partialCount = t.partialCount, this._type = t.type, t.partialCount && t.type !== "custom" && (this._type = this.baseType + t.partialCount.toString()), this.phase = t.phase;
  }
  static getDefaults() {
    return Object.assign(Ii.getDefaults(), {
      detune: 0,
      frequency: 440,
      partialCount: 0,
      partials: [],
      phase: 0,
      type: "sine"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    const n = this.toSeconds(t), i = new nh({
      context: this.context,
      onended: () => this.onstop(this)
    });
    this._oscillator = i, this._wave ? this._oscillator.setPeriodicWave(this._wave) : this._oscillator.type = this._type, this._oscillator.connect(this.output), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.start(n);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    const n = this.toSeconds(t);
    this._oscillator && this._oscillator.stop(n);
  }
  /**
   * Restart the oscillator. Does not stop the oscillator, but instead
   * just cancels any scheduled 'stop' from being invoked.
   */
  _restart(t) {
    const n = this.toSeconds(t);
    return this.log("restart", n), this._oscillator && this._oscillator.cancelStop(), this._state.cancel(n), this;
  }
  /**
   * Sync the signal to the Transport's bpm. Any changes to the transports bpm,
   * will also affect the oscillators frequency.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * osc.frequency.value = 440;
   * // the ratio between the bpm and the frequency will be maintained
   * osc.syncFrequency();
   * // double the tempo
   * Tone.Transport.bpm.value *= 2;
   * // the frequency of the oscillator is doubled to 880
   */
  syncFrequency() {
    return this.context.transport.syncSignal(this.frequency), this;
  }
  /**
   * Unsync the oscillator's frequency from the Transport.
   * @see {@link syncFrequency}
   */
  unsyncFrequency() {
    return this.context.transport.unsyncSignal(this.frequency), this;
  }
  /**
   * Get a cached periodic wave. Avoids having to recompute
   * the oscillator values when they have already been computed
   * with the same values.
   */
  _getCachedPeriodicWave() {
    if (this._type === "custom")
      return sn._periodicWaveCache.find((n) => n.phase === this._phase && JU(n.partials, this._partials));
    {
      const t = sn._periodicWaveCache.find((n) => n.type === this._type && n.phase === this._phase);
      return this._partialCount = t ? t.partialCount : this._partialCount, t;
    }
  }
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t;
    const n = ["sine", "square", "sawtooth", "triangle"].indexOf(t) !== -1;
    if (this._phase === 0 && n)
      this._wave = void 0, this._partialCount = 0, this._oscillator !== null && (this._oscillator.type = t);
    else {
      const i = this._getCachedPeriodicWave();
      if (nt(i)) {
        const { partials: r, wave: s } = i;
        this._wave = s, this._partials = r, this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave);
      } else {
        const [r, s] = this._getRealImaginary(t, this._phase), a = this.context.createPeriodicWave(r, s);
        this._wave = a, this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave), sn._periodicWaveCache.push({
          imag: s,
          partialCount: this._partialCount,
          partials: this._partials,
          phase: this._phase,
          real: r,
          type: this._type,
          wave: this._wave
        }), sn._periodicWaveCache.length > 100 && sn._periodicWaveCache.shift();
      }
    }
  }
  get baseType() {
    return this._type.replace(this.partialCount.toString(), "");
  }
  set baseType(t) {
    this.partialCount && this._type !== "custom" && t !== "custom" ? this.type = t + this.partialCount : this.type = t;
  }
  get partialCount() {
    return this._partialCount;
  }
  set partialCount(t) {
    sa(t, 0);
    let n = this._type;
    const i = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
    if (i && (n = i[1]), this._type !== "custom")
      t === 0 ? this.type = n : this.type = n + t.toString();
    else {
      const r = new Float32Array(t);
      this._partials.forEach((s, a) => r[a] = s), this._partials = Array.from(r), this.type = this._type;
    }
  }
  /**
   * Returns the real and imaginary components based
   * on the oscillator type.
   * @returns [real: Float32Array, imaginary: Float32Array]
   */
  _getRealImaginary(t, n) {
    let r = 2048;
    const s = new Float32Array(r), a = new Float32Array(r);
    let o = 1;
    if (t === "custom") {
      if (o = this._partials.length + 1, this._partialCount = this._partials.length, r = o, this._partials.length === 0)
        return [s, a];
    } else {
      const l = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(t);
      l ? (o = parseInt(l[2], 10) + 1, this._partialCount = parseInt(l[2], 10), t = l[1], o = Math.max(o, 2), r = o) : this._partialCount = 0, this._partials = [];
    }
    for (let l = 1; l < r; ++l) {
      const u = 2 / (l * Math.PI);
      let c;
      switch (t) {
        case "sine":
          c = l <= o ? 1 : 0, this._partials[l - 1] = c;
          break;
        case "square":
          c = l & 1 ? 2 * u : 0, this._partials[l - 1] = c;
          break;
        case "sawtooth":
          c = u * (l & 1 ? 1 : -1), this._partials[l - 1] = c;
          break;
        case "triangle":
          l & 1 ? c = 2 * (u * u) * (l - 1 >> 1 & 1 ? -1 : 1) : c = 0, this._partials[l - 1] = c;
          break;
        case "custom":
          c = this._partials[l - 1];
          break;
        default:
          throw new TypeError("Oscillator: invalid type: " + t);
      }
      c !== 0 ? (s[l] = -c * Math.sin(n * l), a[l] = c * Math.cos(n * l)) : (s[l] = 0, a[l] = 0);
    }
    return [s, a];
  }
  /**
   * Compute the inverse FFT for a given phase.
   */
  _inverseFFT(t, n, i) {
    let r = 0;
    const s = t.length;
    for (let a = 0; a < s; a++)
      r += t[a] * Math.cos(a * i) + n[a] * Math.sin(a * i);
    return r;
  }
  /**
   * Returns the initial value of the oscillator when stopped.
   * E.g. a "sine" oscillator with phase = 90 would return an initial value of -1.
   */
  getInitialValue() {
    const [t, n] = this._getRealImaginary(this._type, 0);
    let i = 0;
    const r = Math.PI * 2, s = 32;
    for (let a = 0; a < s; a++)
      i = Math.max(this._inverseFFT(t, n, a / s * r), i);
    return eq(-this._inverseFFT(t, n, this._phase) / i, -1, 1);
  }
  get partials() {
    return this._partials.slice(0, this.partialCount);
  }
  set partials(t) {
    this._partials = t, this._partialCount = this._partials.length, t.length && (this.type = "custom");
  }
  get phase() {
    return this._phase * (180 / Math.PI);
  }
  set phase(t) {
    this._phase = t * Math.PI / 180, this.type = this._type;
  }
  asArray(t = 1024) {
    return mn(this, void 0, void 0, function* () {
      return Ao(this, t);
    });
  }
  dispose() {
    return super.dispose(), this._oscillator !== null && this._oscillator.dispose(), this._wave = void 0, this.frequency.dispose(), this.detune.dispose(), this;
  }
}
sn._periodicWaveCache = [];
class pq extends El {
  constructor() {
    super(...arguments), this.name = "AudioToGain", this._norm = new Pl({
      context: this.context,
      mapping: (t) => (t + 1) / 2
    }), this.input = this._norm, this.output = this._norm;
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this._norm.dispose(), this;
  }
}
class oo extends bn {
  constructor() {
    super(Object.assign(Te(oo.getDefaults(), arguments, ["value"]))), this.name = "Multiply", this.override = !1;
    const t = Te(oo.getDefaults(), arguments, ["value"]);
    this._mult = this.input = this.output = new Ln({
      context: this.context,
      minValue: t.minValue,
      maxValue: t.maxValue
    }), this.factor = this._param = this._mult.gain, this.factor.setValueAtTime(t.value, 0);
  }
  static getDefaults() {
    return Object.assign(bn.getDefaults(), {
      value: 0
    });
  }
  dispose() {
    return super.dispose(), this._mult.dispose(), this;
  }
}
class mc extends Ii {
  constructor() {
    super(Te(mc.getDefaults(), arguments, ["frequency", "type", "modulationType"])), this.name = "AMOscillator", this._modulationScale = new pq({ context: this.context }), this._modulationNode = new Ln({
      context: this.context
    });
    const t = Te(mc.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    this._carrier = new sn({
      context: this.context,
      detune: t.detune,
      frequency: t.frequency,
      onstop: () => this.onstop(this),
      phase: t.phase,
      type: t.type
    }), this.frequency = this._carrier.frequency, this.detune = this._carrier.detune, this._modulator = new sn({
      context: this.context,
      phase: t.phase,
      type: t.modulationType
    }), this.harmonicity = new oo({
      context: this.context,
      units: "positive",
      value: t.harmonicity
    }), this.frequency.chain(this.harmonicity, this._modulator.frequency), this._modulator.chain(this._modulationScale, this._modulationNode.gain), this._carrier.chain(this._modulationNode, this.output), Jt(this, ["frequency", "detune", "harmonicity"]);
  }
  static getDefaults() {
    return Object.assign(sn.getDefaults(), {
      harmonicity: 1,
      modulationType: "square"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    this._modulator.start(t), this._carrier.start(t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    this._modulator.stop(t), this._carrier.stop(t);
  }
  _restart(t) {
    this._modulator.restart(t), this._carrier.restart(t);
  }
  /**
   * The type of the carrier oscillator
   */
  get type() {
    return this._carrier.type;
  }
  set type(t) {
    this._carrier.type = t;
  }
  get baseType() {
    return this._carrier.baseType;
  }
  set baseType(t) {
    this._carrier.baseType = t;
  }
  get partialCount() {
    return this._carrier.partialCount;
  }
  set partialCount(t) {
    this._carrier.partialCount = t;
  }
  /**
   * The type of the modulator oscillator
   */
  get modulationType() {
    return this._modulator.type;
  }
  set modulationType(t) {
    this._modulator.type = t;
  }
  get phase() {
    return this._carrier.phase;
  }
  set phase(t) {
    this._carrier.phase = t, this._modulator.phase = t;
  }
  get partials() {
    return this._carrier.partials;
  }
  set partials(t) {
    this._carrier.partials = t;
  }
  asArray(t = 1024) {
    return mn(this, void 0, void 0, function* () {
      return Ao(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this._modulationScale.dispose(), this;
  }
}
class vc extends Ii {
  constructor() {
    super(Te(vc.getDefaults(), arguments, ["frequency", "type", "modulationType"])), this.name = "FMOscillator", this._modulationNode = new Ln({
      context: this.context,
      gain: 0
    });
    const t = Te(vc.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    this._carrier = new sn({
      context: this.context,
      detune: t.detune,
      frequency: 0,
      onstop: () => this.onstop(this),
      phase: t.phase,
      type: t.type
    }), this.detune = this._carrier.detune, this.frequency = new bn({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), this._modulator = new sn({
      context: this.context,
      phase: t.phase,
      type: t.modulationType
    }), this.harmonicity = new oo({
      context: this.context,
      units: "positive",
      value: t.harmonicity
    }), this.modulationIndex = new oo({
      context: this.context,
      units: "positive",
      value: t.modulationIndex
    }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.frequency.chain(this.modulationIndex, this._modulationNode), this._modulator.connect(this._modulationNode.gain), this._modulationNode.connect(this._carrier.frequency), this._carrier.connect(this.output), this.detune.connect(this._modulator.detune), Jt(this, ["modulationIndex", "frequency", "detune", "harmonicity"]);
  }
  static getDefaults() {
    return Object.assign(sn.getDefaults(), {
      harmonicity: 1,
      modulationIndex: 2,
      modulationType: "square"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    this._modulator.start(t), this._carrier.start(t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    this._modulator.stop(t), this._carrier.stop(t);
  }
  _restart(t) {
    return this._modulator.restart(t), this._carrier.restart(t), this;
  }
  get type() {
    return this._carrier.type;
  }
  set type(t) {
    this._carrier.type = t;
  }
  get baseType() {
    return this._carrier.baseType;
  }
  set baseType(t) {
    this._carrier.baseType = t;
  }
  get partialCount() {
    return this._carrier.partialCount;
  }
  set partialCount(t) {
    this._carrier.partialCount = t;
  }
  /**
   * The type of the modulator oscillator
   */
  get modulationType() {
    return this._modulator.type;
  }
  set modulationType(t) {
    this._modulator.type = t;
  }
  get phase() {
    return this._carrier.phase;
  }
  set phase(t) {
    this._carrier.phase = t, this._modulator.phase = t;
  }
  get partials() {
    return this._carrier.partials;
  }
  set partials(t) {
    this._carrier.partials = t;
  }
  asArray(t = 1024) {
    return mn(this, void 0, void 0, function* () {
      return Ao(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.frequency.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this.modulationIndex.dispose(), this;
  }
}
class Ol extends Ii {
  constructor() {
    super(Te(Ol.getDefaults(), arguments, ["frequency", "width"])), this.name = "PulseOscillator", this._widthGate = new Ln({
      context: this.context,
      gain: 0
    }), this._thresh = new Pl({
      context: this.context,
      mapping: (n) => n <= 0 ? -1 : 1
    });
    const t = Te(Ol.getDefaults(), arguments, ["frequency", "width"]);
    this.width = new bn({
      context: this.context,
      units: "audioRange",
      value: t.width
    }), this._triangle = new sn({
      context: this.context,
      detune: t.detune,
      frequency: t.frequency,
      onstop: () => this.onstop(this),
      phase: t.phase,
      type: "triangle"
    }), this.frequency = this._triangle.frequency, this.detune = this._triangle.detune, this._triangle.chain(this._thresh, this.output), this.width.chain(this._widthGate, this._thresh), Jt(this, ["width", "frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Ii.getDefaults(), {
      detune: 0,
      frequency: 440,
      phase: 0,
      type: "pulse",
      width: 0.2
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    t = this.toSeconds(t), this._triangle.start(t), this._widthGate.gain.setValueAtTime(1, t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    t = this.toSeconds(t), this._triangle.stop(t), this._widthGate.gain.cancelScheduledValues(t), this._widthGate.gain.setValueAtTime(0, t);
  }
  _restart(t) {
    this._triangle.restart(t), this._widthGate.gain.cancelScheduledValues(t), this._widthGate.gain.setValueAtTime(1, t);
  }
  /**
   * The phase of the oscillator in degrees.
   */
  get phase() {
    return this._triangle.phase;
  }
  set phase(t) {
    this._triangle.phase = t;
  }
  /**
   * The type of the oscillator. Always returns "pulse".
   */
  get type() {
    return "pulse";
  }
  /**
   * The baseType of the oscillator. Always returns "pulse".
   */
  get baseType() {
    return "pulse";
  }
  /**
   * The partials of the waveform. Cannot set partials for this waveform type
   */
  get partials() {
    return [];
  }
  /**
   * No partials for this waveform type.
   */
  get partialCount() {
    return 0;
  }
  /**
   * *Internal use* The carrier oscillator type is fed through the
   * waveshaper node to create the pulse. Using different carrier oscillators
   * changes oscillator's behavior.
   */
  set carrierType(t) {
    this._triangle.type = t;
  }
  asArray(t = 1024) {
    return mn(this, void 0, void 0, function* () {
      return Ao(this, t);
    });
  }
  /**
   * Clean up method.
   */
  dispose() {
    return super.dispose(), this._triangle.dispose(), this.width.dispose(), this._widthGate.dispose(), this._thresh.dispose(), this;
  }
}
class gc extends Ii {
  constructor() {
    super(Te(gc.getDefaults(), arguments, ["frequency", "type", "spread"])), this.name = "FatOscillator", this._oscillators = [];
    const t = Te(gc.getDefaults(), arguments, ["frequency", "type", "spread"]);
    this.frequency = new bn({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), this.detune = new bn({
      context: this.context,
      units: "cents",
      value: t.detune
    }), this._spread = t.spread, this._type = t.type, this._phase = t.phase, this._partials = t.partials, this._partialCount = t.partialCount, this.count = t.count, Jt(this, ["frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(sn.getDefaults(), {
      count: 3,
      spread: 20,
      type: "sawtooth"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    t = this.toSeconds(t), this._forEach((n) => n.start(t));
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    t = this.toSeconds(t), this._forEach((n) => n.stop(t));
  }
  _restart(t) {
    this._forEach((n) => n.restart(t));
  }
  /**
   * Iterate over all of the oscillators
   */
  _forEach(t) {
    for (let n = 0; n < this._oscillators.length; n++)
      t(this._oscillators[n], n);
  }
  /**
   * The type of the oscillator
   */
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t, this._forEach((n) => n.type = t);
  }
  /**
   * The detune spread between the oscillators. If "count" is
   * set to 3 oscillators and the "spread" is set to 40,
   * the three oscillators would be detuned like this: [-20, 0, 20]
   * for a total detune spread of 40 cents.
   * @example
   * const fatOsc = new Tone.FatOscillator().toDestination().start();
   * fatOsc.spread = 70;
   */
  get spread() {
    return this._spread;
  }
  set spread(t) {
    if (this._spread = t, this._oscillators.length > 1) {
      const n = -t / 2, i = t / (this._oscillators.length - 1);
      this._forEach((r, s) => r.detune.value = n + i * s);
    }
  }
  /**
   * The number of detuned oscillators. Must be an integer greater than 1.
   * @example
   * const fatOsc = new Tone.FatOscillator("C#3", "sawtooth").toDestination().start();
   * // use 4 sawtooth oscillators
   * fatOsc.count = 4;
   */
  get count() {
    return this._oscillators.length;
  }
  set count(t) {
    if (sa(t, 1), this._oscillators.length !== t) {
      this._forEach((n) => n.dispose()), this._oscillators = [];
      for (let n = 0; n < t; n++) {
        const i = new sn({
          context: this.context,
          volume: -6 - t * 1.1,
          type: this._type,
          phase: this._phase + n / t * 360,
          partialCount: this._partialCount,
          onstop: n === 0 ? () => this.onstop(this) : wt
        });
        this.type === "custom" && (i.partials = this._partials), this.frequency.connect(i.frequency), this.detune.connect(i.detune), i.detune.overridden = !1, i.connect(this.output), this._oscillators[n] = i;
      }
      this.spread = this._spread, this.state === "started" && this._forEach((n) => n.start());
    }
  }
  get phase() {
    return this._phase;
  }
  set phase(t) {
    this._phase = t, this._forEach((n, i) => n.phase = this._phase + i / this.count * 360);
  }
  get baseType() {
    return this._oscillators[0].baseType;
  }
  set baseType(t) {
    this._forEach((n) => n.baseType = t), this._type = this._oscillators[0].type;
  }
  get partials() {
    return this._oscillators[0].partials;
  }
  set partials(t) {
    this._partials = t, this._partialCount = this._partials.length, t.length && (this._type = "custom", this._forEach((n) => n.partials = t));
  }
  get partialCount() {
    return this._oscillators[0].partialCount;
  }
  set partialCount(t) {
    this._partialCount = t, this._forEach((n) => n.partialCount = t), this._type = this._oscillators[0].type;
  }
  asArray(t = 1024) {
    return mn(this, void 0, void 0, function* () {
      return Ao(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this._forEach((t) => t.dispose()), this;
  }
}
class pc extends Ii {
  constructor() {
    super(Te(pc.getDefaults(), arguments, ["frequency", "modulationFrequency"])), this.name = "PWMOscillator", this.sourceType = "pwm", this._scale = new oo({
      context: this.context,
      value: 2
    });
    const t = Te(pc.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
    this._pulse = new Ol({
      context: this.context,
      frequency: t.modulationFrequency
    }), this._pulse.carrierType = "sine", this.modulationFrequency = this._pulse.frequency, this._modulator = new sn({
      context: this.context,
      detune: t.detune,
      frequency: t.frequency,
      onstop: () => this.onstop(this),
      phase: t.phase
    }), this.frequency = this._modulator.frequency, this.detune = this._modulator.detune, this._modulator.chain(this._scale, this._pulse.width), this._pulse.connect(this.output), Jt(this, ["modulationFrequency", "frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Ii.getDefaults(), {
      detune: 0,
      frequency: 440,
      modulationFrequency: 0.4,
      phase: 0,
      type: "pwm"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    t = this.toSeconds(t), this._modulator.start(t), this._pulse.start(t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    t = this.toSeconds(t), this._modulator.stop(t), this._pulse.stop(t);
  }
  /**
   * restart the oscillator
   */
  _restart(t) {
    this._modulator.restart(t), this._pulse.restart(t);
  }
  /**
   * The type of the oscillator. Always returns "pwm".
   */
  get type() {
    return "pwm";
  }
  /**
   * The baseType of the oscillator. Always returns "pwm".
   */
  get baseType() {
    return "pwm";
  }
  /**
   * The partials of the waveform. Cannot set partials for this waveform type
   */
  get partials() {
    return [];
  }
  /**
   * No partials for this waveform type.
   */
  get partialCount() {
    return 0;
  }
  /**
   * The phase of the oscillator in degrees.
   */
  get phase() {
    return this._modulator.phase;
  }
  set phase(t) {
    this._modulator.phase = t;
  }
  asArray(t = 1024) {
    return mn(this, void 0, void 0, function* () {
      return Ao(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._pulse.dispose(), this._scale.dispose(), this._modulator.dispose(), this;
  }
}
const x_ = {
  am: mc,
  fat: gc,
  fm: vc,
  oscillator: sn,
  pulse: Ol,
  pwm: pc
};
class yc extends Ii {
  constructor() {
    super(Te(yc.getDefaults(), arguments, ["frequency", "type"])), this.name = "OmniOscillator";
    const t = Te(yc.getDefaults(), arguments, ["frequency", "type"]);
    this.frequency = new bn({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), this.detune = new bn({
      context: this.context,
      units: "cents",
      value: t.detune
    }), Jt(this, ["frequency", "detune"]), this.set(t);
  }
  static getDefaults() {
    return Object.assign(sn.getDefaults(), vc.getDefaults(), mc.getDefaults(), gc.getDefaults(), Ol.getDefaults(), pc.getDefaults());
  }
  /**
   * start the oscillator
   */
  _start(t) {
    this._oscillator.start(t);
  }
  /**
   * start the oscillator
   */
  _stop(t) {
    this._oscillator.stop(t);
  }
  _restart(t) {
    return this._oscillator.restart(t), this;
  }
  /**
   * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or
   * prefix the basic types with "fm", "am", or "fat" to use the FMOscillator, AMOscillator or FatOscillator
   * types. The oscillator could also be set to "pwm" or "pulse". All of the parameters of the
   * oscillator's class are accessible when the oscillator is set to that type, but throws an error
   * when it's not.
   * @example
   * const omniOsc = new Tone.OmniOscillator().toDestination().start();
   * omniOsc.type = "pwm";
   * // modulationFrequency is parameter which is available
   * // only when the type is "pwm".
   * omniOsc.modulationFrequency.value = 0.5;
   */
  get type() {
    let t = "";
    return ["am", "fm", "fat"].some((n) => this._sourceType === n) && (t = this._sourceType), t + this._oscillator.type;
  }
  set type(t) {
    t.substr(0, 2) === "fm" ? (this._createNewOscillator("fm"), this._oscillator = this._oscillator, this._oscillator.type = t.substr(2)) : t.substr(0, 2) === "am" ? (this._createNewOscillator("am"), this._oscillator = this._oscillator, this._oscillator.type = t.substr(2)) : t.substr(0, 3) === "fat" ? (this._createNewOscillator("fat"), this._oscillator = this._oscillator, this._oscillator.type = t.substr(3)) : t === "pwm" ? (this._createNewOscillator("pwm"), this._oscillator = this._oscillator) : t === "pulse" ? this._createNewOscillator("pulse") : (this._createNewOscillator("oscillator"), this._oscillator = this._oscillator, this._oscillator.type = t);
  }
  /**
   * The value is an empty array when the type is not "custom".
   * This is not available on "pwm" and "pulse" oscillator types.
   * @see {@link Oscillator.partials}
   */
  get partials() {
    return this._oscillator.partials;
  }
  set partials(t) {
    !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partials = t);
  }
  get partialCount() {
    return this._oscillator.partialCount;
  }
  set partialCount(t) {
    !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partialCount = t);
  }
  set(t) {
    return Reflect.has(t, "type") && t.type && (this.type = t.type), super.set(t), this;
  }
  /**
   * connect the oscillator to the frequency and detune signals
   */
  _createNewOscillator(t) {
    if (t !== this._sourceType) {
      this._sourceType = t;
      const n = x_[t], i = this.now();
      if (this._oscillator) {
        const r = this._oscillator;
        r.stop(i), this.context.setTimeout(() => r.dispose(), this.blockTime);
      }
      this._oscillator = new n({
        context: this.context
      }), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.connect(this.output), this._oscillator.onstop = () => this.onstop(this), this.state === "started" && this._oscillator.start(i);
    }
  }
  get phase() {
    return this._oscillator.phase;
  }
  set phase(t) {
    this._oscillator.phase = t;
  }
  /**
   * The source type of the oscillator.
   * @example
   * const omniOsc = new Tone.OmniOscillator(440, "fmsquare");
   * console.log(omniOsc.sourceType); // 'fm'
   */
  get sourceType() {
    return this._sourceType;
  }
  set sourceType(t) {
    let n = "sine";
    this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse" && (n = this._oscillator.type), t === "fm" ? this.type = "fm" + n : t === "am" ? this.type = "am" + n : t === "fat" ? this.type = "fat" + n : t === "oscillator" ? this.type = n : t === "pulse" ? this.type = "pulse" : t === "pwm" && (this.type = "pwm");
  }
  _getOscType(t, n) {
    return t instanceof x_[n];
  }
  /**
   * The base type of the oscillator.
   * @see {@link Oscillator.baseType}
   * @example
   * const omniOsc = new Tone.OmniOscillator(440, "fmsquare4");
   * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);
   */
  get baseType() {
    return this._oscillator.baseType;
  }
  set baseType(t) {
    !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && t !== "pulse" && t !== "pwm" && (this._oscillator.baseType = t);
  }
  /**
   * The width of the oscillator when sourceType === "pulse".
   * @see {@link PWMOscillator}
   */
  get width() {
    if (this._getOscType(this._oscillator, "pulse"))
      return this._oscillator.width;
  }
  /**
   * The number of detuned oscillators when sourceType === "fat".
   * @see {@link FatOscillator.count}
   */
  get count() {
    if (this._getOscType(this._oscillator, "fat"))
      return this._oscillator.count;
  }
  set count(t) {
    this._getOscType(this._oscillator, "fat") && ro(t) && (this._oscillator.count = t);
  }
  /**
   * The detune spread between the oscillators when sourceType === "fat".
   * @see {@link FatOscillator.count}
   */
  get spread() {
    if (this._getOscType(this._oscillator, "fat"))
      return this._oscillator.spread;
  }
  set spread(t) {
    this._getOscType(this._oscillator, "fat") && ro(t) && (this._oscillator.spread = t);
  }
  /**
   * The type of the modulator oscillator. Only if the oscillator is set to "am" or "fm" types.
   * @see {@link AMOscillator} or {@link FMOscillator}
   */
  get modulationType() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am"))
      return this._oscillator.modulationType;
  }
  set modulationType(t) {
    (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && _s(t) && (this._oscillator.modulationType = t);
  }
  /**
   * The modulation index when the sourceType === "fm"
   * @see {@link FMOscillator}.
   */
  get modulationIndex() {
    if (this._getOscType(this._oscillator, "fm"))
      return this._oscillator.modulationIndex;
  }
  /**
   * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.
   * @see {@link AMOscillator} or {@link FMOscillator}
   */
  get harmonicity() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am"))
      return this._oscillator.harmonicity;
  }
  /**
   * The modulationFrequency Signal of the oscillator when sourceType === "pwm"
   * see {@link PWMOscillator}
   * @min 0.1
   * @max 5
   */
  get modulationFrequency() {
    if (this._getOscType(this._oscillator, "pwm"))
      return this._oscillator.modulationFrequency;
  }
  asArray(t = 1024) {
    return mn(this, void 0, void 0, function* () {
      return Ao(this, t);
    });
  }
  dispose() {
    return super.dispose(), this.detune.dispose(), this.frequency.dispose(), this._oscillator.dispose(), this;
  }
}
function Ex(e, t = 1 / 0) {
  const n = /* @__PURE__ */ new WeakMap();
  return function(i, r) {
    Reflect.defineProperty(i, r, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return n.get(this);
      },
      set: function(s) {
        sa(s, e, t), n.set(this, s);
      }
    });
  };
}
function Os(e, t = 1 / 0) {
  const n = /* @__PURE__ */ new WeakMap();
  return function(i, r) {
    Reflect.defineProperty(i, r, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return n.get(this);
      },
      set: function(s) {
        sa(this.toSeconds(s), e, t), n.set(this, s);
      }
    });
  };
}
class Vl extends Ii {
  constructor() {
    super(Te(Vl.getDefaults(), arguments, [
      "url",
      "onload"
    ])), this.name = "Player", this._activeSources = /* @__PURE__ */ new Set();
    const t = Te(Vl.getDefaults(), arguments, [
      "url",
      "onload"
    ]);
    this._buffer = new Vt({
      onload: this._onload.bind(this, t.onload),
      onerror: t.onerror,
      reverse: t.reverse,
      url: t.url
    }), this.autostart = t.autostart, this._loop = t.loop, this._loopStart = t.loopStart, this._loopEnd = t.loopEnd, this._playbackRate = t.playbackRate, this.fadeIn = t.fadeIn, this.fadeOut = t.fadeOut;
  }
  static getDefaults() {
    return Object.assign(Ii.getDefaults(), {
      autostart: !1,
      fadeIn: 0,
      fadeOut: 0,
      loop: !1,
      loopEnd: 0,
      loopStart: 0,
      onload: wt,
      onerror: wt,
      playbackRate: 1,
      reverse: !1
    });
  }
  /**
   * Load the audio file as an audio buffer.
   * Decodes the audio asynchronously and invokes
   * the callback once the audio buffer loads.
   * Note: this does not need to be called if a url
   * was passed in to the constructor. Only use this
   * if you want to manually load a new url.
   * @param url The url of the buffer to load. Filetype support depends on the browser.
   */
  load(t) {
    return mn(this, void 0, void 0, function* () {
      return yield this._buffer.load(t), this._onload(), this;
    });
  }
  /**
   * Internal callback when the buffer is loaded.
   */
  _onload(t = wt) {
    t(), this.autostart && this.start();
  }
  /**
   * Internal callback when the buffer is done playing.
   */
  _onSourceEnd(t) {
    this.onstop(this), this._activeSources.delete(t), this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started" && (this._state.cancel(this.now()), this._state.setStateAtTime("stopped", this.now()));
  }
  /**
   * Play the buffer at the given startTime. Optionally add an offset
   * and/or duration which will play the buffer from a position
   * within the buffer for the given duration.
   *
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
   */
  start(t, n, i) {
    return super.start(t, n, i), this;
  }
  /**
   * Internal start method
   */
  _start(t, n, i) {
    this._loop ? n = hl(n, this._loopStart) : n = hl(n, 0);
    const r = this.toSeconds(n), s = i;
    i = hl(i, Math.max(this._buffer.duration - r, 0));
    let a = this.toSeconds(i);
    a = a / this._playbackRate, t = this.toSeconds(t);
    const o = new hc({
      url: this._buffer,
      context: this.context,
      fadeIn: this.fadeIn,
      fadeOut: this.fadeOut,
      loop: this._loop,
      loopEnd: this._loopEnd,
      loopStart: this._loopStart,
      onended: this._onSourceEnd.bind(this),
      playbackRate: this._playbackRate
    }).connect(this.output);
    !this._loop && !this._synced && (this._state.cancel(t + a), this._state.setStateAtTime("stopped", t + a, {
      implicitEnd: !0
    })), this._activeSources.add(o), this._loop && Zi(s) ? o.start(t, r) : o.start(t, r, a - this.toSeconds(this.fadeOut));
  }
  /**
   * Stop playback.
   */
  _stop(t) {
    const n = this.toSeconds(t);
    this._activeSources.forEach((i) => i.stop(n));
  }
  /**
   * Stop and then restart the player from the beginning (or offset)
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given,
   * 					it will default to the full length of the sample (minus any offset)
   */
  restart(t, n, i) {
    return super.restart(t, n, i), this;
  }
  _restart(t, n, i) {
    var r;
    (r = [...this._activeSources].pop()) === null || r === void 0 || r.stop(t), this._start(t, n, i);
  }
  /**
   * Seek to a specific time in the player's buffer. If the
   * source is no longer playing at that time, it will stop.
   * @param offset The time to seek to.
   * @param when The time for the seek event to occur.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/gurgling_theremin_1.mp3", () => {
   * 	player.start();
   * 	// seek to the offset in 1 second from now
   * 	player.seek(0.4, "+1");
   * }).toDestination();
   */
  seek(t, n) {
    const i = this.toSeconds(n);
    if (this._state.getValueAtTime(i) === "started") {
      const r = this.toSeconds(t);
      this._stop(i), this._start(i, r);
    }
    return this;
  }
  /**
   * Set the loop start and end. Will only loop if loop is set to true.
   * @param loopStart The loop start time
   * @param loopEnd The loop end time
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/malevoices_aa2_F3.mp3").toDestination();
   * // loop between the given points
   * player.setLoopPoints(0.2, 0.3);
   * player.loop = true;
   * player.autostart = true;
   */
  setLoopPoints(t, n) {
    return this.loopStart = t, this.loopEnd = n, this;
  }
  /**
   * If loop is true, the loop will start at this position.
   */
  get loopStart() {
    return this._loopStart;
  }
  set loopStart(t) {
    this._loopStart = t, this.buffer.loaded && sa(this.toSeconds(t), 0, this.buffer.duration), this._activeSources.forEach((n) => {
      n.loopStart = t;
    });
  }
  /**
   * If loop is true, the loop will end at this position.
   */
  get loopEnd() {
    return this._loopEnd;
  }
  set loopEnd(t) {
    this._loopEnd = t, this.buffer.loaded && sa(this.toSeconds(t), 0, this.buffer.duration), this._activeSources.forEach((n) => {
      n.loopEnd = t;
    });
  }
  /**
   * The audio buffer belonging to the player.
   */
  get buffer() {
    return this._buffer;
  }
  set buffer(t) {
    this._buffer.set(t);
  }
  /**
   * If the buffer should loop once it's over.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/breakbeat.mp3").toDestination();
   * player.loop = true;
   * player.autostart = true;
   */
  get loop() {
    return this._loop;
  }
  set loop(t) {
    if (this._loop !== t && (this._loop = t, this._activeSources.forEach((n) => {
      n.loop = t;
    }), t)) {
      const n = this._state.getNextState("stopped", this.now());
      n && this._state.cancel(n.time);
    }
  }
  /**
   * Normal speed is 1. The pitch will change with the playback rate.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/femalevoices_aa2_A5.mp3").toDestination();
   * // play at 1/4 speed
   * player.playbackRate = 0.25;
   * // play as soon as the buffer is loaded
   * player.autostart = true;
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(t) {
    this._playbackRate = t;
    const n = this.now(), i = this._state.getNextState("stopped", n);
    i && i.implicitEnd && (this._state.cancel(i.time), this._activeSources.forEach((r) => r.cancelStop())), this._activeSources.forEach((r) => {
      r.playbackRate.setValueAtTime(t, n);
    });
  }
  /**
   * If the buffer should be reversed. Note that this sets the underlying {@link ToneAudioBuffer.reverse}, so
   * if multiple players are pointing at the same ToneAudioBuffer, they will all be reversed.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/chime_1.mp3").toDestination();
   * player.autostart = true;
   * player.reverse = true;
   */
  get reverse() {
    return this._buffer.reverse;
  }
  set reverse(t) {
    this._buffer.reverse = t;
  }
  /**
   * If the buffer is loaded
   */
  get loaded() {
    return this._buffer.loaded;
  }
  dispose() {
    return super.dispose(), this._activeSources.forEach((t) => t.dispose()), this._activeSources.clear(), this._buffer.dispose(), this;
  }
}
Vr([
  Os(0)
], Vl.prototype, "fadeIn", void 0);
Vr([
  Os(0)
], Vl.prototype, "fadeOut", void 0);
class Ss extends et {
  constructor() {
    super(Te(Ss.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])), this.name = "Envelope", this._sig = new bn({
      context: this.context,
      value: 0
    }), this.output = this._sig, this.input = void 0;
    const t = Te(Ss.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
    this.attack = t.attack, this.decay = t.decay, this.sustain = t.sustain, this.release = t.release, this.attackCurve = t.attackCurve, this.releaseCurve = t.releaseCurve, this.decayCurve = t.decayCurve;
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      attack: 0.01,
      attackCurve: "linear",
      decay: 0.1,
      decayCurve: "exponential",
      release: 1,
      releaseCurve: "exponential",
      sustain: 0.5
    });
  }
  /**
   * Read the current value of the envelope. Useful for
   * synchronizing visual output to the envelope.
   */
  get value() {
    return this.getValueAtTime(this.now());
  }
  /**
   * Get the curve
   * @param  curve
   * @param  direction  In/Out
   * @return The curve name
   */
  _getCurve(t, n) {
    if (_s(t))
      return t;
    {
      let i;
      for (i in Nd)
        if (Nd[i][n] === t)
          return i;
      return t;
    }
  }
  /**
   * Assign a the curve to the given name using the direction
   * @param  name
   * @param  direction In/Out
   * @param  curve
   */
  _setCurve(t, n, i) {
    if (_s(i) && Reflect.has(Nd, i)) {
      const r = Nd[i];
      Ua(r) ? t !== "_decayCurve" && (this[t] = r[n]) : this[t] = r;
    } else if (wr(i) && t !== "_decayCurve")
      this[t] = i;
    else
      throw new Error("Envelope: invalid curve: " + i);
  }
  /**
   * The shape of the attack.
   * Can be any of these strings:
   * * "linear"
   * * "exponential"
   * * "sine"
   * * "cosine"
   * * "bounce"
   * * "ripple"
   * * "step"
   *
   * Can also be an array which describes the curve. Values
   * in the array are evenly subdivided and linearly
   * interpolated over the duration of the attack.
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope(0.4).toDestination();
   * 	env.attackCurve = "linear";
   * 	env.triggerAttack();
   * }, 1, 1);
   */
  get attackCurve() {
    return this._getCurve(this._attackCurve, "In");
  }
  set attackCurve(t) {
    this._setCurve("_attackCurve", "In", t);
  }
  /**
   * The shape of the release. See the attack curve types.
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope({
   * 		release: 0.8
   * 	}).toDestination();
   * 	env.triggerAttack();
   * 	// release curve could also be defined by an array
   * 	env.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];
   * 	env.triggerRelease(0.2);
   * }, 1, 1);
   */
  get releaseCurve() {
    return this._getCurve(this._releaseCurve, "Out");
  }
  set releaseCurve(t) {
    this._setCurve("_releaseCurve", "Out", t);
  }
  /**
   * The shape of the decay either "linear" or "exponential"
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope({
   * 		sustain: 0.1,
   * 		decay: 0.5
   * 	}).toDestination();
   * 	env.decayCurve = "linear";
   * 	env.triggerAttack();
   * }, 1, 1);
   */
  get decayCurve() {
    return this._getCurve(this._decayCurve, "Out");
  }
  set decayCurve(t) {
    this._setCurve("_decayCurve", "Out", t);
  }
  /**
   * Trigger the attack/decay portion of the ADSR envelope.
   * @param  time When the attack should start.
   * @param velocity The velocity of the envelope scales the vales.
   *                             number between 0-1
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator().connect(env).start();
   * // trigger the attack 0.5 seconds from now with a velocity of 0.2
   * env.triggerAttack("+0.5", 0.2);
   */
  triggerAttack(t, n = 1) {
    this.log("triggerAttack", t, n), t = this.toSeconds(t);
    let r = this.toSeconds(this.attack);
    const s = this.toSeconds(this.decay), a = this.getValueAtTime(t);
    if (a > 0) {
      const o = 1 / r;
      r = (1 - a) / o;
    }
    if (r < this.sampleTime)
      this._sig.cancelScheduledValues(t), this._sig.setValueAtTime(n, t);
    else if (this._attackCurve === "linear")
      this._sig.linearRampTo(n, r, t);
    else if (this._attackCurve === "exponential")
      this._sig.targetRampTo(n, r, t);
    else {
      this._sig.cancelAndHoldAtTime(t);
      let o = this._attackCurve;
      for (let l = 1; l < o.length; l++)
        if (o[l - 1] <= a && a <= o[l]) {
          o = this._attackCurve.slice(l), o[0] = a;
          break;
        }
      this._sig.setValueCurveAtTime(o, t, r, n);
    }
    if (s && this.sustain < 1) {
      const o = n * this.sustain, l = t + r;
      this.log("decay", l), this._decayCurve === "linear" ? this._sig.linearRampToValueAtTime(o, s + l) : this._sig.exponentialApproachValueAtTime(o, l, s);
    }
    return this;
  }
  /**
   * Triggers the release of the envelope.
   * @param  time When the release portion of the envelope should start.
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator({
   * 	type: "sawtooth"
   * }).connect(env).start();
   * env.triggerAttack();
   * // trigger the release half a second after the attack
   * env.triggerRelease("+0.5");
   */
  triggerRelease(t) {
    this.log("triggerRelease", t), t = this.toSeconds(t);
    const n = this.getValueAtTime(t);
    if (n > 0) {
      const i = this.toSeconds(this.release);
      i < this.sampleTime ? this._sig.setValueAtTime(0, t) : this._releaseCurve === "linear" ? this._sig.linearRampTo(0, i, t) : this._releaseCurve === "exponential" ? this._sig.targetRampTo(0, i, t) : (Xe(wr(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array"), this._sig.cancelAndHoldAtTime(t), this._sig.setValueCurveAtTime(this._releaseCurve, t, i, n));
    }
    return this;
  }
  /**
   * Get the scheduled value at the given time. This will
   * return the unconverted (raw) value.
   * @example
   * const env = new Tone.Envelope(0.5, 1, 0.4, 2);
   * env.triggerAttackRelease(2);
   * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);
   */
  getValueAtTime(t) {
    return this._sig.getValueAtTime(t);
  }
  /**
   * triggerAttackRelease is shorthand for triggerAttack, then waiting
   * some duration, then triggerRelease.
   * @param duration The duration of the sustain.
   * @param time When the attack should be triggered.
   * @param velocity The velocity of the envelope.
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator().connect(env).start();
   * // trigger the release 0.5 seconds after the attack
   * env.triggerAttackRelease(0.5);
   */
  triggerAttackRelease(t, n, i = 1) {
    return n = this.toSeconds(n), this.triggerAttack(n, i), this.triggerRelease(n + this.toSeconds(t)), this;
  }
  /**
   * Cancels all scheduled envelope changes after the given time.
   */
  cancel(t) {
    return this._sig.cancelScheduledValues(this.toSeconds(t)), this;
  }
  /**
   * Connect the envelope to a destination node.
   */
  connect(t, n = 0, i = 0) {
    return qy(this, t, n, i), this;
  }
  /**
   * Render the envelope curve to an array of the given length.
   * Good for visualizing the envelope curve. Rescales the duration of the
   * envelope to fit the length.
   */
  asArray(t = 1024) {
    return mn(this, void 0, void 0, function* () {
      const n = t / this.context.sampleRate, i = new Hy(1, n, this.context.sampleRate), r = this.toSeconds(this.attack) + this.toSeconds(this.decay), s = r + this.toSeconds(this.release), a = s * 0.1, o = s + a, l = new this.constructor(Object.assign(this.get(), {
        attack: n * this.toSeconds(this.attack) / o,
        decay: n * this.toSeconds(this.decay) / o,
        release: n * this.toSeconds(this.release) / o,
        context: i
      }));
      return l._sig.toDestination(), l.triggerAttackRelease(n * (r + a) / o, 0), (yield i.render()).getChannelData(0);
    });
  }
  dispose() {
    return super.dispose(), this._sig.dispose(), this;
  }
}
Vr([
  Os(0)
], Ss.prototype, "attack", void 0);
Vr([
  Os(0)
], Ss.prototype, "decay", void 0);
Vr([
  Ex(0, 1)
], Ss.prototype, "sustain", void 0);
Vr([
  Os(0)
], Ss.prototype, "release", void 0);
const Nd = (() => {
  let t, n;
  const i = [];
  for (t = 0; t < 128; t++)
    i[t] = Math.sin(t / (128 - 1) * (Math.PI / 2));
  const r = [], s = 6.4;
  for (t = 0; t < 128 - 1; t++) {
    n = t / (128 - 1);
    const f = Math.sin(n * (Math.PI * 2) * s - Math.PI / 2) + 1;
    r[t] = f / 10 + n * 0.83;
  }
  r[128 - 1] = 1;
  const a = [], o = 5;
  for (t = 0; t < 128; t++)
    a[t] = Math.ceil(t / (128 - 1) * o) / o;
  const l = [];
  for (t = 0; t < 128; t++)
    n = t / (128 - 1), l[t] = 0.5 * (1 - Math.cos(Math.PI * n));
  const u = [];
  for (t = 0; t < 128; t++) {
    n = t / (128 - 1);
    const f = Math.pow(n, 3) * 4 + 0.2, h = Math.cos(f * Math.PI * 2 * n);
    u[t] = Math.abs(h * (1 - n));
  }
  function c(f) {
    const h = new Array(f.length);
    for (let m = 0; m < f.length; m++)
      h[m] = 1 - f[m];
    return h;
  }
  function d(f) {
    return f.slice(0).reverse();
  }
  return {
    bounce: {
      In: c(u),
      Out: u
    },
    cosine: {
      In: i,
      Out: d(i)
    },
    exponential: "exponential",
    linear: "linear",
    ripple: {
      In: r,
      Out: c(r)
    },
    sine: {
      In: l,
      Out: c(l)
    },
    step: {
      In: a,
      Out: c(a)
    }
  };
})();
class lo extends et {
  constructor() {
    super(Te(lo.getDefaults(), arguments)), this._scheduledEvents = [], this._synced = !1, this._original_triggerAttack = this.triggerAttack, this._original_triggerRelease = this.triggerRelease, this._syncedRelease = (n) => this._original_triggerRelease(n);
    const t = Te(lo.getDefaults(), arguments);
    this._volume = this.output = new ao({
      context: this.context,
      volume: t.volume
    }), this.volume = this._volume.volume, Jt(this, "volume");
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      volume: 0
    });
  }
  /**
   * Sync the instrument to the Transport. All subsequent calls of
   * {@link triggerAttack} and {@link triggerRelease} will be scheduled along the transport.
   * @example
   * const fmSynth = new Tone.FMSynth().toDestination();
   * fmSynth.volume.value = -6;
   * fmSynth.sync();
   * // schedule 3 notes when the transport first starts
   * fmSynth.triggerAttackRelease("C4", "8n", 0);
   * fmSynth.triggerAttackRelease("E4", "8n", "8n");
   * fmSynth.triggerAttackRelease("G4", "8n", "4n");
   * // start the transport to hear the notes
   * Tone.Transport.start();
   */
  sync() {
    return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 0), this.context.transport.on("stop", this._syncedRelease), this.context.transport.on("pause", this._syncedRelease), this.context.transport.on("loopEnd", this._syncedRelease)), this;
  }
  /**
   * set _sync
   */
  _syncState() {
    let t = !1;
    return this._synced || (this._synced = !0, t = !0), t;
  }
  /**
   * Wrap the given method so that it can be synchronized
   * @param method Which method to wrap and sync
   * @param  timePosition What position the time argument appears in
   */
  _syncMethod(t, n) {
    const i = this["_original_" + t] = this[t];
    this[t] = (...r) => {
      const s = r[n], a = this.context.transport.schedule((o) => {
        r[n] = o, i.apply(this, r);
      }, s);
      this._scheduledEvents.push(a);
    };
  }
  /**
   * Unsync the instrument from the Transport
   */
  unsync() {
    return this._scheduledEvents.forEach((t) => this.context.transport.clear(t)), this._scheduledEvents = [], this._synced && (this._synced = !1, this.triggerAttack = this._original_triggerAttack, this.triggerRelease = this._original_triggerRelease, this.context.transport.off("stop", this._syncedRelease), this.context.transport.off("pause", this._syncedRelease), this.context.transport.off("loopEnd", this._syncedRelease)), this;
  }
  /**
   * Trigger the attack and then the release after the duration.
   * @param  note     The note to trigger.
   * @param  duration How long the note should be held for before
   *                         triggering the release. This value must be greater than 0.
   * @param time  When the note should be triggered.
   * @param  velocity The velocity the note should be triggered at.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * // trigger "C4" for the duration of an 8th note
   * synth.triggerAttackRelease("C4", "8n");
   */
  triggerAttackRelease(t, n, i, r) {
    const s = this.toSeconds(i), a = this.toSeconds(n);
    return this.triggerAttack(t, s, r), this.triggerRelease(s + a), this;
  }
  /**
   * clean up
   * @returns {Instrument} this
   */
  dispose() {
    return super.dispose(), this._volume.dispose(), this.unsync(), this._scheduledEvents = [], this;
  }
}
class uo extends lo {
  constructor() {
    super(Te(uo.getDefaults(), arguments));
    const t = Te(uo.getDefaults(), arguments);
    this.portamento = t.portamento, this.onsilence = t.onsilence;
  }
  static getDefaults() {
    return Object.assign(lo.getDefaults(), {
      detune: 0,
      onsilence: wt,
      portamento: 0
    });
  }
  /**
   * Trigger the attack of the note optionally with a given velocity.
   * @param  note The note to trigger.
   * @param  time When the note should start.
   * @param  velocity The velocity determines how "loud" the note will be.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * // trigger the note a half second from now at half velocity
   * synth.triggerAttack("C4", "+0.5", 0.5);
   */
  triggerAttack(t, n, i = 1) {
    this.log("triggerAttack", t, n, i);
    const r = this.toSeconds(n);
    return this._triggerEnvelopeAttack(r, i), this.setNote(t, r), this;
  }
  /**
   * Trigger the release portion of the envelope.
   * @param  time If no time is given, the release happens immediately.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * synth.triggerAttack("C4");
   * // trigger the release a second from now
   * synth.triggerRelease("+1");
   */
  triggerRelease(t) {
    this.log("triggerRelease", t);
    const n = this.toSeconds(t);
    return this._triggerEnvelopeRelease(n), this;
  }
  /**
   * Set the note at the given time. If no time is given, the note
   * will set immediately.
   * @param note The note to change to.
   * @param  time The time when the note should be set.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * synth.triggerAttack("C4");
   * // change to F#6 in one quarter note from now.
   * synth.setNote("F#6", "+4n");
   */
  setNote(t, n) {
    const i = this.toSeconds(n), r = t instanceof Gi ? t.toFrequency() : t;
    if (this.portamento > 0 && this.getLevelAtTime(i) > 0.05) {
      const s = this.toSeconds(this.portamento);
      this.frequency.exponentialRampTo(r, s, i);
    } else
      this.frequency.setValueAtTime(r, i);
    return this;
  }
}
Vr([
  Os(0)
], uo.prototype, "portamento", void 0);
class Zy extends Ss {
  constructor() {
    super(Te(Zy.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])), this.name = "AmplitudeEnvelope", this._gainNode = new Ln({
      context: this.context,
      gain: 0
    }), this.output = this._gainNode, this.input = this._gainNode, this._sig.connect(this._gainNode.gain), this.output = this._gainNode, this.input = this._gainNode;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._gainNode.dispose(), this;
  }
}
class bc extends uo {
  constructor() {
    super(Te(bc.getDefaults(), arguments)), this.name = "Synth";
    const t = Te(bc.getDefaults(), arguments);
    this.oscillator = new yc(Object.assign({
      context: this.context,
      detune: t.detune,
      onstop: () => this.onsilence(this)
    }, t.oscillator)), this.frequency = this.oscillator.frequency, this.detune = this.oscillator.detune, this.envelope = new Zy(Object.assign({
      context: this.context
    }, t.envelope)), this.oscillator.chain(this.envelope, this.output), Jt(this, ["oscillator", "frequency", "detune", "envelope"]);
  }
  static getDefaults() {
    return Object.assign(uo.getDefaults(), {
      envelope: Object.assign(T_(Ss.getDefaults(), Object.keys(et.getDefaults())), {
        attack: 5e-3,
        decay: 0.1,
        release: 1,
        sustain: 0.3
      }),
      oscillator: Object.assign(T_(yc.getDefaults(), [...Object.keys(Ii.getDefaults()), "frequency", "detune"]), {
        type: "triangle"
      })
    });
  }
  /**
   * start the attack portion of the envelope
   * @param time the time the attack should start
   * @param velocity the velocity of the note (0-1)
   */
  _triggerEnvelopeAttack(t, n) {
    if (this.envelope.triggerAttack(t, n), this.oscillator.start(t), this.envelope.sustain === 0) {
      const i = this.toSeconds(this.envelope.attack), r = this.toSeconds(this.envelope.decay);
      this.oscillator.stop(t + i + r);
    }
  }
  /**
   * start the release portion of the envelope
   * @param time the time the release should start
   */
  _triggerEnvelopeRelease(t) {
    this.envelope.triggerRelease(t), this.oscillator.stop(t + this.toSeconds(this.envelope.release));
  }
  getLevelAtTime(t) {
    return t = this.toSeconds(t), this.envelope.getValueAtTime(t);
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this.oscillator.dispose(), this.envelope.dispose(), this;
  }
}
class wc extends bc {
  constructor() {
    super(Te(wc.getDefaults(), arguments)), this.name = "MembraneSynth", this.portamento = 0;
    const t = Te(wc.getDefaults(), arguments);
    this.pitchDecay = t.pitchDecay, this.octaves = t.octaves, Jt(this, ["oscillator", "envelope"]);
  }
  static getDefaults() {
    return fl(uo.getDefaults(), bc.getDefaults(), {
      envelope: {
        attack: 1e-3,
        attackCurve: "exponential",
        decay: 0.4,
        release: 1.4,
        sustain: 0.01
      },
      octaves: 10,
      oscillator: {
        type: "sine"
      },
      pitchDecay: 0.05
    });
  }
  setNote(t, n) {
    const i = this.toSeconds(n), r = this.toFrequency(t instanceof Gi ? t.toFrequency() : t), s = r * this.octaves;
    return this.oscillator.frequency.setValueAtTime(s, i), this.oscillator.frequency.exponentialRampToValueAtTime(r, i + this.toSeconds(this.pitchDecay)), this;
  }
  dispose() {
    return super.dispose(), this;
  }
}
Vr([
  Ex(0)
], wc.prototype, "octaves", void 0);
Vr([
  Os(0)
], wc.prototype, "pitchDecay", void 0);
const Px = /* @__PURE__ */ new Set();
function Ky(e) {
  Px.add(e);
}
function Ox(e, t) {
  const n = (
    /* javascript */
    `registerProcessor("${e}", ${t})`
  );
  Px.add(n);
}
const yq = (
  /* javascript */
  `
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the {@link ToneAudioWorklet}. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`
);
Ky(yq);
const bq = (
  /* javascript */
  `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`
);
Ky(bq);
const wq = (
  /* javascript */
  `
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`
);
Ky(wq);
const _q = "feedback-comb-filter", Sq = (
  /* javascript */
  `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`
);
Ox(_q, Sq);
class _c extends lo {
  constructor() {
    super(Te(_c.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "Sampler", this._activeSources = /* @__PURE__ */ new Map();
    const t = Te(_c.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls"), n = {};
    Object.keys(t.urls).forEach((i) => {
      const r = parseInt(i, 10);
      if (Xe(Dd(i) || ro(r) && isFinite(r), `url key is neither a note or midi pitch: ${i}`), Dd(i)) {
        const s = new Gi(this.context, i).toMidi();
        n[s] = t.urls[i];
      } else
        ro(r) && isFinite(r) && (n[r] = t.urls[r]);
    }), this._buffers = new Gy({
      urls: n,
      onload: t.onload,
      baseUrl: t.baseUrl,
      onerror: t.onerror
    }), this.attack = t.attack, this.release = t.release, this.curve = t.curve, this._buffers.loaded && Promise.resolve().then(t.onload);
  }
  static getDefaults() {
    return Object.assign(lo.getDefaults(), {
      attack: 0,
      baseUrl: "",
      curve: "exponential",
      onload: wt,
      onerror: wt,
      release: 0.1,
      urls: {}
    });
  }
  /**
   * Returns the difference in steps between the given midi note at the closets sample.
   */
  _findClosest(t) {
    let i = 0;
    for (; i < 96; ) {
      if (this._buffers.has(t + i))
        return -i;
      if (this._buffers.has(t - i))
        return i;
      i++;
    }
    throw new Error(`No available buffers for note: ${t}`);
  }
  /**
   * @param  notes	The note to play, or an array of notes.
   * @param  time     When to play the note
   * @param  velocity The velocity to play the sample back.
   */
  triggerAttack(t, n, i = 1) {
    return this.log("triggerAttack", t, n, i), Array.isArray(t) || (t = [t]), t.forEach((r) => {
      const s = Ix(new Gi(this.context, r).toFrequency()), a = Math.round(s), o = s - a, l = this._findClosest(a), u = a - l, c = this._buffers.get(u), d = Ax(l + o), f = new hc({
        url: c,
        context: this.context,
        curve: this.curve,
        fadeIn: this.attack,
        fadeOut: this.release,
        playbackRate: d
      }).connect(this.output);
      f.start(n, 0, c.duration / d, i), wr(this._activeSources.get(a)) || this._activeSources.set(a, []), this._activeSources.get(a).push(f), f.onended = () => {
        if (this._activeSources && this._activeSources.has(a)) {
          const h = this._activeSources.get(a), m = h.indexOf(f);
          m !== -1 && h.splice(m, 1);
        }
      };
    }), this;
  }
  /**
   * @param  notes	The note to release, or an array of notes.
   * @param  time     	When to release the note.
   */
  triggerRelease(t, n) {
    return this.log("triggerRelease", t, n), Array.isArray(t) || (t = [t]), t.forEach((i) => {
      const r = new Gi(this.context, i).toMidi();
      if (this._activeSources.has(r) && this._activeSources.get(r).length) {
        const s = this._activeSources.get(r);
        n = this.toSeconds(n), s.forEach((a) => {
          a.stop(n);
        }), this._activeSources.set(r, []);
      }
    }), this;
  }
  /**
   * Release all currently active notes.
   * @param  time     	When to release the notes.
   */
  releaseAll(t) {
    const n = this.toSeconds(t);
    return this._activeSources.forEach((i) => {
      for (; i.length; )
        i.shift().stop(n);
    }), this;
  }
  sync() {
    return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this;
  }
  /**
   * Invoke the attack phase, then after the duration, invoke the release.
   * @param  notes	The note to play and release, or an array of notes.
   * @param  duration The time the note should be held
   * @param  time     When to start the attack
   * @param  velocity The velocity of the attack
   */
  triggerAttackRelease(t, n, i, r = 1) {
    const s = this.toSeconds(i);
    return this.triggerAttack(t, s, r), wr(n) ? (Xe(wr(t), "notes must be an array when duration is array"), t.forEach((a, o) => {
      const l = n[Math.min(o, n.length - 1)];
      this.triggerRelease(a, s + this.toSeconds(l));
    })) : this.triggerRelease(t, s + this.toSeconds(n)), this;
  }
  /**
   * Add a note to the sampler.
   * @param  note      The buffer's pitch.
   * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.
   * @param  callback  The callback to invoke when the url is loaded.
   */
  add(t, n, i) {
    if (Xe(Dd(t) || isFinite(t), `note must be a pitch or midi: ${t}`), Dd(t)) {
      const r = new Gi(this.context, t).toMidi();
      this._buffers.add(r, n, i);
    } else
      this._buffers.add(t, n, i);
    return this;
  }
  /**
   * If the buffers are loaded or not
   */
  get loaded() {
    return this._buffers.loaded;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._buffers.dispose(), this._activeSources.forEach((t) => {
      t.forEach((n) => n.dispose());
    }), this._activeSources.clear(), this;
  }
}
Vr([
  Os(0)
], _c.prototype, "attack", void 0);
Vr([
  Os(0)
], _c.prototype, "release", void 0);
class ih extends et {
  constructor() {
    super(Object.assign(Te(ih.getDefaults(), arguments, ["pan"]))), this.name = "Panner", this._panner = this.context.createStereoPanner(), this.input = this._panner, this.output = this._panner;
    const t = Te(ih.getDefaults(), arguments, ["pan"]);
    this.pan = new Lt({
      context: this.context,
      param: this._panner.pan,
      value: t.pan,
      minValue: -1,
      maxValue: 1
    }), this._panner.channelCount = t.channelCount, this._panner.channelCountMode = "explicit", Jt(this, "pan");
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      pan: 0,
      channelCount: 1
    });
  }
  dispose() {
    return super.dispose(), this._panner.disconnect(), this.pan.dispose(), this;
  }
}
const kq = "bit-crusher", Cq = (
  /* javascript */
  `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`
);
Ox(kq, Cq);
class en extends et {
  constructor() {
    super(Te(en.getDefaults(), arguments, ["solo"])), this.name = "Solo";
    const t = Te(en.getDefaults(), arguments, ["solo"]);
    this.input = this.output = new Ln({
      context: this.context
    }), en._allSolos.has(this.context) || en._allSolos.set(this.context, /* @__PURE__ */ new Set()), en._allSolos.get(this.context).add(this), this.solo = t.solo;
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      solo: !1
    });
  }
  /**
   * Isolates this instance and mutes all other instances of Solo.
   * Only one instance can be soloed at a time. A soloed
   * instance will report `solo=false` when another instance is soloed.
   */
  get solo() {
    return this._isSoloed();
  }
  set solo(t) {
    t ? this._addSolo() : this._removeSolo(), en._allSolos.get(this.context).forEach((n) => n._updateSolo());
  }
  /**
   * If the current instance is muted, i.e. another instance is soloed
   */
  get muted() {
    return this.input.gain.value === 0;
  }
  /**
   * Add this to the soloed array
   */
  _addSolo() {
    en._soloed.has(this.context) || en._soloed.set(this.context, /* @__PURE__ */ new Set()), en._soloed.get(this.context).add(this);
  }
  /**
   * Remove this from the soloed array
   */
  _removeSolo() {
    en._soloed.has(this.context) && en._soloed.get(this.context).delete(this);
  }
  /**
   * Is this on the soloed array
   */
  _isSoloed() {
    return en._soloed.has(this.context) && en._soloed.get(this.context).has(this);
  }
  /**
   * Returns true if no one is soloed
   */
  _noSolos() {
    return !en._soloed.has(this.context) || // or has a solo set but doesn't include any items
    en._soloed.has(this.context) && en._soloed.get(this.context).size === 0;
  }
  /**
   * Solo the current instance and unsolo all other instances.
   */
  _updateSolo() {
    this._isSoloed() ? this.input.gain.value = 1 : this._noSolos() ? this.input.gain.value = 1 : this.input.gain.value = 0;
  }
  dispose() {
    return super.dispose(), en._allSolos.get(this.context).delete(this), this._removeSolo(), this;
  }
}
en._allSolos = /* @__PURE__ */ new Map();
en._soloed = /* @__PURE__ */ new Map();
class rh extends et {
  constructor() {
    super(Te(rh.getDefaults(), arguments, ["pan", "volume"])), this.name = "PanVol";
    const t = Te(rh.getDefaults(), arguments, ["pan", "volume"]);
    this._panner = this.input = new ih({
      context: this.context,
      pan: t.pan,
      channelCount: t.channelCount
    }), this.pan = this._panner.pan, this._volume = this.output = new ao({
      context: this.context,
      volume: t.volume
    }), this.volume = this._volume.volume, this._panner.connect(this._volume), this.mute = t.mute, Jt(this, ["pan", "volume"]);
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      mute: !1,
      pan: 0,
      volume: 0,
      channelCount: 1
    });
  }
  /**
   * Mute/unmute the volume
   */
  get mute() {
    return this._volume.mute;
  }
  set mute(t) {
    this._volume.mute = t;
  }
  dispose() {
    return super.dispose(), this._panner.dispose(), this.pan.dispose(), this._volume.dispose(), this.volume.dispose(), this;
  }
}
class Va extends et {
  constructor() {
    super(Te(Va.getDefaults(), arguments, ["volume", "pan"])), this.name = "Channel";
    const t = Te(Va.getDefaults(), arguments, ["volume", "pan"]);
    this._solo = this.input = new en({
      solo: t.solo,
      context: this.context
    }), this._panVol = this.output = new rh({
      context: this.context,
      pan: t.pan,
      volume: t.volume,
      mute: t.mute,
      channelCount: t.channelCount
    }), this.pan = this._panVol.pan, this.volume = this._panVol.volume, this._solo.connect(this._panVol), Jt(this, ["pan", "volume"]);
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      pan: 0,
      volume: 0,
      mute: !1,
      solo: !1,
      channelCount: 1
    });
  }
  /**
   * Solo/unsolo the channel. Soloing is only relative to other {@link Channel}s and {@link Solo} instances
   */
  get solo() {
    return this._solo.solo;
  }
  set solo(t) {
    this._solo.solo = t;
  }
  /**
   * If the current instance is muted, i.e. another instance is soloed,
   * or the channel is muted
   */
  get muted() {
    return this._solo.muted || this.mute;
  }
  /**
   * Mute/unmute the volume
   */
  get mute() {
    return this._panVol.mute;
  }
  set mute(t) {
    this._panVol.mute = t;
  }
  /**
   * Get the gain node belonging to the bus name. Create it if
   * it doesn't exist
   * @param name The bus name
   */
  _getBus(t) {
    return Va.buses.has(t) || Va.buses.set(t, new Ln({ context: this.context })), Va.buses.get(t);
  }
  /**
   * Send audio to another channel using a string. `send` is a lot like
   * {@link connect}, except it uses a string instead of an object. This can
   * be useful in large applications to decouple sections since {@link send}
   * and {@link receive} can be invoked separately in order to connect an object
   * @param name The channel name to send the audio
   * @param volume The amount of the signal to send.
   * 	Defaults to 0db, i.e. send the entire signal
   * @returns Returns the gain node of this connection.
   */
  send(t, n = 0) {
    const i = this._getBus(t), r = new Ln({
      context: this.context,
      units: "decibels",
      gain: n
    });
    return this.connect(r), r.connect(i), r;
  }
  /**
   * Receive audio from a channel which was connected with {@link send}.
   * @param name The channel name to receive audio from.
   */
  receive(t) {
    return this._getBus(t).connect(this), this;
  }
  dispose() {
    return super.dispose(), this._panVol.dispose(), this.pan.dispose(), this.volume.dispose(), this._solo.dispose(), this;
  }
}
Va.buses = /* @__PURE__ */ new Map();
class Tq extends et {
  constructor() {
    super(...arguments), this.name = "Listener", this.positionX = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.positionX
    }), this.positionY = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.positionY
    }), this.positionZ = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.positionZ
    }), this.forwardX = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.forwardX
    }), this.forwardY = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.forwardY
    }), this.forwardZ = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.forwardZ
    }), this.upX = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.upX
    }), this.upY = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.upY
    }), this.upZ = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.upZ
    });
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      positionX: 0,
      positionY: 0,
      positionZ: 0,
      forwardX: 0,
      forwardY: 0,
      forwardZ: -1,
      upX: 0,
      upY: 1,
      upZ: 0
    });
  }
  dispose() {
    return super.dispose(), this.positionX.dispose(), this.positionY.dispose(), this.positionZ.dispose(), this.forwardX.dispose(), this.forwardY.dispose(), this.forwardZ.dispose(), this.upX.dispose(), this.upY.dispose(), this.upZ.dispose(), this;
  }
}
sm((e) => {
  e.listener = new Tq({ context: e });
});
am((e) => {
  e.listener.dispose();
});
vr().transport;
vr().destination;
vr().destination;
vr().listener;
vr().draw;
vr();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ji = function() {
  return ji = Object.assign || function(t) {
    for (var n, i = 1, r = arguments.length; i < r; i++) {
      n = arguments[i];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]);
    }
    return t;
  }, ji.apply(this, arguments);
}, xq = (
  /** @class */
  function() {
    function e(t) {
      this.options = t, this.listeners = {};
    }
    return e.prototype.on = function(t, n) {
      var i = this.listeners[t] || [];
      this.listeners[t] = i.concat([n]);
    }, e.prototype.triggerEvent = function(t, n) {
      var i = this, r = this.listeners[t] || [];
      r.forEach(function(s) {
        return s({ target: i, event: n });
      });
    }, e;
  }()
), Dl;
(function(e) {
  e[e.Add = 0] = "Add", e[e.Remove = 1] = "Remove";
})(Dl || (Dl = {}));
var Aq = (
  /** @class */
  function() {
    function e() {
      this.notifications = [];
    }
    return e.prototype.push = function(t) {
      this.notifications.push(t), this.updateFn(t, Dl.Add, this.notifications);
    }, e.prototype.splice = function(t, n) {
      var i = this.notifications.splice(t, n)[0];
      return this.updateFn(i, Dl.Remove, this.notifications), i;
    }, e.prototype.indexOf = function(t) {
      return this.notifications.indexOf(t);
    }, e.prototype.onUpdate = function(t) {
      this.updateFn = t;
    }, e;
  }()
), Js;
(function(e) {
  e.Dismiss = "dismiss", e.Click = "click";
})(Js || (Js = {}));
var A_ = {
  types: [
    {
      type: "success",
      className: "notyf__toast--success",
      backgroundColor: "#3dc763",
      icon: {
        className: "notyf__icon--success",
        tagName: "i"
      }
    },
    {
      type: "error",
      className: "notyf__toast--error",
      backgroundColor: "#ed3d3d",
      icon: {
        className: "notyf__icon--error",
        tagName: "i"
      }
    }
  ],
  duration: 2e3,
  ripple: !0,
  position: {
    x: "right",
    y: "bottom"
  },
  dismissible: !1
}, Iq = (
  /** @class */
  function() {
    function e() {
      this.notifications = [], this.events = {}, this.X_POSITION_FLEX_MAP = {
        left: "flex-start",
        center: "center",
        right: "flex-end"
      }, this.Y_POSITION_FLEX_MAP = {
        top: "flex-start",
        center: "center",
        bottom: "flex-end"
      };
      var t = document.createDocumentFragment(), n = this._createHTMLElement({ tagName: "div", className: "notyf" });
      t.appendChild(n), document.body.appendChild(t), this.container = n, this.animationEndEventName = this._getAnimationEndEventName(), this._createA11yContainer();
    }
    return e.prototype.on = function(t, n) {
      var i;
      this.events = ji(ji({}, this.events), (i = {}, i[t] = n, i));
    }, e.prototype.update = function(t, n) {
      n === Dl.Add ? this.addNotification(t) : n === Dl.Remove && this.removeNotification(t);
    }, e.prototype.removeNotification = function(t) {
      var n = this, i = this._popRenderedNotification(t), r;
      if (i) {
        r = i.node, r.classList.add("notyf__toast--disappear");
        var s;
        r.addEventListener(this.animationEndEventName, s = function(a) {
          a.target === r && (r.removeEventListener(n.animationEndEventName, s), n.container.removeChild(r));
        });
      }
    }, e.prototype.addNotification = function(t) {
      var n = this._renderNotification(t);
      this.notifications.push({ notification: t, node: n }), this._announce(t.options.message || "Notification");
    }, e.prototype._renderNotification = function(t) {
      var n, i = this._buildNotificationCard(t), r = t.options.className;
      return r && (n = i.classList).add.apply(n, r.split(" ")), this.container.appendChild(i), i;
    }, e.prototype._popRenderedNotification = function(t) {
      for (var n = -1, i = 0; i < this.notifications.length && n < 0; i++)
        this.notifications[i].notification === t && (n = i);
      if (n !== -1)
        return this.notifications.splice(n, 1)[0];
    }, e.prototype.getXPosition = function(t) {
      var n;
      return ((n = t == null ? void 0 : t.position) === null || n === void 0 ? void 0 : n.x) || "right";
    }, e.prototype.getYPosition = function(t) {
      var n;
      return ((n = t == null ? void 0 : t.position) === null || n === void 0 ? void 0 : n.y) || "bottom";
    }, e.prototype.adjustContainerAlignment = function(t) {
      var n = this.X_POSITION_FLEX_MAP[this.getXPosition(t)], i = this.Y_POSITION_FLEX_MAP[this.getYPosition(t)], r = this.container.style;
      r.setProperty("justify-content", i), r.setProperty("align-items", n);
    }, e.prototype._buildNotificationCard = function(t) {
      var n = this, i = t.options, r = i.icon;
      this.adjustContainerAlignment(i);
      var s = this._createHTMLElement({ tagName: "div", className: "notyf__toast" }), a = this._createHTMLElement({ tagName: "div", className: "notyf__ripple" }), o = this._createHTMLElement({ tagName: "div", className: "notyf__wrapper" }), l = this._createHTMLElement({ tagName: "div", className: "notyf__message" });
      l.innerHTML = i.message || "";
      var u = i.background || i.backgroundColor;
      if (r) {
        var c = this._createHTMLElement({ tagName: "div", className: "notyf__icon" });
        if ((typeof r == "string" || r instanceof String) && (c.innerHTML = new String(r).valueOf()), typeof r == "object") {
          var d = r.tagName, f = d === void 0 ? "i" : d, h = r.className, m = r.text, g = r.color, p = g === void 0 ? u : g, y = this._createHTMLElement({ tagName: f, className: h, text: m });
          p && (y.style.color = p), c.appendChild(y);
        }
        o.appendChild(c);
      }
      if (o.appendChild(l), s.appendChild(o), u && (i.ripple ? (a.style.background = u, s.appendChild(a)) : s.style.background = u), i.dismissible) {
        var k = this._createHTMLElement({ tagName: "div", className: "notyf__dismiss" }), T = this._createHTMLElement({
          tagName: "button",
          className: "notyf__dismiss-btn"
        });
        k.appendChild(T), o.appendChild(k), s.classList.add("notyf__toast--dismissible"), T.addEventListener("click", function(w) {
          var S, C;
          (C = (S = n.events)[Js.Dismiss]) === null || C === void 0 || C.call(S, { target: t, event: w }), w.stopPropagation();
        });
      }
      s.addEventListener("click", function(w) {
        var S, C;
        return (C = (S = n.events)[Js.Click]) === null || C === void 0 ? void 0 : C.call(S, { target: t, event: w });
      });
      var _ = this.getYPosition(i) === "top" ? "upper" : "lower";
      return s.classList.add("notyf__toast--" + _), s;
    }, e.prototype._createHTMLElement = function(t) {
      var n = t.tagName, i = t.className, r = t.text, s = document.createElement(n);
      return i && (s.className = i), s.textContent = r || null, s;
    }, e.prototype._createA11yContainer = function() {
      var t = this._createHTMLElement({ tagName: "div", className: "notyf-announcer" });
      t.setAttribute("aria-atomic", "true"), t.setAttribute("aria-live", "polite"), t.style.border = "0", t.style.clip = "rect(0 0 0 0)", t.style.height = "1px", t.style.margin = "-1px", t.style.overflow = "hidden", t.style.padding = "0", t.style.position = "absolute", t.style.width = "1px", t.style.outline = "0", document.body.appendChild(t), this.a11yContainer = t;
    }, e.prototype._announce = function(t) {
      var n = this;
      this.a11yContainer.textContent = "", setTimeout(function() {
        n.a11yContainer.textContent = t;
      }, 100);
    }, e.prototype._getAnimationEndEventName = function() {
      var t = document.createElement("_fake"), n = {
        MozTransition: "animationend",
        OTransition: "oAnimationEnd",
        WebkitTransition: "webkitAnimationEnd",
        transition: "animationend"
      }, i;
      for (i in n)
        if (t.style[i] !== void 0)
          return n[i];
      return "animationend";
    }, e;
  }()
), Eq = (
  /** @class */
  function() {
    function e(t) {
      var n = this;
      this.dismiss = this._removeNotification, this.notifications = new Aq(), this.view = new Iq();
      var i = this.registerTypes(t);
      this.options = ji(ji({}, A_), t), this.options.types = i, this.notifications.onUpdate(function(r, s) {
        return n.view.update(r, s);
      }), this.view.on(Js.Dismiss, function(r) {
        var s = r.target, a = r.event;
        n._removeNotification(s), s.triggerEvent(Js.Dismiss, a);
      }), this.view.on(Js.Click, function(r) {
        var s = r.target, a = r.event;
        return s.triggerEvent(Js.Click, a);
      });
    }
    return e.prototype.error = function(t) {
      var n = this.normalizeOptions("error", t);
      return this.open(n);
    }, e.prototype.success = function(t) {
      var n = this.normalizeOptions("success", t);
      return this.open(n);
    }, e.prototype.open = function(t) {
      var n = this.options.types.find(function(s) {
        var a = s.type;
        return a === t.type;
      }) || {}, i = ji(ji({}, n), t);
      this.assignProps(["ripple", "position", "dismissible"], i);
      var r = new xq(i);
      return this._pushNotification(r), r;
    }, e.prototype.dismissAll = function() {
      for (; this.notifications.splice(0, 1); )
        ;
    }, e.prototype.assignProps = function(t, n) {
      var i = this;
      t.forEach(function(r) {
        n[r] = n[r] == null ? i.options[r] : n[r];
      });
    }, e.prototype._pushNotification = function(t) {
      var n = this;
      this.notifications.push(t);
      var i = t.options.duration !== void 0 ? t.options.duration : this.options.duration;
      i && setTimeout(function() {
        return n._removeNotification(t);
      }, i);
    }, e.prototype._removeNotification = function(t) {
      var n = this.notifications.indexOf(t);
      n !== -1 && this.notifications.splice(n, 1);
    }, e.prototype.normalizeOptions = function(t, n) {
      var i = { type: t };
      return typeof n == "string" ? i.message = n : typeof n == "object" && (i = ji(ji({}, i), n)), i;
    }, e.prototype.registerTypes = function(t) {
      var n = (t && t.types || []).slice(), i = A_.types.map(function(r) {
        var s = -1;
        n.forEach(function(o, l) {
          o.type === r.type && (s = l);
        });
        var a = s !== -1 ? n.splice(s, 1)[0] : {};
        return ji(ji({}, r), a);
      });
      return i.concat(n);
    }, e;
  }()
), Pq = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, hu = (e, t, n) => (Pq(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Oq = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, xa;
const Vx = {
  backdrop: !0,
  color: "#000000",
  customClass: {
    title: "text-h6",
    htmlContainer: "text-body-2",
    popup: "v-card v-card--density-default v-card--variant-elevated bg-surface elevation-3 pb-3",
    confirmButton: "v-btn v-btn--elevated bg-primary v-btn--density-default v-btn--size-default v-btn--variant-elevated",
    denyButton: "v-btn v-btn--elevated bg-error v-btn--density-default v-btn--size-default v-btn--variant-elevated",
    cancelButton: "v-btn v-btn--elevated bg-cancel v-btn--density-default v-btn--size-default v-btn--variant-elevated"
  },
  buttonsStyling: !0,
  reverseButtons: !0
}, I_ = no.mixin(Vx), Dx = Mh({}, Vx, {
  toast: !0,
  position: "top-end",
  showConfirmButton: !1,
  timer: 3e3,
  timerProgressBar: !0,
  backdrop: void 0,
  didOpen: (e) => {
    e.onmouseenter = no.stopTimer, e.onmouseleave = no.resumeTimer;
  }
});
delete Dx.backdrop;
const E_ = no.mixin(Dx), Md = Is("Sounds");
class Vq {
  /**
   * Creates a new SoundsService
   * @param sounds A map of sound names to their urls
   */
  constructor(t) {
    Oq(this, xa, {}), t && (Md("Initializing sounds", t), this.add(t));
  }
  /**
   * Adds sounds to the service
   * @param sounds A map of sound names to their urls
   */
  add(t) {
    Object.keys(t).forEach((n) => {
      if (!hu(this, xa)[n]) {
        Md("Adding sound", n);
        const i = t[n];
        hu(this, xa)[n] = new Vl({
          url: i
        }).toDestination();
      }
    });
  }
  /**
   * Gets a sound from the service
   * @param key The key of the sound to retrieve
   * @returns The Tone.Player object for the sound
   */
  get(t) {
    return hu(this, xa)[t];
  }
  /**
   * Plays a sound
   * @param key The key of the sound to play
   */
  play(t) {
    const n = hu(this, xa)[t];
    n && (Md("Playing sound", t), n.start());
  }
  /**
   * Stops a sound
   * @param key The key of the sound to stop
   */
  stop(t) {
    const n = hu(this, xa)[t];
    n && (Md("Stopping sound", t), n.stop());
  }
}
xa = /* @__PURE__ */ new WeakMap();
const P_ = new Eq({
  dismissible: !0
}), Dq = {
  install: (e, t) => {
    e.provide("swal", I_), e.config.globalProperties.$swal = I_, e.provide("toast", E_), e.config.globalProperties.$toast = E_, e.provide("notyf", P_), e.config.globalProperties.$notyf = P_;
    const n = new Vq((t == null ? void 0 : t.sounds) || {});
    e.provide("sounds", n), e.config.globalProperties.$sounds = n;
  }
};
var Nq = { exports: {} };
(function(e) {
  (function() {
    function t(O, M, U) {
      return O.call.apply(O.bind, arguments);
    }
    function n(O, M, U) {
      if (!O)
        throw Error();
      if (2 < arguments.length) {
        var Y = Array.prototype.slice.call(arguments, 2);
        return function() {
          var ce = Array.prototype.slice.call(arguments);
          return Array.prototype.unshift.apply(ce, Y), O.apply(M, ce);
        };
      }
      return function() {
        return O.apply(M, arguments);
      };
    }
    function i(O, M, U) {
      return i = Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? t : n, i.apply(null, arguments);
    }
    var r = Date.now || function() {
      return +/* @__PURE__ */ new Date();
    };
    function s(O, M) {
      this.a = O, this.o = M || O, this.c = this.o.document;
    }
    var a = !!window.FontFace;
    function o(O, M, U, Y) {
      if (M = O.c.createElement(M), U)
        for (var ce in U)
          U.hasOwnProperty(ce) && (ce == "style" ? M.style.cssText = U[ce] : M.setAttribute(ce, U[ce]));
      return Y && M.appendChild(O.c.createTextNode(Y)), M;
    }
    function l(O, M, U) {
      O = O.c.getElementsByTagName(M)[0], O || (O = document.documentElement), O.insertBefore(U, O.lastChild);
    }
    function u(O) {
      O.parentNode && O.parentNode.removeChild(O);
    }
    function c(O, M, U) {
      M = M || [], U = U || [];
      for (var Y = O.className.split(/\s+/), ce = 0; ce < M.length; ce += 1) {
        for (var Se = !1, Ie = 0; Ie < Y.length; Ie += 1)
          if (M[ce] === Y[Ie]) {
            Se = !0;
            break;
          }
        Se || Y.push(M[ce]);
      }
      for (M = [], ce = 0; ce < Y.length; ce += 1) {
        for (Se = !1, Ie = 0; Ie < U.length; Ie += 1)
          if (Y[ce] === U[Ie]) {
            Se = !0;
            break;
          }
        Se || M.push(Y[ce]);
      }
      O.className = M.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "");
    }
    function d(O, M) {
      for (var U = O.className.split(/\s+/), Y = 0, ce = U.length; Y < ce; Y++)
        if (U[Y] == M)
          return !0;
      return !1;
    }
    function f(O) {
      return O.o.location.hostname || O.a.location.hostname;
    }
    function h(O, M, U) {
      function Y() {
        Ne && ce && Se && (Ne(Ie), Ne = null);
      }
      M = o(O, "link", { rel: "stylesheet", href: M, media: "all" });
      var ce = !1, Se = !0, Ie = null, Ne = U || null;
      a ? (M.onload = function() {
        ce = !0, Y();
      }, M.onerror = function() {
        ce = !0, Ie = Error("Stylesheet failed to load"), Y();
      }) : setTimeout(function() {
        ce = !0, Y();
      }, 0), l(O, "head", M);
    }
    function m(O, M, U, Y) {
      var ce = O.c.getElementsByTagName("head")[0];
      if (ce) {
        var Se = o(O, "script", { src: M }), Ie = !1;
        return Se.onload = Se.onreadystatechange = function() {
          Ie || this.readyState && this.readyState != "loaded" && this.readyState != "complete" || (Ie = !0, U && U(null), Se.onload = Se.onreadystatechange = null, Se.parentNode.tagName == "HEAD" && ce.removeChild(Se));
        }, ce.appendChild(Se), setTimeout(function() {
          Ie || (Ie = !0, U && U(Error("Script load timeout")));
        }, Y || 5e3), Se;
      }
      return null;
    }
    function g() {
      this.a = 0, this.c = null;
    }
    function p(O) {
      return O.a++, function() {
        O.a--, k(O);
      };
    }
    function y(O, M) {
      O.c = M, k(O);
    }
    function k(O) {
      O.a == 0 && O.c && (O.c(), O.c = null);
    }
    function T(O) {
      this.a = O || "-";
    }
    T.prototype.c = function(O) {
      for (var M = [], U = 0; U < arguments.length; U++)
        M.push(arguments[U].replace(/[\W_]+/g, "").toLowerCase());
      return M.join(this.a);
    };
    function _(O, M) {
      this.c = O, this.f = 4, this.a = "n";
      var U = (M || "n4").match(/^([nio])([1-9])$/i);
      U && (this.a = U[1], this.f = parseInt(U[2], 10));
    }
    function w(O) {
      return x(O) + " " + (O.f + "00") + " 300px " + S(O.c);
    }
    function S(O) {
      var M = [];
      O = O.split(/,\s*/);
      for (var U = 0; U < O.length; U++) {
        var Y = O[U].replace(/['"]/g, "");
        Y.indexOf(" ") != -1 || /^\d/.test(Y) ? M.push("'" + Y + "'") : M.push(Y);
      }
      return M.join(",");
    }
    function C(O) {
      return O.a + O.f;
    }
    function x(O) {
      var M = "normal";
      return O.a === "o" ? M = "oblique" : O.a === "i" && (M = "italic"), M;
    }
    function A(O) {
      var M = 4, U = "n", Y = null;
      return O && ((Y = O.match(/(normal|oblique|italic)/i)) && Y[1] && (U = Y[1].substr(0, 1).toLowerCase()), (Y = O.match(/([1-9]00|normal|bold)/i)) && Y[1] && (/bold/i.test(Y[1]) ? M = 7 : /[1-9]00/.test(Y[1]) && (M = parseInt(Y[1].substr(0, 1), 10)))), U + M;
    }
    function I(O, M) {
      this.c = O, this.f = O.o.document.documentElement, this.h = M, this.a = new T("-"), this.j = M.events !== !1, this.g = M.classes !== !1;
    }
    function E(O) {
      O.g && c(O.f, [O.a.c("wf", "loading")]), V(O, "loading");
    }
    function P(O) {
      if (O.g) {
        var M = d(O.f, O.a.c("wf", "active")), U = [], Y = [O.a.c("wf", "loading")];
        M || U.push(O.a.c("wf", "inactive")), c(O.f, U, Y);
      }
      V(O, "inactive");
    }
    function V(O, M, U) {
      O.j && O.h[M] && (U ? O.h[M](U.c, C(U)) : O.h[M]());
    }
    function N() {
      this.c = {};
    }
    function F(O, M, U) {
      var Y = [], ce;
      for (ce in M)
        if (M.hasOwnProperty(ce)) {
          var Se = O.c[ce];
          Se && Y.push(Se(M[ce], U));
        }
      return Y;
    }
    function $(O, M) {
      this.c = O, this.f = M, this.a = o(this.c, "span", { "aria-hidden": "true" }, this.f);
    }
    function Z(O) {
      l(O.c, "body", O.a);
    }
    function j(O) {
      return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + S(O.c) + ";" + ("font-style:" + x(O) + ";font-weight:" + (O.f + "00") + ";");
    }
    function H(O, M, U, Y, ce, Se) {
      this.g = O, this.j = M, this.a = Y, this.c = U, this.f = ce || 3e3, this.h = Se || void 0;
    }
    H.prototype.start = function() {
      var O = this.c.o.document, M = this, U = r(), Y = new Promise(function(Ie, Ne) {
        function Le() {
          r() - U >= M.f ? Ne() : O.fonts.load(w(M.a), M.h).then(function(Ge) {
            1 <= Ge.length ? Ie() : setTimeout(Le, 25);
          }, function() {
            Ne();
          });
        }
        Le();
      }), ce = null, Se = new Promise(function(Ie, Ne) {
        ce = setTimeout(Ne, M.f);
      });
      Promise.race([Se, Y]).then(function() {
        ce && (clearTimeout(ce), ce = null), M.g(M.a);
      }, function() {
        M.j(M.a);
      });
    };
    function R(O, M, U, Y, ce, Se, Ie) {
      this.v = O, this.B = M, this.c = U, this.a = Y, this.s = Ie || "BESbswy", this.f = {}, this.w = ce || 3e3, this.u = Se || null, this.m = this.j = this.h = this.g = null, this.g = new $(this.c, this.s), this.h = new $(this.c, this.s), this.j = new $(this.c, this.s), this.m = new $(this.c, this.s), O = new _(this.a.c + ",serif", C(this.a)), O = j(O), this.g.a.style.cssText = O, O = new _(this.a.c + ",sans-serif", C(this.a)), O = j(O), this.h.a.style.cssText = O, O = new _("serif", C(this.a)), O = j(O), this.j.a.style.cssText = O, O = new _("sans-serif", C(this.a)), O = j(O), this.m.a.style.cssText = O, Z(this.g), Z(this.h), Z(this.j), Z(this.m);
    }
    var L = { D: "serif", C: "sans-serif" }, ne = null;
    function oe() {
      if (ne === null) {
        var O = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
        ne = !!O && (536 > parseInt(O[1], 10) || parseInt(O[1], 10) === 536 && 11 >= parseInt(O[2], 10));
      }
      return ne;
    }
    R.prototype.start = function() {
      this.f.serif = this.j.a.offsetWidth, this.f["sans-serif"] = this.m.a.offsetWidth, this.A = r(), ee(this);
    };
    function we(O, M, U) {
      for (var Y in L)
        if (L.hasOwnProperty(Y) && M === O.f[L[Y]] && U === O.f[L[Y]])
          return !0;
      return !1;
    }
    function ee(O) {
      var M = O.g.a.offsetWidth, U = O.h.a.offsetWidth, Y;
      (Y = M === O.f.serif && U === O.f["sans-serif"]) || (Y = oe() && we(O, M, U)), Y ? r() - O.A >= O.w ? oe() && we(O, M, U) && (O.u === null || O.u.hasOwnProperty(O.a.c)) ? ue(O, O.v) : ue(O, O.B) : K(O) : ue(O, O.v);
    }
    function K(O) {
      setTimeout(i(function() {
        ee(this);
      }, O), 50);
    }
    function ue(O, M) {
      setTimeout(i(function() {
        u(this.g.a), u(this.h.a), u(this.j.a), u(this.m.a), M(this.a);
      }, O), 0);
    }
    function ve(O, M, U) {
      this.c = O, this.a = M, this.f = 0, this.m = this.j = !1, this.s = U;
    }
    var Fe = null;
    ve.prototype.g = function(O) {
      var M = this.a;
      M.g && c(M.f, [M.a.c("wf", O.c, C(O).toString(), "active")], [M.a.c("wf", O.c, C(O).toString(), "loading"), M.a.c("wf", O.c, C(O).toString(), "inactive")]), V(M, "fontactive", O), this.m = !0, he(this);
    }, ve.prototype.h = function(O) {
      var M = this.a;
      if (M.g) {
        var U = d(M.f, M.a.c("wf", O.c, C(O).toString(), "active")), Y = [], ce = [M.a.c("wf", O.c, C(O).toString(), "loading")];
        U || Y.push(M.a.c("wf", O.c, C(O).toString(), "inactive")), c(M.f, Y, ce);
      }
      V(M, "fontinactive", O), he(this);
    };
    function he(O) {
      --O.f == 0 && O.j && (O.m ? (O = O.a, O.g && c(O.f, [O.a.c("wf", "active")], [O.a.c("wf", "loading"), O.a.c("wf", "inactive")]), V(O, "active")) : P(O.a));
    }
    function Oe(O) {
      this.j = O, this.a = new N(), this.h = 0, this.f = this.g = !0;
    }
    Oe.prototype.load = function(O) {
      this.c = new s(this.j, O.context || this.j), this.g = O.events !== !1, this.f = O.classes !== !1, be(this, new I(this.c, O), O);
    };
    function le(O, M, U, Y, ce) {
      var Se = --O.h == 0;
      (O.f || O.g) && setTimeout(function() {
        var Ie = ce || null, Ne = Y || null || {};
        if (U.length === 0 && Se)
          P(M.a);
        else {
          M.f += U.length, Se && (M.j = Se);
          var Le, Ge = [];
          for (Le = 0; Le < U.length; Le++) {
            var qe = U[Le], Et = Ne[qe.c], Pt = M.a, ui = qe;
            if (Pt.g && c(Pt.f, [Pt.a.c("wf", ui.c, C(ui).toString(), "loading")]), V(Pt, "fontloading", ui), Pt = null, Fe === null)
              if (window.FontFace) {
                var ui = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent), ts = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                Fe = ui ? 42 < parseInt(ui[1], 10) : !ts;
              } else
                Fe = !1;
            Fe ? Pt = new H(i(M.g, M), i(M.h, M), M.c, qe, M.s, Et) : Pt = new R(i(M.g, M), i(M.h, M), M.c, qe, M.s, Ie, Et), Ge.push(Pt);
          }
          for (Le = 0; Le < Ge.length; Le++)
            Ge[Le].start();
        }
      }, 0);
    }
    function be(O, M, U) {
      var ce = [], Y = U.timeout;
      E(M);
      var ce = F(O.a, U, O.c), Se = new ve(O.c, M, Y);
      for (O.h = ce.length, M = 0, U = ce.length; M < U; M++)
        ce[M].load(function(Ie, Ne, Le) {
          le(O, Se, Ie, Ne, Le);
        });
    }
    function Pe(O, M) {
      this.c = O, this.a = M;
    }
    Pe.prototype.load = function(O) {
      function M() {
        if (Se["__mti_fntLst" + Y]) {
          var Ie = Se["__mti_fntLst" + Y](), Ne = [], Le;
          if (Ie)
            for (var Ge = 0; Ge < Ie.length; Ge++) {
              var qe = Ie[Ge].fontfamily;
              Ie[Ge].fontStyle != null && Ie[Ge].fontWeight != null ? (Le = Ie[Ge].fontStyle + Ie[Ge].fontWeight, Ne.push(new _(qe, Le))) : Ne.push(new _(qe));
            }
          O(Ne);
        } else
          setTimeout(function() {
            M();
          }, 50);
      }
      var U = this, Y = U.a.projectId, ce = U.a.version;
      if (Y) {
        var Se = U.c.o;
        m(this.c, (U.a.api || "https://fast.fonts.net/jsapi") + "/" + Y + ".js" + (ce ? "?v=" + ce : ""), function(Ie) {
          Ie ? O([]) : (Se["__MonotypeConfiguration__" + Y] = function() {
            return U.a;
          }, M());
        }).id = "__MonotypeAPIScript__" + Y;
      } else
        O([]);
    };
    function te(O, M) {
      this.c = O, this.a = M;
    }
    te.prototype.load = function(O) {
      var M, U, Y = this.a.urls || [], ce = this.a.families || [], Se = this.a.testStrings || {}, Ie = new g();
      for (M = 0, U = Y.length; M < U; M++)
        h(this.c, Y[M], p(Ie));
      var Ne = [];
      for (M = 0, U = ce.length; M < U; M++)
        if (Y = ce[M].split(":"), Y[1])
          for (var Le = Y[1].split(","), Ge = 0; Ge < Le.length; Ge += 1)
            Ne.push(new _(Y[0], Le[Ge]));
        else
          Ne.push(new _(Y[0]));
      y(Ie, function() {
        O(Ne, Se);
      });
    };
    function me(O, M) {
      O ? this.c = O : this.c = Me, this.a = [], this.f = [], this.g = M || "";
    }
    var Me = "https://fonts.googleapis.com/css";
    function Be(O, M) {
      for (var U = M.length, Y = 0; Y < U; Y++) {
        var ce = M[Y].split(":");
        ce.length == 3 && O.f.push(ce.pop());
        var Se = "";
        ce.length == 2 && ce[1] != "" && (Se = ":"), O.a.push(ce.join(Se));
      }
    }
    function xe(O) {
      if (O.a.length == 0)
        throw Error("No fonts to load!");
      if (O.c.indexOf("kit=") != -1)
        return O.c;
      for (var M = O.a.length, U = [], Y = 0; Y < M; Y++)
        U.push(O.a[Y].replace(/ /g, "+"));
      return M = O.c + "?family=" + U.join("%7C"), 0 < O.f.length && (M += "&subset=" + O.f.join(",")), 0 < O.g.length && (M += "&text=" + encodeURIComponent(O.g)), M;
    }
    function ze(O) {
      this.f = O, this.a = [], this.c = {};
    }
    var Ke = { latin: "BESbswy", "latin-ext": "", cyrillic: "", greek: "", khmer: "", Hanuman: "" }, ut = { thin: "1", extralight: "2", "extra-light": "2", ultralight: "2", "ultra-light": "2", light: "3", regular: "4", book: "4", medium: "5", "semi-bold": "6", semibold: "6", "demi-bold": "6", demibold: "6", bold: "7", "extra-bold": "8", extrabold: "8", "ultra-bold": "8", ultrabold: "8", black: "9", heavy: "9", l: "3", r: "4", b: "7" }, vt = { i: "i", italic: "i", n: "n", normal: "n" }, Vn = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
    function Dn(O) {
      for (var M = O.f.length, U = 0; U < M; U++) {
        var Y = O.f[U].split(":"), ce = Y[0].replace(/\+/g, " "), Se = ["n4"];
        if (2 <= Y.length) {
          var Ie, Ne = Y[1];
          if (Ie = [], Ne)
            for (var Ne = Ne.split(","), Le = Ne.length, Ge = 0; Ge < Le; Ge++) {
              var qe;
              if (qe = Ne[Ge], qe.match(/^[\w-]+$/)) {
                var Et = Vn.exec(qe.toLowerCase());
                if (Et == null)
                  qe = "";
                else {
                  if (qe = Et[2], qe = qe == null || qe == "" ? "n" : vt[qe], Et = Et[1], Et == null || Et == "")
                    Et = "4";
                  else
                    var Pt = ut[Et], Et = Pt || (isNaN(Et) ? "4" : Et.substr(0, 1));
                  qe = [qe, Et].join("");
                }
              } else
                qe = "";
              qe && Ie.push(qe);
            }
          0 < Ie.length && (Se = Ie), Y.length == 3 && (Y = Y[2], Ie = [], Y = Y ? Y.split(",") : Ie, 0 < Y.length && (Y = Ke[Y[0]]) && (O.c[ce] = Y));
        }
        for (O.c[ce] || (Y = Ke[ce]) && (O.c[ce] = Y), Y = 0; Y < Se.length; Y += 1)
          O.a.push(new _(ce, Se[Y]));
      }
    }
    function Dr(O, M) {
      this.c = O, this.a = M;
    }
    var ma = { Arimo: !0, Cousine: !0, Tinos: !0 };
    Dr.prototype.load = function(O) {
      var M = new g(), U = this.c, Y = new me(this.a.api, this.a.text), ce = this.a.families;
      Be(Y, ce);
      var Se = new ze(ce);
      Dn(Se), h(U, xe(Y), p(M)), y(M, function() {
        O(Se.a, Se.c, ma);
      });
    };
    function li(O, M) {
      this.c = O, this.a = M;
    }
    li.prototype.load = function(O) {
      var M = this.a.id, U = this.c.o;
      M ? m(this.c, (this.a.api || "https://use.typekit.net") + "/" + M + ".js", function(Y) {
        if (Y)
          O([]);
        else if (U.Typekit && U.Typekit.config && U.Typekit.config.fn) {
          Y = U.Typekit.config.fn;
          for (var ce = [], Se = 0; Se < Y.length; Se += 2)
            for (var Ie = Y[Se], Ne = Y[Se + 1], Le = 0; Le < Ne.length; Le++)
              ce.push(new _(Ie, Ne[Le]));
          try {
            U.Typekit.load({ events: !1, classes: !1, async: !0 });
          } catch {
          }
          O(ce);
        }
      }, 2e3) : O([]);
    };
    function q(O, M) {
      this.c = O, this.f = M, this.a = [];
    }
    q.prototype.load = function(O) {
      var M = this.f.id, U = this.c.o, Y = this;
      M ? (U.__webfontfontdeckmodule__ || (U.__webfontfontdeckmodule__ = {}), U.__webfontfontdeckmodule__[M] = function(ce, Se) {
        for (var Ie = 0, Ne = Se.fonts.length; Ie < Ne; ++Ie) {
          var Le = Se.fonts[Ie];
          Y.a.push(new _(Le.name, A("font-weight:" + Le.weight + ";font-style:" + Le.style)));
        }
        O(Y.a);
      }, m(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + f(this.c) + "/" + M + ".js", function(ce) {
        ce && O([]);
      })) : O([]);
    };
    var z = new Oe(window);
    z.a.c.custom = function(O, M) {
      return new te(M, O);
    }, z.a.c.fontdeck = function(O, M) {
      return new q(M, O);
    }, z.a.c.monotype = function(O, M) {
      return new Pe(M, O);
    }, z.a.c.typekit = function(O, M) {
      return new li(M, O);
    }, z.a.c.google = function(O, M) {
      return new Dr(M, O);
    };
    var de = { load: i(z.load, z) };
    e.exports ? e.exports = de : (window.WebFont = de, window.WebFontConfig && z.load(window.WebFontConfig));
  })();
})(Nq);
const Wo = Is("Webfontloader"), Mq = {
  install: (e, t) => {
    const n = X(!1);
    if (n.value === !1 && t && (t.custom || t.google || t.typekit || t.fontdeck || t.monotype)) {
      const i = () => {
        t && t.loading && typeof t.loading == "function" && t.loading(), e.config.globalProperties.$bus && e.config.globalProperties.$bus.emit("webfonts:loading", { local: !0 }), Wo("Webfonts loading");
      }, r = () => {
        t && t.active && typeof t.active == "function" && t.active(), e.config.globalProperties.$bus && e.config.globalProperties.$bus.emit("webfonts:active", { local: !0 }), Wo("Webfonts active");
      }, s = () => {
        t && t.inactive && typeof t.inactive == "function" && t.inactive(), e.config.globalProperties.$bus && e.config.globalProperties.$bus.emit("webfonts:inactive", { local: !0 }), Wo("Webfonts inactive");
      };
      if (typeof window < "u" && typeof window.WebFont < "u")
        try {
          window.WebFont.load({
            ...t,
            loading: i,
            active: r,
            inactive: s
          }), n.value = !0;
        } catch (a) {
          Wo("Error loading webfonts", a);
        }
      else
        typeof window.WebFont > "u" && Wo("WebFont not loaded in global scope");
    } else
      n.value === !1 && Wo("No webfonts to load");
  }
}, C9 = {
  install: (e, t) => {
    var n;
    e.use(e$, t == null ? void 0 : t.push), e.use(Dq, { sounds: (n = t == null ? void 0 : t.ui) == null ? void 0 : n.sounds }), e.use(Mq, t == null ? void 0 : t.webfontloader);
  }
};
const Rq = B({
  ...ke(),
  ...YS({
    fullHeight: !0
  }),
  ...Qe()
}, "VApp"), Fq = J()({
  name: "VApp",
  props: Rq(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = lt(e), {
      layoutClasses: r,
      getLayoutItem: s,
      items: a,
      layoutRef: o
    } = KS(e), {
      rtlClasses: l
    } = wn();
    return re(() => v("div", {
      ref: o,
      class: ["v-application", i.themeClasses.value, r.value, l.value, e.class],
      style: [e.style]
    }, [v("div", {
      class: "v-application__wrap"
    }, [v(tS, null, {
      default: () => {
        var u;
        return [v(De, null, [(u = n.default) == null ? void 0 : u.call(n)])];
      }
    })])])), {
      getLayoutItem: s,
      items: a,
      theme: i
    };
  }
});
const Nx = B({
  text: String,
  ...ke(),
  ...je()
}, "VToolbarTitle"), Xy = J()({
  name: "VToolbarTitle",
  props: Nx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => {
      const i = !!(n.default || n.text || e.text);
      return v(e.tag, {
        class: ["v-toolbar-title", e.class],
        style: e.style
      }, {
        default: () => {
          var r;
          return [i && v("div", {
            class: "v-toolbar-title__placeholder"
          }, [n.text ? n.text() : e.text, (r = n.default) == null ? void 0 : r.call(n)])];
        }
      });
    }), {};
  }
});
function Bq(e) {
  return {
    aspectStyles: b(() => {
      const t = Number(e.aspectRatio);
      return t ? {
        paddingBottom: String(1 / t * 100) + "%"
      } : void 0;
    })
  };
}
const Mx = B({
  aspectRatio: [String, Number],
  contentClass: null,
  inline: Boolean,
  ...ke(),
  ...Sn()
}, "VResponsive"), Eg = J()({
  name: "VResponsive",
  props: Mx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      aspectStyles: i
    } = Bq(e), {
      dimensionStyles: r
    } = kn(e);
    return re(() => {
      var s;
      return v("div", {
        class: ["v-responsive", {
          "v-responsive--inline": e.inline
        }, e.class],
        style: [r.value, e.style]
      }, [v("div", {
        class: "v-responsive__sizer",
        style: i.value
      }, null), (s = n.additional) == null ? void 0 : s.call(n), n.default && v("div", {
        class: ["v-responsive__content", e.contentClass]
      }, [n.default()])]);
    }), {};
  }
}), Rx = B({
  alt: String,
  cover: Boolean,
  color: String,
  draggable: {
    type: [Boolean, String],
    default: void 0
  },
  eager: Boolean,
  gradient: String,
  lazySrc: String,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  sizes: String,
  src: {
    type: [String, Object],
    default: ""
  },
  crossorigin: String,
  referrerpolicy: String,
  srcset: String,
  position: String,
  ...Mx(),
  ...ke(),
  ...It(),
  ...xr()
}, "VImg"), ks = J()({
  name: "VImg",
  directives: {
    intersect: Nc
  },
  props: Rx(),
  emits: {
    loadstart: (e) => !0,
    load: (e) => !0,
    error: (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const {
      backgroundColorClasses: r,
      backgroundColorStyles: s
    } = gt(G(e, "color")), {
      roundedClasses: a
    } = Ht(e), o = Ut("VImg"), l = pe(""), u = X(), c = pe(e.eager ? "loading" : "idle"), d = pe(), f = pe(), h = b(() => e.src && typeof e.src == "object" ? {
      src: e.src.src,
      srcset: e.srcset || e.src.srcset,
      lazySrc: e.lazySrc || e.src.lazySrc,
      aspect: Number(e.aspectRatio || e.src.aspect || 0)
    } : {
      src: e.src,
      srcset: e.srcset,
      lazySrc: e.lazySrc,
      aspect: Number(e.aspectRatio || 0)
    }), m = b(() => h.value.aspect || d.value / f.value || 0);
    fe(() => e.src, () => {
      g(c.value !== "idle");
    }), fe(m, (P, V) => {
      !P && V && u.value && _(u.value);
    }), ip(() => g());
    function g(P) {
      if (!(e.eager && P) && !(rp && !P && !e.eager)) {
        if (c.value = "loading", h.value.lazySrc) {
          const V = new Image();
          V.src = h.value.lazySrc, _(V, null);
        }
        h.value.src && He(() => {
          var V;
          n("loadstart", ((V = u.value) == null ? void 0 : V.currentSrc) || h.value.src), setTimeout(() => {
            var N;
            if (!o.isUnmounted)
              if ((N = u.value) != null && N.complete) {
                if (u.value.naturalWidth || y(), c.value === "error")
                  return;
                m.value || _(u.value, null), c.value === "loading" && p();
              } else
                m.value || _(u.value), k();
          });
        });
      }
    }
    function p() {
      var P;
      o.isUnmounted || (k(), _(u.value), c.value = "loaded", n("load", ((P = u.value) == null ? void 0 : P.currentSrc) || h.value.src));
    }
    function y() {
      var P;
      o.isUnmounted || (c.value = "error", n("error", ((P = u.value) == null ? void 0 : P.currentSrc) || h.value.src));
    }
    function k() {
      const P = u.value;
      P && (l.value = P.currentSrc || P.src);
    }
    let T = -1;
    ai(() => {
      clearTimeout(T);
    });
    function _(P) {
      let V = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
      const N = () => {
        if (clearTimeout(T), o.isUnmounted)
          return;
        const {
          naturalHeight: F,
          naturalWidth: $
        } = P;
        F || $ ? (d.value = $, f.value = F) : !P.complete && c.value === "loading" && V != null ? T = window.setTimeout(N, V) : (P.currentSrc.endsWith(".svg") || P.currentSrc.startsWith("data:image/svg+xml")) && (d.value = 1, f.value = 1);
      };
      N();
    }
    const w = b(() => ({
      "v-img__img--cover": e.cover,
      "v-img__img--contain": !e.cover
    })), S = () => {
      var N;
      if (!h.value.src || c.value === "idle")
        return null;
      const P = v("img", {
        class: ["v-img__img", w.value],
        style: {
          objectPosition: e.position
        },
        src: h.value.src,
        srcset: h.value.srcset,
        alt: e.alt,
        crossorigin: e.crossorigin,
        referrerpolicy: e.referrerpolicy,
        draggable: e.draggable,
        sizes: e.sizes,
        ref: u,
        onLoad: p,
        onError: y
      }, null), V = (N = i.sources) == null ? void 0 : N.call(i);
      return v(Gn, {
        transition: e.transition,
        appear: !0
      }, {
        default: () => [Rt(V ? v("picture", {
          class: "v-img__picture"
        }, [V, P]) : P, [[Tr, c.value === "loaded"]])]
      });
    }, C = () => v(Gn, {
      transition: e.transition
    }, {
      default: () => [h.value.lazySrc && c.value !== "loaded" && v("img", {
        class: ["v-img__img", "v-img__img--preload", w.value],
        style: {
          objectPosition: e.position
        },
        src: h.value.lazySrc,
        alt: e.alt,
        crossorigin: e.crossorigin,
        referrerpolicy: e.referrerpolicy,
        draggable: e.draggable
      }, null)]
    }), x = () => i.placeholder ? v(Gn, {
      transition: e.transition,
      appear: !0
    }, {
      default: () => [(c.value === "loading" || c.value === "error" && !i.error) && v("div", {
        class: "v-img__placeholder"
      }, [i.placeholder()])]
    }) : null, A = () => i.error ? v(Gn, {
      transition: e.transition,
      appear: !0
    }, {
      default: () => [c.value === "error" && v("div", {
        class: "v-img__error"
      }, [i.error()])]
    }) : null, I = () => e.gradient ? v("div", {
      class: "v-img__gradient",
      style: {
        backgroundImage: `linear-gradient(${e.gradient})`
      }
    }, null) : null, E = pe(!1);
    {
      const P = fe(m, (V) => {
        V && (requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            E.value = !0;
          });
        }), P());
      });
    }
    return re(() => {
      const P = Eg.filterProps(e);
      return Rt(v(Eg, ie({
        class: ["v-img", {
          "v-img--booting": !E.value
        }, r.value, a.value, e.class],
        style: [{
          width: _e(e.width === "auto" ? d.value : e.width)
        }, s.value, e.style]
      }, P, {
        aspectRatio: m.value,
        "aria-label": e.alt,
        role: e.alt ? "img" : void 0
      }), {
        additional: () => v(De, null, [v(S, null, null), v(C, null, null), v(I, null, null), v(x, null, null), v(A, null, null)]),
        default: i.default
      }), [[Ei("intersect"), {
        handler: g,
        options: e.options
      }, null, {
        once: !0
      }]]);
    }), {
      currentSrc: l,
      image: u,
      state: c,
      naturalWidth: d,
      naturalHeight: f
    };
  }
}), Ni = B({
  border: [Boolean, Number, String]
}, "border");
function er(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Kr();
  return {
    borderClasses: b(() => {
      const i = ia(e) ? e.value : e.border, r = [];
      if (i === !0 || i === "")
        r.push(`${t}--border`);
      else if (typeof i == "string" || i === 0)
        for (const s of String(i).split(" "))
          r.push(`border-${s}`);
      return r;
    })
  };
}
const gn = B({
  elevation: {
    type: [Number, String],
    validator(e) {
      const t = parseInt(e);
      return !isNaN(t) && t >= 0 && // Material Design has a maximum elevation of 24
      // https://material.io/design/environment/elevation.html#default-elevations
      t <= 24;
    }
  }
}, "elevation");
function On(e) {
  return {
    elevationClasses: b(() => {
      const n = ia(e) ? e.value : e.elevation, i = [];
      return n == null || i.push(`elevation-${n}`), i;
    })
  };
}
const Lq = [null, "prominent", "default", "comfortable", "compact"], Fx = B({
  absolute: Boolean,
  collapse: Boolean,
  color: String,
  density: {
    type: String,
    default: "default",
    validator: (e) => Lq.includes(e)
  },
  extended: Boolean,
  extensionHeight: {
    type: [Number, String],
    default: 48
  },
  flat: Boolean,
  floating: Boolean,
  height: {
    type: [Number, String],
    default: 64
  },
  image: String,
  title: String,
  ...Ni(),
  ...ke(),
  ...gn(),
  ...It(),
  ...je({
    tag: "header"
  }),
  ...Qe()
}, "VToolbar"), Pg = J()({
  name: "VToolbar",
  props: Fx(),
  setup(e, t) {
    var h;
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: r
    } = gt(G(e, "color")), {
      borderClasses: s
    } = er(e), {
      elevationClasses: a
    } = On(e), {
      roundedClasses: o
    } = Ht(e), {
      themeClasses: l
    } = lt(e), {
      rtlClasses: u
    } = wn(), c = pe(!!(e.extended || (h = n.extension) != null && h.call(n))), d = b(() => parseInt(Number(e.height) + (e.density === "prominent" ? Number(e.height) : 0) - (e.density === "comfortable" ? 8 : 0) - (e.density === "compact" ? 16 : 0), 10)), f = b(() => c.value ? parseInt(Number(e.extensionHeight) + (e.density === "prominent" ? Number(e.extensionHeight) : 0) - (e.density === "comfortable" ? 4 : 0) - (e.density === "compact" ? 8 : 0), 10) : 0);
    return jt({
      VBtn: {
        variant: "text"
      }
    }), re(() => {
      var y;
      const m = !!(e.title || n.title), g = !!(n.image || e.image), p = (y = n.extension) == null ? void 0 : y.call(n);
      return c.value = !!(e.extended || p), v(e.tag, {
        class: ["v-toolbar", {
          "v-toolbar--absolute": e.absolute,
          "v-toolbar--collapse": e.collapse,
          "v-toolbar--flat": e.flat,
          "v-toolbar--floating": e.floating,
          [`v-toolbar--density-${e.density}`]: !0
        }, i.value, s.value, a.value, o.value, l.value, u.value, e.class],
        style: [r.value, e.style]
      }, {
        default: () => [g && v("div", {
          key: "image",
          class: "v-toolbar__image"
        }, [n.image ? v(Ze, {
          key: "image-defaults",
          disabled: !e.image,
          defaults: {
            VImg: {
              cover: !0,
              src: e.image
            }
          }
        }, n.image) : v(ks, {
          key: "image-img",
          cover: !0,
          src: e.image
        }, null)]), v(Ze, {
          defaults: {
            VTabs: {
              height: _e(d.value)
            }
          }
        }, {
          default: () => {
            var k, T, _;
            return [v("div", {
              class: "v-toolbar__content",
              style: {
                height: _e(d.value)
              }
            }, [n.prepend && v("div", {
              class: "v-toolbar__prepend"
            }, [(k = n.prepend) == null ? void 0 : k.call(n)]), m && v(Xy, {
              key: "title",
              text: e.title
            }, {
              text: n.title
            }), (T = n.default) == null ? void 0 : T.call(n), n.append && v("div", {
              class: "v-toolbar__append"
            }, [(_ = n.append) == null ? void 0 : _.call(n)])])];
          }
        }), v(Ze, {
          defaults: {
            VTabs: {
              height: _e(f.value)
            }
          }
        }, {
          default: () => [v(vh, null, {
            default: () => [c.value && v("div", {
              class: "v-toolbar__extension",
              style: {
                height: _e(f.value)
              }
            }, [p])]
          })]
        })]
      });
    }), {
      contentHeight: d,
      extensionHeight: f
    };
  }
}), $q = B({
  scrollTarget: {
    type: String
  },
  scrollThreshold: {
    type: [String, Number],
    default: 300
  }
}, "scroll");
function Wq(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    canScroll: n
  } = t;
  let i = 0;
  const r = X(null), s = pe(0), a = pe(0), o = pe(0), l = pe(!1), u = pe(!1), c = b(() => Number(e.scrollThreshold)), d = b(() => Xt((c.value - s.value) / c.value || 0)), f = () => {
    const h = r.value;
    !h || n && !n.value || (i = s.value, s.value = "window" in h ? h.pageYOffset : h.scrollTop, u.value = s.value < i, o.value = Math.abs(s.value - c.value));
  };
  return fe(u, () => {
    a.value = a.value || s.value;
  }), fe(l, () => {
    a.value = 0;
  }), En(() => {
    fe(() => e.scrollTarget, (h) => {
      var g;
      const m = h ? document.querySelector(h) : window;
      if (!m) {
        pr(`Unable to locate element with identifier ${h}`);
        return;
      }
      m !== r.value && ((g = r.value) == null || g.removeEventListener("scroll", f), r.value = m, r.value.addEventListener("scroll", f, {
        passive: !0
      }));
    }, {
      immediate: !0
    });
  }), ai(() => {
    var h;
    (h = r.value) == null || h.removeEventListener("scroll", f);
  }), n && fe(n, f, {
    immediate: !0
  }), {
    scrollThreshold: c,
    currentScroll: s,
    currentThreshold: o,
    isScrollActive: l,
    scrollRatio: d,
    // required only for testing
    // probably can be removed
    // later (2 chars chlng)
    isScrollingUp: u,
    savedScroll: a
  };
}
function Io() {
  const e = pe(!1);
  return En(() => {
    window.requestAnimationFrame(() => {
      e.value = !0;
    });
  }), {
    ssrBootStyles: b(() => e.value ? void 0 : {
      transition: "none !important"
    }),
    isBooted: Fl(e)
  };
}
const jq = B({
  scrollBehavior: String,
  modelValue: {
    type: Boolean,
    default: !0
  },
  location: {
    type: String,
    default: "top",
    validator: (e) => ["top", "bottom"].includes(e)
  },
  ...Fx(),
  ...bo(),
  ...$q(),
  height: {
    type: [Number, String],
    default: 64
  }
}, "VAppBar"), Hq = J()({
  name: "VAppBar",
  props: jq(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = X(), r = Ee(e, "modelValue"), s = b(() => {
      var _;
      const T = new Set(((_ = e.scrollBehavior) == null ? void 0 : _.split(" ")) ?? []);
      return {
        hide: T.has("hide"),
        fullyHide: T.has("fully-hide"),
        inverted: T.has("inverted"),
        collapse: T.has("collapse"),
        elevate: T.has("elevate"),
        fadeImage: T.has("fade-image")
        // shrink: behavior.has('shrink'),
      };
    }), a = b(() => {
      const T = s.value;
      return T.hide || T.fullyHide || T.inverted || T.collapse || T.elevate || T.fadeImage || // behavior.shrink ||
      !r.value;
    }), {
      currentScroll: o,
      scrollThreshold: l,
      isScrollingUp: u,
      scrollRatio: c
    } = Wq(e, {
      canScroll: a
    }), d = b(() => s.value.hide || s.value.fullyHide), f = b(() => e.collapse || s.value.collapse && (s.value.inverted ? c.value > 0 : c.value === 0)), h = b(() => e.flat || s.value.fullyHide && !r.value || s.value.elevate && (s.value.inverted ? o.value > 0 : o.value === 0)), m = b(() => s.value.fadeImage ? s.value.inverted ? 1 - c.value : c.value : void 0), g = b(() => {
      var w, S;
      const T = Number(((w = i.value) == null ? void 0 : w.contentHeight) ?? e.height), _ = Number(((S = i.value) == null ? void 0 : S.extensionHeight) ?? 0);
      return d.value ? o.value < l.value || s.value.fullyHide ? T + _ : T : T + _;
    });
    vi(b(() => !!e.scrollBehavior), () => {
      Wt(() => {
        d.value ? s.value.inverted ? r.value = o.value > l.value : r.value = u.value || o.value < l.value : r.value = !0;
      });
    });
    const {
      ssrBootStyles: p
    } = Io(), {
      layoutItemStyles: y,
      layoutIsReady: k
    } = wo({
      id: e.name,
      order: b(() => parseInt(e.order, 10)),
      position: G(e, "location"),
      layoutSize: g,
      elementSize: pe(void 0),
      active: r,
      absolute: G(e, "absolute")
    });
    return re(() => {
      const T = Pg.filterProps(e);
      return v(Pg, ie({
        ref: i,
        class: ["v-app-bar", {
          "v-app-bar--bottom": e.location === "bottom"
        }, e.class],
        style: [{
          ...y.value,
          "--v-toolbar-image-opacity": m.value,
          height: void 0,
          ...p.value
        }, e.style]
      }, T, {
        collapse: f.value,
        flat: h.value
      }), n);
    }), k;
  }
});
const zq = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
function fa(e, t) {
  return v(De, null, [e && v("span", {
    key: "overlay",
    class: `${t}__overlay`
  }, null), v("span", {
    key: "underlay",
    class: `${t}__underlay`
  }, null)]);
}
const tr = B({
  color: String,
  variant: {
    type: String,
    default: "elevated",
    validator: (e) => zq.includes(e)
  }
}, "variant");
function Eo(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Kr();
  const n = b(() => {
    const {
      variant: s
    } = Ct(e);
    return `${t}--variant-${s}`;
  }), {
    colorClasses: i,
    colorStyles: r
  } = pp(b(() => {
    const {
      variant: s,
      color: a
    } = Ct(e);
    return {
      [["elevated", "flat"].includes(s) ? "background" : "text"]: a
    };
  }));
  return {
    colorClasses: i,
    colorStyles: r,
    variantClasses: n
  };
}
const Bx = B({
  baseColor: String,
  divided: Boolean,
  ...Ni(),
  ...ke(),
  ..._n(),
  ...gn(),
  ...It(),
  ...je(),
  ...Qe(),
  ...tr()
}, "VBtnGroup"), Og = J()({
  name: "VBtnGroup",
  props: Bx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      densityClasses: r
    } = Kn(e), {
      borderClasses: s
    } = er(e), {
      elevationClasses: a
    } = On(e), {
      roundedClasses: o
    } = Ht(e);
    jt({
      VBtn: {
        height: "auto",
        baseColor: G(e, "baseColor"),
        color: G(e, "color"),
        density: G(e, "density"),
        flat: !0,
        variant: G(e, "variant")
      }
    }), re(() => v(e.tag, {
      class: ["v-btn-group", {
        "v-btn-group--divided": e.divided
      }, i.value, s.value, r.value, a.value, o.value, e.class],
      style: e.style
    }, n));
  }
}), Po = B({
  modelValue: {
    type: null,
    default: void 0
  },
  multiple: Boolean,
  mandatory: [Boolean, String],
  max: Number,
  selectedClass: String,
  disabled: Boolean
}, "group"), Oo = B({
  value: null,
  disabled: Boolean,
  selectedClass: String
}, "group-item");
function Vo(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  const i = Ut("useGroupItem");
  if (!i)
    throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
  const r = Pn();
  Tt(Symbol.for(`${t.description}:id`), r);
  const s = tt(t, null);
  if (!s) {
    if (!n)
      return s;
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${t.description}`);
  }
  const a = G(e, "value"), o = b(() => !!(s.disabled.value || e.disabled));
  s.register({
    id: r,
    value: a,
    disabled: o
  }, i), ai(() => {
    s.unregister(r);
  });
  const l = b(() => s.isSelected(r)), u = b(() => s.items.value[0].id === r), c = b(() => s.items.value[s.items.value.length - 1].id === r), d = b(() => l.value && [s.selectedClass.value, e.selectedClass]);
  return fe(l, (f) => {
    i.emit("group:selected", {
      value: f
    });
  }, {
    flush: "sync"
  }), {
    id: r,
    isSelected: l,
    isFirst: u,
    isLast: c,
    toggle: () => s.select(r, !l.value),
    select: (f) => s.select(r, f),
    selectedClass: d,
    value: a,
    disabled: o,
    group: s
  };
}
function ha(e, t) {
  let n = !1;
  const i = ti([]), r = Ee(e, "modelValue", [], (f) => f == null ? [] : Lx(i, Nt(f)), (f) => {
    const h = qq(i, f);
    return e.multiple ? h : h[0];
  }), s = Ut("useGroup");
  function a(f, h) {
    const m = f, g = Symbol.for(`${t.description}:id`), y = Ko(g, s == null ? void 0 : s.vnode).indexOf(h);
    Ct(m.value) == null && (m.value = y, m.useIndexAsValue = !0), y > -1 ? i.splice(y, 0, m) : i.push(m);
  }
  function o(f) {
    if (n)
      return;
    l();
    const h = i.findIndex((m) => m.id === f);
    i.splice(h, 1);
  }
  function l() {
    const f = i.find((h) => !h.disabled);
    f && e.mandatory === "force" && !r.value.length && (r.value = [f.id]);
  }
  En(() => {
    l();
  }), ai(() => {
    n = !0;
  }), JE(() => {
    for (let f = 0; f < i.length; f++)
      i[f].useIndexAsValue && (i[f].value = f);
  });
  function u(f, h) {
    const m = i.find((g) => g.id === f);
    if (!(h && (m != null && m.disabled)))
      if (e.multiple) {
        const g = r.value.slice(), p = g.findIndex((k) => k === f), y = ~p;
        if (h = h ?? !y, y && e.mandatory && g.length <= 1 || !y && e.max != null && g.length + 1 > e.max)
          return;
        p < 0 && h ? g.push(f) : p >= 0 && !h && g.splice(p, 1), r.value = g;
      } else {
        const g = r.value.includes(f);
        if (e.mandatory && g)
          return;
        r.value = h ?? !g ? [f] : [];
      }
  }
  function c(f) {
    if (e.multiple && pr('This method is not supported when using "multiple" prop'), r.value.length) {
      const h = r.value[0], m = i.findIndex((y) => y.id === h);
      let g = (m + f) % i.length, p = i[g];
      for (; p.disabled && g !== m; )
        g = (g + f) % i.length, p = i[g];
      if (p.disabled)
        return;
      r.value = [i[g].id];
    } else {
      const h = i.find((m) => !m.disabled);
      h && (r.value = [h.id]);
    }
  }
  const d = {
    register: a,
    unregister: o,
    selected: r,
    select: u,
    disabled: G(e, "disabled"),
    prev: () => c(i.length - 1),
    next: () => c(1),
    isSelected: (f) => r.value.includes(f),
    selectedClass: b(() => e.selectedClass),
    items: b(() => i),
    getItemIndex: (f) => Uq(i, f)
  };
  return Tt(t, d), d;
}
function Uq(e, t) {
  const n = Lx(e, [t]);
  return n.length ? e.findIndex((i) => i.id === n[0]) : -1;
}
function Lx(e, t) {
  const n = [];
  return t.forEach((i) => {
    const r = e.find((a) => Yr(i, a.value)), s = e[i];
    (r == null ? void 0 : r.value) != null ? n.push(r.id) : s != null && n.push(s.id);
  }), n;
}
function qq(e, t) {
  const n = [];
  return t.forEach((i) => {
    const r = e.findIndex((s) => s.id === i);
    if (~r) {
      const s = e[r];
      n.push(s.value != null ? s.value : r);
    }
  }), n;
}
const Jy = Symbol.for("vuetify:v-btn-toggle"), Gq = B({
  ...Bx(),
  ...Po()
}, "VBtnToggle"), Yq = J()({
  name: "VBtnToggle",
  props: Gq(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isSelected: i,
      next: r,
      prev: s,
      select: a,
      selected: o
    } = ha(e, Jy);
    return re(() => {
      const l = Og.filterProps(e);
      return v(Og, ie({
        class: ["v-btn-toggle", e.class]
      }, l, {
        style: e.style
      }), {
        default: () => {
          var u;
          return [(u = n.default) == null ? void 0 : u.call(n, {
            isSelected: i,
            next: r,
            prev: s,
            select: a,
            selected: o
          })];
        }
      });
    }), {
      next: r,
      prev: s,
      select: a
    };
  }
});
const Zq = B({
  bgColor: String,
  color: String,
  indeterminate: [Boolean, String],
  modelValue: {
    type: [Number, String],
    default: 0
  },
  rotate: {
    type: [Number, String],
    default: 0
  },
  width: {
    type: [Number, String],
    default: 4
  },
  ...ke(),
  ...Xr(),
  ...je({
    tag: "div"
  }),
  ...Qe()
}, "VProgressCircular"), Nl = J()({
  name: "VProgressCircular",
  props: Zq(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = 20, r = 2 * Math.PI * i, s = X(), {
      themeClasses: a
    } = lt(e), {
      sizeClasses: o,
      sizeStyles: l
    } = $l(e), {
      textColorClasses: u,
      textColorStyles: c
    } = $n(G(e, "color")), {
      textColorClasses: d,
      textColorStyles: f
    } = $n(G(e, "bgColor")), {
      intersectionRef: h,
      isIntersecting: m
    } = yh(), {
      resizeRef: g,
      contentRect: p
    } = Sr(), y = b(() => Math.max(0, Math.min(100, parseFloat(e.modelValue)))), k = b(() => Number(e.width)), T = b(() => l.value ? Number(e.size) : p.value ? p.value.width : Math.max(k.value, 32)), _ = b(() => i / (1 - k.value / T.value) * 2), w = b(() => k.value / T.value * _.value), S = b(() => _e((100 - y.value) / 100 * r));
    return Wt(() => {
      h.value = s.value, g.value = s.value;
    }), re(() => v(e.tag, {
      ref: s,
      class: ["v-progress-circular", {
        "v-progress-circular--indeterminate": !!e.indeterminate,
        "v-progress-circular--visible": m.value,
        "v-progress-circular--disable-shrink": e.indeterminate === "disable-shrink"
      }, a.value, o.value, u.value, e.class],
      style: [l.value, c.value, e.style],
      role: "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": e.indeterminate ? void 0 : y.value
    }, {
      default: () => [v("svg", {
        style: {
          transform: `rotate(calc(-90deg + ${Number(e.rotate)}deg))`
        },
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${_.value} ${_.value}`
      }, [v("circle", {
        class: ["v-progress-circular__underlay", d.value],
        style: f.value,
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r: i,
        "stroke-width": w.value,
        "stroke-dasharray": r,
        "stroke-dashoffset": 0
      }, null), v("circle", {
        class: "v-progress-circular__overlay",
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r: i,
        "stroke-width": w.value,
        "stroke-dasharray": r,
        "stroke-dashoffset": S.value
      }, null)]), n.default && v("div", {
        class: "v-progress-circular__content"
      }, [n.default({
        value: y.value
      })])]
    })), {};
  }
}), Kq = ["static", "relative", "fixed", "absolute", "sticky"], su = B({
  position: {
    type: String,
    validator: (
      /* istanbul ignore next */
      (e) => Kq.includes(e)
    )
  }
}, "position");
function au(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Kr();
  return {
    positionClasses: b(() => e.position ? `${t}--${e.position}` : void 0)
  };
}
function Xq() {
  const e = Ut("useRoute");
  return b(() => {
    var t;
    return (t = e == null ? void 0 : e.proxy) == null ? void 0 : t.$route;
  });
}
function $x() {
  var e, t;
  return (t = (e = Ut("useRouter")) == null ? void 0 : e.proxy) == null ? void 0 : t.$router;
}
function ad(e, t) {
  var u, c;
  const n = QE("RouterLink"), i = b(() => !!(e.href || e.to)), r = b(() => (i == null ? void 0 : i.value) || Yb(t, "click") || Yb(e, "click"));
  if (typeof n == "string" || !("useLink" in n))
    return {
      isLink: i,
      isClickable: r,
      href: G(e, "href")
    };
  const s = b(() => ({
    ...e,
    to: G(() => e.to || "")
  })), a = n.useLink(s.value), o = b(() => e.to ? a : void 0), l = Xq();
  return {
    isLink: i,
    isClickable: r,
    route: (u = o.value) == null ? void 0 : u.route,
    navigate: (c = o.value) == null ? void 0 : c.navigate,
    isActive: b(() => {
      var d, f, h;
      return o.value ? e.exact ? l.value ? ((h = o.value.isExactActive) == null ? void 0 : h.value) && Yr(o.value.route.value.query, l.value.query) : ((f = o.value.isExactActive) == null ? void 0 : f.value) ?? !1 : ((d = o.value.isActive) == null ? void 0 : d.value) ?? !1 : !1;
    }),
    href: b(() => {
      var d;
      return e.to ? (d = o.value) == null ? void 0 : d.route.value.href : e.href;
    })
  };
}
const od = B({
  href: String,
  replace: Boolean,
  to: [String, Object],
  exact: Boolean
}, "router");
let kv = !1;
function Jq(e, t) {
  let n = !1, i, r;
  ft && (He(() => {
    window.addEventListener("popstate", s), i = e == null ? void 0 : e.beforeEach((a, o, l) => {
      kv ? n ? t(l) : l() : setTimeout(() => n ? t(l) : l()), kv = !0;
    }), r = e == null ? void 0 : e.afterEach(() => {
      kv = !1;
    });
  }), jn(() => {
    window.removeEventListener("popstate", s), i == null || i(), r == null || r();
  }));
  function s(a) {
    var o;
    (o = a.state) != null && o.replaced || (n = !0, setTimeout(() => n = !1));
  }
}
function Qq(e, t) {
  fe(() => {
    var n;
    return (n = e.isActive) == null ? void 0 : n.value;
  }, (n) => {
    e.isLink.value && n && t && He(() => {
      t(!0);
    });
  }, {
    immediate: !0
  });
}
const Vg = Symbol("rippleStop"), e6 = 80;
function O_(e, t) {
  e.style.transform = t, e.style.webkitTransform = t;
}
function Dg(e) {
  return e.constructor.name === "TouchEvent";
}
function Wx(e) {
  return e.constructor.name === "KeyboardEvent";
}
const t6 = function(e, t) {
  var d;
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = 0, r = 0;
  if (!Wx(e)) {
    const f = t.getBoundingClientRect(), h = Dg(e) ? e.touches[e.touches.length - 1] : e;
    i = h.clientX - f.left, r = h.clientY - f.top;
  }
  let s = 0, a = 0.3;
  (d = t._ripple) != null && d.circle ? (a = 0.15, s = t.clientWidth / 2, s = n.center ? s : s + Math.sqrt((i - s) ** 2 + (r - s) ** 2) / 4) : s = Math.sqrt(t.clientWidth ** 2 + t.clientHeight ** 2) / 2;
  const o = `${(t.clientWidth - s * 2) / 2}px`, l = `${(t.clientHeight - s * 2) / 2}px`, u = n.center ? o : `${i - s}px`, c = n.center ? l : `${r - s}px`;
  return {
    radius: s,
    scale: a,
    x: u,
    y: c,
    centerX: o,
    centerY: l
  };
}, sh = {
  /* eslint-disable max-statements */
  show(e, t) {
    var h;
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!((h = t == null ? void 0 : t._ripple) != null && h.enabled))
      return;
    const i = document.createElement("span"), r = document.createElement("span");
    i.appendChild(r), i.className = "v-ripple__container", n.class && (i.className += ` ${n.class}`);
    const {
      radius: s,
      scale: a,
      x: o,
      y: l,
      centerX: u,
      centerY: c
    } = t6(e, t, n), d = `${s * 2}px`;
    r.className = "v-ripple__animation", r.style.width = d, r.style.height = d, t.appendChild(i);
    const f = window.getComputedStyle(t);
    f && f.position === "static" && (t.style.position = "relative", t.dataset.previousPosition = "static"), r.classList.add("v-ripple__animation--enter"), r.classList.add("v-ripple__animation--visible"), O_(r, `translate(${o}, ${l}) scale3d(${a},${a},${a})`), r.dataset.activated = String(performance.now()), setTimeout(() => {
      r.classList.remove("v-ripple__animation--enter"), r.classList.add("v-ripple__animation--in"), O_(r, `translate(${u}, ${c}) scale3d(1,1,1)`);
    }, 0);
  },
  hide(e) {
    var s;
    if (!((s = e == null ? void 0 : e._ripple) != null && s.enabled))
      return;
    const t = e.getElementsByClassName("v-ripple__animation");
    if (t.length === 0)
      return;
    const n = t[t.length - 1];
    if (n.dataset.isHiding)
      return;
    n.dataset.isHiding = "true";
    const i = performance.now() - Number(n.dataset.activated), r = Math.max(250 - i, 0);
    setTimeout(() => {
      n.classList.remove("v-ripple__animation--in"), n.classList.add("v-ripple__animation--out"), setTimeout(() => {
        var o;
        e.getElementsByClassName("v-ripple__animation").length === 1 && e.dataset.previousPosition && (e.style.position = e.dataset.previousPosition, delete e.dataset.previousPosition), ((o = n.parentNode) == null ? void 0 : o.parentNode) === e && e.removeChild(n.parentNode);
      }, 300);
    }, r);
  }
};
function jx(e) {
  return typeof e > "u" || !!e;
}
function Sc(e) {
  const t = {}, n = e.currentTarget;
  if (!(!(n != null && n._ripple) || n._ripple.touched || e[Vg])) {
    if (e[Vg] = !0, Dg(e))
      n._ripple.touched = !0, n._ripple.isTouch = !0;
    else if (n._ripple.isTouch)
      return;
    if (t.center = n._ripple.centered || Wx(e), n._ripple.class && (t.class = n._ripple.class), Dg(e)) {
      if (n._ripple.showTimerCommit)
        return;
      n._ripple.showTimerCommit = () => {
        sh.show(e, n, t);
      }, n._ripple.showTimer = window.setTimeout(() => {
        var i;
        (i = n == null ? void 0 : n._ripple) != null && i.showTimerCommit && (n._ripple.showTimerCommit(), n._ripple.showTimerCommit = null);
      }, e6);
    } else
      sh.show(e, n, t);
  }
}
function V_(e) {
  e[Vg] = !0;
}
function Ti(e) {
  const t = e.currentTarget;
  if (t != null && t._ripple) {
    if (window.clearTimeout(t._ripple.showTimer), e.type === "touchend" && t._ripple.showTimerCommit) {
      t._ripple.showTimerCommit(), t._ripple.showTimerCommit = null, t._ripple.showTimer = window.setTimeout(() => {
        Ti(e);
      });
      return;
    }
    window.setTimeout(() => {
      t._ripple && (t._ripple.touched = !1);
    }), sh.hide(t);
  }
}
function Hx(e) {
  const t = e.currentTarget;
  t != null && t._ripple && (t._ripple.showTimerCommit && (t._ripple.showTimerCommit = null), window.clearTimeout(t._ripple.showTimer));
}
let kc = !1;
function zx(e) {
  !kc && (e.keyCode === Hb.enter || e.keyCode === Hb.space) && (kc = !0, Sc(e));
}
function Ux(e) {
  kc = !1, Ti(e);
}
function qx(e) {
  kc && (kc = !1, Ti(e));
}
function Gx(e, t, n) {
  const {
    value: i,
    modifiers: r
  } = t, s = jx(i);
  if (s || sh.hide(e), e._ripple = e._ripple ?? {}, e._ripple.enabled = s, e._ripple.centered = r.center, e._ripple.circle = r.circle, zu(i) && i.class && (e._ripple.class = i.class), s && !n) {
    if (r.stop) {
      e.addEventListener("touchstart", V_, {
        passive: !0
      }), e.addEventListener("mousedown", V_);
      return;
    }
    e.addEventListener("touchstart", Sc, {
      passive: !0
    }), e.addEventListener("touchend", Ti, {
      passive: !0
    }), e.addEventListener("touchmove", Hx, {
      passive: !0
    }), e.addEventListener("touchcancel", Ti), e.addEventListener("mousedown", Sc), e.addEventListener("mouseup", Ti), e.addEventListener("mouseleave", Ti), e.addEventListener("keydown", zx), e.addEventListener("keyup", Ux), e.addEventListener("blur", qx), e.addEventListener("dragstart", Ti, {
      passive: !0
    });
  } else
    !s && n && Yx(e);
}
function Yx(e) {
  e.removeEventListener("mousedown", Sc), e.removeEventListener("touchstart", Sc), e.removeEventListener("touchend", Ti), e.removeEventListener("touchmove", Hx), e.removeEventListener("touchcancel", Ti), e.removeEventListener("mouseup", Ti), e.removeEventListener("mouseleave", Ti), e.removeEventListener("keydown", zx), e.removeEventListener("keyup", Ux), e.removeEventListener("dragstart", Ti), e.removeEventListener("blur", qx);
}
function n6(e, t) {
  Gx(e, t, !1);
}
function i6(e) {
  delete e._ripple, Yx(e);
}
function r6(e, t) {
  if (t.value === t.oldValue)
    return;
  const n = jx(t.oldValue);
  Gx(e, t, n);
}
const Vs = {
  mounted: n6,
  unmounted: i6,
  updated: r6
}, lm = B({
  active: {
    type: Boolean,
    default: void 0
  },
  baseColor: String,
  symbol: {
    type: null,
    default: Jy
  },
  flat: Boolean,
  icon: [Boolean, String, Function, Object],
  prependIcon: We,
  appendIcon: We,
  block: Boolean,
  readonly: Boolean,
  slim: Boolean,
  stacked: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  text: String,
  ...Ni(),
  ...ke(),
  ..._n(),
  ...Sn(),
  ...gn(),
  ...Oo(),
  ...wh(),
  ...ua(),
  ...su(),
  ...It(),
  ...od(),
  ...Xr(),
  ...je({
    tag: "button"
  }),
  ...Qe(),
  ...tr({
    variant: "elevated"
  })
}, "VBtn"), st = J()({
  name: "VBtn",
  props: lm(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      themeClasses: r
    } = lt(e), {
      borderClasses: s
    } = er(e), {
      densityClasses: a
    } = Kn(e), {
      dimensionStyles: o
    } = kn(e), {
      elevationClasses: l
    } = On(e), {
      loaderClasses: u
    } = Oc(e), {
      locationStyles: c
    } = yo(e), {
      positionClasses: d
    } = au(e), {
      roundedClasses: f
    } = Ht(e), {
      sizeClasses: h,
      sizeStyles: m
    } = $l(e), g = Vo(e, e.symbol, !1), p = ad(e, n), y = b(() => {
      var I;
      return e.active !== void 0 ? e.active : p.isLink.value ? (I = p.isActive) == null ? void 0 : I.value : g == null ? void 0 : g.isSelected.value;
    }), k = b(() => {
      var E, P;
      return {
        color: (g == null ? void 0 : g.isSelected.value) && (!p.isLink.value || ((E = p.isActive) == null ? void 0 : E.value)) || !g || ((P = p.isActive) == null ? void 0 : P.value) ? e.color ?? e.baseColor : e.baseColor,
        variant: e.variant
      };
    }), {
      colorClasses: T,
      colorStyles: _,
      variantClasses: w
    } = Eo(k), S = b(() => (g == null ? void 0 : g.disabled.value) || e.disabled), C = b(() => e.variant === "elevated" && !(e.disabled || e.flat || e.border)), x = b(() => {
      if (!(e.value === void 0 || typeof e.value == "symbol"))
        return Object(e.value) === e.value ? JSON.stringify(e.value, null, 0) : e.value;
    });
    function A(I) {
      var E;
      S.value || p.isLink.value && (I.metaKey || I.ctrlKey || I.shiftKey || I.button !== 0 || n.target === "_blank") || ((E = p.navigate) == null || E.call(p, I), g == null || g.toggle());
    }
    return Qq(p, g == null ? void 0 : g.select), re(() => {
      const I = p.isLink.value ? "a" : e.tag, E = !!(e.prependIcon || i.prepend), P = !!(e.appendIcon || i.append), V = !!(e.icon && e.icon !== !0);
      return Rt(v(I, {
        type: I === "a" ? void 0 : "button",
        class: ["v-btn", g == null ? void 0 : g.selectedClass.value, {
          "v-btn--active": y.value,
          "v-btn--block": e.block,
          "v-btn--disabled": S.value,
          "v-btn--elevated": C.value,
          "v-btn--flat": e.flat,
          "v-btn--icon": !!e.icon,
          "v-btn--loading": e.loading,
          "v-btn--readonly": e.readonly,
          "v-btn--slim": e.slim,
          "v-btn--stacked": e.stacked
        }, r.value, s.value, T.value, a.value, l.value, u.value, d.value, f.value, h.value, w.value, e.class],
        style: [_.value, o.value, c.value, m.value, e.style],
        "aria-busy": e.loading ? !0 : void 0,
        disabled: S.value || void 0,
        href: p.href.value,
        tabindex: e.loading || e.readonly ? -1 : void 0,
        onClick: A,
        value: x.value
      }, {
        default: () => {
          var N;
          return [fa(!0, "v-btn"), !e.icon && E && v("span", {
            key: "prepend",
            class: "v-btn__prepend"
          }, [i.prepend ? v(Ze, {
            key: "prepend-defaults",
            disabled: !e.prependIcon,
            defaults: {
              VIcon: {
                icon: e.prependIcon
              }
            }
          }, i.prepend) : v(at, {
            key: "prepend-icon",
            icon: e.prependIcon
          }, null)]), v("span", {
            class: "v-btn__content",
            "data-no-activator": ""
          }, [!i.default && V ? v(at, {
            key: "content-icon",
            icon: e.icon
          }, null) : v(Ze, {
            key: "content-defaults",
            disabled: !V,
            defaults: {
              VIcon: {
                icon: e.icon
              }
            }
          }, {
            default: () => {
              var F;
              return [((F = i.default) == null ? void 0 : F.call(i)) ?? e.text];
            }
          })]), !e.icon && P && v("span", {
            key: "append",
            class: "v-btn__append"
          }, [i.append ? v(Ze, {
            key: "append-defaults",
            disabled: !e.appendIcon,
            defaults: {
              VIcon: {
                icon: e.appendIcon
              }
            }
          }, i.append) : v(at, {
            key: "append-icon",
            icon: e.appendIcon
          }, null)]), !!e.loading && v("span", {
            key: "loader",
            class: "v-btn__loader"
          }, [((N = i.loader) == null ? void 0 : N.call(i)) ?? v(Nl, {
            color: typeof e.loading == "boolean" ? void 0 : e.loading,
            indeterminate: !0,
            width: "2"
          }, null)])];
        }
      }), [[Vs, !S.value && !!e.ripple, "", {
        center: !!e.icon
      }]]);
    }), {
      group: g
    };
  }
}), s6 = B({
  ...lm({
    icon: "$menu",
    variant: "text"
  })
}, "VAppBarNavIcon"), a6 = J()({
  name: "VAppBarNavIcon",
  props: s6(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => v(st, ie(e, {
      class: ["v-app-bar-nav-icon"]
    }), n)), {};
  }
}), o6 = J()({
  name: "VAppBarTitle",
  props: Nx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => v(Xy, ie(e, {
      class: "v-app-bar-title"
    }), n)), {};
  }
});
const Zx = Zr("v-alert-title"), l6 = ["success", "info", "warning", "error"], u6 = B({
  border: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || ["top", "end", "bottom", "start"].includes(e)
  },
  borderColor: String,
  closable: Boolean,
  closeIcon: {
    type: We,
    default: "$close"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  icon: {
    type: [Boolean, String, Function, Object],
    default: null
  },
  modelValue: {
    type: Boolean,
    default: !0
  },
  prominent: Boolean,
  title: String,
  text: String,
  type: {
    type: String,
    validator: (e) => l6.includes(e)
  },
  ...ke(),
  ..._n(),
  ...Sn(),
  ...gn(),
  ...ua(),
  ...su(),
  ...It(),
  ...je(),
  ...Qe(),
  ...tr({
    variant: "flat"
  })
}, "VAlert"), c6 = J()({
  name: "VAlert",
  props: u6(),
  emits: {
    "click:close": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const r = Ee(e, "modelValue"), s = b(() => {
      if (e.icon !== !1)
        return e.type ? e.icon ?? `$${e.type}` : e.icon;
    }), a = b(() => ({
      color: e.color ?? e.type,
      variant: e.variant
    })), {
      themeClasses: o
    } = lt(e), {
      colorClasses: l,
      colorStyles: u,
      variantClasses: c
    } = Eo(a), {
      densityClasses: d
    } = Kn(e), {
      dimensionStyles: f
    } = kn(e), {
      elevationClasses: h
    } = On(e), {
      locationStyles: m
    } = yo(e), {
      positionClasses: g
    } = au(e), {
      roundedClasses: p
    } = Ht(e), {
      textColorClasses: y,
      textColorStyles: k
    } = $n(G(e, "borderColor")), {
      t: T
    } = qt(), _ = b(() => ({
      "aria-label": T(e.closeLabel),
      onClick(w) {
        r.value = !1, n("click:close", w);
      }
    }));
    return () => {
      const w = !!(i.prepend || s.value), S = !!(i.title || e.title), C = !!(i.close || e.closable);
      return r.value && v(e.tag, {
        class: ["v-alert", e.border && {
          "v-alert--border": !!e.border,
          [`v-alert--border-${e.border === !0 ? "start" : e.border}`]: !0
        }, {
          "v-alert--prominent": e.prominent
        }, o.value, l.value, d.value, h.value, g.value, p.value, c.value, e.class],
        style: [u.value, f.value, m.value, e.style],
        role: "alert"
      }, {
        default: () => {
          var x, A;
          return [fa(!1, "v-alert"), e.border && v("div", {
            key: "border",
            class: ["v-alert__border", y.value],
            style: k.value
          }, null), w && v("div", {
            key: "prepend",
            class: "v-alert__prepend"
          }, [i.prepend ? v(Ze, {
            key: "prepend-defaults",
            disabled: !s.value,
            defaults: {
              VIcon: {
                density: e.density,
                icon: s.value,
                size: e.prominent ? 44 : 28
              }
            }
          }, i.prepend) : v(at, {
            key: "prepend-icon",
            density: e.density,
            icon: s.value,
            size: e.prominent ? 44 : 28
          }, null)]), v("div", {
            class: "v-alert__content"
          }, [S && v(Zx, {
            key: "title"
          }, {
            default: () => {
              var I;
              return [((I = i.title) == null ? void 0 : I.call(i)) ?? e.title];
            }
          }), ((x = i.text) == null ? void 0 : x.call(i)) ?? e.text, (A = i.default) == null ? void 0 : A.call(i)]), i.append && v("div", {
            key: "append",
            class: "v-alert__append"
          }, [i.append()]), C && v("div", {
            key: "close",
            class: "v-alert__close"
          }, [i.close ? v(Ze, {
            key: "close-defaults",
            defaults: {
              VBtn: {
                icon: e.closeIcon,
                size: "x-small",
                variant: "text"
              }
            }
          }, {
            default: () => {
              var I;
              return [(I = i.close) == null ? void 0 : I.call(i, {
                props: _.value
              })];
            }
          }) : v(st, ie({
            key: "close-btn",
            icon: e.closeIcon,
            size: "x-small",
            variant: "text"
          }, _.value), null)])];
        }
      });
    };
  }
});
const d6 = B({
  start: Boolean,
  end: Boolean,
  icon: We,
  image: String,
  text: String,
  ...ke(),
  ..._n(),
  ...It(),
  ...Xr(),
  ...je(),
  ...Qe(),
  ...tr({
    variant: "flat"
  })
}, "VAvatar"), Ji = J()({
  name: "VAvatar",
  props: d6(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      colorClasses: r,
      colorStyles: s,
      variantClasses: a
    } = Eo(e), {
      densityClasses: o
    } = Kn(e), {
      roundedClasses: l
    } = Ht(e), {
      sizeClasses: u,
      sizeStyles: c
    } = $l(e);
    return re(() => v(e.tag, {
      class: ["v-avatar", {
        "v-avatar--start": e.start,
        "v-avatar--end": e.end
      }, i.value, r.value, o.value, l.value, u.value, a.value, e.class],
      style: [s.value, c.value, e.style]
    }, {
      default: () => [n.default ? v(Ze, {
        key: "content-defaults",
        defaults: {
          VImg: {
            cover: !0,
            image: e.image
          },
          VIcon: {
            icon: e.icon
          }
        }
      }, {
        default: () => [n.default()]
      }) : e.image ? v(ks, {
        key: "image",
        src: e.image,
        alt: "",
        cover: !0
      }, null) : e.icon ? v(at, {
        key: "icon",
        icon: e.icon
      }, null) : e.text, fa(!1, "v-avatar")]
    })), {};
  }
});
const Kx = Symbol.for("vuetify:selection-control-group"), Qy = B({
  color: String,
  disabled: {
    type: Boolean,
    default: null
  },
  defaultsTarget: String,
  error: Boolean,
  id: String,
  inline: Boolean,
  falseIcon: We,
  trueIcon: We,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: {
    type: Boolean,
    default: null
  },
  modelValue: null,
  type: String,
  valueComparator: {
    type: Function,
    default: Yr
  },
  ...ke(),
  ..._n(),
  ...Qe()
}, "SelectionControlGroup"), f6 = B({
  ...Qy({
    defaultsTarget: "VSelectionControl"
  })
}, "VSelectionControlGroup"), Xx = J()({
  name: "VSelectionControlGroup",
  props: f6(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), r = Pn(), s = b(() => e.id || `v-selection-control-group-${r}`), a = b(() => e.name || s.value), o = /* @__PURE__ */ new Set();
    return Tt(Kx, {
      modelValue: i,
      forceUpdate: () => {
        o.forEach((l) => l());
      },
      onForceUpdate: (l) => {
        o.add(l), jn(() => {
          o.delete(l);
        });
      }
    }), jt({
      [e.defaultsTarget]: {
        color: G(e, "color"),
        disabled: G(e, "disabled"),
        density: G(e, "density"),
        error: G(e, "error"),
        inline: G(e, "inline"),
        modelValue: i,
        multiple: b(() => !!e.multiple || e.multiple == null && Array.isArray(i.value)),
        name: a,
        falseIcon: G(e, "falseIcon"),
        trueIcon: G(e, "trueIcon"),
        readonly: G(e, "readonly"),
        ripple: G(e, "ripple"),
        type: G(e, "type"),
        valueComparator: G(e, "valueComparator")
      }
    }), re(() => {
      var l;
      return v("div", {
        class: ["v-selection-control-group", {
          "v-selection-control-group--inline": e.inline
        }, e.class],
        style: e.style,
        role: e.type === "radio" ? "radiogroup" : void 0
      }, [(l = n.default) == null ? void 0 : l.call(n)]);
    }), {};
  }
}), um = B({
  label: String,
  baseColor: String,
  trueValue: null,
  falseValue: null,
  value: null,
  ...ke(),
  ...Qy()
}, "VSelectionControl");
function h6(e) {
  const t = tt(Kx, void 0), {
    densityClasses: n
  } = Kn(e), i = Ee(e, "modelValue"), r = b(() => e.trueValue !== void 0 ? e.trueValue : e.value !== void 0 ? e.value : !0), s = b(() => e.falseValue !== void 0 ? e.falseValue : !1), a = b(() => !!e.multiple || e.multiple == null && Array.isArray(i.value)), o = b({
    get() {
      const h = t ? t.modelValue.value : i.value;
      return a.value ? Nt(h).some((m) => e.valueComparator(m, r.value)) : e.valueComparator(h, r.value);
    },
    set(h) {
      if (e.readonly)
        return;
      const m = h ? r.value : s.value;
      let g = m;
      a.value && (g = h ? [...Nt(i.value), m] : Nt(i.value).filter((p) => !e.valueComparator(p, r.value))), t ? t.modelValue.value = g : i.value = g;
    }
  }), {
    textColorClasses: l,
    textColorStyles: u
  } = $n(b(() => {
    if (!(e.error || e.disabled))
      return o.value ? e.color : e.baseColor;
  })), {
    backgroundColorClasses: c,
    backgroundColorStyles: d
  } = gt(b(() => o.value && !e.error && !e.disabled ? e.color : e.baseColor)), f = b(() => o.value ? e.trueIcon : e.falseIcon);
  return {
    group: t,
    densityClasses: n,
    trueValue: r,
    falseValue: s,
    model: o,
    textColorClasses: l,
    textColorStyles: u,
    backgroundColorClasses: c,
    backgroundColorStyles: d,
    icon: f
  };
}
const co = J()({
  name: "VSelectionControl",
  directives: {
    Ripple: Vs
  },
  inheritAttrs: !1,
  props: um(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      group: r,
      densityClasses: s,
      icon: a,
      model: o,
      textColorClasses: l,
      textColorStyles: u,
      backgroundColorClasses: c,
      backgroundColorStyles: d,
      trueValue: f
    } = h6(e), h = Pn(), m = pe(!1), g = pe(!1), p = X(), y = b(() => e.id || `input-${h}`), k = b(() => !e.disabled && !e.readonly);
    r == null || r.onForceUpdate(() => {
      p.value && (p.value.checked = o.value);
    });
    function T(C) {
      k.value && (m.value = !0, pl(C.target, ":focus-visible") !== !1 && (g.value = !0));
    }
    function _() {
      m.value = !1, g.value = !1;
    }
    function w(C) {
      C.stopPropagation();
    }
    function S(C) {
      k.value && (e.readonly && r && He(() => r.forceUpdate()), o.value = C.target.checked);
    }
    return re(() => {
      var E, P;
      const C = i.label ? i.label({
        label: e.label,
        props: {
          for: y.value
        }
      }) : e.label, [x, A] = la(n), I = v("input", ie({
        ref: p,
        checked: o.value,
        disabled: !!e.disabled,
        id: y.value,
        onBlur: _,
        onFocus: T,
        onInput: S,
        "aria-disabled": !!e.disabled,
        "aria-label": e.label,
        type: e.type,
        value: f.value,
        name: e.name,
        "aria-checked": e.type === "checkbox" ? o.value : void 0
      }, A), null);
      return v("div", ie({
        class: ["v-selection-control", {
          "v-selection-control--dirty": o.value,
          "v-selection-control--disabled": e.disabled,
          "v-selection-control--error": e.error,
          "v-selection-control--focused": m.value,
          "v-selection-control--focus-visible": g.value,
          "v-selection-control--inline": e.inline
        }, s.value, e.class]
      }, x, {
        style: e.style
      }), [v("div", {
        class: ["v-selection-control__wrapper", l.value],
        style: u.value
      }, [(E = i.default) == null ? void 0 : E.call(i, {
        backgroundColorClasses: c,
        backgroundColorStyles: d
      }), Rt(v("div", {
        class: ["v-selection-control__input"]
      }, [((P = i.input) == null ? void 0 : P.call(i, {
        model: o,
        textColorClasses: l,
        textColorStyles: u,
        backgroundColorClasses: c,
        backgroundColorStyles: d,
        inputNode: I,
        icon: a.value,
        props: {
          onFocus: T,
          onBlur: _,
          id: y.value
        }
      })) ?? v(De, null, [a.value && v(at, {
        key: "icon",
        icon: a.value
      }, null), I])]), [[Ei("ripple"), e.ripple && [!e.disabled && !e.readonly, null, ["center", "circle"]]]])]), C && v(Ll, {
        for: y.value,
        onClick: w
      }, {
        default: () => [C]
      })]);
    }), {
      isFocused: m,
      input: p
    };
  }
}), Jx = B({
  indeterminate: Boolean,
  indeterminateIcon: {
    type: We,
    default: "$checkboxIndeterminate"
  },
  ...um({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })
}, "VCheckboxBtn"), Cs = J()({
  name: "VCheckboxBtn",
  props: Jx(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:indeterminate": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "indeterminate"), r = Ee(e, "modelValue");
    function s(l) {
      i.value && (i.value = !1);
    }
    const a = b(() => i.value ? e.indeterminateIcon : e.falseIcon), o = b(() => i.value ? e.indeterminateIcon : e.trueIcon);
    return re(() => {
      const l = an(co.filterProps(e), ["modelValue"]);
      return v(co, ie(l, {
        modelValue: r.value,
        "onUpdate:modelValue": [(u) => r.value = u, s],
        class: ["v-checkbox-btn", e.class],
        style: e.style,
        type: "checkbox",
        falseIcon: a.value,
        trueIcon: o.value,
        "aria-checked": i.value ? "mixed" : void 0
      }), n);
    }), {};
  }
}), m6 = B({
  ...As(),
  ...an(Jx(), ["inline"])
}, "VCheckbox"), v6 = J()({
  name: "VCheckbox",
  inheritAttrs: !1,
  props: m6(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:focused": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const r = Ee(e, "modelValue"), {
      isFocused: s,
      focus: a,
      blur: o
    } = xs(e), l = Pn(), u = b(() => e.id || `checkbox-${l}`);
    return re(() => {
      const [c, d] = la(n), f = Wn.filterProps(e), h = Cs.filterProps(e);
      return v(Wn, ie({
        class: ["v-checkbox", e.class]
      }, c, f, {
        modelValue: r.value,
        "onUpdate:modelValue": (m) => r.value = m,
        id: u.value,
        focused: s.value,
        style: e.style
      }), {
        ...i,
        default: (m) => {
          let {
            id: g,
            messagesId: p,
            isDisabled: y,
            isReadonly: k,
            isValid: T
          } = m;
          return v(Cs, ie(h, {
            id: g.value,
            "aria-describedby": p.value,
            disabled: y.value,
            readonly: k.value
          }, d, {
            error: T.value === !1,
            modelValue: r.value,
            "onUpdate:modelValue": (_) => r.value = _,
            onFocus: a,
            onBlur: o
          }), i);
        }
      });
    }), {};
  }
});
function g6(e) {
  let {
    selectedElement: t,
    containerElement: n,
    isRtl: i,
    isHorizontal: r
  } = e;
  const s = Cc(r, n), a = Qx(r, i, n), o = Cc(r, t), l = eA(r, t), u = o * 0.4;
  return a > l ? l - u : a + s < l + o ? l - s + o + u : a;
}
function p6(e) {
  let {
    selectedElement: t,
    containerElement: n,
    isHorizontal: i
  } = e;
  const r = Cc(i, n), s = eA(i, t), a = Cc(i, t);
  return s - r / 2 + a / 2;
}
function D_(e, t) {
  const n = e ? "scrollWidth" : "scrollHeight";
  return (t == null ? void 0 : t[n]) || 0;
}
function y6(e, t) {
  const n = e ? "clientWidth" : "clientHeight";
  return (t == null ? void 0 : t[n]) || 0;
}
function Qx(e, t, n) {
  if (!n)
    return 0;
  const {
    scrollLeft: i,
    offsetWidth: r,
    scrollWidth: s
  } = n;
  return e ? t ? s - r + i : i : n.scrollTop;
}
function Cc(e, t) {
  const n = e ? "offsetWidth" : "offsetHeight";
  return (t == null ? void 0 : t[n]) || 0;
}
function eA(e, t) {
  const n = e ? "offsetLeft" : "offsetTop";
  return (t == null ? void 0 : t[n]) || 0;
}
const tA = Symbol.for("vuetify:v-slide-group"), eb = B({
  centerActive: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  symbol: {
    type: null,
    default: tA
  },
  nextIcon: {
    type: We,
    default: "$next"
  },
  prevIcon: {
    type: We,
    default: "$prev"
  },
  showArrows: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || ["always", "desktop", "mobile"].includes(e)
  },
  ...ke(),
  ...jl({
    mobile: null
  }),
  ...je(),
  ...Po({
    selectedClass: "v-slide-group-item--active"
  })
}, "VSlideGroup"), Tc = J()({
  name: "VSlideGroup",
  props: eb(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isRtl: i
    } = wn(), {
      displayClasses: r,
      mobile: s
    } = Ar(e), a = ha(e, e.symbol), o = pe(!1), l = pe(0), u = pe(0), c = pe(0), d = b(() => e.direction === "horizontal"), {
      resizeRef: f,
      contentRect: h
    } = Sr(), {
      resizeRef: m,
      contentRect: g
    } = Sr(), p = CV(), y = b(() => ({
      container: f.el,
      duration: 200,
      easing: "easeOutQuart"
    })), k = b(() => a.selected.value.length ? a.items.value.findIndex((R) => R.id === a.selected.value[0]) : -1), T = b(() => a.selected.value.length ? a.items.value.findIndex((R) => R.id === a.selected.value[a.selected.value.length - 1]) : -1);
    if (ft) {
      let R = -1;
      fe(() => [a.selected.value, h.value, g.value, d.value], () => {
        cancelAnimationFrame(R), R = requestAnimationFrame(() => {
          if (h.value && g.value) {
            const L = d.value ? "width" : "height";
            u.value = h.value[L], c.value = g.value[L], o.value = u.value + 1 < c.value;
          }
          if (k.value >= 0 && m.el) {
            const L = m.el.children[T.value];
            w(L, e.centerActive);
          }
        });
      });
    }
    const _ = pe(!1);
    function w(R, L) {
      let ne = 0;
      L ? ne = p6({
        containerElement: f.el,
        isHorizontal: d.value,
        selectedElement: R
      }) : ne = g6({
        containerElement: f.el,
        isHorizontal: d.value,
        isRtl: i.value,
        selectedElement: R
      }), S(ne);
    }
    function S(R) {
      if (!ft || !f.el)
        return;
      const L = Cc(d.value, f.el), ne = Qx(d.value, i.value, f.el);
      if (!(D_(d.value, f.el) <= L || // Prevent scrolling by only a couple of pixels, which doesn't look smooth
      Math.abs(R - ne) < 16)) {
        if (d.value && i.value && f.el) {
          const {
            scrollWidth: we,
            offsetWidth: ee
          } = f.el;
          R = we - ee - R;
        }
        d.value ? p.horizontal(R, y.value) : p(R, y.value);
      }
    }
    function C(R) {
      const {
        scrollTop: L,
        scrollLeft: ne
      } = R.target;
      l.value = d.value ? ne : L;
    }
    function x(R) {
      if (_.value = !0, !(!o.value || !m.el)) {
        for (const L of R.composedPath())
          for (const ne of m.el.children)
            if (ne === L) {
              w(ne);
              return;
            }
      }
    }
    function A(R) {
      _.value = !1;
    }
    let I = !1;
    function E(R) {
      var L;
      !I && !_.value && !(R.relatedTarget && ((L = m.el) != null && L.contains(R.relatedTarget))) && N(), I = !1;
    }
    function P() {
      I = !0;
    }
    function V(R) {
      if (!m.el)
        return;
      function L(ne) {
        R.preventDefault(), N(ne);
      }
      d.value ? R.key === "ArrowRight" ? L(i.value ? "prev" : "next") : R.key === "ArrowLeft" && L(i.value ? "next" : "prev") : R.key === "ArrowDown" ? L("next") : R.key === "ArrowUp" && L("prev"), R.key === "Home" ? L("first") : R.key === "End" && L("last");
    }
    function N(R) {
      var ne, oe;
      if (!m.el)
        return;
      let L;
      if (!R)
        L = Uu(m.el)[0];
      else if (R === "next") {
        if (L = (ne = m.el.querySelector(":focus")) == null ? void 0 : ne.nextElementSibling, !L)
          return N("first");
      } else if (R === "prev") {
        if (L = (oe = m.el.querySelector(":focus")) == null ? void 0 : oe.previousElementSibling, !L)
          return N("last");
      } else
        R === "first" ? L = m.el.firstElementChild : R === "last" && (L = m.el.lastElementChild);
      L && L.focus({
        preventScroll: !0
      });
    }
    function F(R) {
      const L = d.value && i.value ? -1 : 1, ne = (R === "prev" ? -L : L) * u.value;
      let oe = l.value + ne;
      if (d.value && i.value && f.el) {
        const {
          scrollWidth: we,
          offsetWidth: ee
        } = f.el;
        oe += we - ee;
      }
      S(oe);
    }
    const $ = b(() => ({
      next: a.next,
      prev: a.prev,
      select: a.select,
      isSelected: a.isSelected
    })), Z = b(() => {
      switch (e.showArrows) {
        case "always":
          return !0;
        case "desktop":
          return !s.value;
        case !0:
          return o.value || Math.abs(l.value) > 0;
        case "mobile":
          return s.value || o.value || Math.abs(l.value) > 0;
        default:
          return !s.value && (o.value || Math.abs(l.value) > 0);
      }
    }), j = b(() => Math.abs(l.value) > 1), H = b(() => {
      if (!f.value)
        return !1;
      const R = D_(d.value, f.el), L = y6(d.value, f.el);
      return R - L - Math.abs(l.value) > 1;
    });
    return re(() => v(e.tag, {
      class: ["v-slide-group", {
        "v-slide-group--vertical": !d.value,
        "v-slide-group--has-affixes": Z.value,
        "v-slide-group--is-overflowing": o.value
      }, r.value, e.class],
      style: e.style,
      tabindex: _.value || a.selected.value.length ? -1 : 0,
      onFocus: E
    }, {
      default: () => {
        var R, L, ne;
        return [Z.value && v("div", {
          key: "prev",
          class: ["v-slide-group__prev", {
            "v-slide-group__prev--disabled": !j.value
          }],
          onMousedown: P,
          onClick: () => j.value && F("prev")
        }, [((R = n.prev) == null ? void 0 : R.call(n, $.value)) ?? v(Gu, null, {
          default: () => [v(at, {
            icon: i.value ? e.nextIcon : e.prevIcon
          }, null)]
        })]), v("div", {
          key: "container",
          ref: f,
          class: "v-slide-group__container",
          onScroll: C
        }, [v("div", {
          ref: m,
          class: "v-slide-group__content",
          onFocusin: x,
          onFocusout: A,
          onKeydown: V
        }, [(L = n.default) == null ? void 0 : L.call(n, $.value)])]), Z.value && v("div", {
          key: "next",
          class: ["v-slide-group__next", {
            "v-slide-group__next--disabled": !H.value
          }],
          onMousedown: P,
          onClick: () => H.value && F("next")
        }, [((ne = n.next) == null ? void 0 : ne.call(n, $.value)) ?? v(Gu, null, {
          default: () => [v(at, {
            icon: i.value ? e.prevIcon : e.nextIcon
          }, null)]
        })])];
      }
    })), {
      selected: a.selected,
      scrollTo: F,
      scrollOffset: l,
      focus: N
    };
  }
}), nA = Symbol.for("vuetify:v-chip-group"), b6 = B({
  column: Boolean,
  filter: Boolean,
  valueComparator: {
    type: Function,
    default: Yr
  },
  ...eb(),
  ...ke(),
  ...Po({
    selectedClass: "v-chip--selected"
  }),
  ...je(),
  ...Qe(),
  ...tr({
    variant: "tonal"
  })
}, "VChipGroup"), w6 = J()({
  name: "VChipGroup",
  props: b6(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      isSelected: r,
      select: s,
      next: a,
      prev: o,
      selected: l
    } = ha(e, nA);
    return jt({
      VChip: {
        color: G(e, "color"),
        disabled: G(e, "disabled"),
        filter: G(e, "filter"),
        variant: G(e, "variant")
      }
    }), re(() => {
      const u = Tc.filterProps(e);
      return v(Tc, ie(u, {
        class: ["v-chip-group", {
          "v-chip-group--column": e.column
        }, i.value, e.class],
        style: e.style
      }), {
        default: () => {
          var c;
          return [(c = n.default) == null ? void 0 : c.call(n, {
            isSelected: r,
            select: s,
            next: a,
            prev: o,
            selected: l.value
          })];
        }
      });
    }), {};
  }
}), _6 = B({
  activeClass: String,
  appendAvatar: String,
  appendIcon: We,
  closable: Boolean,
  closeIcon: {
    type: We,
    default: "$delete"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  draggable: Boolean,
  filter: Boolean,
  filterIcon: {
    type: String,
    default: "$complete"
  },
  label: Boolean,
  link: {
    type: Boolean,
    default: void 0
  },
  pill: Boolean,
  prependAvatar: String,
  prependIcon: We,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  text: String,
  modelValue: {
    type: Boolean,
    default: !0
  },
  onClick: ri(),
  onClickOnce: ri(),
  ...Ni(),
  ...ke(),
  ..._n(),
  ...gn(),
  ...Oo(),
  ...It(),
  ...od(),
  ...Xr(),
  ...je({
    tag: "span"
  }),
  ...Qe(),
  ...tr({
    variant: "tonal"
  })
}, "VChip"), ou = J()({
  name: "VChip",
  directives: {
    Ripple: Vs
  },
  props: _6(),
  emits: {
    "click:close": (e) => !0,
    "update:modelValue": (e) => !0,
    "group:selected": (e) => !0,
    click: (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const {
      t: s
    } = qt(), {
      borderClasses: a
    } = er(e), {
      colorClasses: o,
      colorStyles: l,
      variantClasses: u
    } = Eo(e), {
      densityClasses: c
    } = Kn(e), {
      elevationClasses: d
    } = On(e), {
      roundedClasses: f
    } = Ht(e), {
      sizeClasses: h
    } = $l(e), {
      themeClasses: m
    } = lt(e), g = Ee(e, "modelValue"), p = Vo(e, nA, !1), y = ad(e, n), k = b(() => e.link !== !1 && y.isLink.value), T = b(() => !e.disabled && e.link !== !1 && (!!p || e.link || y.isClickable.value)), _ = b(() => ({
      "aria-label": s(e.closeLabel),
      onClick(C) {
        C.preventDefault(), C.stopPropagation(), g.value = !1, i("click:close", C);
      }
    }));
    function w(C) {
      var x;
      i("click", C), T.value && ((x = y.navigate) == null || x.call(y, C), p == null || p.toggle());
    }
    function S(C) {
      (C.key === "Enter" || C.key === " ") && (C.preventDefault(), w(C));
    }
    return () => {
      const C = y.isLink.value ? "a" : e.tag, x = !!(e.appendIcon || e.appendAvatar), A = !!(x || r.append), I = !!(r.close || e.closable), E = !!(r.filter || e.filter) && p, P = !!(e.prependIcon || e.prependAvatar), V = !!(P || r.prepend), N = !p || p.isSelected.value;
      return g.value && Rt(v(C, {
        class: ["v-chip", {
          "v-chip--disabled": e.disabled,
          "v-chip--label": e.label,
          "v-chip--link": T.value,
          "v-chip--filter": E,
          "v-chip--pill": e.pill
        }, m.value, a.value, N ? o.value : void 0, c.value, d.value, f.value, h.value, u.value, p == null ? void 0 : p.selectedClass.value, e.class],
        style: [N ? l.value : void 0, e.style],
        disabled: e.disabled || void 0,
        draggable: e.draggable,
        href: y.href.value,
        tabindex: T.value ? 0 : void 0,
        onClick: w,
        onKeydown: T.value && !k.value && S
      }, {
        default: () => {
          var F;
          return [fa(T.value, "v-chip"), E && v(gp, {
            key: "filter"
          }, {
            default: () => [Rt(v("div", {
              class: "v-chip__filter"
            }, [r.filter ? v(Ze, {
              key: "filter-defaults",
              disabled: !e.filterIcon,
              defaults: {
                VIcon: {
                  icon: e.filterIcon
                }
              }
            }, r.filter) : v(at, {
              key: "filter-icon",
              icon: e.filterIcon
            }, null)]), [[Tr, p.isSelected.value]])]
          }), V && v("div", {
            key: "prepend",
            class: "v-chip__prepend"
          }, [r.prepend ? v(Ze, {
            key: "prepend-defaults",
            disabled: !P,
            defaults: {
              VAvatar: {
                image: e.prependAvatar,
                start: !0
              },
              VIcon: {
                icon: e.prependIcon,
                start: !0
              }
            }
          }, r.prepend) : v(De, null, [e.prependIcon && v(at, {
            key: "prepend-icon",
            icon: e.prependIcon,
            start: !0
          }, null), e.prependAvatar && v(Ji, {
            key: "prepend-avatar",
            image: e.prependAvatar,
            start: !0
          }, null)])]), v("div", {
            class: "v-chip__content",
            "data-no-activator": ""
          }, [((F = r.default) == null ? void 0 : F.call(r, {
            isSelected: p == null ? void 0 : p.isSelected.value,
            selectedClass: p == null ? void 0 : p.selectedClass.value,
            select: p == null ? void 0 : p.select,
            toggle: p == null ? void 0 : p.toggle,
            value: p == null ? void 0 : p.value.value,
            disabled: e.disabled
          })) ?? e.text]), A && v("div", {
            key: "append",
            class: "v-chip__append"
          }, [r.append ? v(Ze, {
            key: "append-defaults",
            disabled: !x,
            defaults: {
              VAvatar: {
                end: !0,
                image: e.appendAvatar
              },
              VIcon: {
                end: !0,
                icon: e.appendIcon
              }
            }
          }, r.append) : v(De, null, [e.appendIcon && v(at, {
            key: "append-icon",
            end: !0,
            icon: e.appendIcon
          }, null), e.appendAvatar && v(Ji, {
            key: "append-avatar",
            end: !0,
            image: e.appendAvatar
          }, null)])]), I && v("button", ie({
            key: "close",
            class: "v-chip__close",
            type: "button"
          }, _.value), [r.close ? v(Ze, {
            key: "close-defaults",
            defaults: {
              VIcon: {
                icon: e.closeIcon,
                size: "x-small"
              }
            }
          }, r.close) : v(at, {
            key: "close-icon",
            icon: e.closeIcon,
            size: "x-small"
          }, null)])];
        }
      }), [[Ei("ripple"), T.value && e.ripple, null]]);
    };
  }
});
const Ng = Symbol.for("vuetify:list");
function iA() {
  const e = tt(Ng, {
    hasPrepend: pe(!1),
    updateHasPrepend: () => null
  }), t = {
    hasPrepend: pe(!1),
    updateHasPrepend: (n) => {
      n && (t.hasPrepend.value = n);
    }
  };
  return Tt(Ng, t), e;
}
function rA() {
  return tt(Ng, null);
}
const tb = (e) => {
  const t = {
    activate: (n) => {
      let {
        id: i,
        value: r,
        activated: s
      } = n;
      return i = si(i), e && !r && s.size === 1 && s.has(i) || (r ? s.add(i) : s.delete(i)), s;
    },
    in: (n, i, r) => {
      let s = /* @__PURE__ */ new Set();
      if (n != null)
        for (const a of Nt(n))
          s = t.activate({
            id: a,
            value: !0,
            activated: new Set(s),
            children: i,
            parents: r
          });
      return s;
    },
    out: (n) => Array.from(n)
  };
  return t;
}, sA = (e) => {
  const t = tb(e);
  return {
    activate: (i) => {
      let {
        activated: r,
        id: s,
        ...a
      } = i;
      s = si(s);
      const o = r.has(s) ? /* @__PURE__ */ new Set([s]) : /* @__PURE__ */ new Set();
      return t.activate({
        ...a,
        id: s,
        activated: o
      });
    },
    in: (i, r, s) => {
      let a = /* @__PURE__ */ new Set();
      if (i != null) {
        const o = Nt(i);
        o.length && (a = t.in(o.slice(0, 1), r, s));
      }
      return a;
    },
    out: (i, r, s) => t.out(i, r, s)
  };
}, S6 = (e) => {
  const t = tb(e);
  return {
    activate: (i) => {
      let {
        id: r,
        activated: s,
        children: a,
        ...o
      } = i;
      return r = si(r), a.has(r) ? s : t.activate({
        id: r,
        activated: s,
        children: a,
        ...o
      });
    },
    in: t.in,
    out: t.out
  };
}, k6 = (e) => {
  const t = sA(e);
  return {
    activate: (i) => {
      let {
        id: r,
        activated: s,
        children: a,
        ...o
      } = i;
      return r = si(r), a.has(r) ? s : t.activate({
        id: r,
        activated: s,
        children: a,
        ...o
      });
    },
    in: t.in,
    out: t.out
  };
}, C6 = {
  open: (e) => {
    let {
      id: t,
      value: n,
      opened: i,
      parents: r
    } = e;
    if (n) {
      const s = /* @__PURE__ */ new Set();
      s.add(t);
      let a = r.get(t);
      for (; a != null; )
        s.add(a), a = r.get(a);
      return s;
    } else
      return i.delete(t), i;
  },
  select: () => null
}, aA = {
  open: (e) => {
    let {
      id: t,
      value: n,
      opened: i,
      parents: r
    } = e;
    if (n) {
      let s = r.get(t);
      for (i.add(t); s != null && s !== t; )
        i.add(s), s = r.get(s);
      return i;
    } else
      i.delete(t);
    return i;
  },
  select: () => null
}, T6 = {
  open: aA.open,
  select: (e) => {
    let {
      id: t,
      value: n,
      opened: i,
      parents: r
    } = e;
    if (!n)
      return i;
    const s = [];
    let a = r.get(t);
    for (; a != null; )
      s.push(a), a = r.get(a);
    return new Set(s);
  }
}, nb = (e) => {
  const t = {
    select: (n) => {
      let {
        id: i,
        value: r,
        selected: s
      } = n;
      if (i = si(i), e && !r) {
        const a = Array.from(s.entries()).reduce((o, l) => {
          let [u, c] = l;
          return c === "on" && o.push(u), o;
        }, []);
        if (a.length === 1 && a[0] === i)
          return s;
      }
      return s.set(i, r ? "on" : "off"), s;
    },
    in: (n, i, r) => {
      let s = /* @__PURE__ */ new Map();
      for (const a of n || [])
        s = t.select({
          id: a,
          value: !0,
          selected: new Map(s),
          children: i,
          parents: r
        });
      return s;
    },
    out: (n) => {
      const i = [];
      for (const [r, s] of n.entries())
        s === "on" && i.push(r);
      return i;
    }
  };
  return t;
}, oA = (e) => {
  const t = nb(e);
  return {
    select: (i) => {
      let {
        selected: r,
        id: s,
        ...a
      } = i;
      s = si(s);
      const o = r.has(s) ? /* @__PURE__ */ new Map([[s, r.get(s)]]) : /* @__PURE__ */ new Map();
      return t.select({
        ...a,
        id: s,
        selected: o
      });
    },
    in: (i, r, s) => {
      let a = /* @__PURE__ */ new Map();
      return i != null && i.length && (a = t.in(i.slice(0, 1), r, s)), a;
    },
    out: (i, r, s) => t.out(i, r, s)
  };
}, x6 = (e) => {
  const t = nb(e);
  return {
    select: (i) => {
      let {
        id: r,
        selected: s,
        children: a,
        ...o
      } = i;
      return r = si(r), a.has(r) ? s : t.select({
        id: r,
        selected: s,
        children: a,
        ...o
      });
    },
    in: t.in,
    out: t.out
  };
}, A6 = (e) => {
  const t = oA(e);
  return {
    select: (i) => {
      let {
        id: r,
        selected: s,
        children: a,
        ...o
      } = i;
      return r = si(r), a.has(r) ? s : t.select({
        id: r,
        selected: s,
        children: a,
        ...o
      });
    },
    in: t.in,
    out: t.out
  };
}, I6 = (e) => {
  const t = {
    select: (n) => {
      let {
        id: i,
        value: r,
        selected: s,
        children: a,
        parents: o
      } = n;
      i = si(i);
      const l = new Map(s), u = [i];
      for (; u.length; ) {
        const d = u.shift();
        s.set(d, r ? "on" : "off"), a.has(d) && u.push(...a.get(d));
      }
      let c = o.get(i);
      for (; c; ) {
        const d = a.get(c), f = d.every((m) => s.get(m) === "on"), h = d.every((m) => !s.has(m) || s.get(m) === "off");
        s.set(c, f ? "on" : h ? "off" : "indeterminate"), c = o.get(c);
      }
      return e && !r && Array.from(s.entries()).reduce((f, h) => {
        let [m, g] = h;
        return g === "on" && f.push(m), f;
      }, []).length === 0 ? l : s;
    },
    in: (n, i, r) => {
      let s = /* @__PURE__ */ new Map();
      for (const a of n || [])
        s = t.select({
          id: a,
          value: !0,
          selected: new Map(s),
          children: i,
          parents: r
        });
      return s;
    },
    out: (n, i) => {
      const r = [];
      for (const [s, a] of n.entries())
        a === "on" && !i.has(s) && r.push(s);
      return r;
    }
  };
  return t;
}, xc = Symbol.for("vuetify:nested"), lA = {
  id: pe(),
  root: {
    register: () => null,
    unregister: () => null,
    parents: X(/* @__PURE__ */ new Map()),
    children: X(/* @__PURE__ */ new Map()),
    open: () => null,
    openOnSelect: () => null,
    activate: () => null,
    select: () => null,
    activatable: X(!1),
    selectable: X(!1),
    opened: X(/* @__PURE__ */ new Set()),
    activated: X(/* @__PURE__ */ new Set()),
    selected: X(/* @__PURE__ */ new Map()),
    selectedValues: X([])
  }
}, E6 = B({
  activatable: Boolean,
  selectable: Boolean,
  activeStrategy: [String, Function, Object],
  selectStrategy: [String, Function, Object],
  openStrategy: [String, Object],
  opened: null,
  activated: null,
  selected: null,
  mandatory: Boolean
}, "nested"), P6 = (e) => {
  let t = !1;
  const n = X(/* @__PURE__ */ new Map()), i = X(/* @__PURE__ */ new Map()), r = Ee(e, "opened", e.opened, (h) => new Set(h), (h) => [...h.values()]), s = b(() => {
    if (typeof e.activeStrategy == "object")
      return e.activeStrategy;
    if (typeof e.activeStrategy == "function")
      return e.activeStrategy(e.mandatory);
    switch (e.activeStrategy) {
      case "leaf":
        return S6(e.mandatory);
      case "single-leaf":
        return k6(e.mandatory);
      case "independent":
        return tb(e.mandatory);
      case "single-independent":
      default:
        return sA(e.mandatory);
    }
  }), a = b(() => {
    if (typeof e.selectStrategy == "object")
      return e.selectStrategy;
    if (typeof e.selectStrategy == "function")
      return e.selectStrategy(e.mandatory);
    switch (e.selectStrategy) {
      case "single-leaf":
        return A6(e.mandatory);
      case "leaf":
        return x6(e.mandatory);
      case "independent":
        return nb(e.mandatory);
      case "single-independent":
        return oA(e.mandatory);
      case "classic":
      default:
        return I6(e.mandatory);
    }
  }), o = b(() => {
    if (typeof e.openStrategy == "object")
      return e.openStrategy;
    switch (e.openStrategy) {
      case "list":
        return T6;
      case "single":
        return C6;
      case "multiple":
      default:
        return aA;
    }
  }), l = Ee(e, "activated", e.activated, (h) => s.value.in(h, n.value, i.value), (h) => s.value.out(h, n.value, i.value)), u = Ee(e, "selected", e.selected, (h) => a.value.in(h, n.value, i.value), (h) => a.value.out(h, n.value, i.value));
  ai(() => {
    t = !0;
  });
  function c(h) {
    const m = [];
    let g = h;
    for (; g != null; )
      m.unshift(g), g = i.value.get(g);
    return m;
  }
  const d = Ut("nested"), f = {
    id: pe(),
    root: {
      opened: r,
      activatable: G(e, "activatable"),
      selectable: G(e, "selectable"),
      activated: l,
      selected: u,
      selectedValues: b(() => {
        const h = [];
        for (const [m, g] of u.value.entries())
          g === "on" && h.push(m);
        return h;
      }),
      register: (h, m, g) => {
        m && h !== m && i.value.set(h, m), g && n.value.set(h, []), m != null && n.value.set(m, [...n.value.get(m) || [], h]);
      },
      unregister: (h) => {
        if (t)
          return;
        n.value.delete(h);
        const m = i.value.get(h);
        if (m) {
          const g = n.value.get(m) ?? [];
          n.value.set(m, g.filter((p) => p !== h));
        }
        i.value.delete(h), r.value.delete(h);
      },
      open: (h, m, g) => {
        d.emit("click:open", {
          id: h,
          value: m,
          path: c(h),
          event: g
        });
        const p = o.value.open({
          id: h,
          value: m,
          opened: new Set(r.value),
          children: n.value,
          parents: i.value,
          event: g
        });
        p && (r.value = p);
      },
      openOnSelect: (h, m, g) => {
        const p = o.value.select({
          id: h,
          value: m,
          selected: new Map(u.value),
          opened: new Set(r.value),
          children: n.value,
          parents: i.value,
          event: g
        });
        p && (r.value = p);
      },
      select: (h, m, g) => {
        d.emit("click:select", {
          id: h,
          value: m,
          path: c(h),
          event: g
        });
        const p = a.value.select({
          id: h,
          value: m,
          selected: new Map(u.value),
          children: n.value,
          parents: i.value,
          event: g
        });
        p && (u.value = p), f.root.openOnSelect(h, m, g);
      },
      activate: (h, m, g) => {
        if (!e.activatable)
          return f.root.select(h, !0, g);
        d.emit("click:activate", {
          id: h,
          value: m,
          path: c(h),
          event: g
        });
        const p = s.value.activate({
          id: h,
          value: m,
          activated: new Set(l.value),
          children: n.value,
          parents: i.value,
          event: g
        });
        p && (l.value = p);
      },
      children: n,
      parents: i
    }
  };
  return Tt(xc, f), f.root;
}, uA = (e, t) => {
  const n = tt(xc, lA), i = Symbol(Pn()), r = b(() => e.value !== void 0 ? e.value : i), s = {
    ...n,
    id: r,
    open: (a, o) => n.root.open(r.value, a, o),
    openOnSelect: (a, o) => n.root.openOnSelect(r.value, a, o),
    isOpen: b(() => n.root.opened.value.has(r.value)),
    parent: b(() => n.root.parents.value.get(r.value)),
    activate: (a, o) => n.root.activate(r.value, a, o),
    isActivated: b(() => n.root.activated.value.has(si(r.value))),
    select: (a, o) => n.root.select(r.value, a, o),
    isSelected: b(() => n.root.selected.value.get(si(r.value)) === "on"),
    isIndeterminate: b(() => n.root.selected.value.get(r.value) === "indeterminate"),
    isLeaf: b(() => !n.root.children.value.get(r.value)),
    isGroupActivator: n.isGroupActivator
  };
  return !n.isGroupActivator && n.root.register(r.value, n.id.value, t), ai(() => {
    !n.isGroupActivator && n.root.unregister(r.value);
  }), t && Tt(xc, s), s;
}, O6 = () => {
  const e = tt(xc, lA);
  Tt(xc, {
    ...e,
    isGroupActivator: !0
  });
}, V6 = Pi({
  name: "VListGroupActivator",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return O6(), () => {
      var i;
      return (i = n.default) == null ? void 0 : i.call(n);
    };
  }
}), D6 = B({
  /* @deprecated */
  activeColor: String,
  baseColor: String,
  color: String,
  collapseIcon: {
    type: We,
    default: "$collapse"
  },
  expandIcon: {
    type: We,
    default: "$expand"
  },
  prependIcon: We,
  appendIcon: We,
  fluid: Boolean,
  subgroup: Boolean,
  title: String,
  value: null,
  ...ke(),
  ...je()
}, "VListGroup"), Mg = J()({
  name: "VListGroup",
  props: D6(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isOpen: i,
      open: r,
      id: s
    } = uA(G(e, "value"), !0), a = b(() => `v-list-group--id-${String(s.value)}`), o = rA(), {
      isBooted: l
    } = Io();
    function u(h) {
      r(!i.value, h);
    }
    const c = b(() => ({
      onClick: u,
      class: "v-list-group__header",
      id: a.value
    })), d = b(() => i.value ? e.collapseIcon : e.expandIcon), f = b(() => ({
      VListItem: {
        active: i.value,
        activeColor: e.activeColor,
        baseColor: e.baseColor,
        color: e.color,
        prependIcon: e.prependIcon || e.subgroup && d.value,
        appendIcon: e.appendIcon || !e.subgroup && d.value,
        title: e.title,
        value: e.value
      }
    }));
    return re(() => v(e.tag, {
      class: ["v-list-group", {
        "v-list-group--prepend": o == null ? void 0 : o.hasPrepend.value,
        "v-list-group--fluid": e.fluid,
        "v-list-group--subgroup": e.subgroup,
        "v-list-group--open": i.value
      }, e.class],
      style: e.style
    }, {
      default: () => [n.activator && v(Ze, {
        defaults: f.value
      }, {
        default: () => [v(V6, null, {
          default: () => [n.activator({
            props: c.value,
            isOpen: i.value
          })]
        })]
      }), v(Gn, {
        transition: {
          component: vh
        },
        disabled: !l.value
      }, {
        default: () => {
          var h;
          return [Rt(v("div", {
            class: "v-list-group__items",
            role: "group",
            "aria-labelledby": a.value
          }, [(h = n.default) == null ? void 0 : h.call(n)]), [[Tr, i.value]])];
        }
      })]
    })), {
      isOpen: i
    };
  }
});
const N6 = B({
  opacity: [Number, String],
  ...ke(),
  ...je()
}, "VListItemSubtitle"), cA = J()({
  name: "VListItemSubtitle",
  props: N6(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => v(e.tag, {
      class: ["v-list-item-subtitle", e.class],
      style: [{
        "--v-list-item-subtitle-opacity": e.opacity
      }, e.style]
    }, n)), {};
  }
}), dA = Zr("v-list-item-title"), M6 = B({
  active: {
    type: Boolean,
    default: void 0
  },
  activeClass: String,
  /* @deprecated */
  activeColor: String,
  appendAvatar: String,
  appendIcon: We,
  baseColor: String,
  disabled: Boolean,
  lines: [Boolean, String],
  link: {
    type: Boolean,
    default: void 0
  },
  nav: Boolean,
  prependAvatar: String,
  prependIcon: We,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  slim: Boolean,
  subtitle: [String, Number],
  title: [String, Number],
  value: null,
  onClick: ri(),
  onClickOnce: ri(),
  ...Ni(),
  ...ke(),
  ..._n(),
  ...Sn(),
  ...gn(),
  ...It(),
  ...od(),
  ...je(),
  ...Qe(),
  ...tr({
    variant: "text"
  })
}, "VListItem"), Ts = J()({
  name: "VListItem",
  directives: {
    Ripple: Vs
  },
  props: M6(),
  emits: {
    click: (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i,
      emit: r
    } = t;
    const s = ad(e, n), a = b(() => e.value === void 0 ? s.href.value : e.value), {
      activate: o,
      isActivated: l,
      select: u,
      isSelected: c,
      isIndeterminate: d,
      isGroupActivator: f,
      root: h,
      parent: m,
      openOnSelect: g
    } = uA(a, !1), p = rA(), y = b(() => {
      var R;
      return e.active !== !1 && (e.active || ((R = s.isActive) == null ? void 0 : R.value) || (h.activatable.value ? l.value : c.value));
    }), k = b(() => e.link !== !1 && s.isLink.value), T = b(() => !e.disabled && e.link !== !1 && (e.link || s.isClickable.value || !!p && (h.selectable.value || h.activatable.value || e.value != null))), _ = b(() => e.rounded || e.nav), w = b(() => e.color ?? e.activeColor), S = b(() => ({
      color: y.value ? w.value ?? e.baseColor : e.baseColor,
      variant: e.variant
    }));
    fe(() => {
      var R;
      return (R = s.isActive) == null ? void 0 : R.value;
    }, (R) => {
      R && m.value != null && h.open(m.value, !0), R && g(R);
    }, {
      immediate: !0
    });
    const {
      themeClasses: C
    } = lt(e), {
      borderClasses: x
    } = er(e), {
      colorClasses: A,
      colorStyles: I,
      variantClasses: E
    } = Eo(S), {
      densityClasses: P
    } = Kn(e), {
      dimensionStyles: V
    } = kn(e), {
      elevationClasses: N
    } = On(e), {
      roundedClasses: F
    } = Ht(_), $ = b(() => e.lines ? `v-list-item--${e.lines}-line` : void 0), Z = b(() => ({
      isActive: y.value,
      select: u,
      isSelected: c.value,
      isIndeterminate: d.value
    }));
    function j(R) {
      var L;
      r("click", R), T.value && ((L = s.navigate) == null || L.call(s, R), !f && (h.activatable.value ? o(!l.value, R) : (h.selectable.value || e.value != null) && u(!c.value, R)));
    }
    function H(R) {
      (R.key === "Enter" || R.key === " ") && (R.preventDefault(), j(R));
    }
    return re(() => {
      const R = k.value ? "a" : e.tag, L = i.title || e.title != null, ne = i.subtitle || e.subtitle != null, oe = !!(e.appendAvatar || e.appendIcon), we = !!(oe || i.append), ee = !!(e.prependAvatar || e.prependIcon), K = !!(ee || i.prepend);
      return p == null || p.updateHasPrepend(K), e.activeColor && TP("active-color", ["color", "base-color"]), Rt(v(R, {
        class: ["v-list-item", {
          "v-list-item--active": y.value,
          "v-list-item--disabled": e.disabled,
          "v-list-item--link": T.value,
          "v-list-item--nav": e.nav,
          "v-list-item--prepend": !K && (p == null ? void 0 : p.hasPrepend.value),
          "v-list-item--slim": e.slim,
          [`${e.activeClass}`]: e.activeClass && y.value
        }, C.value, x.value, A.value, P.value, N.value, $.value, F.value, E.value, e.class],
        style: [I.value, V.value, e.style],
        href: s.href.value,
        tabindex: T.value ? p ? -2 : 0 : void 0,
        onClick: j,
        onKeydown: T.value && !k.value && H
      }, {
        default: () => {
          var ue;
          return [fa(T.value || y.value, "v-list-item"), K && v("div", {
            key: "prepend",
            class: "v-list-item__prepend"
          }, [i.prepend ? v(Ze, {
            key: "prepend-defaults",
            disabled: !ee,
            defaults: {
              VAvatar: {
                density: e.density,
                image: e.prependAvatar
              },
              VIcon: {
                density: e.density,
                icon: e.prependIcon
              },
              VListItemAction: {
                start: !0
              }
            }
          }, {
            default: () => {
              var ve;
              return [(ve = i.prepend) == null ? void 0 : ve.call(i, Z.value)];
            }
          }) : v(De, null, [e.prependAvatar && v(Ji, {
            key: "prepend-avatar",
            density: e.density,
            image: e.prependAvatar
          }, null), e.prependIcon && v(at, {
            key: "prepend-icon",
            density: e.density,
            icon: e.prependIcon
          }, null)]), v("div", {
            class: "v-list-item__spacer"
          }, null)]), v("div", {
            class: "v-list-item__content",
            "data-no-activator": ""
          }, [L && v(dA, {
            key: "title"
          }, {
            default: () => {
              var ve;
              return [((ve = i.title) == null ? void 0 : ve.call(i, {
                title: e.title
              })) ?? e.title];
            }
          }), ne && v(cA, {
            key: "subtitle"
          }, {
            default: () => {
              var ve;
              return [((ve = i.subtitle) == null ? void 0 : ve.call(i, {
                subtitle: e.subtitle
              })) ?? e.subtitle];
            }
          }), (ue = i.default) == null ? void 0 : ue.call(i, Z.value)]), we && v("div", {
            key: "append",
            class: "v-list-item__append"
          }, [i.append ? v(Ze, {
            key: "append-defaults",
            disabled: !oe,
            defaults: {
              VAvatar: {
                density: e.density,
                image: e.appendAvatar
              },
              VIcon: {
                density: e.density,
                icon: e.appendIcon
              },
              VListItemAction: {
                end: !0
              }
            }
          }, {
            default: () => {
              var ve;
              return [(ve = i.append) == null ? void 0 : ve.call(i, Z.value)];
            }
          }) : v(De, null, [e.appendIcon && v(at, {
            key: "append-icon",
            density: e.density,
            icon: e.appendIcon
          }, null), e.appendAvatar && v(Ji, {
            key: "append-avatar",
            density: e.density,
            image: e.appendAvatar
          }, null)]), v("div", {
            class: "v-list-item__spacer"
          }, null)])];
        }
      }), [[Ei("ripple"), T.value && e.ripple]]);
    }), {
      isGroupActivator: f,
      isSelected: c,
      list: p,
      select: u
    };
  }
}), R6 = B({
  color: String,
  inset: Boolean,
  sticky: Boolean,
  title: String,
  ...ke(),
  ...je()
}, "VListSubheader"), fA = J()({
  name: "VListSubheader",
  props: R6(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      textColorClasses: i,
      textColorStyles: r
    } = $n(G(e, "color"));
    return re(() => {
      const s = !!(n.default || e.title);
      return v(e.tag, {
        class: ["v-list-subheader", {
          "v-list-subheader--inset": e.inset,
          "v-list-subheader--sticky": e.sticky
        }, i.value, e.class],
        style: [{
          textColorStyles: r
        }, e.style]
      }, {
        default: () => {
          var a;
          return [s && v("div", {
            class: "v-list-subheader__text"
          }, [((a = n.default) == null ? void 0 : a.call(n)) ?? e.title])];
        }
      });
    }), {};
  }
});
const F6 = B({
  color: String,
  inset: Boolean,
  length: [Number, String],
  opacity: [Number, String],
  thickness: [Number, String],
  vertical: Boolean,
  ...ke(),
  ...Qe()
}, "VDivider"), ld = J()({
  name: "VDivider",
  props: F6(),
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      themeClasses: r
    } = lt(e), {
      textColorClasses: s,
      textColorStyles: a
    } = $n(G(e, "color")), o = b(() => {
      const l = {};
      return e.length && (l[e.vertical ? "maxHeight" : "maxWidth"] = _e(e.length)), e.thickness && (l[e.vertical ? "borderRightWidth" : "borderTopWidth"] = _e(e.thickness)), l;
    });
    return re(() => {
      const l = v("hr", {
        class: [{
          "v-divider": !0,
          "v-divider--inset": e.inset,
          "v-divider--vertical": e.vertical
        }, r.value, s.value, e.class],
        style: [o.value, a.value, {
          "--v-border-opacity": e.opacity
        }, e.style],
        "aria-orientation": !n.role || n.role === "separator" ? e.vertical ? "vertical" : "horizontal" : void 0,
        role: `${n.role || "separator"}`
      }, null);
      return i.default ? v("div", {
        class: ["v-divider__wrapper", {
          "v-divider__wrapper--vertical": e.vertical,
          "v-divider__wrapper--inset": e.inset
        }]
      }, [l, v("div", {
        class: "v-divider__content"
      }, [i.default()]), l]) : l;
    }), {};
  }
}), B6 = B({
  items: Array,
  returnObject: Boolean
}, "VListChildren"), hA = J()({
  name: "VListChildren",
  props: B6(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return iA(), () => {
      var i, r;
      return ((i = n.default) == null ? void 0 : i.call(n)) ?? ((r = e.items) == null ? void 0 : r.map((s) => {
        var f, h;
        let {
          children: a,
          props: o,
          type: l,
          raw: u
        } = s;
        if (l === "divider")
          return ((f = n.divider) == null ? void 0 : f.call(n, {
            props: o
          })) ?? v(ld, o, null);
        if (l === "subheader")
          return ((h = n.subheader) == null ? void 0 : h.call(n, {
            props: o
          })) ?? v(fA, o, null);
        const c = {
          subtitle: n.subtitle ? (m) => {
            var g;
            return (g = n.subtitle) == null ? void 0 : g.call(n, {
              ...m,
              item: u
            });
          } : void 0,
          prepend: n.prepend ? (m) => {
            var g;
            return (g = n.prepend) == null ? void 0 : g.call(n, {
              ...m,
              item: u
            });
          } : void 0,
          append: n.append ? (m) => {
            var g;
            return (g = n.append) == null ? void 0 : g.call(n, {
              ...m,
              item: u
            });
          } : void 0,
          title: n.title ? (m) => {
            var g;
            return (g = n.title) == null ? void 0 : g.call(n, {
              ...m,
              item: u
            });
          } : void 0
        }, d = Mg.filterProps(o);
        return a ? v(Mg, ie({
          value: o == null ? void 0 : o.value
        }, d), {
          activator: (m) => {
            let {
              props: g
            } = m;
            const p = {
              ...o,
              ...g,
              value: e.returnObject ? u : o.value
            };
            return n.header ? n.header({
              props: p
            }) : v(Ts, p, c);
          },
          default: () => v(hA, {
            items: a,
            returnObject: e.returnObject
          }, n)
        }) : n.item ? n.item({
          props: o
        }) : v(Ts, ie(o, {
          value: e.returnObject ? u : o.value
        }), c);
      }));
    };
  }
}), mA = B({
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: [String, Array, Function],
    default: "title"
  },
  itemValue: {
    type: [String, Array, Function],
    default: "value"
  },
  itemChildren: {
    type: [Boolean, String, Array, Function],
    default: "children"
  },
  itemProps: {
    type: [Boolean, String, Array, Function],
    default: "props"
  },
  returnObject: Boolean,
  valueComparator: {
    type: Function,
    default: Yr
  }
}, "list-items");
function Gs(e, t) {
  const n = hn(t, e.itemTitle, t), i = hn(t, e.itemValue, n), r = hn(t, e.itemChildren), s = e.itemProps === !0 ? typeof t == "object" && t != null && !Array.isArray(t) ? "children" in t ? an(t, ["children"]) : t : void 0 : hn(t, e.itemProps), a = {
    title: n,
    value: i,
    ...s
  };
  return {
    title: String(a.title ?? ""),
    value: a.value,
    props: a,
    children: Array.isArray(r) ? vA(e, r) : void 0,
    raw: t
  };
}
function vA(e, t) {
  const n = [];
  for (const i of t)
    n.push(Gs(e, i));
  return n;
}
function ib(e) {
  const t = b(() => vA(e, e.items)), n = b(() => t.value.some((s) => s.value === null));
  function i(s) {
    return n.value || (s = s.filter((a) => a !== null)), s.map((a) => e.returnObject && typeof a == "string" ? Gs(e, a) : t.value.find((o) => e.valueComparator(a, o.value)) || Gs(e, a));
  }
  function r(s) {
    return e.returnObject ? s.map((a) => {
      let {
        raw: o
      } = a;
      return o;
    }) : s.map((a) => {
      let {
        value: o
      } = a;
      return o;
    });
  }
  return {
    items: t,
    transformIn: i,
    transformOut: r
  };
}
function L6(e) {
  return typeof e == "string" || typeof e == "number" || typeof e == "boolean";
}
function $6(e, t) {
  const n = hn(t, e.itemType, "item"), i = L6(t) ? t : hn(t, e.itemTitle), r = hn(t, e.itemValue, void 0), s = hn(t, e.itemChildren), a = e.itemProps === !0 ? an(t, ["children"]) : hn(t, e.itemProps), o = {
    title: i,
    value: r,
    ...a
  };
  return {
    type: n,
    title: o.title,
    value: o.value,
    props: o,
    children: n === "item" && s ? gA(e, s) : void 0,
    raw: t
  };
}
function gA(e, t) {
  const n = [];
  for (const i of t)
    n.push($6(e, i));
  return n;
}
function W6(e) {
  return {
    items: b(() => gA(e, e.items))
  };
}
const j6 = B({
  baseColor: String,
  /* @deprecated */
  activeColor: String,
  activeClass: String,
  bgColor: String,
  disabled: Boolean,
  expandIcon: String,
  collapseIcon: String,
  lines: {
    type: [Boolean, String],
    default: "one"
  },
  slim: Boolean,
  nav: Boolean,
  ...E6({
    selectStrategy: "single-leaf",
    openStrategy: "list"
  }),
  ...Ni(),
  ...ke(),
  ..._n(),
  ...Sn(),
  ...gn(),
  itemType: {
    type: String,
    default: "type"
  },
  ...mA(),
  ...It(),
  ...je(),
  ...Qe(),
  ...tr({
    variant: "text"
  })
}, "VList"), cm = J()({
  name: "VList",
  props: j6(),
  emits: {
    "update:selected": (e) => !0,
    "update:activated": (e) => !0,
    "update:opened": (e) => !0,
    "click:open": (e) => !0,
    "click:activate": (e) => !0,
    "click:select": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      items: i
    } = W6(e), {
      themeClasses: r
    } = lt(e), {
      backgroundColorClasses: s,
      backgroundColorStyles: a
    } = gt(G(e, "bgColor")), {
      borderClasses: o
    } = er(e), {
      densityClasses: l
    } = Kn(e), {
      dimensionStyles: u
    } = kn(e), {
      elevationClasses: c
    } = On(e), {
      roundedClasses: d
    } = Ht(e), {
      children: f,
      open: h,
      parents: m,
      select: g
    } = P6(e), p = b(() => e.lines ? `v-list--${e.lines}-line` : void 0), y = G(e, "activeColor"), k = G(e, "baseColor"), T = G(e, "color");
    iA(), jt({
      VListGroup: {
        activeColor: y,
        baseColor: k,
        color: T,
        expandIcon: G(e, "expandIcon"),
        collapseIcon: G(e, "collapseIcon")
      },
      VListItem: {
        activeClass: G(e, "activeClass"),
        activeColor: y,
        baseColor: k,
        color: T,
        density: G(e, "density"),
        disabled: G(e, "disabled"),
        lines: G(e, "lines"),
        nav: G(e, "nav"),
        slim: G(e, "slim"),
        variant: G(e, "variant")
      }
    });
    const _ = pe(!1), w = X();
    function S(P) {
      _.value = !0;
    }
    function C(P) {
      _.value = !1;
    }
    function x(P) {
      var V;
      !_.value && !(P.relatedTarget && ((V = w.value) != null && V.contains(P.relatedTarget))) && E();
    }
    function A(P) {
      const V = P.target;
      if (!(!w.value || ["INPUT", "TEXTAREA"].includes(V.tagName))) {
        if (P.key === "ArrowDown")
          E("next");
        else if (P.key === "ArrowUp")
          E("prev");
        else if (P.key === "Home")
          E("first");
        else if (P.key === "End")
          E("last");
        else
          return;
        P.preventDefault();
      }
    }
    function I(P) {
      _.value = !0;
    }
    function E(P) {
      if (w.value)
        return gl(w.value, P);
    }
    return re(() => v(e.tag, {
      ref: w,
      class: ["v-list", {
        "v-list--disabled": e.disabled,
        "v-list--nav": e.nav,
        "v-list--slim": e.slim
      }, r.value, s.value, o.value, l.value, c.value, p.value, d.value, e.class],
      style: [a.value, u.value, e.style],
      tabindex: e.disabled || _.value ? -1 : 0,
      role: "listbox",
      "aria-activedescendant": void 0,
      onFocusin: S,
      onFocusout: C,
      onFocus: x,
      onKeydown: A,
      onMousedown: I
    }, {
      default: () => [v(hA, {
        items: i.value,
        returnObject: e.returnObject
      }, n)]
    })), {
      open: h,
      select: g,
      focus: E,
      children: f,
      parents: m
    };
  }
}), H6 = Zr("v-list-img"), z6 = B({
  start: Boolean,
  end: Boolean,
  ...ke(),
  ...je()
}, "VListItemAction"), U6 = J()({
  name: "VListItemAction",
  props: z6(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => v(e.tag, {
      class: ["v-list-item-action", {
        "v-list-item-action--start": e.start,
        "v-list-item-action--end": e.end
      }, e.class],
      style: e.style
    }, n)), {};
  }
}), q6 = B({
  start: Boolean,
  end: Boolean,
  ...ke(),
  ...je()
}, "VListItemMedia"), G6 = J()({
  name: "VListItemMedia",
  props: q6(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => v(e.tag, {
      class: ["v-list-item-media", {
        "v-list-item-media--start": e.start,
        "v-list-item-media--end": e.end
      }, e.class],
      style: e.style
    }, n)), {};
  }
});
function Cv(e, t) {
  return {
    x: e.x + t.x,
    y: e.y + t.y
  };
}
function Y6(e, t) {
  return {
    x: e.x - t.x,
    y: e.y - t.y
  };
}
function N_(e, t) {
  if (e.side === "top" || e.side === "bottom") {
    const {
      side: n,
      align: i
    } = e, r = i === "left" ? 0 : i === "center" ? t.width / 2 : i === "right" ? t.width : i, s = n === "top" ? 0 : n === "bottom" ? t.height : n;
    return Cv({
      x: r,
      y: s
    }, t);
  } else if (e.side === "left" || e.side === "right") {
    const {
      side: n,
      align: i
    } = e, r = n === "left" ? 0 : n === "right" ? t.width : n, s = i === "top" ? 0 : i === "center" ? t.height / 2 : i === "bottom" ? t.height : i;
    return Cv({
      x: r,
      y: s
    }, t);
  }
  return Cv({
    x: t.width / 2,
    y: t.height / 2
  }, t);
}
const pA = {
  static: X6,
  // specific viewport position, usually centered
  connected: Q6
  // connected to a certain element
}, Z6 = B({
  locationStrategy: {
    type: [String, Function],
    default: "static",
    validator: (e) => typeof e == "function" || e in pA
  },
  location: {
    type: String,
    default: "bottom"
  },
  origin: {
    type: String,
    default: "auto"
  },
  offset: [Number, String, Array]
}, "VOverlay-location-strategies");
function K6(e, t) {
  const n = X({}), i = X();
  ft && vi(() => !!(t.isActive.value && e.locationStrategy), (s) => {
    var a, o;
    fe(() => e.locationStrategy, s), jn(() => {
      window.removeEventListener("resize", r), i.value = void 0;
    }), window.addEventListener("resize", r, {
      passive: !0
    }), typeof e.locationStrategy == "function" ? i.value = (a = e.locationStrategy(t, e, n)) == null ? void 0 : a.updateLocation : i.value = (o = pA[e.locationStrategy](t, e, n)) == null ? void 0 : o.updateLocation;
  });
  function r(s) {
    var a;
    (a = i.value) == null || a.call(i, s);
  }
  return {
    contentStyles: n,
    updateLocation: i
  };
}
function X6() {
}
function J6(e, t) {
  t ? e.style.removeProperty("left") : e.style.removeProperty("right");
  const n = lp(e);
  return t ? n.x += parseFloat(e.style.right || 0) : n.x -= parseFloat(e.style.left || 0), n.y -= parseFloat(e.style.top || 0), n;
}
function Q6(e, t, n) {
  (Array.isArray(e.target.value) || UP(e.target.value)) && Object.assign(n.value, {
    position: "fixed",
    top: 0,
    [e.isRtl.value ? "right" : "left"]: 0
  });
  const {
    preferredAnchor: r,
    preferredOrigin: s
  } = ap(() => {
    const m = Pv(t.location, e.isRtl.value), g = t.origin === "overlap" ? m : t.origin === "auto" ? Hm(m) : Pv(t.origin, e.isRtl.value);
    return m.side === g.side && m.align === zm(g).align ? {
      preferredAnchor: Kb(m),
      preferredOrigin: Kb(g)
    } : {
      preferredAnchor: m,
      preferredOrigin: g
    };
  }), [a, o, l, u] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((m) => b(() => {
    const g = parseFloat(t[m]);
    return isNaN(g) ? 1 / 0 : g;
  })), c = b(() => {
    if (Array.isArray(t.offset))
      return t.offset;
    if (typeof t.offset == "string") {
      const m = t.offset.split(" ").map(parseFloat);
      return m.length < 2 && m.push(0), m;
    }
    return typeof t.offset == "number" ? [t.offset, 0] : [0, 0];
  });
  let d = !1;
  const f = new ResizeObserver(() => {
    d && h();
  });
  fe([e.target, e.contentEl], (m, g) => {
    let [p, y] = m, [k, T] = g;
    k && !Array.isArray(k) && f.unobserve(k), p && !Array.isArray(p) && f.observe(p), T && f.unobserve(T), y && f.observe(y);
  }, {
    immediate: !0
  }), jn(() => {
    f.disconnect();
  });
  function h() {
    if (d = !1, requestAnimationFrame(() => d = !0), !e.target.value || !e.contentEl.value)
      return;
    const m = hS(e.target.value), g = J6(e.contentEl.value, e.isRtl.value), p = vf(e.contentEl.value), y = 12;
    p.length || (p.push(document.documentElement), e.contentEl.value.style.top && e.contentEl.value.style.left || (g.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0), g.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0)));
    const k = p.reduce((E, P) => {
      const V = P.getBoundingClientRect(), N = new Wa({
        x: P === document.documentElement ? 0 : V.x,
        y: P === document.documentElement ? 0 : V.y,
        width: P.clientWidth,
        height: P.clientHeight
      });
      return E ? new Wa({
        x: Math.max(E.left, N.left),
        y: Math.max(E.top, N.top),
        width: Math.min(E.right, N.right) - Math.max(E.left, N.left),
        height: Math.min(E.bottom, N.bottom) - Math.max(E.top, N.top)
      }) : N;
    }, void 0);
    k.x += y, k.y += y, k.width -= y * 2, k.height -= y * 2;
    let T = {
      anchor: r.value,
      origin: s.value
    };
    function _(E) {
      const P = new Wa(g), V = N_(E.anchor, m), N = N_(E.origin, P);
      let {
        x: F,
        y: $
      } = Y6(V, N);
      switch (E.anchor.side) {
        case "top":
          $ -= c.value[0];
          break;
        case "bottom":
          $ += c.value[0];
          break;
        case "left":
          F -= c.value[0];
          break;
        case "right":
          F += c.value[0];
          break;
      }
      switch (E.anchor.align) {
        case "top":
          $ -= c.value[1];
          break;
        case "bottom":
          $ += c.value[1];
          break;
        case "left":
          F -= c.value[1];
          break;
        case "right":
          F += c.value[1];
          break;
      }
      return P.x += F, P.y += $, P.width = Math.min(P.width, l.value), P.height = Math.min(P.height, u.value), {
        overflows: Jb(P, k),
        x: F,
        y: $
      };
    }
    let w = 0, S = 0;
    const C = {
      x: 0,
      y: 0
    }, x = {
      x: !1,
      y: !1
    };
    let A = -1;
    for (; ; ) {
      if (A++ > 10) {
        hf("Infinite loop detected in connectedLocationStrategy");
        break;
      }
      const {
        x: E,
        y: P,
        overflows: V
      } = _(T);
      w += E, S += P, g.x += E, g.y += P;
      {
        const N = Xb(T.anchor), F = V.x.before || V.x.after, $ = V.y.before || V.y.after;
        let Z = !1;
        if (["x", "y"].forEach((j) => {
          if (j === "x" && F && !x.x || j === "y" && $ && !x.y) {
            const H = {
              anchor: {
                ...T.anchor
              },
              origin: {
                ...T.origin
              }
            }, R = j === "x" ? N === "y" ? zm : Hm : N === "y" ? Hm : zm;
            H.anchor = R(H.anchor), H.origin = R(H.origin);
            const {
              overflows: L
            } = _(H);
            (L[j].before <= V[j].before && L[j].after <= V[j].after || L[j].before + L[j].after < (V[j].before + V[j].after) / 2) && (T = H, Z = x[j] = !0);
          }
        }), Z)
          continue;
      }
      V.x.before && (w += V.x.before, g.x += V.x.before), V.x.after && (w -= V.x.after, g.x -= V.x.after), V.y.before && (S += V.y.before, g.y += V.y.before), V.y.after && (S -= V.y.after, g.y -= V.y.after);
      {
        const N = Jb(g, k);
        C.x = k.width - N.x.before - N.x.after, C.y = k.height - N.y.before - N.y.after, w += N.x.before, g.x += N.x.before, S += N.y.before, g.y += N.y.before;
      }
      break;
    }
    const I = Xb(T.anchor);
    return Object.assign(n.value, {
      "--v-overlay-anchor-origin": `${T.anchor.side} ${T.anchor.align}`,
      transformOrigin: `${T.origin.side} ${T.origin.align}`,
      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,
      top: _e(Tv(S)),
      left: e.isRtl.value ? void 0 : _e(Tv(w)),
      right: e.isRtl.value ? _e(Tv(-w)) : void 0,
      minWidth: _e(I === "y" ? Math.min(a.value, m.width) : a.value),
      maxWidth: _e(M_(Xt(C.x, a.value === 1 / 0 ? 0 : a.value, l.value))),
      maxHeight: _e(M_(Xt(C.y, o.value === 1 / 0 ? 0 : o.value, u.value)))
    }), {
      available: C,
      contentBox: g
    };
  }
  return fe(() => [r.value, s.value, t.offset, t.minWidth, t.minHeight, t.maxWidth, t.maxHeight], () => h()), He(() => {
    const m = h();
    if (!m)
      return;
    const {
      available: g,
      contentBox: p
    } = m;
    p.height > g.y && requestAnimationFrame(() => {
      h(), requestAnimationFrame(() => {
        h();
      });
    });
  }), {
    updateLocation: h
  };
}
function Tv(e) {
  return Math.round(e * devicePixelRatio) / devicePixelRatio;
}
function M_(e) {
  return Math.ceil(e * devicePixelRatio) / devicePixelRatio;
}
let Rg = !0;
const ah = [];
function e5(e) {
  !Rg || ah.length ? (ah.push(e), Fg()) : (Rg = !1, e(), Fg());
}
let R_ = -1;
function Fg() {
  cancelAnimationFrame(R_), R_ = requestAnimationFrame(() => {
    const e = ah.shift();
    e && e(), ah.length ? Fg() : Rg = !0;
  });
}
const uf = {
  none: null,
  close: i5,
  block: r5,
  reposition: s5
}, t5 = B({
  scrollStrategy: {
    type: [String, Function],
    default: "block",
    validator: (e) => typeof e == "function" || e in uf
  }
}, "VOverlay-scroll-strategies");
function n5(e, t) {
  if (!ft)
    return;
  let n;
  Wt(async () => {
    n == null || n.stop(), t.isActive.value && e.scrollStrategy && (n = np(), await new Promise((i) => setTimeout(i)), n.active && n.run(() => {
      var i;
      typeof e.scrollStrategy == "function" ? e.scrollStrategy(t, e, n) : (i = uf[e.scrollStrategy]) == null || i.call(uf, t, e, n);
    }));
  }), jn(() => {
    n == null || n.stop();
  });
}
function i5(e) {
  function t(n) {
    e.isActive.value = !1;
  }
  yA(e.targetEl.value ?? e.contentEl.value, t);
}
function r5(e, t) {
  var a;
  const n = (a = e.root.value) == null ? void 0 : a.offsetParent, i = [.../* @__PURE__ */ new Set([...vf(e.targetEl.value, t.contained ? n : void 0), ...vf(e.contentEl.value, t.contained ? n : void 0)])].filter((o) => !o.classList.contains("v-overlay-scroll-blocked")), r = window.innerWidth - document.documentElement.offsetWidth, s = ((o) => hp(o) && o)(n || document.documentElement);
  s && e.root.value.classList.add("v-overlay--scroll-blocked"), i.forEach((o, l) => {
    o.style.setProperty("--v-body-scroll-x", _e(-o.scrollLeft)), o.style.setProperty("--v-body-scroll-y", _e(-o.scrollTop)), o !== document.documentElement && o.style.setProperty("--v-scrollbar-offset", _e(r)), o.classList.add("v-overlay-scroll-blocked");
  }), jn(() => {
    i.forEach((o, l) => {
      const u = parseFloat(o.style.getPropertyValue("--v-body-scroll-x")), c = parseFloat(o.style.getPropertyValue("--v-body-scroll-y")), d = o.style.scrollBehavior;
      o.style.scrollBehavior = "auto", o.style.removeProperty("--v-body-scroll-x"), o.style.removeProperty("--v-body-scroll-y"), o.style.removeProperty("--v-scrollbar-offset"), o.classList.remove("v-overlay-scroll-blocked"), o.scrollLeft = -u, o.scrollTop = -c, o.style.scrollBehavior = d;
    }), s && e.root.value.classList.remove("v-overlay--scroll-blocked");
  });
}
function s5(e, t, n) {
  let i = !1, r = -1, s = -1;
  function a(o) {
    e5(() => {
      var c, d;
      const l = performance.now();
      (d = (c = e.updateLocation).value) == null || d.call(c, o), i = (performance.now() - l) / (1e3 / 60) > 2;
    });
  }
  s = (typeof requestIdleCallback > "u" ? (o) => o() : requestIdleCallback)(() => {
    n.run(() => {
      yA(e.targetEl.value ?? e.contentEl.value, (o) => {
        i ? (cancelAnimationFrame(r), r = requestAnimationFrame(() => {
          r = requestAnimationFrame(() => {
            a(o);
          });
        })) : a(o);
      });
    });
  }), jn(() => {
    typeof cancelIdleCallback < "u" && cancelIdleCallback(s), cancelAnimationFrame(r);
  });
}
function yA(e, t) {
  const n = [document, ...vf(e)];
  n.forEach((i) => {
    i.addEventListener("scroll", t, {
      passive: !0
    });
  }), jn(() => {
    n.forEach((i) => {
      i.removeEventListener("scroll", t);
    });
  });
}
const Bg = Symbol.for("vuetify:v-menu"), rb = B({
  closeDelay: [Number, String],
  openDelay: [Number, String]
}, "delay");
function sb(e, t) {
  let n = () => {
  };
  function i(a) {
    n == null || n();
    const o = Number(a ? e.openDelay : e.closeDelay);
    return new Promise((l) => {
      n = hP(o, () => {
        t == null || t(a), l(a);
      });
    });
  }
  function r() {
    return i(!0);
  }
  function s() {
    return i(!1);
  }
  return {
    clearDelay: n,
    runOpenDelay: r,
    runCloseDelay: s
  };
}
const a5 = B({
  target: [String, Object],
  activator: [String, Object],
  activatorProps: {
    type: Object,
    default: () => ({})
  },
  openOnClick: {
    type: Boolean,
    default: void 0
  },
  openOnHover: Boolean,
  openOnFocus: {
    type: Boolean,
    default: void 0
  },
  closeOnContentClick: Boolean,
  ...rb()
}, "VOverlay-activator");
function o5(e, t) {
  let {
    isActive: n,
    isTop: i
  } = t;
  const r = Ut("useActivator"), s = X();
  let a = !1, o = !1, l = !0;
  const u = b(() => e.openOnFocus || e.openOnFocus == null && e.openOnHover), c = b(() => e.openOnClick || e.openOnClick == null && !e.openOnHover && !u.value), {
    runOpenDelay: d,
    runCloseDelay: f
  } = sb(e, (C) => {
    C === (e.openOnHover && a || u.value && o) && !(e.openOnHover && n.value && !i.value) && (n.value !== C && (l = !0), n.value = C);
  }), h = X(), m = {
    onClick: (C) => {
      C.stopPropagation(), s.value = C.currentTarget || C.target, n.value || (h.value = [C.clientX, C.clientY]), n.value = !n.value;
    },
    onMouseenter: (C) => {
      var x;
      (x = C.sourceCapabilities) != null && x.firesTouchEvents || (a = !0, s.value = C.currentTarget || C.target, d());
    },
    onMouseleave: (C) => {
      a = !1, f();
    },
    onFocus: (C) => {
      pl(C.target, ":focus-visible") !== !1 && (o = !0, C.stopPropagation(), s.value = C.currentTarget || C.target, d());
    },
    onBlur: (C) => {
      o = !1, C.stopPropagation(), f();
    }
  }, g = b(() => {
    const C = {};
    return c.value && (C.onClick = m.onClick), e.openOnHover && (C.onMouseenter = m.onMouseenter, C.onMouseleave = m.onMouseleave), u.value && (C.onFocus = m.onFocus, C.onBlur = m.onBlur), C;
  }), p = b(() => {
    const C = {};
    if (e.openOnHover && (C.onMouseenter = () => {
      a = !0, d();
    }, C.onMouseleave = () => {
      a = !1, f();
    }), u.value && (C.onFocusin = () => {
      o = !0, d();
    }, C.onFocusout = () => {
      o = !1, f();
    }), e.closeOnContentClick) {
      const x = tt(Bg, null);
      C.onClick = () => {
        n.value = !1, x == null || x.closeParents();
      };
    }
    return C;
  }), y = b(() => {
    const C = {};
    return e.openOnHover && (C.onMouseenter = () => {
      l && (a = !0, l = !1, d());
    }, C.onMouseleave = () => {
      a = !1, f();
    }), C;
  });
  fe(i, (C) => {
    C && (e.openOnHover && !a && (!u.value || !o) || u.value && !o && (!e.openOnHover || !a)) && (n.value = !1);
  }), fe(n, (C) => {
    C || setTimeout(() => {
      h.value = void 0;
    });
  }, {
    flush: "post"
  });
  const k = ff();
  Wt(() => {
    k.value && He(() => {
      s.value = k.el;
    });
  });
  const T = ff(), _ = b(() => e.target === "cursor" && h.value ? h.value : T.value ? T.el : bA(e.target, r) || s.value), w = b(() => Array.isArray(_.value) ? void 0 : _.value);
  let S;
  return fe(() => !!e.activator, (C) => {
    C && ft ? (S = np(), S.run(() => {
      l5(e, r, {
        activatorEl: s,
        activatorEvents: g
      });
    })) : S && S.stop();
  }, {
    flush: "post",
    immediate: !0
  }), jn(() => {
    S == null || S.stop();
  }), {
    activatorEl: s,
    activatorRef: k,
    target: _,
    targetEl: w,
    targetRef: T,
    activatorEvents: g,
    contentEvents: p,
    scrimEvents: y
  };
}
function l5(e, t, n) {
  let {
    activatorEl: i,
    activatorEvents: r
  } = n;
  fe(() => e.activator, (l, u) => {
    if (u && l !== u) {
      const c = o(u);
      c && a(c);
    }
    l && He(() => s());
  }, {
    immediate: !0
  }), fe(() => e.activatorProps, () => {
    s();
  }), jn(() => {
    a();
  });
  function s() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : o(), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
    l && gP(l, ie(r.value, u));
  }
  function a() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : o(), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
    l && pP(l, ie(r.value, u));
  }
  function o() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.activator;
    const u = bA(l, t);
    return i.value = (u == null ? void 0 : u.nodeType) === Node.ELEMENT_NODE ? u : void 0, i.value;
  }
}
function bA(e, t) {
  var i, r;
  if (!e)
    return;
  let n;
  if (e === "parent") {
    let s = (r = (i = t == null ? void 0 : t.proxy) == null ? void 0 : i.$el) == null ? void 0 : r.parentNode;
    for (; s != null && s.hasAttribute("data-no-activator"); )
      s = s.parentNode;
    n = s;
  } else
    typeof e == "string" ? n = document.querySelector(e) : "$el" in e ? n = e.$el : n = e;
  return n;
}
function wA() {
  if (!ft)
    return pe(!1);
  const {
    ssr: e
  } = Ar();
  if (e) {
    const t = pe(!1);
    return En(() => {
      t.value = !0;
    }), t;
  } else
    return pe(!0);
}
const ab = B({
  eager: Boolean
}, "lazy");
function ob(e, t) {
  const n = pe(!1), i = b(() => n.value || e.eager || t.value);
  fe(t, () => n.value = !0);
  function r() {
    e.eager || (n.value = !1);
  }
  return {
    isBooted: n,
    hasContent: i,
    onAfterLeave: r
  };
}
function Do() {
  const t = Ut("useScopeId").vnode.scopeId;
  return {
    scopeId: t ? {
      [t]: ""
    } : void 0
  };
}
const F_ = Symbol.for("vuetify:stack"), mu = ti([]);
function u5(e, t, n) {
  const i = Ut("useStack"), r = !n, s = tt(F_, void 0), a = ti({
    activeChildren: /* @__PURE__ */ new Set()
  });
  Tt(F_, a);
  const o = pe(+t.value);
  vi(e, () => {
    var d;
    const c = (d = mu.at(-1)) == null ? void 0 : d[1];
    o.value = c ? c + 10 : +t.value, r && mu.push([i.uid, o.value]), s == null || s.activeChildren.add(i.uid), jn(() => {
      if (r) {
        const f = si(mu).findIndex((h) => h[0] === i.uid);
        mu.splice(f, 1);
      }
      s == null || s.activeChildren.delete(i.uid);
    });
  });
  const l = pe(!0);
  r && Wt(() => {
    var d;
    const c = ((d = mu.at(-1)) == null ? void 0 : d[0]) === i.uid;
    setTimeout(() => l.value = c);
  });
  const u = b(() => !a.activeChildren.size);
  return {
    globalTop: Fl(l),
    localTop: u,
    stackStyles: b(() => ({
      zIndex: o.value
    }))
  };
}
function c5(e) {
  return {
    teleportTarget: b(() => {
      const n = e.value;
      if (n === !0 || !ft)
        return;
      const i = n === !1 ? document.body : typeof n == "string" ? document.querySelector(n) : n;
      if (i == null) {
        Ec(`Unable to locate target ${n}`);
        return;
      }
      let r = i.querySelector(":scope > .v-overlay-container");
      return r || (r = document.createElement("div"), r.className = "v-overlay-container", i.appendChild(r)), r;
    })
  };
}
function d5() {
  return !0;
}
function _A(e, t, n) {
  if (!e || SA(e, n) === !1)
    return !1;
  const i = xS(t);
  if (typeof ShadowRoot < "u" && i instanceof ShadowRoot && i.host === e.target)
    return !1;
  const r = (typeof n.value == "object" && n.value.include || (() => []))();
  return r.push(t), !r.some((s) => s == null ? void 0 : s.contains(e.target));
}
function SA(e, t) {
  return (typeof t.value == "object" && t.value.closeConditional || d5)(e);
}
function f5(e, t, n) {
  const i = typeof n.value == "function" ? n.value : n.value.handler;
  t._clickOutside.lastMousedownWasOutside && _A(e, t, n) && setTimeout(() => {
    SA(e, n) && i && i(e);
  }, 0);
}
function B_(e, t) {
  const n = xS(e);
  t(document), typeof ShadowRoot < "u" && n instanceof ShadowRoot && t(n);
}
const kA = {
  // [data-app] may not be found
  // if using bind, inserted makes
  // sure that the root element is
  // available, iOS does not support
  // clicks on body
  mounted(e, t) {
    const n = (r) => f5(r, e, t), i = (r) => {
      e._clickOutside.lastMousedownWasOutside = _A(r, e, t);
    };
    B_(e, (r) => {
      r.addEventListener("click", n, !0), r.addEventListener("mousedown", i, !0);
    }), e._clickOutside || (e._clickOutside = {
      lastMousedownWasOutside: !1
    }), e._clickOutside[t.instance.$.uid] = {
      onClick: n,
      onMousedown: i
    };
  },
  unmounted(e, t) {
    e._clickOutside && (B_(e, (n) => {
      var s;
      if (!n || !((s = e._clickOutside) != null && s[t.instance.$.uid]))
        return;
      const {
        onClick: i,
        onMousedown: r
      } = e._clickOutside[t.instance.$.uid];
      n.removeEventListener("click", i, !0), n.removeEventListener("mousedown", r, !0);
    }), delete e._clickOutside[t.instance.$.uid]);
  }
};
function h5(e) {
  const {
    modelValue: t,
    color: n,
    ...i
  } = e;
  return v(na, {
    name: "fade-transition",
    appear: !0
  }, {
    default: () => [e.modelValue && v("div", ie({
      class: ["v-overlay__scrim", e.color.backgroundColorClasses.value],
      style: e.color.backgroundColorStyles.value
    }, i), null)]
  });
}
const ud = B({
  absolute: Boolean,
  attach: [Boolean, String, Object],
  closeOnBack: {
    type: Boolean,
    default: !0
  },
  contained: Boolean,
  contentClass: null,
  contentProps: null,
  disabled: Boolean,
  opacity: [Number, String],
  noClickAnimation: Boolean,
  modelValue: Boolean,
  persistent: Boolean,
  scrim: {
    type: [Boolean, String],
    default: !0
  },
  zIndex: {
    type: [Number, String],
    default: 2e3
  },
  ...a5(),
  ...ke(),
  ...Sn(),
  ...ab(),
  ...Z6(),
  ...t5(),
  ...Qe(),
  ...xr()
}, "VOverlay"), Gr = J()({
  name: "VOverlay",
  directives: {
    ClickOutside: kA
  },
  inheritAttrs: !1,
  props: {
    _disableGlobalStack: Boolean,
    ...ud()
  },
  emits: {
    "click:outside": (e) => !0,
    "update:modelValue": (e) => !0,
    afterEnter: () => !0,
    afterLeave: () => !0
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: i,
      emit: r
    } = t;
    const s = Ee(e, "modelValue"), a = b({
      get: () => s.value,
      set: (ee) => {
        ee && e.disabled || (s.value = ee);
      }
    }), {
      teleportTarget: o
    } = c5(b(() => e.attach || e.contained)), {
      themeClasses: l
    } = lt(e), {
      rtlClasses: u,
      isRtl: c
    } = wn(), {
      hasContent: d,
      onAfterLeave: f
    } = ob(e, a), h = gt(b(() => typeof e.scrim == "string" ? e.scrim : null)), {
      globalTop: m,
      localTop: g,
      stackStyles: p
    } = u5(a, G(e, "zIndex"), e._disableGlobalStack), {
      activatorEl: y,
      activatorRef: k,
      target: T,
      targetEl: _,
      targetRef: w,
      activatorEvents: S,
      contentEvents: C,
      scrimEvents: x
    } = o5(e, {
      isActive: a,
      isTop: g
    }), {
      dimensionStyles: A
    } = kn(e), I = wA(), {
      scopeId: E
    } = Do();
    fe(() => e.disabled, (ee) => {
      ee && (a.value = !1);
    });
    const P = X(), V = X(), N = X(), {
      contentStyles: F,
      updateLocation: $
    } = K6(e, {
      isRtl: c,
      contentEl: N,
      target: T,
      isActive: a
    });
    n5(e, {
      root: P,
      contentEl: N,
      targetEl: _,
      isActive: a,
      updateLocation: $
    });
    function Z(ee) {
      r("click:outside", ee), e.persistent ? ne() : a.value = !1;
    }
    function j(ee) {
      return a.value && m.value && // If using scrim, only close if clicking on it rather than anything opened on top
      (!e.scrim || ee.target === V.value);
    }
    ft && fe(a, (ee) => {
      ee ? window.addEventListener("keydown", H) : window.removeEventListener("keydown", H);
    }, {
      immediate: !0
    }), ai(() => {
      ft && window.removeEventListener("keydown", H);
    });
    function H(ee) {
      var K, ue;
      ee.key === "Escape" && m.value && (e.persistent ? ne() : (a.value = !1, (K = N.value) != null && K.contains(document.activeElement) && ((ue = y.value) == null || ue.focus())));
    }
    const R = $x();
    vi(() => e.closeOnBack, () => {
      Jq(R, (ee) => {
        m.value && a.value ? (ee(!1), e.persistent ? ne() : a.value = !1) : ee();
      });
    });
    const L = X();
    fe(() => a.value && (e.absolute || e.contained) && o.value == null, (ee) => {
      if (ee) {
        const K = fp(P.value);
        K && K !== document.scrollingElement && (L.value = K.scrollTop);
      }
    });
    function ne() {
      e.noClickAnimation || N.value && Na(N.value, [{
        transformOrigin: "center"
      }, {
        transform: "scale(1.03)"
      }, {
        transformOrigin: "center"
      }], {
        duration: 150,
        easing: qu
      });
    }
    function oe() {
      r("afterEnter");
    }
    function we() {
      f(), r("afterLeave");
    }
    return re(() => {
      var ee;
      return v(De, null, [(ee = n.activator) == null ? void 0 : ee.call(n, {
        isActive: a.value,
        targetRef: w,
        props: ie({
          ref: k
        }, S.value, e.activatorProps)
      }), I.value && d.value && v(eP, {
        disabled: !o.value,
        to: o.value
      }, {
        default: () => [v("div", ie({
          class: ["v-overlay", {
            "v-overlay--absolute": e.absolute || e.contained,
            "v-overlay--active": a.value,
            "v-overlay--contained": e.contained
          }, l.value, u.value, e.class],
          style: [p.value, {
            "--v-overlay-opacity": e.opacity,
            top: _e(L.value)
          }, e.style],
          ref: P
        }, E, i), [v(h5, ie({
          color: h,
          modelValue: a.value && !!e.scrim,
          ref: V
        }, x.value), null), v(Gn, {
          appear: !0,
          persisted: !0,
          transition: e.transition,
          target: T.value,
          onAfterEnter: oe,
          onAfterLeave: we
        }, {
          default: () => {
            var K;
            return [Rt(v("div", ie({
              ref: N,
              class: ["v-overlay__content", e.contentClass],
              style: [A.value, F.value]
            }, C.value, e.contentProps), [(K = n.default) == null ? void 0 : K.call(n, {
              isActive: a
            })]), [[Tr, a.value], [Ei("click-outside"), {
              handler: Z,
              closeConditional: j,
              include: () => [y.value]
            }]])];
          }
        })])]
      })]);
    }), {
      activatorEl: y,
      scrimEl: V,
      target: T,
      animateClick: ne,
      contentEl: N,
      globalTop: m,
      localTop: g,
      updateLocation: $
    };
  }
}), CA = B({
  // TODO
  // disableKeys: Boolean,
  id: String,
  ...an(ud({
    closeDelay: 250,
    closeOnContentClick: !0,
    locationStrategy: "connected",
    openDelay: 300,
    scrim: !1,
    scrollStrategy: "reposition",
    transition: {
      component: mh
    }
  }), ["absolute"])
}, "VMenu"), Ml = J()({
  name: "VMenu",
  props: CA(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), {
      scopeId: r
    } = Do(), s = Pn(), a = b(() => e.id || `v-menu-${s}`), o = X(), l = tt(Bg, null), u = pe(0);
    Tt(Bg, {
      register() {
        ++u.value;
      },
      unregister() {
        --u.value;
      },
      closeParents(g) {
        setTimeout(() => {
          !u.value && !e.persistent && (g == null || g && !mP(g, o.value.contentEl)) && (i.value = !1, l == null || l.closeParents());
        }, 40);
      }
    });
    async function c(g) {
      var k, T, _;
      const p = g.relatedTarget, y = g.target;
      await He(), i.value && p !== y && ((k = o.value) != null && k.contentEl) && // We're the topmost menu
      ((T = o.value) != null && T.globalTop) && // It isn't the document or the menu body
      ![document, o.value.contentEl].includes(y) && // It isn't inside the menu body
      !o.value.contentEl.contains(y) && ((_ = Uu(o.value.contentEl)[0]) == null || _.focus());
    }
    fe(i, (g) => {
      g ? (l == null || l.register(), document.addEventListener("focusin", c, {
        once: !0
      })) : (l == null || l.unregister(), document.removeEventListener("focusin", c));
    });
    function d(g) {
      l == null || l.closeParents(g);
    }
    function f(g) {
      var p, y, k;
      if (!e.disabled)
        if (g.key === "Tab" || g.key === "Enter" && !e.closeOnContentClick) {
          if (g.key === "Enter" && g.target instanceof HTMLTextAreaElement)
            return;
          g.key === "Enter" && g.preventDefault(), cS(Uu((p = o.value) == null ? void 0 : p.contentEl, !1), g.shiftKey ? "prev" : "next", (_) => _.tabIndex >= 0) || (i.value = !1, (k = (y = o.value) == null ? void 0 : y.activatorEl) == null || k.focus());
        } else
          ["Enter", " "].includes(g.key) && e.closeOnContentClick && (i.value = !1, l == null || l.closeParents());
    }
    function h(g) {
      var y;
      if (e.disabled)
        return;
      const p = (y = o.value) == null ? void 0 : y.contentEl;
      p && i.value ? g.key === "ArrowDown" ? (g.preventDefault(), gl(p, "next")) : g.key === "ArrowUp" && (g.preventDefault(), gl(p, "prev")) : ["ArrowDown", "ArrowUp"].includes(g.key) && (i.value = !0, g.preventDefault(), setTimeout(() => setTimeout(() => h(g))));
    }
    const m = b(() => ie({
      "aria-haspopup": "menu",
      "aria-expanded": String(i.value),
      "aria-owns": a.value,
      onKeydown: h
    }, e.activatorProps));
    return re(() => {
      const g = Gr.filterProps(e);
      return v(Gr, ie({
        ref: o,
        id: a.value,
        class: ["v-menu", e.class],
        style: e.style
      }, g, {
        modelValue: i.value,
        "onUpdate:modelValue": (p) => i.value = p,
        absolute: !0,
        activatorProps: m.value,
        "onClick:outside": d,
        onKeydown: f
      }, r), {
        activator: n.activator,
        default: function() {
          for (var p = arguments.length, y = new Array(p), k = 0; k < p; k++)
            y[k] = arguments[k];
          return v(Ze, {
            root: "VMenu"
          }, {
            default: () => {
              var T;
              return [(T = n.default) == null ? void 0 : T.call(n, ...y)];
            }
          });
        }
      });
    }), Qi({
      id: a,
      openChildren: u
    }, o);
  }
});
const m5 = B({
  renderless: Boolean,
  ...ke()
}, "VVirtualScrollItem"), TA = J()({
  name: "VVirtualScrollItem",
  inheritAttrs: !1,
  props: m5(),
  emits: {
    "update:height": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const {
      resizeRef: s,
      contentRect: a
    } = Sr(void 0, "border");
    fe(() => {
      var o;
      return (o = a.value) == null ? void 0 : o.height;
    }, (o) => {
      o != null && i("update:height", o);
    }), re(() => {
      var o, l;
      return e.renderless ? v(De, null, [(o = r.default) == null ? void 0 : o.call(r, {
        itemRef: s
      })]) : v("div", ie({
        ref: s,
        class: ["v-virtual-scroll__item", e.class],
        style: e.style
      }, n), [(l = r.default) == null ? void 0 : l.call(r)]);
    });
  }
}), v5 = -1, g5 = 1, xv = 100, xA = B({
  itemHeight: {
    type: [Number, String],
    default: null
  },
  height: [Number, String]
}, "virtual");
function AA(e, t) {
  const n = Ar(), i = pe(0);
  Wt(() => {
    i.value = parseFloat(e.itemHeight || 0);
  });
  const r = pe(0), s = pe(Math.ceil(
    // Assume 16px items filling the entire screen height if
    // not provided. This is probably incorrect but it minimises
    // the chance of ending up with empty space at the bottom.
    // The default value is set here to avoid poisoning getSize()
    (parseInt(e.height) || n.height.value) / (i.value || 16)
  ) || 1), a = pe(0), o = pe(0), l = X(), u = X();
  let c = 0;
  const {
    resizeRef: d,
    contentRect: f
  } = Sr();
  Wt(() => {
    d.value = l.value;
  });
  const h = b(() => {
    var H;
    return l.value === document.documentElement ? n.height.value : ((H = f.value) == null ? void 0 : H.height) || parseInt(e.height) || 0;
  }), m = b(() => !!(l.value && u.value && h.value && i.value));
  let g = Array.from({
    length: t.value.length
  }), p = Array.from({
    length: t.value.length
  });
  const y = pe(0);
  let k = -1;
  function T(H) {
    return g[H] || i.value;
  }
  const _ = uP(() => {
    const H = performance.now();
    p[0] = 0;
    const R = t.value.length;
    for (let L = 1; L <= R - 1; L++)
      p[L] = (p[L - 1] || 0) + T(L - 1);
    y.value = Math.max(y.value, performance.now() - H);
  }, y), w = fe(m, (H) => {
    H && (w(), c = u.value.offsetTop, _.immediate(), F(), ~k && He(() => {
      ft && window.requestAnimationFrame(() => {
        Z(k), k = -1;
      });
    }));
  });
  jn(() => {
    _.clear();
  });
  function S(H, R) {
    const L = g[H], ne = i.value;
    i.value = ne ? Math.min(i.value, R) : R, (L !== R || ne !== i.value) && (g[H] = R, _());
  }
  function C(H) {
    return H = Xt(H, 0, t.value.length - 1), p[H] || 0;
  }
  function x(H) {
    return p5(p, H);
  }
  let A = 0, I = 0, E = 0;
  fe(h, (H, R) => {
    R && (F(), H < R && requestAnimationFrame(() => {
      I = 0, F();
    }));
  });
  function P() {
    if (!l.value || !u.value)
      return;
    const H = l.value.scrollTop, R = performance.now();
    R - E > 500 ? (I = Math.sign(H - A), c = u.value.offsetTop) : I = H - A, A = H, E = R, F();
  }
  function V() {
    !l.value || !u.value || (I = 0, E = 0, F());
  }
  let N = -1;
  function F() {
    cancelAnimationFrame(N), N = requestAnimationFrame($);
  }
  function $() {
    if (!l.value || !h.value)
      return;
    const H = A - c, R = Math.sign(I), L = Math.max(0, H - xv), ne = Xt(x(L), 0, t.value.length), oe = H + h.value + xv, we = Xt(x(oe) + 1, ne + 1, t.value.length);
    if (
      // Only update the side we're scrolling towards,
      // the other side will be updated incidentally
      (R !== v5 || ne < r.value) && (R !== g5 || we > s.value)
    ) {
      const ee = C(r.value) - C(ne), K = C(we) - C(s.value);
      Math.max(ee, K) > xv ? (r.value = ne, s.value = we) : (ne <= 0 && (r.value = ne), we >= t.value.length && (s.value = we));
    }
    a.value = C(r.value), o.value = C(t.value.length) - C(s.value);
  }
  function Z(H) {
    const R = C(H);
    !l.value || H && !R ? k = H : l.value.scrollTop = R;
  }
  const j = b(() => t.value.slice(r.value, s.value).map((H, R) => ({
    raw: H,
    index: R + r.value
  })));
  return fe(t, () => {
    g = Array.from({
      length: t.value.length
    }), p = Array.from({
      length: t.value.length
    }), _.immediate(), F();
  }, {
    deep: !0
  }), {
    containerRef: l,
    markerRef: u,
    computedItems: j,
    paddingTop: a,
    paddingBottom: o,
    scrollToIndex: Z,
    handleScroll: P,
    handleScrollend: V,
    handleItemResize: S
  };
}
function p5(e, t) {
  let n = e.length - 1, i = 0, r = 0, s = null, a = -1;
  if (e[n] < t)
    return n;
  for (; i <= n; )
    if (r = i + n >> 1, s = e[r], s > t)
      n = r - 1;
    else if (s < t)
      a = r, i = r + 1;
    else
      return s === t ? r : i;
  return a;
}
const y5 = B({
  items: {
    type: Array,
    default: () => []
  },
  renderless: Boolean,
  ...xA(),
  ...ke(),
  ...Sn()
}, "VVirtualScroll"), dm = J()({
  name: "VVirtualScroll",
  props: y5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ut("VVirtualScroll"), {
      dimensionStyles: r
    } = kn(e), {
      containerRef: s,
      markerRef: a,
      handleScroll: o,
      handleScrollend: l,
      handleItemResize: u,
      scrollToIndex: c,
      paddingTop: d,
      paddingBottom: f,
      computedItems: h
    } = AA(e, G(e, "items"));
    return vi(() => e.renderless, () => {
      function m() {
        var y, k;
        const p = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) ? "addEventListener" : "removeEventListener";
        s.value === document.documentElement ? (document[p]("scroll", o, {
          passive: !0
        }), document[p]("scrollend", l)) : ((y = s.value) == null || y[p]("scroll", o, {
          passive: !0
        }), (k = s.value) == null || k[p]("scrollend", l));
      }
      En(() => {
        s.value = fp(i.vnode.el, !0), m(!0);
      }), jn(m);
    }), re(() => {
      const m = h.value.map((g) => v(TA, {
        key: g.index,
        renderless: e.renderless,
        "onUpdate:height": (p) => u(g.index, p)
      }, {
        default: (p) => {
          var y;
          return (y = n.default) == null ? void 0 : y.call(n, {
            item: g.raw,
            index: g.index,
            ...p
          });
        }
      }));
      return e.renderless ? v(De, null, [v("div", {
        ref: a,
        class: "v-virtual-scroll__spacer",
        style: {
          paddingTop: _e(d.value)
        }
      }, null), m, v("div", {
        class: "v-virtual-scroll__spacer",
        style: {
          paddingBottom: _e(f.value)
        }
      }, null)]) : v("div", {
        ref: s,
        class: ["v-virtual-scroll", e.class],
        onScrollPassive: o,
        onScrollend: l,
        style: [r.value, e.style]
      }, [v("div", {
        ref: a,
        class: "v-virtual-scroll__container",
        style: {
          paddingTop: _e(d.value),
          paddingBottom: _e(f.value)
        }
      }, [m])]);
    }), {
      scrollToIndex: c
    };
  }
});
function lb(e, t) {
  const n = pe(!1);
  let i;
  function r(o) {
    cancelAnimationFrame(i), n.value = !0, i = requestAnimationFrame(() => {
      i = requestAnimationFrame(() => {
        n.value = !1;
      });
    });
  }
  async function s() {
    await new Promise((o) => requestAnimationFrame(o)), await new Promise((o) => requestAnimationFrame(o)), await new Promise((o) => requestAnimationFrame(o)), await new Promise((o) => {
      if (n.value) {
        const l = fe(n, () => {
          l(), o();
        });
      } else
        o();
    });
  }
  async function a(o) {
    var c, d;
    if (o.key === "Tab" && ((c = t.value) == null || c.focus()), !["PageDown", "PageUp", "Home", "End"].includes(o.key))
      return;
    const l = (d = e.value) == null ? void 0 : d.$el;
    if (!l)
      return;
    (o.key === "Home" || o.key === "End") && l.scrollTo({
      top: o.key === "Home" ? 0 : l.scrollHeight,
      behavior: "smooth"
    }), await s();
    const u = l.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
    if (o.key === "PageDown" || o.key === "Home") {
      const f = l.getBoundingClientRect().top;
      for (const h of u)
        if (h.getBoundingClientRect().top >= f) {
          h.focus();
          break;
        }
    } else {
      const f = l.getBoundingClientRect().bottom;
      for (const h of [...u].reverse())
        if (h.getBoundingClientRect().bottom <= f) {
          h.focus();
          break;
        }
    }
  }
  return {
    onListScroll: r,
    onListKeydown: a
  };
}
const ub = B({
  chips: Boolean,
  closableChips: Boolean,
  closeText: {
    type: String,
    default: "$vuetify.close"
  },
  openText: {
    type: String,
    default: "$vuetify.open"
  },
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  listProps: {
    type: Object
  },
  menu: Boolean,
  menuIcon: {
    type: We,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  itemColor: String,
  ...mA({
    itemChildren: !1
  })
}, "Select"), b5 = B({
  ...ub(),
  ...an(Sh({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...xr({
    transition: {
      component: mh
    }
  })
}, "VSelect"), cb = J()({
  name: "VSelect",
  props: b5(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: i
    } = qt(), r = X(), s = X(), a = X(), o = Ee(e, "menu"), l = b({
      get: () => o.value,
      set: (j) => {
        var H;
        o.value && !j && ((H = s.value) != null && H.openChildren) || (o.value = j);
      }
    }), {
      items: u,
      transformIn: c,
      transformOut: d
    } = ib(e), f = Ee(e, "modelValue", [], (j) => c(j === null ? [null] : Nt(j)), (j) => {
      const H = d(j);
      return e.multiple ? H : H[0] ?? null;
    }), h = b(() => typeof e.counterValue == "function" ? e.counterValue(f.value) : typeof e.counterValue == "number" ? e.counterValue : f.value.length), m = _h(), g = b(() => f.value.map((j) => j.value)), p = pe(!1), y = b(() => l.value ? e.closeText : e.openText);
    let k = "", T;
    const _ = b(() => e.hideSelected ? u.value.filter((j) => !f.value.some((H) => e.valueComparator(H, j))) : u.value), w = b(() => e.hideNoData && !_.value.length || e.readonly || (m == null ? void 0 : m.isReadonly.value)), S = b(() => {
      var j;
      return {
        ...e.menuProps,
        activatorProps: {
          ...((j = e.menuProps) == null ? void 0 : j.activatorProps) || {},
          "aria-haspopup": "listbox"
          // Set aria-haspopup to 'listbox'
        }
      };
    }), C = X(), {
      onListScroll: x,
      onListKeydown: A
    } = lb(C, r);
    function I(j) {
      e.openOnClear && (l.value = !0);
    }
    function E() {
      w.value || (l.value = !l.value);
    }
    function P(j) {
      var oe, we;
      if (!j.key || e.readonly || m != null && m.isReadonly.value)
        return;
      ["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(j.key) && j.preventDefault(), ["Enter", "ArrowDown", " "].includes(j.key) && (l.value = !0), ["Escape", "Tab"].includes(j.key) && (l.value = !1), j.key === "Home" ? (oe = C.value) == null || oe.focus("first") : j.key === "End" && ((we = C.value) == null || we.focus("last"));
      const H = 1e3;
      function R(ee) {
        const K = ee.key.length === 1, ue = !ee.ctrlKey && !ee.metaKey && !ee.altKey;
        return K && ue;
      }
      if (e.multiple || !R(j))
        return;
      const L = performance.now();
      L - T > H && (k = ""), k += j.key.toLowerCase(), T = L;
      const ne = u.value.find((ee) => ee.title.toLowerCase().startsWith(k));
      if (ne !== void 0) {
        f.value = [ne];
        const ee = _.value.indexOf(ne);
        ft && window.requestAnimationFrame(() => {
          var K;
          ee >= 0 && ((K = a.value) == null || K.scrollToIndex(ee));
        });
      }
    }
    function V(j) {
      let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!j.props.disabled)
        if (e.multiple) {
          const R = f.value.findIndex((ne) => e.valueComparator(ne.value, j.value)), L = H ?? !~R;
          if (~R) {
            const ne = L ? [...f.value, j] : [...f.value];
            ne.splice(R, 1), f.value = ne;
          } else
            L && (f.value = [...f.value, j]);
        } else {
          const R = H !== !1;
          f.value = R ? [j] : [], He(() => {
            l.value = !1;
          });
        }
    }
    function N(j) {
      var H;
      (H = C.value) != null && H.$el.contains(j.relatedTarget) || (l.value = !1);
    }
    function F() {
      var j;
      p.value && ((j = r.value) == null || j.focus());
    }
    function $(j) {
      p.value = !0;
    }
    function Z(j) {
      if (j == null)
        f.value = [];
      else if (pl(r.value, ":autofill") || pl(r.value, ":-webkit-autofill")) {
        const H = u.value.find((R) => R.title === j);
        H && V(H);
      } else
        r.value && (r.value.value = "");
    }
    return fe(l, () => {
      if (!e.hideSelected && l.value && f.value.length) {
        const j = _.value.findIndex((H) => f.value.some((R) => e.valueComparator(R.value, H.value)));
        ft && window.requestAnimationFrame(() => {
          var H;
          j >= 0 && ((H = a.value) == null || H.scrollToIndex(j));
        });
      }
    }), fe(() => e.items, (j, H) => {
      l.value || p.value && !H.length && j.length && (l.value = !0);
    }), re(() => {
      const j = !!(e.chips || n.chip), H = !!(!e.hideNoData || _.value.length || n["prepend-item"] || n["append-item"] || n["no-data"]), R = f.value.length > 0, L = gi.filterProps(e), ne = R || !p.value && e.label && !e.persistentPlaceholder ? void 0 : e.placeholder;
      return v(gi, ie({
        ref: r
      }, L, {
        modelValue: f.value.map((oe) => oe.props.value).join(", "),
        "onUpdate:modelValue": Z,
        focused: p.value,
        "onUpdate:focused": (oe) => p.value = oe,
        validationValue: f.externalValue,
        counterValue: h.value,
        dirty: R,
        class: ["v-select", {
          "v-select--active-menu": l.value,
          "v-select--chips": !!e.chips,
          [`v-select--${e.multiple ? "multiple" : "single"}`]: !0,
          "v-select--selected": f.value.length,
          "v-select--selection-slot": !!n.selection
        }, e.class],
        style: e.style,
        inputmode: "none",
        placeholder: ne,
        "onClick:clear": I,
        "onMousedown:control": E,
        onBlur: N,
        onKeydown: P,
        "aria-label": i(y.value),
        title: i(y.value)
      }), {
        ...n,
        default: () => v(De, null, [v(Ml, ie({
          ref: s,
          modelValue: l.value,
          "onUpdate:modelValue": (oe) => l.value = oe,
          activator: "parent",
          contentClass: "v-select__content",
          disabled: w.value,
          eager: e.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: e.transition,
          onAfterLeave: F
        }, S.value), {
          default: () => [H && v(cm, ie({
            ref: C,
            selected: g.value,
            selectStrategy: e.multiple ? "independent" : "single-independent",
            onMousedown: (oe) => oe.preventDefault(),
            onKeydown: A,
            onFocusin: $,
            onScrollPassive: x,
            tabindex: "-1",
            "aria-live": "polite",
            color: e.itemColor ?? e.color
          }, e.listProps), {
            default: () => {
              var oe, we, ee;
              return [(oe = n["prepend-item"]) == null ? void 0 : oe.call(n), !_.value.length && !e.hideNoData && (((we = n["no-data"]) == null ? void 0 : we.call(n)) ?? v(Ts, {
                title: i(e.noDataText)
              }, null)), v(dm, {
                ref: a,
                renderless: !0,
                items: _.value
              }, {
                default: (K) => {
                  var Oe;
                  let {
                    item: ue,
                    index: ve,
                    itemRef: Fe
                  } = K;
                  const he = ie(ue.props, {
                    ref: Fe,
                    key: ve,
                    onClick: () => V(ue, null)
                  });
                  return ((Oe = n.item) == null ? void 0 : Oe.call(n, {
                    item: ue,
                    index: ve,
                    props: he
                  })) ?? v(Ts, ie(he, {
                    role: "option"
                  }), {
                    prepend: (le) => {
                      let {
                        isSelected: be
                      } = le;
                      return v(De, null, [e.multiple && !e.hideSelected ? v(Cs, {
                        key: ue.value,
                        modelValue: be,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, ue.props.prependAvatar && v(Ji, {
                        image: ue.props.prependAvatar
                      }, null), ue.props.prependIcon && v(at, {
                        icon: ue.props.prependIcon
                      }, null)]);
                    }
                  });
                }
              }), (ee = n["append-item"]) == null ? void 0 : ee.call(n)];
            }
          })]
        }), f.value.map((oe, we) => {
          function ee(Fe) {
            Fe.stopPropagation(), Fe.preventDefault(), V(oe, !1);
          }
          const K = {
            "onClick:close": ee,
            onKeydown(Fe) {
              Fe.key !== "Enter" && Fe.key !== " " || (Fe.preventDefault(), Fe.stopPropagation(), ee(Fe));
            },
            onMousedown(Fe) {
              Fe.preventDefault(), Fe.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, ue = j ? !!n.chip : !!n.selection, ve = ue ? fh(j ? n.chip({
            item: oe,
            index: we,
            props: K
          }) : n.selection({
            item: oe,
            index: we
          })) : void 0;
          if (!(ue && !ve))
            return v("div", {
              key: oe.value,
              class: "v-select__selection"
            }, [j ? n.chip ? v(Ze, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: e.closableChips,
                  size: "small",
                  text: oe.title
                }
              }
            }, {
              default: () => [ve]
            }) : v(ou, ie({
              key: "chip",
              closable: e.closableChips,
              size: "small",
              text: oe.title,
              disabled: oe.props.disabled
            }, K), null) : ve ?? v("span", {
              class: "v-select__selection-text"
            }, [oe.title, e.multiple && we < f.value.length - 1 && v("span", {
              class: "v-select__selection-comma"
            }, [_r(",")])])]);
        })]),
        "append-inner": function() {
          var K;
          for (var oe = arguments.length, we = new Array(oe), ee = 0; ee < oe; ee++)
            we[ee] = arguments[ee];
          return v(De, null, [(K = n["append-inner"]) == null ? void 0 : K.call(n, ...we), e.menuIcon ? v(at, {
            class: "v-select__menu-icon",
            icon: e.menuIcon
          }, null) : void 0]);
        }
      });
    }), Qi({
      isFocused: p,
      menu: l,
      select: V
    }, r);
  }
}), w5 = (e, t, n) => e == null || t == null ? -1 : e.toString().toLocaleLowerCase().indexOf(t.toString().toLocaleLowerCase()), cd = B({
  customFilter: Function,
  customKeyFilter: Object,
  filterKeys: [Array, String],
  filterMode: {
    type: String,
    default: "intersection"
  },
  noFilter: Boolean
}, "filter");
function _5(e, t, n) {
  var o;
  const i = [], r = (n == null ? void 0 : n.default) ?? w5, s = n != null && n.filterKeys ? Nt(n.filterKeys) : !1, a = Object.keys((n == null ? void 0 : n.customKeyFilter) ?? {}).length;
  if (!(e != null && e.length))
    return i;
  e:
    for (let l = 0; l < e.length; l++) {
      const [u, c = u] = Nt(e[l]), d = {}, f = {};
      let h = -1;
      if (t && !(n != null && n.noFilter)) {
        if (typeof u == "object") {
          const p = s || Object.keys(c);
          for (const y of p) {
            const k = hn(c, y), T = (o = n == null ? void 0 : n.customKeyFilter) == null ? void 0 : o[y];
            if (h = T ? T(k, t, u) : r(k, t, u), h !== -1 && h !== !1)
              T ? d[y] = h : f[y] = h;
            else if ((n == null ? void 0 : n.filterMode) === "every")
              continue e;
          }
        } else
          h = r(u, t, u), h !== -1 && h !== !1 && (f.title = h);
        const m = Object.keys(f).length, g = Object.keys(d).length;
        if (!m && !g || (n == null ? void 0 : n.filterMode) === "union" && g !== a && !m || (n == null ? void 0 : n.filterMode) === "intersection" && (g !== a || !m))
          continue;
      }
      i.push({
        index: l,
        matches: {
          ...f,
          ...d
        }
      });
    }
  return i;
}
function dd(e, t, n, i) {
  const r = X([]), s = X(/* @__PURE__ */ new Map()), a = b(() => i != null && i.transform ? Ct(t).map((l) => [l, i.transform(l)]) : Ct(t));
  Wt(() => {
    const l = typeof n == "function" ? n() : Ct(n), u = typeof l != "string" && typeof l != "number" ? "" : String(l), c = _5(a.value, u, {
      customKeyFilter: {
        ...e.customKeyFilter,
        ...Ct(i == null ? void 0 : i.customKeyFilter)
      },
      default: e.customFilter,
      filterKeys: e.filterKeys,
      filterMode: e.filterMode,
      noFilter: e.noFilter
    }), d = Ct(t), f = [], h = /* @__PURE__ */ new Map();
    c.forEach((m) => {
      let {
        index: g,
        matches: p
      } = m;
      const y = d[g];
      f.push(y), h.set(y.value, p);
    }), r.value = f, s.value = h;
  });
  function o(l) {
    return s.value.get(l.value);
  }
  return {
    filteredItems: r,
    filteredMatches: s,
    getMatches: o
  };
}
function S5(e, t, n) {
  if (t == null)
    return e;
  if (Array.isArray(t))
    throw new Error("Multiple matches is not implemented");
  return typeof t == "number" && ~t ? v(De, null, [v("span", {
    class: "v-autocomplete__unmask"
  }, [e.substr(0, t)]), v("span", {
    class: "v-autocomplete__mask"
  }, [e.substr(t, n)]), v("span", {
    class: "v-autocomplete__unmask"
  }, [e.substr(t + n)])]) : e;
}
const k5 = B({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: Boolean,
  search: String,
  ...cd({
    filterKeys: ["title"]
  }),
  ...ub(),
  ...an(Sh({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...xr({
    transition: !1
  })
}, "VAutocomplete"), C5 = J()({
  name: "VAutocomplete",
  props: k5(),
  emits: {
    "update:focused": (e) => !0,
    "update:search": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: i
    } = qt(), r = X(), s = pe(!1), a = pe(!0), o = pe(!1), l = X(), u = X(), c = Ee(e, "menu"), d = b({
      get: () => c.value,
      set: (he) => {
        var Oe;
        c.value && !he && ((Oe = l.value) != null && Oe.openChildren) || (c.value = he);
      }
    }), f = pe(-1), h = b(() => {
      var he;
      return (he = r.value) == null ? void 0 : he.color;
    }), m = b(() => d.value ? e.closeText : e.openText), {
      items: g,
      transformIn: p,
      transformOut: y
    } = ib(e), {
      textColorClasses: k,
      textColorStyles: T
    } = $n(h), _ = Ee(e, "search", ""), w = Ee(e, "modelValue", [], (he) => p(he === null ? [null] : Nt(he)), (he) => {
      const Oe = y(he);
      return e.multiple ? Oe : Oe[0] ?? null;
    }), S = b(() => typeof e.counterValue == "function" ? e.counterValue(w.value) : typeof e.counterValue == "number" ? e.counterValue : w.value.length), C = _h(), {
      filteredItems: x,
      getMatches: A
    } = dd(e, g, () => a.value ? "" : _.value), I = b(() => e.hideSelected ? x.value.filter((he) => !w.value.some((Oe) => Oe.value === he.value)) : x.value), E = b(() => !!(e.chips || n.chip)), P = b(() => E.value || !!n.selection), V = b(() => w.value.map((he) => he.props.value)), N = b(() => {
      var Oe;
      return (e.autoSelectFirst === !0 || e.autoSelectFirst === "exact" && _.value === ((Oe = I.value[0]) == null ? void 0 : Oe.title)) && I.value.length > 0 && !a.value && !o.value;
    }), F = b(() => e.hideNoData && !I.value.length || e.readonly || (C == null ? void 0 : C.isReadonly.value)), $ = X(), {
      onListScroll: Z,
      onListKeydown: j
    } = lb($, r);
    function H(he) {
      e.openOnClear && (d.value = !0), _.value = "";
    }
    function R() {
      F.value || (d.value = !0);
    }
    function L(he) {
      F.value || (s.value && (he.preventDefault(), he.stopPropagation()), d.value = !d.value);
    }
    function ne(he) {
      var be, Pe, te;
      if (e.readonly || C != null && C.isReadonly.value)
        return;
      const Oe = r.value.selectionStart, le = w.value.length;
      if ((f.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(he.key)) && he.preventDefault(), ["Enter", "ArrowDown"].includes(he.key) && (d.value = !0), ["Escape"].includes(he.key) && (d.value = !1), N.value && he.key === "Enter" && Fe(I.value[0]), he.key === "ArrowDown" && N.value && ((be = $.value) == null || be.focus("next")), ["Backspace", "Delete"].includes(he.key)) {
        if (!e.multiple && P.value && w.value.length > 0 && !_.value)
          return Fe(w.value[0], !1);
        if (~f.value) {
          const me = f.value;
          Fe(w.value[f.value], !1), f.value = me >= le - 1 ? le - 2 : me;
        } else
          he.key === "Backspace" && !_.value && (f.value = le - 1);
      }
      if (e.multiple) {
        if (he.key === "ArrowLeft") {
          if (f.value < 0 && Oe > 0)
            return;
          const me = f.value > -1 ? f.value - 1 : le - 1;
          w.value[me] ? f.value = me : (f.value = -1, r.value.setSelectionRange((Pe = _.value) == null ? void 0 : Pe.length, (te = _.value) == null ? void 0 : te.length));
        }
        if (he.key === "ArrowRight") {
          if (f.value < 0)
            return;
          const me = f.value + 1;
          w.value[me] ? f.value = me : (f.value = -1, r.value.setSelectionRange(0, 0));
        }
      }
    }
    function oe(he) {
      if (pl(r.value, ":autofill") || pl(r.value, ":-webkit-autofill")) {
        const Oe = g.value.find((le) => le.title === he.target.value);
        Oe && Fe(Oe);
      }
    }
    function we() {
      var he;
      s.value && (a.value = !0, (he = r.value) == null || he.focus());
    }
    function ee(he) {
      s.value = !0, setTimeout(() => {
        o.value = !0;
      });
    }
    function K(he) {
      o.value = !1;
    }
    function ue(he) {
      (he == null || he === "" && !e.multiple && !P.value) && (w.value = []);
    }
    const ve = pe(!1);
    function Fe(he) {
      let Oe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!(!he || he.props.disabled))
        if (e.multiple) {
          const le = w.value.findIndex((Pe) => e.valueComparator(Pe.value, he.value)), be = Oe ?? !~le;
          if (~le) {
            const Pe = be ? [...w.value, he] : [...w.value];
            Pe.splice(le, 1), w.value = Pe;
          } else
            be && (w.value = [...w.value, he]);
          e.clearOnSelect && (_.value = "");
        } else {
          const le = Oe !== !1;
          w.value = le ? [he] : [], _.value = le && !P.value ? he.title : "", He(() => {
            d.value = !1, a.value = !0;
          });
        }
    }
    return fe(s, (he, Oe) => {
      var le;
      he !== Oe && (he ? (ve.value = !0, _.value = e.multiple || P.value ? "" : String(((le = w.value.at(-1)) == null ? void 0 : le.props.title) ?? ""), a.value = !0, He(() => ve.value = !1)) : (!e.multiple && _.value == null ? w.value = [] : N.value && !o.value && !w.value.some((be) => {
        let {
          value: Pe
        } = be;
        return Pe === I.value[0].value;
      }) && Fe(I.value[0]), d.value = !1, (e.multiple || P.value) && (_.value = ""), f.value = -1));
    }), fe(_, (he) => {
      !s.value || ve.value || (he && (d.value = !0), a.value = !he);
    }), fe(d, () => {
      if (!e.hideSelected && d.value && w.value.length) {
        const he = I.value.findIndex((Oe) => w.value.some((le) => Oe.value === le.value));
        ft && window.requestAnimationFrame(() => {
          var Oe;
          he >= 0 && ((Oe = u.value) == null || Oe.scrollToIndex(he));
        });
      }
    }), fe(() => e.items, (he, Oe) => {
      d.value || s.value && !Oe.length && he.length && (d.value = !0);
    }), re(() => {
      const he = !!(!e.hideNoData || I.value.length || n["prepend-item"] || n["append-item"] || n["no-data"]), Oe = w.value.length > 0, le = gi.filterProps(e);
      return v(gi, ie({
        ref: r
      }, le, {
        modelValue: _.value,
        "onUpdate:modelValue": [(be) => _.value = be, ue],
        focused: s.value,
        "onUpdate:focused": (be) => s.value = be,
        validationValue: w.externalValue,
        counterValue: S.value,
        dirty: Oe,
        onChange: oe,
        class: ["v-autocomplete", `v-autocomplete--${e.multiple ? "multiple" : "single"}`, {
          "v-autocomplete--active-menu": d.value,
          "v-autocomplete--chips": !!e.chips,
          "v-autocomplete--selection-slot": !!P.value,
          "v-autocomplete--selecting-index": f.value > -1
        }, e.class],
        style: e.style,
        readonly: e.readonly,
        placeholder: Oe ? void 0 : e.placeholder,
        "onClick:clear": H,
        "onMousedown:control": R,
        onKeydown: ne
      }), {
        ...n,
        default: () => v(De, null, [v(Ml, ie({
          ref: l,
          modelValue: d.value,
          "onUpdate:modelValue": (be) => d.value = be,
          activator: "parent",
          contentClass: "v-autocomplete__content",
          disabled: F.value,
          eager: e.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: e.transition,
          onAfterLeave: we
        }, e.menuProps), {
          default: () => [he && v(cm, ie({
            ref: $,
            selected: V.value,
            selectStrategy: e.multiple ? "independent" : "single-independent",
            onMousedown: (be) => be.preventDefault(),
            onKeydown: j,
            onFocusin: ee,
            onFocusout: K,
            onScrollPassive: Z,
            tabindex: "-1",
            "aria-live": "polite",
            color: e.itemColor ?? e.color
          }, e.listProps), {
            default: () => {
              var be, Pe, te;
              return [(be = n["prepend-item"]) == null ? void 0 : be.call(n), !I.value.length && !e.hideNoData && (((Pe = n["no-data"]) == null ? void 0 : Pe.call(n)) ?? v(Ts, {
                title: i(e.noDataText)
              }, null)), v(dm, {
                ref: u,
                renderless: !0,
                items: I.value
              }, {
                default: (me) => {
                  var Ke;
                  let {
                    item: Me,
                    index: Be,
                    itemRef: xe
                  } = me;
                  const ze = ie(Me.props, {
                    ref: xe,
                    key: Be,
                    active: N.value && Be === 0 ? !0 : void 0,
                    onClick: () => Fe(Me, null)
                  });
                  return ((Ke = n.item) == null ? void 0 : Ke.call(n, {
                    item: Me,
                    index: Be,
                    props: ze
                  })) ?? v(Ts, ie(ze, {
                    role: "option"
                  }), {
                    prepend: (ut) => {
                      let {
                        isSelected: vt
                      } = ut;
                      return v(De, null, [e.multiple && !e.hideSelected ? v(Cs, {
                        key: Me.value,
                        modelValue: vt,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, Me.props.prependAvatar && v(Ji, {
                        image: Me.props.prependAvatar
                      }, null), Me.props.prependIcon && v(at, {
                        icon: Me.props.prependIcon
                      }, null)]);
                    },
                    title: () => {
                      var ut, vt;
                      return a.value ? Me.title : S5(Me.title, (ut = A(Me)) == null ? void 0 : ut.title, ((vt = _.value) == null ? void 0 : vt.length) ?? 0);
                    }
                  });
                }
              }), (te = n["append-item"]) == null ? void 0 : te.call(n)];
            }
          })]
        }), w.value.map((be, Pe) => {
          function te(xe) {
            xe.stopPropagation(), xe.preventDefault(), Fe(be, !1);
          }
          const me = {
            "onClick:close": te,
            onKeydown(xe) {
              xe.key !== "Enter" && xe.key !== " " || (xe.preventDefault(), xe.stopPropagation(), te(xe));
            },
            onMousedown(xe) {
              xe.preventDefault(), xe.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, Me = E.value ? !!n.chip : !!n.selection, Be = Me ? fh(E.value ? n.chip({
            item: be,
            index: Pe,
            props: me
          }) : n.selection({
            item: be,
            index: Pe
          })) : void 0;
          if (!(Me && !Be))
            return v("div", {
              key: be.value,
              class: ["v-autocomplete__selection", Pe === f.value && ["v-autocomplete__selection--selected", k.value]],
              style: Pe === f.value ? T.value : {}
            }, [E.value ? n.chip ? v(Ze, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: e.closableChips,
                  size: "small",
                  text: be.title
                }
              }
            }, {
              default: () => [Be]
            }) : v(ou, ie({
              key: "chip",
              closable: e.closableChips,
              size: "small",
              text: be.title,
              disabled: be.props.disabled
            }, me), null) : Be ?? v("span", {
              class: "v-autocomplete__selection-text"
            }, [be.title, e.multiple && Pe < w.value.length - 1 && v("span", {
              class: "v-autocomplete__selection-comma"
            }, [_r(",")])])]);
        })]),
        "append-inner": function() {
          var me;
          for (var be = arguments.length, Pe = new Array(be), te = 0; te < be; te++)
            Pe[te] = arguments[te];
          return v(De, null, [(me = n["append-inner"]) == null ? void 0 : me.call(n, ...Pe), e.menuIcon ? v(at, {
            class: "v-autocomplete__menu-icon",
            icon: e.menuIcon,
            onMousedown: L,
            onClick: dS,
            "aria-label": i(m.value),
            title: i(m.value),
            tabindex: "-1"
          }, null) : void 0]);
        }
      });
    }), Qi({
      isFocused: s,
      isPristine: a,
      menu: d,
      search: _,
      filteredItems: x,
      select: Fe
    }, r);
  }
});
const T5 = B({
  bordered: Boolean,
  color: String,
  content: [Number, String],
  dot: Boolean,
  floating: Boolean,
  icon: We,
  inline: Boolean,
  label: {
    type: String,
    default: "$vuetify.badge"
  },
  max: [Number, String],
  modelValue: {
    type: Boolean,
    default: !0
  },
  offsetX: [Number, String],
  offsetY: [Number, String],
  textColor: String,
  ...ke(),
  ...ua({
    location: "top end"
  }),
  ...It(),
  ...je(),
  ...Qe(),
  ...xr({
    transition: "scale-rotate-transition"
  })
}, "VBadge"), x5 = J()({
  name: "VBadge",
  inheritAttrs: !1,
  props: T5(),
  setup(e, t) {
    const {
      backgroundColorClasses: n,
      backgroundColorStyles: i
    } = gt(G(e, "color")), {
      roundedClasses: r
    } = Ht(e), {
      t: s
    } = qt(), {
      textColorClasses: a,
      textColorStyles: o
    } = $n(G(e, "textColor")), {
      themeClasses: l
    } = PS(), {
      locationStyles: u
    } = yo(e, !0, (c) => (e.floating ? e.dot ? 2 : 4 : e.dot ? 8 : 12) + (["top", "bottom"].includes(c) ? +(e.offsetY ?? 0) : ["left", "right"].includes(c) ? +(e.offsetX ?? 0) : 0));
    return re(() => {
      const c = Number(e.content), d = !e.max || isNaN(c) ? e.content : c <= +e.max ? c : `${e.max}+`, [f, h] = Ev(t.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
      return v(e.tag, ie({
        class: ["v-badge", {
          "v-badge--bordered": e.bordered,
          "v-badge--dot": e.dot,
          "v-badge--floating": e.floating,
          "v-badge--inline": e.inline
        }, e.class]
      }, h, {
        style: e.style
      }), {
        default: () => {
          var m, g;
          return [v("div", {
            class: "v-badge__wrapper"
          }, [(g = (m = t.slots).default) == null ? void 0 : g.call(m), v(Gn, {
            transition: e.transition
          }, {
            default: () => {
              var p, y;
              return [Rt(v("span", ie({
                class: ["v-badge__badge", l.value, n.value, r.value, a.value],
                style: [i.value, o.value, e.inline ? {} : u.value],
                "aria-atomic": "true",
                "aria-label": s(e.label, c),
                "aria-live": "polite",
                role: "status"
              }, f), [e.dot ? void 0 : t.slots.badge ? (y = (p = t.slots).badge) == null ? void 0 : y.call(p) : e.icon ? v(at, {
                icon: e.icon
              }, null) : d]), [[Tr, e.modelValue]])];
            }
          })])];
        }
      });
    }), {};
  }
});
const A5 = B({
  color: String,
  density: String,
  ...ke()
}, "VBannerActions"), IA = J()({
  name: "VBannerActions",
  props: A5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return jt({
      VBtn: {
        color: e.color,
        density: e.density,
        slim: !0,
        variant: "text"
      }
    }), re(() => {
      var i;
      return v("div", {
        class: ["v-banner-actions", e.class],
        style: e.style
      }, [(i = n.default) == null ? void 0 : i.call(n)]);
    }), {};
  }
}), EA = Zr("v-banner-text"), I5 = B({
  avatar: String,
  bgColor: String,
  color: String,
  icon: We,
  lines: String,
  stacked: Boolean,
  sticky: Boolean,
  text: String,
  ...Ni(),
  ...ke(),
  ..._n(),
  ...Sn(),
  ...jl({
    mobile: null
  }),
  ...gn(),
  ...ua(),
  ...su(),
  ...It(),
  ...je(),
  ...Qe()
}, "VBanner"), E5 = J()({
  name: "VBanner",
  props: I5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: r
    } = gt(e, "bgColor"), {
      borderClasses: s
    } = er(e), {
      densityClasses: a
    } = Kn(e), {
      displayClasses: o,
      mobile: l
    } = Ar(e), {
      dimensionStyles: u
    } = kn(e), {
      elevationClasses: c
    } = On(e), {
      locationStyles: d
    } = yo(e), {
      positionClasses: f
    } = au(e), {
      roundedClasses: h
    } = Ht(e), {
      themeClasses: m
    } = lt(e), g = G(e, "color"), p = G(e, "density");
    jt({
      VBannerActions: {
        color: g,
        density: p
      }
    }), re(() => {
      const y = !!(e.text || n.text), k = !!(e.avatar || e.icon), T = !!(k || n.prepend);
      return v(e.tag, {
        class: ["v-banner", {
          "v-banner--stacked": e.stacked || l.value,
          "v-banner--sticky": e.sticky,
          [`v-banner--${e.lines}-line`]: !!e.lines
        }, m.value, i.value, s.value, a.value, o.value, c.value, f.value, h.value, e.class],
        style: [r.value, u.value, d.value, e.style],
        role: "banner"
      }, {
        default: () => {
          var _;
          return [T && v("div", {
            key: "prepend",
            class: "v-banner__prepend"
          }, [n.prepend ? v(Ze, {
            key: "prepend-defaults",
            disabled: !k,
            defaults: {
              VAvatar: {
                color: g.value,
                density: p.value,
                icon: e.icon,
                image: e.avatar
              }
            }
          }, n.prepend) : v(Ji, {
            key: "prepend-avatar",
            color: g.value,
            density: p.value,
            icon: e.icon,
            image: e.avatar
          }, null)]), v("div", {
            class: "v-banner__content"
          }, [y && v(EA, {
            key: "text"
          }, {
            default: () => {
              var w;
              return [((w = n.text) == null ? void 0 : w.call(n)) ?? e.text];
            }
          }), (_ = n.default) == null ? void 0 : _.call(n)]), n.actions && v(IA, {
            key: "actions"
          }, n.actions)];
        }
      });
    });
  }
});
const P5 = B({
  baseColor: String,
  bgColor: String,
  color: String,
  grow: Boolean,
  mode: {
    type: String,
    validator: (e) => !e || ["horizontal", "shift"].includes(e)
  },
  height: {
    type: [Number, String],
    default: 56
  },
  active: {
    type: Boolean,
    default: !0
  },
  ...Ni(),
  ...ke(),
  ..._n(),
  ...gn(),
  ...It(),
  ...bo({
    name: "bottom-navigation"
  }),
  ...je({
    tag: "header"
  }),
  ...Po({
    selectedClass: "v-btn--selected"
  }),
  ...Qe()
}, "VBottomNavigation"), O5 = J()({
  name: "VBottomNavigation",
  props: P5(),
  emits: {
    "update:active": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = PS(), {
      borderClasses: r
    } = er(e), {
      backgroundColorClasses: s,
      backgroundColorStyles: a
    } = gt(G(e, "bgColor")), {
      densityClasses: o
    } = Kn(e), {
      elevationClasses: l
    } = On(e), {
      roundedClasses: u
    } = Ht(e), {
      ssrBootStyles: c
    } = Io(), d = b(() => Number(e.height) - (e.density === "comfortable" ? 8 : 0) - (e.density === "compact" ? 16 : 0)), f = Ee(e, "active", e.active), {
      layoutItemStyles: h,
      layoutIsReady: m
    } = wo({
      id: e.name,
      order: b(() => parseInt(e.order, 10)),
      position: b(() => "bottom"),
      layoutSize: b(() => f.value ? d.value : 0),
      elementSize: d,
      active: f,
      absolute: G(e, "absolute")
    });
    return ha(e, Jy), jt({
      VBtn: {
        baseColor: G(e, "baseColor"),
        color: G(e, "color"),
        density: G(e, "density"),
        stacked: b(() => e.mode !== "horizontal"),
        variant: "text"
      }
    }, {
      scoped: !0
    }), re(() => v(e.tag, {
      class: ["v-bottom-navigation", {
        "v-bottom-navigation--active": f.value,
        "v-bottom-navigation--grow": e.grow,
        "v-bottom-navigation--shift": e.mode === "shift"
      }, i.value, s.value, r.value, o.value, l.value, u.value, e.class],
      style: [a.value, h.value, {
        height: _e(d.value)
      }, c.value, e.style]
    }, {
      default: () => [n.default && v("div", {
        class: "v-bottom-navigation__content"
      }, [n.default()])]
    })), m;
  }
});
const PA = B({
  fullscreen: Boolean,
  retainFocus: {
    type: Boolean,
    default: !0
  },
  scrollable: Boolean,
  ...ud({
    origin: "center center",
    scrollStrategy: "block",
    transition: {
      component: mh
    },
    zIndex: 2400
  })
}, "VDialog"), Lg = J()({
  name: "VDialog",
  props: PA(),
  emits: {
    "update:modelValue": (e) => !0,
    afterLeave: () => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const r = Ee(e, "modelValue"), {
      scopeId: s
    } = Do(), a = X();
    function o(c) {
      var h, m;
      const d = c.relatedTarget, f = c.target;
      if (d !== f && ((h = a.value) != null && h.contentEl) && // We're the topmost dialog
      ((m = a.value) != null && m.globalTop) && // It isn't the document or the dialog body
      ![document, a.value.contentEl].includes(f) && // It isn't inside the dialog body
      !a.value.contentEl.contains(f)) {
        const g = Uu(a.value.contentEl);
        if (!g.length)
          return;
        const p = g[0], y = g[g.length - 1];
        d === p ? y.focus() : p.focus();
      }
    }
    ft && fe(() => r.value && e.retainFocus, (c) => {
      c ? document.addEventListener("focusin", o) : document.removeEventListener("focusin", o);
    }, {
      immediate: !0
    });
    function l() {
      var c;
      (c = a.value) != null && c.contentEl && !a.value.contentEl.contains(document.activeElement) && a.value.contentEl.focus({
        preventScroll: !0
      });
    }
    function u() {
      n("afterLeave");
    }
    return fe(r, async (c) => {
      var d;
      c || (await He(), (d = a.value.activatorEl) == null || d.focus({
        preventScroll: !0
      }));
    }), re(() => {
      const c = Gr.filterProps(e), d = ie({
        "aria-haspopup": "dialog",
        "aria-expanded": String(r.value)
      }, e.activatorProps), f = ie({
        tabindex: -1
      }, e.contentProps);
      return v(Gr, ie({
        ref: a,
        class: ["v-dialog", {
          "v-dialog--fullscreen": e.fullscreen,
          "v-dialog--scrollable": e.scrollable
        }, e.class],
        style: e.style
      }, c, {
        modelValue: r.value,
        "onUpdate:modelValue": (h) => r.value = h,
        "aria-modal": "true",
        activatorProps: d,
        contentProps: f,
        role: "dialog",
        onAfterEnter: l,
        onAfterLeave: u
      }, s), {
        activator: i.activator,
        default: function() {
          for (var h = arguments.length, m = new Array(h), g = 0; g < h; g++)
            m[g] = arguments[g];
          return v(Ze, {
            root: "VDialog"
          }, {
            default: () => {
              var p;
              return [(p = i.default) == null ? void 0 : p.call(i, ...m)];
            }
          });
        }
      });
    }), Qi({}, a);
  }
}), V5 = B({
  inset: Boolean,
  ...PA({
    transition: "bottom-sheet-transition"
  })
}, "VBottomSheet"), D5 = J()({
  name: "VBottomSheet",
  props: V5(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue");
    return re(() => {
      const r = Lg.filterProps(e);
      return v(Lg, ie(r, {
        contentClass: ["v-bottom-sheet__content", e.contentClass],
        modelValue: i.value,
        "onUpdate:modelValue": (s) => i.value = s,
        class: ["v-bottom-sheet", {
          "v-bottom-sheet--inset": e.inset
        }, e.class],
        style: e.style
      }), n);
    }), {};
  }
});
const N5 = B({
  divider: [Number, String],
  ...ke()
}, "VBreadcrumbsDivider"), OA = J()({
  name: "VBreadcrumbsDivider",
  props: N5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => {
      var i;
      return v("li", {
        class: ["v-breadcrumbs-divider", e.class],
        style: e.style
      }, [((i = n == null ? void 0 : n.default) == null ? void 0 : i.call(n)) ?? e.divider]);
    }), {};
  }
}), M5 = B({
  active: Boolean,
  activeClass: String,
  activeColor: String,
  color: String,
  disabled: Boolean,
  title: String,
  ...ke(),
  ...od(),
  ...je({
    tag: "li"
  })
}, "VBreadcrumbsItem"), VA = J()({
  name: "VBreadcrumbsItem",
  props: M5(),
  setup(e, t) {
    let {
      slots: n,
      attrs: i
    } = t;
    const r = ad(e, i), s = b(() => {
      var u;
      return e.active || ((u = r.isActive) == null ? void 0 : u.value);
    }), a = b(() => s.value ? e.activeColor : e.color), {
      textColorClasses: o,
      textColorStyles: l
    } = $n(a);
    return re(() => v(e.tag, {
      class: ["v-breadcrumbs-item", {
        "v-breadcrumbs-item--active": s.value,
        "v-breadcrumbs-item--disabled": e.disabled,
        [`${e.activeClass}`]: s.value && e.activeClass
      }, o.value, e.class],
      style: [l.value, e.style],
      "aria-current": s.value ? "page" : void 0
    }, {
      default: () => {
        var u, c;
        return [r.isLink.value ? v("a", {
          class: "v-breadcrumbs-item--link",
          href: r.href.value,
          "aria-current": s.value ? "page" : void 0,
          onClick: r.navigate
        }, [((c = n.default) == null ? void 0 : c.call(n)) ?? e.title]) : ((u = n.default) == null ? void 0 : u.call(n)) ?? e.title];
      }
    })), {};
  }
}), R5 = B({
  activeClass: String,
  activeColor: String,
  bgColor: String,
  color: String,
  disabled: Boolean,
  divider: {
    type: String,
    default: "/"
  },
  icon: We,
  items: {
    type: Array,
    default: () => []
  },
  ...ke(),
  ..._n(),
  ...It(),
  ...je({
    tag: "ul"
  })
}, "VBreadcrumbs"), F5 = J()({
  name: "VBreadcrumbs",
  props: R5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: r
    } = gt(G(e, "bgColor")), {
      densityClasses: s
    } = Kn(e), {
      roundedClasses: a
    } = Ht(e);
    jt({
      VBreadcrumbsDivider: {
        divider: G(e, "divider")
      },
      VBreadcrumbsItem: {
        activeClass: G(e, "activeClass"),
        activeColor: G(e, "activeColor"),
        color: G(e, "color"),
        disabled: G(e, "disabled")
      }
    });
    const o = b(() => e.items.map((l) => typeof l == "string" ? {
      item: {
        title: l
      },
      raw: l
    } : {
      item: l,
      raw: l
    }));
    return re(() => {
      const l = !!(n.prepend || e.icon);
      return v(e.tag, {
        class: ["v-breadcrumbs", i.value, s.value, a.value, e.class],
        style: [r.value, e.style]
      }, {
        default: () => {
          var u;
          return [l && v("li", {
            key: "prepend",
            class: "v-breadcrumbs__prepend"
          }, [n.prepend ? v(Ze, {
            key: "prepend-defaults",
            disabled: !e.icon,
            defaults: {
              VIcon: {
                icon: e.icon,
                start: !0
              }
            }
          }, n.prepend) : v(at, {
            key: "prepend-icon",
            start: !0,
            icon: e.icon
          }, null)]), o.value.map((c, d, f) => {
            var g;
            let {
              item: h,
              raw: m
            } = c;
            return v(De, null, [((g = n.item) == null ? void 0 : g.call(n, {
              item: h,
              index: d
            })) ?? v(VA, ie({
              key: d,
              disabled: d >= f.length - 1
            }, typeof h == "string" ? {
              title: h
            } : h), {
              default: n.title ? () => {
                var p;
                return (p = n.title) == null ? void 0 : p.call(n, {
                  item: h,
                  index: d
                });
              } : void 0
            }), d < f.length - 1 && v(OA, null, {
              default: n.divider ? () => {
                var p;
                return (p = n.divider) == null ? void 0 : p.call(n, {
                  item: m,
                  index: d
                });
              } : void 0
            })]);
          }), (u = n.default) == null ? void 0 : u.call(n)];
        }
      });
    }), {};
  }
});
const DA = J()({
  name: "VCardActions",
  props: ke(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return jt({
      VBtn: {
        slim: !0,
        variant: "text"
      }
    }), re(() => {
      var i;
      return v("div", {
        class: ["v-card-actions", e.class],
        style: e.style
      }, [(i = n.default) == null ? void 0 : i.call(n)]);
    }), {};
  }
}), B5 = B({
  opacity: [Number, String],
  ...ke(),
  ...je()
}, "VCardSubtitle"), NA = J()({
  name: "VCardSubtitle",
  props: B5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => v(e.tag, {
      class: ["v-card-subtitle", e.class],
      style: [{
        "--v-card-subtitle-opacity": e.opacity
      }, e.style]
    }, n)), {};
  }
}), MA = Zr("v-card-title"), L5 = B({
  appendAvatar: String,
  appendIcon: We,
  prependAvatar: String,
  prependIcon: We,
  subtitle: [String, Number],
  title: [String, Number],
  ...ke(),
  ..._n()
}, "VCardItem"), RA = J()({
  name: "VCardItem",
  props: L5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => {
      var u;
      const i = !!(e.prependAvatar || e.prependIcon), r = !!(i || n.prepend), s = !!(e.appendAvatar || e.appendIcon), a = !!(s || n.append), o = !!(e.title != null || n.title), l = !!(e.subtitle != null || n.subtitle);
      return v("div", {
        class: ["v-card-item", e.class],
        style: e.style
      }, [r && v("div", {
        key: "prepend",
        class: "v-card-item__prepend"
      }, [n.prepend ? v(Ze, {
        key: "prepend-defaults",
        disabled: !i,
        defaults: {
          VAvatar: {
            density: e.density,
            image: e.prependAvatar
          },
          VIcon: {
            density: e.density,
            icon: e.prependIcon
          }
        }
      }, n.prepend) : v(De, null, [e.prependAvatar && v(Ji, {
        key: "prepend-avatar",
        density: e.density,
        image: e.prependAvatar
      }, null), e.prependIcon && v(at, {
        key: "prepend-icon",
        density: e.density,
        icon: e.prependIcon
      }, null)])]), v("div", {
        class: "v-card-item__content"
      }, [o && v(MA, {
        key: "title"
      }, {
        default: () => {
          var c;
          return [((c = n.title) == null ? void 0 : c.call(n)) ?? e.title];
        }
      }), l && v(NA, {
        key: "subtitle"
      }, {
        default: () => {
          var c;
          return [((c = n.subtitle) == null ? void 0 : c.call(n)) ?? e.subtitle];
        }
      }), (u = n.default) == null ? void 0 : u.call(n)]), a && v("div", {
        key: "append",
        class: "v-card-item__append"
      }, [n.append ? v(Ze, {
        key: "append-defaults",
        disabled: !s,
        defaults: {
          VAvatar: {
            density: e.density,
            image: e.appendAvatar
          },
          VIcon: {
            density: e.density,
            icon: e.appendIcon
          }
        }
      }, n.append) : v(De, null, [e.appendIcon && v(at, {
        key: "append-icon",
        density: e.density,
        icon: e.appendIcon
      }, null), e.appendAvatar && v(Ji, {
        key: "append-avatar",
        density: e.density,
        image: e.appendAvatar
      }, null)])])]);
    }), {};
  }
}), $5 = B({
  opacity: [Number, String],
  ...ke(),
  ...je()
}, "VCardText"), FA = J()({
  name: "VCardText",
  props: $5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => v(e.tag, {
      class: ["v-card-text", e.class],
      style: [{
        "--v-card-text-opacity": e.opacity
      }, e.style]
    }, n)), {};
  }
}), W5 = B({
  appendAvatar: String,
  appendIcon: We,
  disabled: Boolean,
  flat: Boolean,
  hover: Boolean,
  image: String,
  link: {
    type: Boolean,
    default: void 0
  },
  prependAvatar: String,
  prependIcon: We,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  subtitle: [String, Number],
  text: [String, Number],
  title: [String, Number],
  ...Ni(),
  ...ke(),
  ..._n(),
  ...Sn(),
  ...gn(),
  ...wh(),
  ...ua(),
  ...su(),
  ...It(),
  ...od(),
  ...je(),
  ...Qe(),
  ...tr({
    variant: "elevated"
  })
}, "VCard"), j5 = J()({
  name: "VCard",
  directives: {
    Ripple: Vs
  },
  props: W5(),
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      themeClasses: r
    } = lt(e), {
      borderClasses: s
    } = er(e), {
      colorClasses: a,
      colorStyles: o,
      variantClasses: l
    } = Eo(e), {
      densityClasses: u
    } = Kn(e), {
      dimensionStyles: c
    } = kn(e), {
      elevationClasses: d
    } = On(e), {
      loaderClasses: f
    } = Oc(e), {
      locationStyles: h
    } = yo(e), {
      positionClasses: m
    } = au(e), {
      roundedClasses: g
    } = Ht(e), p = ad(e, n), y = b(() => e.link !== !1 && p.isLink.value), k = b(() => !e.disabled && e.link !== !1 && (e.link || p.isClickable.value));
    return re(() => {
      const T = y.value ? "a" : e.tag, _ = !!(i.title || e.title != null), w = !!(i.subtitle || e.subtitle != null), S = _ || w, C = !!(i.append || e.appendAvatar || e.appendIcon), x = !!(i.prepend || e.prependAvatar || e.prependIcon), A = !!(i.image || e.image), I = S || x || C, E = !!(i.text || e.text != null);
      return Rt(v(T, {
        class: ["v-card", {
          "v-card--disabled": e.disabled,
          "v-card--flat": e.flat,
          "v-card--hover": e.hover && !(e.disabled || e.flat),
          "v-card--link": k.value
        }, r.value, s.value, a.value, u.value, d.value, f.value, m.value, g.value, l.value, e.class],
        style: [o.value, c.value, h.value, e.style],
        href: p.href.value,
        onClick: k.value && p.navigate,
        tabindex: e.disabled ? -1 : void 0
      }, {
        default: () => {
          var P;
          return [A && v("div", {
            key: "image",
            class: "v-card__image"
          }, [i.image ? v(Ze, {
            key: "image-defaults",
            disabled: !e.image,
            defaults: {
              VImg: {
                cover: !0,
                src: e.image
              }
            }
          }, i.image) : v(ks, {
            key: "image-img",
            cover: !0,
            src: e.image
          }, null)]), v(Vc, {
            name: "v-card",
            active: !!e.loading,
            color: typeof e.loading == "boolean" ? void 0 : e.loading
          }, {
            default: i.loader
          }), I && v(RA, {
            key: "item",
            prependAvatar: e.prependAvatar,
            prependIcon: e.prependIcon,
            title: e.title,
            subtitle: e.subtitle,
            appendAvatar: e.appendAvatar,
            appendIcon: e.appendIcon
          }, {
            default: i.item,
            prepend: i.prepend,
            title: i.title,
            subtitle: i.subtitle,
            append: i.append
          }), E && v(FA, {
            key: "text"
          }, {
            default: () => {
              var V;
              return [((V = i.text) == null ? void 0 : V.call(i)) ?? e.text];
            }
          }), (P = i.default) == null ? void 0 : P.call(i), i.actions && v(DA, null, {
            default: i.actions
          }), fa(k.value, "v-card")];
        }
      }), [[Ei("ripple"), k.value && e.ripple]]);
    }), {};
  }
});
const H5 = (e) => {
  const {
    touchstartX: t,
    touchendX: n,
    touchstartY: i,
    touchendY: r
  } = e, s = 0.5, a = 16;
  e.offsetX = n - t, e.offsetY = r - i, Math.abs(e.offsetY) < s * Math.abs(e.offsetX) && (e.left && n < t - a && e.left(e), e.right && n > t + a && e.right(e)), Math.abs(e.offsetX) < s * Math.abs(e.offsetY) && (e.up && r < i - a && e.up(e), e.down && r > i + a && e.down(e));
};
function z5(e, t) {
  var i;
  const n = e.changedTouches[0];
  t.touchstartX = n.clientX, t.touchstartY = n.clientY, (i = t.start) == null || i.call(t, {
    originalEvent: e,
    ...t
  });
}
function U5(e, t) {
  var i;
  const n = e.changedTouches[0];
  t.touchendX = n.clientX, t.touchendY = n.clientY, (i = t.end) == null || i.call(t, {
    originalEvent: e,
    ...t
  }), H5(t);
}
function q5(e, t) {
  var i;
  const n = e.changedTouches[0];
  t.touchmoveX = n.clientX, t.touchmoveY = n.clientY, (i = t.move) == null || i.call(t, {
    originalEvent: e,
    ...t
  });
}
function G5() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const t = {
    touchstartX: 0,
    touchstartY: 0,
    touchendX: 0,
    touchendY: 0,
    touchmoveX: 0,
    touchmoveY: 0,
    offsetX: 0,
    offsetY: 0,
    left: e.left,
    right: e.right,
    up: e.up,
    down: e.down,
    start: e.start,
    move: e.move,
    end: e.end
  };
  return {
    touchstart: (n) => z5(n, t),
    touchend: (n) => U5(n, t),
    touchmove: (n) => q5(n, t)
  };
}
function Y5(e, t) {
  var o;
  const n = t.value, i = n != null && n.parent ? e.parentElement : e, r = (n == null ? void 0 : n.options) ?? {
    passive: !0
  }, s = (o = t.instance) == null ? void 0 : o.$.uid;
  if (!i || !s)
    return;
  const a = G5(t.value);
  i._touchHandlers = i._touchHandlers ?? /* @__PURE__ */ Object.create(null), i._touchHandlers[s] = a, sS(a).forEach((l) => {
    i.addEventListener(l, a[l], r);
  });
}
function Z5(e, t) {
  var s, a;
  const n = (s = t.value) != null && s.parent ? e.parentElement : e, i = (a = t.instance) == null ? void 0 : a.$.uid;
  if (!(n != null && n._touchHandlers) || !i)
    return;
  const r = n._touchHandlers[i];
  sS(r).forEach((o) => {
    n.removeEventListener(o, r[o]);
  }), delete n._touchHandlers[i];
}
const db = {
  mounted: Y5,
  unmounted: Z5
}, BA = Symbol.for("vuetify:v-window"), LA = Symbol.for("vuetify:v-window-group"), fm = B({
  continuous: Boolean,
  nextIcon: {
    type: [Boolean, String, Function, Object],
    default: "$next"
  },
  prevIcon: {
    type: [Boolean, String, Function, Object],
    default: "$prev"
  },
  reverse: Boolean,
  showArrows: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || e === "hover"
  },
  touch: {
    type: [Object, Boolean],
    default: void 0
  },
  direction: {
    type: String,
    default: "horizontal"
  },
  modelValue: null,
  disabled: Boolean,
  selectedClass: {
    type: String,
    default: "v-window-item--active"
  },
  // TODO: mandatory should probably not be exposed but do this for now
  mandatory: {
    type: [Boolean, String],
    default: "force"
  },
  ...ke(),
  ...je(),
  ...Qe()
}, "VWindow"), fo = J()({
  name: "VWindow",
  directives: {
    Touch: db
  },
  props: fm(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      isRtl: r
    } = wn(), {
      t: s
    } = qt(), a = ha(e, LA), o = X(), l = b(() => r.value ? !e.reverse : e.reverse), u = pe(!1), c = b(() => {
      const _ = e.direction === "vertical" ? "y" : "x", S = (l.value ? !u.value : u.value) ? "-reverse" : "";
      return `v-window-${_}${S}-transition`;
    }), d = pe(0), f = X(void 0), h = b(() => a.items.value.findIndex((_) => a.selected.value.includes(_.id)));
    fe(h, (_, w) => {
      const S = a.items.value.length, C = S - 1;
      S <= 2 ? u.value = _ < w : _ === C && w === 0 ? u.value = !0 : _ === 0 && w === C ? u.value = !1 : u.value = _ < w;
    }), Tt(BA, {
      transition: c,
      isReversed: u,
      transitionCount: d,
      transitionHeight: f,
      rootRef: o
    });
    const m = b(() => e.continuous || h.value !== 0), g = b(() => e.continuous || h.value !== a.items.value.length - 1);
    function p() {
      m.value && a.prev();
    }
    function y() {
      g.value && a.next();
    }
    const k = b(() => {
      const _ = [], w = {
        icon: r.value ? e.nextIcon : e.prevIcon,
        class: `v-window__${l.value ? "right" : "left"}`,
        onClick: a.prev,
        "aria-label": s("$vuetify.carousel.prev")
      };
      _.push(m.value ? n.prev ? n.prev({
        props: w
      }) : v(st, w, null) : v("div", null, null));
      const S = {
        icon: r.value ? e.prevIcon : e.nextIcon,
        class: `v-window__${l.value ? "left" : "right"}`,
        onClick: a.next,
        "aria-label": s("$vuetify.carousel.next")
      };
      return _.push(g.value ? n.next ? n.next({
        props: S
      }) : v(st, S, null) : v("div", null, null)), _;
    }), T = b(() => e.touch === !1 ? e.touch : {
      ...{
        left: () => {
          l.value ? p() : y();
        },
        right: () => {
          l.value ? y() : p();
        },
        start: (w) => {
          let {
            originalEvent: S
          } = w;
          S.stopPropagation();
        }
      },
      ...e.touch === !0 ? {} : e.touch
    });
    return re(() => Rt(v(e.tag, {
      ref: o,
      class: ["v-window", {
        "v-window--show-arrows-on-hover": e.showArrows === "hover"
      }, i.value, e.class],
      style: e.style
    }, {
      default: () => {
        var _, w;
        return [v("div", {
          class: "v-window__container",
          style: {
            height: f.value
          }
        }, [(_ = n.default) == null ? void 0 : _.call(n, {
          group: a
        }), e.showArrows !== !1 && v("div", {
          class: "v-window__controls"
        }, [k.value])]), (w = n.additional) == null ? void 0 : w.call(n, {
          group: a
        })];
      }
    }), [[Ei("touch"), T.value]])), {
      group: a
    };
  }
}), K5 = B({
  color: String,
  cycle: Boolean,
  delimiterIcon: {
    type: We,
    default: "$delimiter"
  },
  height: {
    type: [Number, String],
    default: 500
  },
  hideDelimiters: Boolean,
  hideDelimiterBackground: Boolean,
  interval: {
    type: [Number, String],
    default: 6e3,
    validator: (e) => Number(e) > 0
  },
  progress: [Boolean, String],
  verticalDelimiters: [Boolean, String],
  ...fm({
    continuous: !0,
    mandatory: "force",
    showArrows: !0
  })
}, "VCarousel"), X5 = J()({
  name: "VCarousel",
  props: K5(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), {
      t: r
    } = qt(), s = X();
    let a = -1;
    fe(i, l), fe(() => e.interval, l), fe(() => e.cycle, (u) => {
      u ? l() : window.clearTimeout(a);
    }), En(o);
    function o() {
      !e.cycle || !s.value || (a = window.setTimeout(s.value.group.next, +e.interval > 0 ? +e.interval : 6e3));
    }
    function l() {
      window.clearTimeout(a), window.requestAnimationFrame(o);
    }
    return re(() => {
      const u = fo.filterProps(e);
      return v(fo, ie({
        ref: s
      }, u, {
        modelValue: i.value,
        "onUpdate:modelValue": (c) => i.value = c,
        class: ["v-carousel", {
          "v-carousel--hide-delimiter-background": e.hideDelimiterBackground,
          "v-carousel--vertical-delimiters": e.verticalDelimiters
        }, e.class],
        style: [{
          height: _e(e.height)
        }, e.style]
      }), {
        default: n.default,
        additional: (c) => {
          let {
            group: d
          } = c;
          return v(De, null, [!e.hideDelimiters && v("div", {
            class: "v-carousel__controls",
            style: {
              left: e.verticalDelimiters === "left" && e.verticalDelimiters ? 0 : "auto",
              right: e.verticalDelimiters === "right" ? 0 : "auto"
            }
          }, [d.items.value.length > 0 && v(Ze, {
            defaults: {
              VBtn: {
                color: e.color,
                icon: e.delimiterIcon,
                size: "x-small",
                variant: "text"
              }
            },
            scoped: !0
          }, {
            default: () => [d.items.value.map((f, h) => {
              const m = {
                id: `carousel-item-${f.id}`,
                "aria-label": r("$vuetify.carousel.ariaLabel.delimiter", h + 1, d.items.value.length),
                class: ["v-carousel__controls__item", d.isSelected(f.id) && "v-btn--active"],
                onClick: () => d.select(f.id, !0)
              };
              return n.item ? n.item({
                props: m,
                item: f
              }) : v(st, ie(f, m), null);
            })]
          })]), e.progress && v(bh, {
            class: "v-carousel__progress",
            color: typeof e.progress == "string" ? e.progress : void 0,
            modelValue: (d.getItemIndex(i.value) + 1) / d.items.value.length * 100
          }, null)]);
        },
        prev: n.prev,
        next: n.next
      });
    }), {};
  }
}), hm = B({
  reverseTransition: {
    type: [Boolean, String],
    default: void 0
  },
  transition: {
    type: [Boolean, String],
    default: void 0
  },
  ...ke(),
  ...Oo(),
  ...ab()
}, "VWindowItem"), ho = J()({
  name: "VWindowItem",
  directives: {
    Touch: db
  },
  props: hm(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = tt(BA), r = Vo(e, LA), {
      isBooted: s
    } = Io();
    if (!i || !r)
      throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
    const a = pe(!1), o = b(() => s.value && (i.isReversed.value ? e.reverseTransition !== !1 : e.transition !== !1));
    function l() {
      !a.value || !i || (a.value = !1, i.transitionCount.value > 0 && (i.transitionCount.value -= 1, i.transitionCount.value === 0 && (i.transitionHeight.value = void 0)));
    }
    function u() {
      var m;
      a.value || !i || (a.value = !0, i.transitionCount.value === 0 && (i.transitionHeight.value = _e((m = i.rootRef.value) == null ? void 0 : m.clientHeight)), i.transitionCount.value += 1);
    }
    function c() {
      l();
    }
    function d(m) {
      a.value && He(() => {
        !o.value || !a.value || !i || (i.transitionHeight.value = _e(m.clientHeight));
      });
    }
    const f = b(() => {
      const m = i.isReversed.value ? e.reverseTransition : e.transition;
      return o.value ? {
        name: typeof m != "string" ? i.transition.value : m,
        onBeforeEnter: u,
        onAfterEnter: l,
        onEnterCancelled: c,
        onBeforeLeave: u,
        onAfterLeave: l,
        onLeaveCancelled: c,
        onEnter: d
      } : !1;
    }), {
      hasContent: h
    } = ob(e, r.isSelected);
    return re(() => v(Gn, {
      transition: f.value,
      disabled: !s.value
    }, {
      default: () => {
        var m;
        return [Rt(v("div", {
          class: ["v-window-item", r.selectedClass.value, e.class],
          style: e.style
        }, [h.value && ((m = n.default) == null ? void 0 : m.call(n))]), [[Tr, r.isSelected.value]])];
      }
    })), {
      groupItem: r
    };
  }
}), J5 = B({
  ...Rx(),
  ...hm()
}, "VCarouselItem"), Q5 = J()({
  name: "VCarouselItem",
  inheritAttrs: !1,
  props: J5(),
  setup(e, t) {
    let {
      slots: n,
      attrs: i
    } = t;
    re(() => {
      const r = ks.filterProps(e), s = ho.filterProps(e);
      return v(ho, ie({
        class: ["v-carousel-item", e.class]
      }, s), {
        default: () => [v(ks, ie(i, r), n)]
      });
    });
  }
});
const eG = Zr("v-code");
const tG = B({
  color: {
    type: Object
  },
  disabled: Boolean,
  dotSize: {
    type: [Number, String],
    default: 10
  },
  height: {
    type: [Number, String],
    default: 150
  },
  width: {
    type: [Number, String],
    default: 300
  },
  ...ke()
}, "VColorPickerCanvas"), nG = Pi({
  name: "VColorPickerCanvas",
  props: tG(),
  emits: {
    "update:color": (e) => !0,
    "update:position": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const i = pe(!1), r = X(), s = pe(parseFloat(e.width)), a = pe(parseFloat(e.height)), o = X({
      x: 0,
      y: 0
    }), l = b({
      get: () => o.value,
      set(p) {
        var T, _;
        if (!r.value)
          return;
        const {
          x: y,
          y: k
        } = p;
        o.value = p, n("update:color", {
          h: ((T = e.color) == null ? void 0 : T.h) ?? 0,
          s: Xt(y, 0, s.value) / s.value,
          v: 1 - Xt(k, 0, a.value) / a.value,
          a: ((_ = e.color) == null ? void 0 : _.a) ?? 1
        });
      }
    }), u = b(() => {
      const {
        x: p,
        y
      } = l.value, k = parseInt(e.dotSize, 10) / 2;
      return {
        width: _e(e.dotSize),
        height: _e(e.dotSize),
        transform: `translate(${_e(p - k)}, ${_e(y - k)})`
      };
    }), {
      resizeRef: c
    } = Sr((p) => {
      var T;
      if (!((T = c.el) != null && T.offsetParent))
        return;
      const {
        width: y,
        height: k
      } = p[0].contentRect;
      s.value = y, a.value = k;
    });
    function d(p, y, k) {
      const {
        left: T,
        top: _,
        width: w,
        height: S
      } = k;
      l.value = {
        x: Xt(p - T, 0, w),
        y: Xt(y - _, 0, S)
      };
    }
    function f(p) {
      p.type === "mousedown" && p.preventDefault(), !e.disabled && (h(p), window.addEventListener("mousemove", h), window.addEventListener("mouseup", m), window.addEventListener("touchmove", h), window.addEventListener("touchend", m));
    }
    function h(p) {
      if (e.disabled || !r.value)
        return;
      i.value = !0;
      const y = fP(p);
      d(y.clientX, y.clientY, r.value.getBoundingClientRect());
    }
    function m() {
      window.removeEventListener("mousemove", h), window.removeEventListener("mouseup", m), window.removeEventListener("touchmove", h), window.removeEventListener("touchend", m);
    }
    function g() {
      var _;
      if (!r.value)
        return;
      const p = r.value, y = p.getContext("2d");
      if (!y)
        return;
      const k = y.createLinearGradient(0, 0, p.width, 0);
      k.addColorStop(0, "hsla(0, 0%, 100%, 1)"), k.addColorStop(1, `hsla(${((_ = e.color) == null ? void 0 : _.h) ?? 0}, 100%, 50%, 1)`), y.fillStyle = k, y.fillRect(0, 0, p.width, p.height);
      const T = y.createLinearGradient(0, 0, 0, p.height);
      T.addColorStop(0, "hsla(0, 0%, 0%, 0)"), T.addColorStop(1, "hsla(0, 0%, 0%, 1)"), y.fillStyle = T, y.fillRect(0, 0, p.width, p.height);
    }
    return fe(() => {
      var p;
      return (p = e.color) == null ? void 0 : p.h;
    }, g, {
      immediate: !0
    }), fe(() => [s.value, a.value], (p, y) => {
      g(), o.value = {
        x: l.value.x * p[0] / y[0],
        y: l.value.y * p[1] / y[1]
      };
    }, {
      flush: "post"
    }), fe(() => e.color, () => {
      if (i.value) {
        i.value = !1;
        return;
      }
      o.value = e.color ? {
        x: e.color.s * s.value,
        y: (1 - e.color.v) * a.value
      } : {
        x: 0,
        y: 0
      };
    }, {
      deep: !0,
      immediate: !0
    }), En(() => g()), re(() => v("div", {
      ref: c,
      class: ["v-color-picker-canvas", e.class],
      style: e.style,
      onMousedown: f,
      onTouchstartPassive: f
    }, [v("canvas", {
      ref: r,
      width: s.value,
      height: a.value
    }, null), e.color && v("div", {
      class: ["v-color-picker-canvas__dot", {
        "v-color-picker-canvas__dot--disabled": e.disabled
      }],
      style: u.value
    }, null)])), {};
  }
});
function iG(e, t) {
  if (t) {
    const {
      a: n,
      ...i
    } = e;
    return i;
  }
  return e;
}
function rG(e, t) {
  if (t == null || typeof t == "string") {
    const n = kS(e);
    return e.a === 1 ? n.slice(0, 7) : n;
  }
  if (typeof t == "object") {
    let n;
    return Da(t, ["r", "g", "b"]) ? n = bs(e) : Da(t, ["h", "s", "l"]) ? n = pS(e) : Da(t, ["h", "s", "v"]) && (n = e), iG(n, !Da(t, ["a"]) && e.a === 1);
  }
  return e;
}
const al = {
  h: 0,
  s: 0,
  v: 0,
  a: 1
}, $g = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "R",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.r),
    getColor: (e, t) => ({
      ...e,
      r: Number(t)
    })
  }, {
    label: "G",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.g),
    getColor: (e, t) => ({
      ...e,
      g: Number(t)
    })
  }, {
    label: "B",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.b),
    getColor: (e, t) => ({
      ...e,
      b: Number(t)
    })
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (e) => {
      let {
        a: t
      } = e;
      return t != null ? Math.round(t * 100) / 100 : 1;
    },
    getColor: (e, t) => ({
      ...e,
      a: Number(t)
    })
  }],
  to: bs,
  from: hh
};
var X_;
const sG = {
  ...$g,
  inputs: (X_ = $g.inputs) == null ? void 0 : X_.slice(0, 3)
}, Wg = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "H",
    max: 360,
    step: 1,
    getValue: (e) => Math.round(e.h),
    getColor: (e, t) => ({
      ...e,
      h: Number(t)
    })
  }, {
    label: "S",
    max: 1,
    step: 0.01,
    getValue: (e) => Math.round(e.s * 100) / 100,
    getColor: (e, t) => ({
      ...e,
      s: Number(t)
    })
  }, {
    label: "L",
    max: 1,
    step: 0.01,
    getValue: (e) => Math.round(e.l * 100) / 100,
    getColor: (e, t) => ({
      ...e,
      l: Number(t)
    })
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (e) => {
      let {
        a: t
      } = e;
      return t != null ? Math.round(t * 100) / 100 : 1;
    },
    getColor: (e, t) => ({
      ...e,
      a: Number(t)
    })
  }],
  to: pS,
  from: cp
}, aG = {
  ...Wg,
  inputs: Wg.inputs.slice(0, 3)
}, $A = {
  inputProps: {
    type: "text"
  },
  inputs: [{
    label: "HEXA",
    getValue: (e) => e,
    getColor: (e, t) => t
  }],
  to: kS,
  from: SS
}, oG = {
  ...$A,
  inputs: [{
    label: "HEX",
    getValue: (e) => e.slice(0, 7),
    getColor: (e, t) => t
  }]
}, Ga = {
  rgb: sG,
  rgba: $g,
  hsl: aG,
  hsla: Wg,
  hex: oG,
  hexa: $A
}, lG = (e) => {
  let {
    label: t,
    ...n
  } = e;
  return v("div", {
    class: "v-color-picker-edit__input"
  }, [v("input", n, null), v("span", null, [t])]);
}, uG = B({
  color: Object,
  disabled: Boolean,
  mode: {
    type: String,
    default: "rgba",
    validator: (e) => Object.keys(Ga).includes(e)
  },
  modes: {
    type: Array,
    default: () => Object.keys(Ga),
    validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(Ga).includes(t))
  },
  ...ke()
}, "VColorPickerEdit"), cG = Pi({
  name: "VColorPickerEdit",
  props: uG(),
  emits: {
    "update:color": (e) => !0,
    "update:mode": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const i = b(() => e.modes.map((s) => ({
      ...Ga[s],
      name: s
    }))), r = b(() => {
      var o;
      const s = i.value.find((l) => l.name === e.mode);
      if (!s)
        return [];
      const a = e.color ? s.to(e.color) : null;
      return (o = s.inputs) == null ? void 0 : o.map((l) => {
        let {
          getValue: u,
          getColor: c,
          ...d
        } = l;
        return {
          ...s.inputProps,
          ...d,
          disabled: e.disabled,
          value: a && u(a),
          onChange: (f) => {
            const h = f.target;
            h && n("update:color", s.from(c(a ?? s.to(al), h.value)));
          }
        };
      });
    });
    return re(() => {
      var s;
      return v("div", {
        class: ["v-color-picker-edit", e.class],
        style: e.style
      }, [(s = r.value) == null ? void 0 : s.map((a) => v(lG, a, null)), i.value.length > 1 && v(st, {
        icon: "$unfold",
        size: "x-small",
        variant: "plain",
        onClick: () => {
          const a = i.value.findIndex((o) => o.name === e.mode);
          n("update:mode", i.value[(a + 1) % i.value.length].name);
        }
      }, null)]);
    }), {};
  }
});
const fb = Symbol.for("vuetify:v-slider");
function jg(e, t, n) {
  const i = n === "vertical", r = t.getBoundingClientRect(), s = "touches" in e ? e.touches[0] : e;
  return i ? s.clientY - (r.top + r.height / 2) : s.clientX - (r.left + r.width / 2);
}
function dG(e, t) {
  return "touches" in e && e.touches.length ? e.touches[0][t] : "changedTouches" in e && e.changedTouches.length ? e.changedTouches[0][t] : e[t];
}
const WA = B({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  readonly: {
    type: Boolean,
    default: null
  },
  max: {
    type: [Number, String],
    default: 100
  },
  min: {
    type: [Number, String],
    default: 0
  },
  step: {
    type: [Number, String],
    default: 0
  },
  thumbColor: String,
  thumbLabel: {
    type: [Boolean, String],
    default: void 0,
    validator: (e) => typeof e == "boolean" || e === "always"
  },
  thumbSize: {
    type: [Number, String],
    default: 20
  },
  showTicks: {
    type: [Boolean, String],
    default: !1,
    validator: (e) => typeof e == "boolean" || e === "always"
  },
  ticks: {
    type: [Array, Object]
  },
  tickSize: {
    type: [Number, String],
    default: 2
  },
  color: String,
  trackColor: String,
  trackFillColor: String,
  trackSize: {
    type: [Number, String],
    default: 4
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  reverse: Boolean,
  ...It(),
  ...gn({
    elevation: 2
  }),
  ripple: {
    type: Boolean,
    default: !0
  }
}, "Slider"), jA = (e) => {
  const t = b(() => parseFloat(e.min)), n = b(() => parseFloat(e.max)), i = b(() => +e.step > 0 ? parseFloat(e.step) : 0), r = b(() => Math.max(zb(i.value), zb(t.value)));
  function s(a) {
    if (a = parseFloat(a), i.value <= 0)
      return a;
    const o = Xt(a, t.value, n.value), l = t.value % i.value, u = Math.round((o - l) / i.value) * i.value + l;
    return parseFloat(Math.min(u, n.value).toFixed(r.value));
  }
  return {
    min: t,
    max: n,
    step: i,
    decimals: r,
    roundValue: s
  };
}, HA = (e) => {
  let {
    props: t,
    steps: n,
    onSliderStart: i,
    onSliderMove: r,
    onSliderEnd: s,
    getActiveThumb: a
  } = e;
  const {
    isRtl: o
  } = wn(), l = G(t, "reverse"), u = b(() => t.direction === "vertical"), c = b(() => u.value !== l.value), {
    min: d,
    max: f,
    step: h,
    decimals: m,
    roundValue: g
  } = n, p = b(() => parseInt(t.thumbSize, 10)), y = b(() => parseInt(t.tickSize, 10)), k = b(() => parseInt(t.trackSize, 10)), T = b(() => (f.value - d.value) / h.value), _ = G(t, "disabled"), w = b(() => t.error || t.disabled ? void 0 : t.thumbColor ?? t.color), S = b(() => t.error || t.disabled ? void 0 : t.trackColor ?? t.color), C = b(() => t.error || t.disabled ? void 0 : t.trackFillColor ?? t.color), x = pe(!1), A = pe(0), I = X(), E = X();
  function P(K) {
    var te;
    const ue = t.direction === "vertical", ve = ue ? "top" : "left", Fe = ue ? "height" : "width", he = ue ? "clientY" : "clientX", {
      [ve]: Oe,
      [Fe]: le
    } = (te = I.value) == null ? void 0 : te.$el.getBoundingClientRect(), be = dG(K, he);
    let Pe = Math.min(Math.max((be - Oe - A.value) / le, 0), 1) || 0;
    return (ue ? c.value : c.value !== o.value) && (Pe = 1 - Pe), g(d.value + Pe * (f.value - d.value));
  }
  const V = (K) => {
    s({
      value: P(K)
    }), x.value = !1, A.value = 0;
  }, N = (K) => {
    E.value = a(K), E.value && (E.value.focus(), x.value = !0, E.value.contains(K.target) ? A.value = jg(K, E.value, t.direction) : (A.value = 0, r({
      value: P(K)
    })), i({
      value: P(K)
    }));
  }, F = {
    passive: !0,
    capture: !0
  };
  function $(K) {
    r({
      value: P(K)
    });
  }
  function Z(K) {
    K.stopPropagation(), K.preventDefault(), V(K), window.removeEventListener("mousemove", $, F), window.removeEventListener("mouseup", Z);
  }
  function j(K) {
    var ue;
    V(K), window.removeEventListener("touchmove", $, F), (ue = K.target) == null || ue.removeEventListener("touchend", j);
  }
  function H(K) {
    var ue;
    N(K), window.addEventListener("touchmove", $, F), (ue = K.target) == null || ue.addEventListener("touchend", j, {
      passive: !1
    });
  }
  function R(K) {
    K.preventDefault(), N(K), window.addEventListener("mousemove", $, F), window.addEventListener("mouseup", Z, {
      passive: !1
    });
  }
  const L = (K) => {
    const ue = (K - d.value) / (f.value - d.value) * 100;
    return Xt(isNaN(ue) ? 0 : ue, 0, 100);
  }, ne = G(t, "showTicks"), oe = b(() => ne.value ? t.ticks ? Array.isArray(t.ticks) ? t.ticks.map((K) => ({
    value: K,
    position: L(K),
    label: K.toString()
  })) : Object.keys(t.ticks).map((K) => ({
    value: parseFloat(K),
    position: L(parseFloat(K)),
    label: t.ticks[K]
  })) : T.value !== 1 / 0 ? Hr(T.value + 1).map((K) => {
    const ue = d.value + K * h.value;
    return {
      value: ue,
      position: L(ue)
    };
  }) : [] : []), we = b(() => oe.value.some((K) => {
    let {
      label: ue
    } = K;
    return !!ue;
  })), ee = {
    activeThumbRef: E,
    color: G(t, "color"),
    decimals: m,
    disabled: _,
    direction: G(t, "direction"),
    elevation: G(t, "elevation"),
    hasLabels: we,
    isReversed: l,
    indexFromEnd: c,
    min: d,
    max: f,
    mousePressed: x,
    numTicks: T,
    onSliderMousedown: R,
    onSliderTouchstart: H,
    parsedTicks: oe,
    parseMouseMove: P,
    position: L,
    readonly: G(t, "readonly"),
    rounded: G(t, "rounded"),
    roundValue: g,
    showTicks: ne,
    startOffset: A,
    step: h,
    thumbSize: p,
    thumbColor: w,
    thumbLabel: G(t, "thumbLabel"),
    ticks: G(t, "ticks"),
    tickSize: y,
    trackColor: S,
    trackContainerRef: I,
    trackFillColor: C,
    trackSize: k,
    vertical: u
  };
  return Tt(fb, ee), ee;
}, fG = B({
  focused: Boolean,
  max: {
    type: Number,
    required: !0
  },
  min: {
    type: Number,
    required: !0
  },
  modelValue: {
    type: Number,
    required: !0
  },
  position: {
    type: Number,
    required: !0
  },
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  ...ke()
}, "VSliderThumb"), Hg = J()({
  name: "VSliderThumb",
  directives: {
    Ripple: Vs
  },
  props: fG(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const r = tt(fb), {
      isRtl: s,
      rtlClasses: a
    } = wn();
    if (!r)
      throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
    const {
      thumbColor: o,
      step: l,
      disabled: u,
      thumbSize: c,
      thumbLabel: d,
      direction: f,
      isReversed: h,
      vertical: m,
      readonly: g,
      elevation: p,
      mousePressed: y,
      decimals: k,
      indexFromEnd: T
    } = r, _ = b(() => u.value ? void 0 : p.value), {
      elevationClasses: w
    } = On(_), {
      textColorClasses: S,
      textColorStyles: C
    } = $n(o), {
      pageup: x,
      pagedown: A,
      end: I,
      home: E,
      left: P,
      right: V,
      down: N,
      up: F
    } = Iv, $ = [x, A, I, E, P, V, N, F], Z = b(() => l.value ? [1, 2, 3] : [1, 5, 10]);
    function j(R, L) {
      if (!$.includes(R.key))
        return;
      R.preventDefault();
      const ne = l.value || 0.1, oe = (e.max - e.min) / ne;
      if ([P, V, N, F].includes(R.key)) {
        const ee = (m.value ? [s.value ? P : V, h.value ? N : F] : T.value !== s.value ? [P, F] : [V, F]).includes(R.key) ? 1 : -1, K = R.shiftKey ? 2 : R.ctrlKey ? 1 : 0;
        L = L + ee * ne * Z.value[K];
      } else if (R.key === E)
        L = e.min;
      else if (R.key === I)
        L = e.max;
      else {
        const we = R.key === A ? 1 : -1;
        L = L - we * ne * (oe > 100 ? oe / 10 : 10);
      }
      return Math.max(e.min, Math.min(e.max, L));
    }
    function H(R) {
      const L = j(R, e.modelValue);
      L != null && i("update:modelValue", L);
    }
    return re(() => {
      const R = _e(T.value ? 100 - e.position : e.position, "%");
      return v("div", {
        class: ["v-slider-thumb", {
          "v-slider-thumb--focused": e.focused,
          "v-slider-thumb--pressed": e.focused && y.value
        }, e.class, a.value],
        style: [{
          "--v-slider-thumb-position": R,
          "--v-slider-thumb-size": _e(c.value)
        }, e.style],
        role: "slider",
        tabindex: u.value ? -1 : 0,
        "aria-valuemin": e.min,
        "aria-valuemax": e.max,
        "aria-valuenow": e.modelValue,
        "aria-readonly": !!g.value,
        "aria-orientation": f.value,
        onKeydown: g.value ? void 0 : H
      }, [v("div", {
        class: ["v-slider-thumb__surface", S.value, w.value],
        style: {
          ...C.value
        }
      }, null), Rt(v("div", {
        class: ["v-slider-thumb__ripple", S.value],
        style: C.value
      }, null), [[Ei("ripple"), e.ripple, null, {
        circle: !0,
        center: !0
      }]]), v(mp, {
        origin: "bottom center"
      }, {
        default: () => {
          var L;
          return [Rt(v("div", {
            class: "v-slider-thumb__label-container"
          }, [v("div", {
            class: ["v-slider-thumb__label"]
          }, [v("div", null, [((L = n["thumb-label"]) == null ? void 0 : L.call(n, {
            modelValue: e.modelValue
          })) ?? e.modelValue.toFixed(l.value ? k.value : 1)])])]), [[Tr, d.value && e.focused || d.value === "always"]])];
        }
      })]);
    }), {};
  }
});
const hG = B({
  start: {
    type: Number,
    required: !0
  },
  stop: {
    type: Number,
    required: !0
  },
  ...ke()
}, "VSliderTrack"), zA = J()({
  name: "VSliderTrack",
  props: hG(),
  emits: {},
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = tt(fb);
    if (!i)
      throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
    const {
      color: r,
      parsedTicks: s,
      rounded: a,
      showTicks: o,
      tickSize: l,
      trackColor: u,
      trackFillColor: c,
      trackSize: d,
      vertical: f,
      min: h,
      max: m,
      indexFromEnd: g
    } = i, {
      roundedClasses: p
    } = Ht(a), {
      backgroundColorClasses: y,
      backgroundColorStyles: k
    } = gt(c), {
      backgroundColorClasses: T,
      backgroundColorStyles: _
    } = gt(u), w = b(() => `inset-${f.value ? "block" : "inline"}-${g.value ? "end" : "start"}`), S = b(() => f.value ? "height" : "width"), C = b(() => ({
      [w.value]: "0%",
      [S.value]: "100%"
    })), x = b(() => e.stop - e.start), A = b(() => ({
      [w.value]: _e(e.start, "%"),
      [S.value]: _e(x.value, "%")
    })), I = b(() => o.value ? (f.value ? s.value.slice().reverse() : s.value).map((P, V) => {
      var F;
      const N = P.value !== h.value && P.value !== m.value ? _e(P.position, "%") : void 0;
      return v("div", {
        key: P.value,
        class: ["v-slider-track__tick", {
          "v-slider-track__tick--filled": P.position >= e.start && P.position <= e.stop,
          "v-slider-track__tick--first": P.value === h.value,
          "v-slider-track__tick--last": P.value === m.value
        }],
        style: {
          [w.value]: N
        }
      }, [(P.label || n["tick-label"]) && v("div", {
        class: "v-slider-track__tick-label"
      }, [((F = n["tick-label"]) == null ? void 0 : F.call(n, {
        tick: P,
        index: V
      })) ?? P.label])]);
    }) : []);
    return re(() => v("div", {
      class: ["v-slider-track", p.value, e.class],
      style: [{
        "--v-slider-track-size": _e(d.value),
        "--v-slider-tick-size": _e(l.value)
      }, e.style]
    }, [v("div", {
      class: ["v-slider-track__background", T.value, {
        "v-slider-track__background--opacity": !!r.value || !c.value
      }],
      style: {
        ...C.value,
        ..._.value
      }
    }, null), v("div", {
      class: ["v-slider-track__fill", y.value],
      style: {
        ...A.value,
        ...k.value
      }
    }, null), o.value && v("div", {
      class: ["v-slider-track__ticks", {
        "v-slider-track__ticks--always-show": o.value === "always"
      }]
    }, [I.value])])), {};
  }
}), mG = B({
  ...Pc(),
  ...WA(),
  ...As(),
  modelValue: {
    type: [Number, String],
    default: 0
  }
}, "VSlider"), zg = J()({
  name: "VSlider",
  props: mG(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    start: (e) => !0,
    end: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const r = X(), {
      rtlClasses: s
    } = wn(), a = jA(e), o = Ee(e, "modelValue", void 0, (S) => a.roundValue(S ?? a.min.value)), {
      min: l,
      max: u,
      mousePressed: c,
      roundValue: d,
      onSliderMousedown: f,
      onSliderTouchstart: h,
      trackContainerRef: m,
      position: g,
      hasLabels: p,
      readonly: y
    } = HA({
      props: e,
      steps: a,
      onSliderStart: () => {
        i("start", o.value);
      },
      onSliderEnd: (S) => {
        let {
          value: C
        } = S;
        const x = d(C);
        o.value = x, i("end", x);
      },
      onSliderMove: (S) => {
        let {
          value: C
        } = S;
        return o.value = d(C);
      },
      getActiveThumb: () => {
        var S;
        return (S = r.value) == null ? void 0 : S.$el;
      }
    }), {
      isFocused: k,
      focus: T,
      blur: _
    } = xs(e), w = b(() => g(o.value));
    return re(() => {
      const S = Wn.filterProps(e), C = !!(e.label || n.label || n.prepend);
      return v(Wn, ie({
        class: ["v-slider", {
          "v-slider--has-labels": !!n["tick-label"] || p.value,
          "v-slider--focused": k.value,
          "v-slider--pressed": c.value,
          "v-slider--disabled": e.disabled
        }, s.value, e.class],
        style: e.style
      }, S, {
        focused: k.value
      }), {
        ...n,
        prepend: C ? (x) => {
          var A, I;
          return v(De, null, [((A = n.label) == null ? void 0 : A.call(n, x)) ?? (e.label ? v(Ll, {
            id: x.id.value,
            class: "v-slider__label",
            text: e.label
          }, null) : void 0), (I = n.prepend) == null ? void 0 : I.call(n, x)]);
        } : void 0,
        default: (x) => {
          let {
            id: A,
            messagesId: I
          } = x;
          return v("div", {
            class: "v-slider__container",
            onMousedown: y.value ? void 0 : f,
            onTouchstartPassive: y.value ? void 0 : h
          }, [v("input", {
            id: A.value,
            name: e.name || A.value,
            disabled: !!e.disabled,
            readonly: !!e.readonly,
            tabindex: "-1",
            value: o.value
          }, null), v(zA, {
            ref: m,
            start: 0,
            stop: w.value
          }, {
            "tick-label": n["tick-label"]
          }), v(Hg, {
            ref: r,
            "aria-describedby": I.value,
            focused: k.value,
            min: l.value,
            max: u.value,
            modelValue: o.value,
            "onUpdate:modelValue": (E) => o.value = E,
            position: w.value,
            elevation: e.elevation,
            onFocus: T,
            onBlur: _,
            ripple: e.ripple
          }, {
            "thumb-label": n["thumb-label"]
          })]);
        }
      });
    }), {};
  }
}), vG = B({
  color: {
    type: Object
  },
  disabled: Boolean,
  hideAlpha: Boolean,
  ...ke()
}, "VColorPickerPreview"), gG = Pi({
  name: "VColorPickerPreview",
  props: vG(),
  emits: {
    "update:color": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const i = new AbortController();
    eS(() => i.abort());
    async function r() {
      if (!Wb)
        return;
      const s = new window.EyeDropper();
      try {
        const a = await s.open({
          signal: i.signal
        }), o = SS(a.sRGBHex);
        n("update:color", {
          ...e.color ?? al,
          ...o
        });
      } catch {
      }
    }
    return re(() => {
      var s, a;
      return v("div", {
        class: ["v-color-picker-preview", {
          "v-color-picker-preview--hide-alpha": e.hideAlpha
        }, e.class],
        style: e.style
      }, [Wb && v("div", {
        class: "v-color-picker-preview__eye-dropper",
        key: "eyeDropper"
      }, [v(st, {
        onClick: r,
        icon: "$eyeDropper",
        variant: "plain",
        density: "comfortable"
      }, null)]), v("div", {
        class: "v-color-picker-preview__dot"
      }, [v("div", {
        style: {
          background: bS(e.color ?? al)
        }
      }, null)]), v("div", {
        class: "v-color-picker-preview__sliders"
      }, [v(zg, {
        class: "v-color-picker-preview__track v-color-picker-preview__hue",
        modelValue: (s = e.color) == null ? void 0 : s.h,
        "onUpdate:modelValue": (o) => n("update:color", {
          ...e.color ?? al,
          h: o
        }),
        step: 0,
        min: 0,
        max: 360,
        disabled: e.disabled,
        thumbSize: 14,
        trackSize: 8,
        trackFillColor: "white",
        hideDetails: !0
      }, null), !e.hideAlpha && v(zg, {
        class: "v-color-picker-preview__track v-color-picker-preview__alpha",
        modelValue: ((a = e.color) == null ? void 0 : a.a) ?? 1,
        "onUpdate:modelValue": (o) => n("update:color", {
          ...e.color ?? al,
          a: o
        }),
        step: 1 / 256,
        min: 0,
        max: 1,
        disabled: e.disabled,
        thumbSize: 14,
        trackSize: 8,
        trackFillColor: "white",
        hideDetails: !0
      }, null)])]);
    }), {};
  }
});
const pG = {
  base: "#f44336",
  lighten5: "#ffebee",
  lighten4: "#ffcdd2",
  lighten3: "#ef9a9a",
  lighten2: "#e57373",
  lighten1: "#ef5350",
  darken1: "#e53935",
  darken2: "#d32f2f",
  darken3: "#c62828",
  darken4: "#b71c1c",
  accent1: "#ff8a80",
  accent2: "#ff5252",
  accent3: "#ff1744",
  accent4: "#d50000"
}, yG = {
  base: "#e91e63",
  lighten5: "#fce4ec",
  lighten4: "#f8bbd0",
  lighten3: "#f48fb1",
  lighten2: "#f06292",
  lighten1: "#ec407a",
  darken1: "#d81b60",
  darken2: "#c2185b",
  darken3: "#ad1457",
  darken4: "#880e4f",
  accent1: "#ff80ab",
  accent2: "#ff4081",
  accent3: "#f50057",
  accent4: "#c51162"
}, bG = {
  base: "#9c27b0",
  lighten5: "#f3e5f5",
  lighten4: "#e1bee7",
  lighten3: "#ce93d8",
  lighten2: "#ba68c8",
  lighten1: "#ab47bc",
  darken1: "#8e24aa",
  darken2: "#7b1fa2",
  darken3: "#6a1b9a",
  darken4: "#4a148c",
  accent1: "#ea80fc",
  accent2: "#e040fb",
  accent3: "#d500f9",
  accent4: "#aa00ff"
}, wG = {
  base: "#673ab7",
  lighten5: "#ede7f6",
  lighten4: "#d1c4e9",
  lighten3: "#b39ddb",
  lighten2: "#9575cd",
  lighten1: "#7e57c2",
  darken1: "#5e35b1",
  darken2: "#512da8",
  darken3: "#4527a0",
  darken4: "#311b92",
  accent1: "#b388ff",
  accent2: "#7c4dff",
  accent3: "#651fff",
  accent4: "#6200ea"
}, _G = {
  base: "#3f51b5",
  lighten5: "#e8eaf6",
  lighten4: "#c5cae9",
  lighten3: "#9fa8da",
  lighten2: "#7986cb",
  lighten1: "#5c6bc0",
  darken1: "#3949ab",
  darken2: "#303f9f",
  darken3: "#283593",
  darken4: "#1a237e",
  accent1: "#8c9eff",
  accent2: "#536dfe",
  accent3: "#3d5afe",
  accent4: "#304ffe"
}, SG = {
  base: "#2196f3",
  lighten5: "#e3f2fd",
  lighten4: "#bbdefb",
  lighten3: "#90caf9",
  lighten2: "#64b5f6",
  lighten1: "#42a5f5",
  darken1: "#1e88e5",
  darken2: "#1976d2",
  darken3: "#1565c0",
  darken4: "#0d47a1",
  accent1: "#82b1ff",
  accent2: "#448aff",
  accent3: "#2979ff",
  accent4: "#2962ff"
}, kG = {
  base: "#03a9f4",
  lighten5: "#e1f5fe",
  lighten4: "#b3e5fc",
  lighten3: "#81d4fa",
  lighten2: "#4fc3f7",
  lighten1: "#29b6f6",
  darken1: "#039be5",
  darken2: "#0288d1",
  darken3: "#0277bd",
  darken4: "#01579b",
  accent1: "#80d8ff",
  accent2: "#40c4ff",
  accent3: "#00b0ff",
  accent4: "#0091ea"
}, CG = {
  base: "#00bcd4",
  lighten5: "#e0f7fa",
  lighten4: "#b2ebf2",
  lighten3: "#80deea",
  lighten2: "#4dd0e1",
  lighten1: "#26c6da",
  darken1: "#00acc1",
  darken2: "#0097a7",
  darken3: "#00838f",
  darken4: "#006064",
  accent1: "#84ffff",
  accent2: "#18ffff",
  accent3: "#00e5ff",
  accent4: "#00b8d4"
}, TG = {
  base: "#009688",
  lighten5: "#e0f2f1",
  lighten4: "#b2dfdb",
  lighten3: "#80cbc4",
  lighten2: "#4db6ac",
  lighten1: "#26a69a",
  darken1: "#00897b",
  darken2: "#00796b",
  darken3: "#00695c",
  darken4: "#004d40",
  accent1: "#a7ffeb",
  accent2: "#64ffda",
  accent3: "#1de9b6",
  accent4: "#00bfa5"
}, xG = {
  base: "#4caf50",
  lighten5: "#e8f5e9",
  lighten4: "#c8e6c9",
  lighten3: "#a5d6a7",
  lighten2: "#81c784",
  lighten1: "#66bb6a",
  darken1: "#43a047",
  darken2: "#388e3c",
  darken3: "#2e7d32",
  darken4: "#1b5e20",
  accent1: "#b9f6ca",
  accent2: "#69f0ae",
  accent3: "#00e676",
  accent4: "#00c853"
}, AG = {
  base: "#8bc34a",
  lighten5: "#f1f8e9",
  lighten4: "#dcedc8",
  lighten3: "#c5e1a5",
  lighten2: "#aed581",
  lighten1: "#9ccc65",
  darken1: "#7cb342",
  darken2: "#689f38",
  darken3: "#558b2f",
  darken4: "#33691e",
  accent1: "#ccff90",
  accent2: "#b2ff59",
  accent3: "#76ff03",
  accent4: "#64dd17"
}, IG = {
  base: "#cddc39",
  lighten5: "#f9fbe7",
  lighten4: "#f0f4c3",
  lighten3: "#e6ee9c",
  lighten2: "#dce775",
  lighten1: "#d4e157",
  darken1: "#c0ca33",
  darken2: "#afb42b",
  darken3: "#9e9d24",
  darken4: "#827717",
  accent1: "#f4ff81",
  accent2: "#eeff41",
  accent3: "#c6ff00",
  accent4: "#aeea00"
}, EG = {
  base: "#ffeb3b",
  lighten5: "#fffde7",
  lighten4: "#fff9c4",
  lighten3: "#fff59d",
  lighten2: "#fff176",
  lighten1: "#ffee58",
  darken1: "#fdd835",
  darken2: "#fbc02d",
  darken3: "#f9a825",
  darken4: "#f57f17",
  accent1: "#ffff8d",
  accent2: "#ffff00",
  accent3: "#ffea00",
  accent4: "#ffd600"
}, PG = {
  base: "#ffc107",
  lighten5: "#fff8e1",
  lighten4: "#ffecb3",
  lighten3: "#ffe082",
  lighten2: "#ffd54f",
  lighten1: "#ffca28",
  darken1: "#ffb300",
  darken2: "#ffa000",
  darken3: "#ff8f00",
  darken4: "#ff6f00",
  accent1: "#ffe57f",
  accent2: "#ffd740",
  accent3: "#ffc400",
  accent4: "#ffab00"
}, OG = {
  base: "#ff9800",
  lighten5: "#fff3e0",
  lighten4: "#ffe0b2",
  lighten3: "#ffcc80",
  lighten2: "#ffb74d",
  lighten1: "#ffa726",
  darken1: "#fb8c00",
  darken2: "#f57c00",
  darken3: "#ef6c00",
  darken4: "#e65100",
  accent1: "#ffd180",
  accent2: "#ffab40",
  accent3: "#ff9100",
  accent4: "#ff6d00"
}, VG = {
  base: "#ff5722",
  lighten5: "#fbe9e7",
  lighten4: "#ffccbc",
  lighten3: "#ffab91",
  lighten2: "#ff8a65",
  lighten1: "#ff7043",
  darken1: "#f4511e",
  darken2: "#e64a19",
  darken3: "#d84315",
  darken4: "#bf360c",
  accent1: "#ff9e80",
  accent2: "#ff6e40",
  accent3: "#ff3d00",
  accent4: "#dd2c00"
}, DG = {
  base: "#795548",
  lighten5: "#efebe9",
  lighten4: "#d7ccc8",
  lighten3: "#bcaaa4",
  lighten2: "#a1887f",
  lighten1: "#8d6e63",
  darken1: "#6d4c41",
  darken2: "#5d4037",
  darken3: "#4e342e",
  darken4: "#3e2723"
}, NG = {
  base: "#607d8b",
  lighten5: "#eceff1",
  lighten4: "#cfd8dc",
  lighten3: "#b0bec5",
  lighten2: "#90a4ae",
  lighten1: "#78909c",
  darken1: "#546e7a",
  darken2: "#455a64",
  darken3: "#37474f",
  darken4: "#263238"
}, MG = {
  base: "#9e9e9e",
  lighten5: "#fafafa",
  lighten4: "#f5f5f5",
  lighten3: "#eeeeee",
  lighten2: "#e0e0e0",
  lighten1: "#bdbdbd",
  darken1: "#757575",
  darken2: "#616161",
  darken3: "#424242",
  darken4: "#212121"
}, RG = {
  black: "#000000",
  white: "#ffffff",
  transparent: "#ffffff00"
}, FG = {
  red: pG,
  pink: yG,
  purple: bG,
  deepPurple: wG,
  indigo: _G,
  blue: SG,
  lightBlue: kG,
  cyan: CG,
  teal: TG,
  green: xG,
  lightGreen: AG,
  lime: IG,
  yellow: EG,
  amber: PG,
  orange: OG,
  deepOrange: VG,
  brown: DG,
  blueGrey: NG,
  grey: MG,
  shades: RG
}, BG = B({
  swatches: {
    type: Array,
    default: () => LG(FG)
  },
  disabled: Boolean,
  color: Object,
  maxHeight: [Number, String],
  ...ke()
}, "VColorPickerSwatches");
function LG(e) {
  return Object.keys(e).map((t) => {
    const n = e[t];
    return n.base ? [n.base, n.darken4, n.darken3, n.darken2, n.darken1, n.lighten1, n.lighten2, n.lighten3, n.lighten4, n.lighten5] : [n.black, n.white, n.transparent];
  });
}
const $G = Pi({
  name: "VColorPickerSwatches",
  props: BG(),
  emits: {
    "update:color": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    return re(() => v("div", {
      class: ["v-color-picker-swatches", e.class],
      style: [{
        maxHeight: _e(e.maxHeight)
      }, e.style]
    }, [v("div", null, [e.swatches.map((i) => v("div", {
      class: "v-color-picker-swatches__swatch"
    }, [i.map((r) => {
      const s = Hi(r), a = hh(s), o = yS(s);
      return v("div", {
        class: "v-color-picker-swatches__color",
        onClick: () => a && n("update:color", a)
      }, [v("div", {
        style: {
          background: o
        }
      }, [e.color && Yr(e.color, a) ? v(at, {
        size: "x-small",
        icon: "$success",
        color: FP(r, "#FFFFFF") > 2 ? "white" : "black"
      }, null) : void 0])]);
    })]))])])), {};
  }
});
const mm = B({
  color: String,
  ...Ni(),
  ...ke(),
  ...Sn(),
  ...gn(),
  ...ua(),
  ...su(),
  ...It(),
  ...je(),
  ...Qe()
}, "VSheet"), mo = J()({
  name: "VSheet",
  props: mm(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      backgroundColorClasses: r,
      backgroundColorStyles: s
    } = gt(G(e, "color")), {
      borderClasses: a
    } = er(e), {
      dimensionStyles: o
    } = kn(e), {
      elevationClasses: l
    } = On(e), {
      locationStyles: u
    } = yo(e), {
      positionClasses: c
    } = au(e), {
      roundedClasses: d
    } = Ht(e);
    return re(() => v(e.tag, {
      class: ["v-sheet", i.value, r.value, a.value, l.value, c.value, d.value, e.class],
      style: [s.value, o.value, u.value, e.style]
    }, n)), {};
  }
}), WG = B({
  canvasHeight: {
    type: [String, Number],
    default: 150
  },
  disabled: Boolean,
  dotSize: {
    type: [Number, String],
    default: 10
  },
  hideCanvas: Boolean,
  hideSliders: Boolean,
  hideInputs: Boolean,
  mode: {
    type: String,
    default: "rgba",
    validator: (e) => Object.keys(Ga).includes(e)
  },
  modes: {
    type: Array,
    default: () => Object.keys(Ga),
    validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(Ga).includes(t))
  },
  showSwatches: Boolean,
  swatches: Array,
  swatchesMaxHeight: {
    type: [Number, String],
    default: 150
  },
  modelValue: {
    type: [Object, String]
  },
  ...an(mm({
    width: 300
  }), ["height", "location", "minHeight", "maxHeight", "minWidth", "maxWidth"])
}, "VColorPicker"), jG = Pi({
  name: "VColorPicker",
  props: WG(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:mode": (e) => !0
  },
  setup(e) {
    const t = Ee(e, "mode"), n = X(null), i = Ee(e, "modelValue", void 0, (l) => {
      if (l == null || l === "")
        return null;
      let u;
      try {
        u = hh(Hi(l));
      } catch (c) {
        return pr(c), null;
      }
      return u;
    }, (l) => l ? rG(l, e.modelValue) : null), r = b(() => i.value ? {
      ...i.value,
      h: n.value ?? i.value.h
    } : null), {
      rtlClasses: s
    } = wn();
    let a = !0;
    fe(i, (l) => {
      if (!a) {
        a = !0;
        return;
      }
      l && (n.value = l.h);
    }, {
      immediate: !0
    });
    const o = (l) => {
      a = !1, n.value = l.h, i.value = l;
    };
    return En(() => {
      e.modes.includes(t.value) || (t.value = e.modes[0]);
    }), jt({
      VSlider: {
        color: void 0,
        trackColor: void 0,
        trackFillColor: void 0
      }
    }), re(() => {
      const l = mo.filterProps(e);
      return v(mo, ie({
        rounded: e.rounded,
        elevation: e.elevation,
        theme: e.theme,
        class: ["v-color-picker", s.value, e.class],
        style: [{
          "--v-color-picker-color-hsv": bS({
            ...r.value ?? al,
            a: 1
          })
        }, e.style]
      }, l, {
        maxWidth: e.width
      }), {
        default: () => [!e.hideCanvas && v(nG, {
          key: "canvas",
          color: r.value,
          "onUpdate:color": o,
          disabled: e.disabled,
          dotSize: e.dotSize,
          width: e.width,
          height: e.canvasHeight
        }, null), (!e.hideSliders || !e.hideInputs) && v("div", {
          key: "controls",
          class: "v-color-picker__controls"
        }, [!e.hideSliders && v(gG, {
          key: "preview",
          color: r.value,
          "onUpdate:color": o,
          hideAlpha: !t.value.endsWith("a"),
          disabled: e.disabled
        }, null), !e.hideInputs && v(cG, {
          key: "edit",
          modes: e.modes,
          mode: t.value,
          "onUpdate:mode": (u) => t.value = u,
          color: r.value,
          "onUpdate:color": o,
          disabled: e.disabled
        }, null)]), e.showSwatches && v($G, {
          key: "swatches",
          color: r.value,
          "onUpdate:color": o,
          maxHeight: e.swatchesMaxHeight,
          swatches: e.swatches,
          disabled: e.disabled
        }, null)]
      });
    }), {};
  }
});
function HG(e, t, n) {
  if (t == null)
    return e;
  if (Array.isArray(t))
    throw new Error("Multiple matches is not implemented");
  return typeof t == "number" && ~t ? v(De, null, [v("span", {
    class: "v-combobox__unmask"
  }, [e.substr(0, t)]), v("span", {
    class: "v-combobox__mask"
  }, [e.substr(t, n)]), v("span", {
    class: "v-combobox__unmask"
  }, [e.substr(t + n)])]) : e;
}
const zG = B({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: {
    type: Boolean,
    default: !0
  },
  delimiters: Array,
  ...cd({
    filterKeys: ["title"]
  }),
  ...ub({
    hideNoData: !0,
    returnObject: !0
  }),
  ...an(Sh({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...xr({
    transition: !1
  })
}, "VCombobox"), UG = J()({
  name: "VCombobox",
  props: zG(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:search": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, t) {
    var Oe;
    let {
      emit: n,
      slots: i
    } = t;
    const {
      t: r
    } = qt(), s = X(), a = pe(!1), o = pe(!0), l = pe(!1), u = X(), c = X(), d = Ee(e, "menu"), f = b({
      get: () => d.value,
      set: (le) => {
        var be;
        d.value && !le && ((be = u.value) != null && be.openChildren) || (d.value = le);
      }
    }), h = pe(-1);
    let m = !1;
    const g = b(() => {
      var le;
      return (le = s.value) == null ? void 0 : le.color;
    }), p = b(() => f.value ? e.closeText : e.openText), {
      items: y,
      transformIn: k,
      transformOut: T
    } = ib(e), {
      textColorClasses: _,
      textColorStyles: w
    } = $n(g), S = Ee(e, "modelValue", [], (le) => k(Nt(le)), (le) => {
      const be = T(le);
      return e.multiple ? be : be[0] ?? null;
    }), C = _h(), x = b(() => !!(e.chips || i.chip)), A = b(() => x.value || !!i.selection), I = pe(!e.multiple && !A.value ? ((Oe = S.value[0]) == null ? void 0 : Oe.title) ?? "" : ""), E = b({
      get: () => I.value,
      set: (le) => {
        var be;
        if (I.value = le ?? "", !e.multiple && !A.value && (S.value = [Gs(e, le)]), le && e.multiple && ((be = e.delimiters) != null && be.length)) {
          const Pe = le.split(new RegExp(`(?:${e.delimiters.join("|")})+`));
          Pe.length > 1 && (Pe.forEach((te) => {
            te = te.trim(), te && ue(Gs(e, te));
          }), I.value = "");
        }
        le || (h.value = -1), o.value = !le;
      }
    }), P = b(() => typeof e.counterValue == "function" ? e.counterValue(S.value) : typeof e.counterValue == "number" ? e.counterValue : e.multiple ? S.value.length : E.value.length);
    fe(I, (le) => {
      m ? He(() => m = !1) : a.value && !f.value && (f.value = !0), n("update:search", le);
    }), fe(S, (le) => {
      var be;
      !e.multiple && !A.value && (I.value = ((be = le[0]) == null ? void 0 : be.title) ?? "");
    });
    const {
      filteredItems: V,
      getMatches: N
    } = dd(e, y, () => o.value ? "" : E.value), F = b(() => e.hideSelected ? V.value.filter((le) => !S.value.some((be) => be.value === le.value)) : V.value), $ = b(() => S.value.map((le) => le.value)), Z = b(() => {
      var be;
      return (e.autoSelectFirst === !0 || e.autoSelectFirst === "exact" && E.value === ((be = F.value[0]) == null ? void 0 : be.title)) && F.value.length > 0 && !o.value && !l.value;
    }), j = b(() => e.hideNoData && !F.value.length || e.readonly || (C == null ? void 0 : C.isReadonly.value)), H = X(), {
      onListScroll: R,
      onListKeydown: L
    } = lb(H, s);
    function ne(le) {
      m = !0, e.openOnClear && (f.value = !0);
    }
    function oe() {
      j.value || (f.value = !0);
    }
    function we(le) {
      j.value || (a.value && (le.preventDefault(), le.stopPropagation()), f.value = !f.value);
    }
    function ee(le) {
      var te;
      if (lP(le) || e.readonly || C != null && C.isReadonly.value)
        return;
      const be = s.value.selectionStart, Pe = S.value.length;
      if ((h.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(le.key)) && le.preventDefault(), ["Enter", "ArrowDown"].includes(le.key) && (f.value = !0), ["Escape"].includes(le.key) && (f.value = !1), ["Enter", "Escape"].includes(le.key) && (Z.value && le.key === "Enter" && ue(V.value[0]), o.value = !0), le.key === "ArrowDown" && Z.value && ((te = H.value) == null || te.focus("next")), le.key === "Enter" && E.value && (ue(Gs(e, E.value)), A.value && (I.value = "")), ["Backspace", "Delete"].includes(le.key)) {
        if (!e.multiple && A.value && S.value.length > 0 && !E.value)
          return ue(S.value[0], !1);
        if (~h.value) {
          const me = h.value;
          ue(S.value[h.value], !1), h.value = me >= Pe - 1 ? Pe - 2 : me;
        } else
          le.key === "Backspace" && !E.value && (h.value = Pe - 1);
      }
      if (e.multiple) {
        if (le.key === "ArrowLeft") {
          if (h.value < 0 && be > 0)
            return;
          const me = h.value > -1 ? h.value - 1 : Pe - 1;
          S.value[me] ? h.value = me : (h.value = -1, s.value.setSelectionRange(E.value.length, E.value.length));
        }
        if (le.key === "ArrowRight") {
          if (h.value < 0)
            return;
          const me = h.value + 1;
          S.value[me] ? h.value = me : (h.value = -1, s.value.setSelectionRange(0, 0));
        }
      }
    }
    function K() {
      var le;
      a.value && (o.value = !0, (le = s.value) == null || le.focus());
    }
    function ue(le) {
      let be = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!(!le || le.props.disabled))
        if (e.multiple) {
          const Pe = S.value.findIndex((me) => e.valueComparator(me.value, le.value)), te = be ?? !~Pe;
          if (~Pe) {
            const me = te ? [...S.value, le] : [...S.value];
            me.splice(Pe, 1), S.value = me;
          } else
            te && (S.value = [...S.value, le]);
          e.clearOnSelect && (E.value = "");
        } else {
          const Pe = be !== !1;
          S.value = Pe ? [le] : [], I.value = Pe && !A.value ? le.title : "", He(() => {
            f.value = !1, o.value = !0;
          });
        }
    }
    function ve(le) {
      a.value = !0, setTimeout(() => {
        l.value = !0;
      });
    }
    function Fe(le) {
      l.value = !1;
    }
    function he(le) {
      (le == null || le === "" && !e.multiple && !A.value) && (S.value = []);
    }
    return fe(a, (le, be) => {
      if (!(le || le === be)) {
        if (h.value = -1, f.value = !1, Z.value && !l.value && !S.value.some((Pe) => {
          let {
            value: te
          } = Pe;
          return te === F.value[0].value;
        })) {
          ue(F.value[0]);
          return;
        }
        if (E.value) {
          if (e.multiple) {
            ue(Gs(e, E.value));
            return;
          }
          if (!A.value)
            return;
          S.value.some((Pe) => {
            let {
              title: te
            } = Pe;
            return te === E.value;
          }) ? I.value = "" : ue(Gs(e, E.value));
        }
      }
    }), fe(f, () => {
      if (!e.hideSelected && f.value && S.value.length) {
        const le = F.value.findIndex((be) => S.value.some((Pe) => e.valueComparator(Pe.value, be.value)));
        ft && window.requestAnimationFrame(() => {
          var be;
          le >= 0 && ((be = c.value) == null || be.scrollToIndex(le));
        });
      }
    }), fe(() => e.items, (le, be) => {
      f.value || a.value && !be.length && le.length && (f.value = !0);
    }), re(() => {
      const le = !!(!e.hideNoData || F.value.length || i["prepend-item"] || i["append-item"] || i["no-data"]), be = S.value.length > 0, Pe = gi.filterProps(e);
      return v(gi, ie({
        ref: s
      }, Pe, {
        modelValue: E.value,
        "onUpdate:modelValue": [(te) => E.value = te, he],
        focused: a.value,
        "onUpdate:focused": (te) => a.value = te,
        validationValue: S.externalValue,
        counterValue: P.value,
        dirty: be,
        class: ["v-combobox", {
          "v-combobox--active-menu": f.value,
          "v-combobox--chips": !!e.chips,
          "v-combobox--selection-slot": !!A.value,
          "v-combobox--selecting-index": h.value > -1,
          [`v-combobox--${e.multiple ? "multiple" : "single"}`]: !0
        }, e.class],
        style: e.style,
        readonly: e.readonly,
        placeholder: be ? void 0 : e.placeholder,
        "onClick:clear": ne,
        "onMousedown:control": oe,
        onKeydown: ee
      }), {
        ...i,
        default: () => v(De, null, [v(Ml, ie({
          ref: u,
          modelValue: f.value,
          "onUpdate:modelValue": (te) => f.value = te,
          activator: "parent",
          contentClass: "v-combobox__content",
          disabled: j.value,
          eager: e.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: e.transition,
          onAfterLeave: K
        }, e.menuProps), {
          default: () => [le && v(cm, ie({
            ref: H,
            selected: $.value,
            selectStrategy: e.multiple ? "independent" : "single-independent",
            onMousedown: (te) => te.preventDefault(),
            onKeydown: L,
            onFocusin: ve,
            onFocusout: Fe,
            onScrollPassive: R,
            tabindex: "-1",
            "aria-live": "polite",
            color: e.itemColor ?? e.color
          }, e.listProps), {
            default: () => {
              var te, me, Me;
              return [(te = i["prepend-item"]) == null ? void 0 : te.call(i), !F.value.length && !e.hideNoData && (((me = i["no-data"]) == null ? void 0 : me.call(i)) ?? v(Ts, {
                title: r(e.noDataText)
              }, null)), v(dm, {
                ref: c,
                renderless: !0,
                items: F.value
              }, {
                default: (Be) => {
                  var vt;
                  let {
                    item: xe,
                    index: ze,
                    itemRef: Ke
                  } = Be;
                  const ut = ie(xe.props, {
                    ref: Ke,
                    key: ze,
                    active: Z.value && ze === 0 ? !0 : void 0,
                    onClick: () => ue(xe, null)
                  });
                  return ((vt = i.item) == null ? void 0 : vt.call(i, {
                    item: xe,
                    index: ze,
                    props: ut
                  })) ?? v(Ts, ie(ut, {
                    role: "option"
                  }), {
                    prepend: (Vn) => {
                      let {
                        isSelected: Dn
                      } = Vn;
                      return v(De, null, [e.multiple && !e.hideSelected ? v(Cs, {
                        key: xe.value,
                        modelValue: Dn,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, xe.props.prependAvatar && v(Ji, {
                        image: xe.props.prependAvatar
                      }, null), xe.props.prependIcon && v(at, {
                        icon: xe.props.prependIcon
                      }, null)]);
                    },
                    title: () => {
                      var Vn, Dn;
                      return o.value ? xe.title : HG(xe.title, (Vn = N(xe)) == null ? void 0 : Vn.title, ((Dn = E.value) == null ? void 0 : Dn.length) ?? 0);
                    }
                  });
                }
              }), (Me = i["append-item"]) == null ? void 0 : Me.call(i)];
            }
          })]
        }), S.value.map((te, me) => {
          function Me(Ke) {
            Ke.stopPropagation(), Ke.preventDefault(), ue(te, !1);
          }
          const Be = {
            "onClick:close": Me,
            onKeydown(Ke) {
              Ke.key !== "Enter" && Ke.key !== " " || (Ke.preventDefault(), Ke.stopPropagation(), Me(Ke));
            },
            onMousedown(Ke) {
              Ke.preventDefault(), Ke.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, xe = x.value ? !!i.chip : !!i.selection, ze = xe ? fh(x.value ? i.chip({
            item: te,
            index: me,
            props: Be
          }) : i.selection({
            item: te,
            index: me
          })) : void 0;
          if (!(xe && !ze))
            return v("div", {
              key: te.value,
              class: ["v-combobox__selection", me === h.value && ["v-combobox__selection--selected", _.value]],
              style: me === h.value ? w.value : {}
            }, [x.value ? i.chip ? v(Ze, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: e.closableChips,
                  size: "small",
                  text: te.title
                }
              }
            }, {
              default: () => [ze]
            }) : v(ou, ie({
              key: "chip",
              closable: e.closableChips,
              size: "small",
              text: te.title,
              disabled: te.props.disabled
            }, Be), null) : ze ?? v("span", {
              class: "v-combobox__selection-text"
            }, [te.title, e.multiple && me < S.value.length - 1 && v("span", {
              class: "v-combobox__selection-comma"
            }, [_r(",")])])]);
        })]),
        "append-inner": function() {
          var Be;
          for (var te = arguments.length, me = new Array(te), Me = 0; Me < te; Me++)
            me[Me] = arguments[Me];
          return v(De, null, [(Be = i["append-inner"]) == null ? void 0 : Be.call(i, ...me), (!e.hideNoData || e.items.length) && e.menuIcon ? v(at, {
            class: "v-combobox__menu-icon",
            icon: e.menuIcon,
            onMousedown: we,
            onClick: dS,
            "aria-label": r(p.value),
            title: r(p.value),
            tabindex: "-1"
          }, null) : void 0]);
        }
      });
    }), Qi({
      isFocused: a,
      isPristine: o,
      menu: f,
      search: E,
      selectionIndex: h,
      filteredItems: V,
      select: ue
    }, s);
  }
}), qG = B({
  modelValue: null,
  color: String,
  cancelText: {
    type: String,
    default: "$vuetify.confirmEdit.cancel"
  },
  okText: {
    type: String,
    default: "$vuetify.confirmEdit.ok"
  }
}, "VConfirmEdit"), GG = J()({
  name: "VConfirmEdit",
  props: qG(),
  emits: {
    cancel: () => !0,
    save: (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const r = Ee(e, "modelValue"), s = X();
    Wt(() => {
      s.value = structuredClone(si(r.value));
    });
    const {
      t: a
    } = qt(), o = b(() => Yr(r.value, s.value));
    function l() {
      r.value = s.value, n("save", s.value);
    }
    function u() {
      s.value = structuredClone(si(r.value)), n("cancel");
    }
    let c = !1;
    return re(() => {
      var f;
      const d = v(De, null, [v(st, {
        disabled: o.value,
        variant: "text",
        color: e.color,
        onClick: u,
        text: a(e.cancelText)
      }, null), v(st, {
        disabled: o.value,
        variant: "text",
        color: e.color,
        onClick: l,
        text: a(e.okText)
      }, null)]);
      return v(De, null, [(f = i.default) == null ? void 0 : f.call(i, {
        model: s,
        save: l,
        cancel: u,
        isPristine: o.value,
        get actions() {
          return c = !0, d;
        }
      }), !c && d]);
    }), {
      save: l,
      cancel: u,
      isPristine: o
    };
  }
}), UA = B({
  expandOnClick: Boolean,
  showExpand: Boolean,
  expanded: {
    type: Array,
    default: () => []
  }
}, "DataTable-expand"), qA = Symbol.for("vuetify:datatable:expanded");
function vm(e) {
  const t = G(e, "expandOnClick"), n = Ee(e, "expanded", e.expanded, (o) => new Set(o), (o) => [...o.values()]);
  function i(o, l) {
    const u = new Set(n.value);
    l ? u.add(o.value) : u.delete(o.value), n.value = u;
  }
  function r(o) {
    return n.value.has(o.value);
  }
  function s(o) {
    i(o, !r(o));
  }
  const a = {
    expand: i,
    expanded: n,
    expandOnClick: t,
    isExpanded: r,
    toggleExpand: s
  };
  return Tt(qA, a), a;
}
function GA() {
  const e = tt(qA);
  if (!e)
    throw new Error("foo");
  return e;
}
const hb = B({
  groupBy: {
    type: Array,
    default: () => []
  }
}, "DataTable-group"), YA = Symbol.for("vuetify:data-table-group");
function mb(e) {
  return {
    groupBy: Ee(e, "groupBy")
  };
}
function gm(e) {
  const {
    groupBy: t,
    sortBy: n
  } = e, i = X(/* @__PURE__ */ new Set()), r = b(() => t.value.map((u) => ({
    ...u,
    order: u.order ?? !1
  })).concat(n.value));
  function s(u) {
    return i.value.has(u.id);
  }
  function a(u) {
    const c = new Set(i.value);
    s(u) ? c.delete(u.id) : c.add(u.id), i.value = c;
  }
  function o(u) {
    function c(d) {
      const f = [];
      for (const h of d.items)
        "type" in h && h.type === "group" ? f.push(...c(h)) : f.push(h);
      return f;
    }
    return c({
      type: "group",
      items: u,
      id: "dummy",
      key: "dummy",
      value: "dummy",
      depth: 0
    });
  }
  const l = {
    sortByWithGroups: r,
    toggleGroup: a,
    opened: i,
    groupBy: t,
    extractRows: o,
    isGroupOpen: s
  };
  return Tt(YA, l), l;
}
function ZA() {
  const e = tt(YA);
  if (!e)
    throw new Error("Missing group!");
  return e;
}
function YG(e, t) {
  if (!e.length)
    return [];
  const n = /* @__PURE__ */ new Map();
  for (const i of e) {
    const r = Hu(i.raw, t);
    n.has(r) || n.set(r, []), n.get(r).push(i);
  }
  return n;
}
function KA(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "root";
  if (!t.length)
    return [];
  const r = YG(e, t[0]), s = [], a = t.slice(1);
  return r.forEach((o, l) => {
    const u = t[0], c = `${i}_${u}_${l}`;
    s.push({
      depth: n,
      id: c,
      key: u,
      value: l,
      items: a.length ? KA(o, a, n + 1, c) : o,
      type: "group"
    });
  }), s;
}
function XA(e, t) {
  const n = [];
  for (const i of e)
    "type" in i && i.type === "group" ? (i.value != null && n.push(i), (t.has(i.id) || i.value == null) && n.push(...XA(i.items, t))) : n.push(i);
  return n;
}
function pm(e, t, n) {
  return {
    flatItems: b(() => {
      if (!t.value.length)
        return e.value;
      const r = KA(e.value, t.value.map((s) => s.key));
      return XA(r, n.value);
    })
  };
}
function ym(e) {
  let {
    page: t,
    itemsPerPage: n,
    sortBy: i,
    groupBy: r,
    search: s
  } = e;
  const a = Ut("VDataTable"), o = b(() => ({
    page: t.value,
    itemsPerPage: n.value,
    sortBy: i.value,
    groupBy: r.value,
    search: s.value
  }));
  let l = null;
  fe(o, () => {
    Yr(l, o.value) || (l && l.search !== o.value.search && (t.value = 1), a.emit("update:options", o.value), l = o.value);
  }, {
    deep: !0,
    immediate: !0
  });
}
const vb = B({
  page: {
    type: [Number, String],
    default: 1
  },
  itemsPerPage: {
    type: [Number, String],
    default: 10
  }
}, "DataTable-paginate"), JA = Symbol.for("vuetify:data-table-pagination");
function gb(e) {
  const t = Ee(e, "page", void 0, (i) => +(i ?? 1)), n = Ee(e, "itemsPerPage", void 0, (i) => +(i ?? 10));
  return {
    page: t,
    itemsPerPage: n
  };
}
function pb(e) {
  const {
    page: t,
    itemsPerPage: n,
    itemsLength: i
  } = e, r = b(() => n.value === -1 ? 0 : n.value * (t.value - 1)), s = b(() => n.value === -1 ? i.value : Math.min(i.value, r.value + n.value)), a = b(() => n.value === -1 || i.value === 0 ? 1 : Math.ceil(i.value / n.value));
  Wt(() => {
    t.value > a.value && (t.value = a.value);
  });
  function o(f) {
    n.value = f, t.value = 1;
  }
  function l() {
    t.value = Xt(t.value + 1, 1, a.value);
  }
  function u() {
    t.value = Xt(t.value - 1, 1, a.value);
  }
  function c(f) {
    t.value = Xt(f, 1, a.value);
  }
  const d = {
    page: t,
    itemsPerPage: n,
    startIndex: r,
    stopIndex: s,
    pageCount: a,
    itemsLength: i,
    nextPage: l,
    prevPage: u,
    setPage: c,
    setItemsPerPage: o
  };
  return Tt(JA, d), d;
}
function ZG() {
  const e = tt(JA);
  if (!e)
    throw new Error("Missing pagination!");
  return e;
}
function QA(e) {
  const t = Ut("usePaginatedItems"), {
    items: n,
    startIndex: i,
    stopIndex: r,
    itemsPerPage: s
  } = e, a = b(() => s.value <= 0 ? n.value : n.value.slice(i.value, r.value));
  return fe(a, (o) => {
    t.emit("update:currentItems", o);
  }), {
    paginatedItems: a
  };
}
const KG = {
  showSelectAll: !1,
  allSelected: () => [],
  select: (e) => {
    var i;
    let {
      items: t,
      value: n
    } = e;
    return new Set(n ? [(i = t[0]) == null ? void 0 : i.value] : []);
  },
  selectAll: (e) => {
    let {
      selected: t
    } = e;
    return t;
  }
}, eI = {
  showSelectAll: !0,
  allSelected: (e) => {
    let {
      currentPage: t
    } = e;
    return t;
  },
  select: (e) => {
    let {
      items: t,
      value: n,
      selected: i
    } = e;
    for (const r of t)
      n ? i.add(r.value) : i.delete(r.value);
    return i;
  },
  selectAll: (e) => {
    let {
      value: t,
      currentPage: n,
      selected: i
    } = e;
    return eI.select({
      items: n,
      value: t,
      selected: i
    });
  }
}, tI = {
  showSelectAll: !0,
  allSelected: (e) => {
    let {
      allItems: t
    } = e;
    return t;
  },
  select: (e) => {
    let {
      items: t,
      value: n,
      selected: i
    } = e;
    for (const r of t)
      n ? i.add(r.value) : i.delete(r.value);
    return i;
  },
  selectAll: (e) => {
    let {
      value: t,
      allItems: n,
      selected: i
    } = e;
    return tI.select({
      items: n,
      value: t,
      selected: i
    });
  }
}, nI = B({
  showSelect: Boolean,
  selectStrategy: {
    type: [String, Object],
    default: "page"
  },
  modelValue: {
    type: Array,
    default: () => []
  },
  valueComparator: {
    type: Function,
    default: Yr
  }
}, "DataTable-select"), iI = Symbol.for("vuetify:data-table-selection");
function bm(e, t) {
  let {
    allItems: n,
    currentPage: i
  } = t;
  const r = Ee(e, "modelValue", e.modelValue, (y) => new Set(Nt(y).map((k) => {
    var T;
    return ((T = n.value.find((_) => e.valueComparator(k, _.value))) == null ? void 0 : T.value) ?? k;
  })), (y) => [...y.values()]), s = b(() => n.value.filter((y) => y.selectable)), a = b(() => i.value.filter((y) => y.selectable)), o = b(() => {
    if (typeof e.selectStrategy == "object")
      return e.selectStrategy;
    switch (e.selectStrategy) {
      case "single":
        return KG;
      case "all":
        return tI;
      case "page":
      default:
        return eI;
    }
  });
  function l(y) {
    return Nt(y).every((k) => r.value.has(k.value));
  }
  function u(y) {
    return Nt(y).some((k) => r.value.has(k.value));
  }
  function c(y, k) {
    const T = o.value.select({
      items: y,
      value: k,
      selected: new Set(r.value)
    });
    r.value = T;
  }
  function d(y) {
    c([y], !l([y]));
  }
  function f(y) {
    const k = o.value.selectAll({
      value: y,
      allItems: s.value,
      currentPage: a.value,
      selected: new Set(r.value)
    });
    r.value = k;
  }
  const h = b(() => r.value.size > 0), m = b(() => {
    const y = o.value.allSelected({
      allItems: s.value,
      currentPage: a.value
    });
    return !!y.length && l(y);
  }), g = b(() => o.value.showSelectAll), p = {
    toggleSelect: d,
    select: c,
    selectAll: f,
    isSelected: l,
    isSomeSelected: u,
    someSelected: h,
    allSelected: m,
    showSelectAll: g
  };
  return Tt(iI, p), p;
}
function wm() {
  const e = tt(iI);
  if (!e)
    throw new Error("Missing selection!");
  return e;
}
const rI = B({
  sortBy: {
    type: Array,
    default: () => []
  },
  customKeySort: Object,
  multiSort: Boolean,
  mustSort: Boolean
}, "DataTable-sort"), sI = Symbol.for("vuetify:data-table-sort");
function _m(e) {
  const t = Ee(e, "sortBy"), n = G(e, "mustSort"), i = G(e, "multiSort");
  return {
    sortBy: t,
    mustSort: n,
    multiSort: i
  };
}
function Sm(e) {
  const {
    sortBy: t,
    mustSort: n,
    multiSort: i,
    page: r
  } = e, s = (l) => {
    if (l.key == null)
      return;
    let u = t.value.map((d) => ({
      ...d
    })) ?? [];
    const c = u.find((d) => d.key === l.key);
    c ? c.order === "desc" ? n.value ? c.order = "asc" : u = u.filter((d) => d.key !== l.key) : c.order = "desc" : i.value ? u = [...u, {
      key: l.key,
      order: "asc"
    }] : u = [{
      key: l.key,
      order: "asc"
    }], t.value = u, r && (r.value = 1);
  };
  function a(l) {
    return !!t.value.find((u) => u.key === l.key);
  }
  const o = {
    sortBy: t,
    toggleSort: s,
    isSorted: a
  };
  return Tt(sI, o), o;
}
function aI() {
  const e = tt(sI);
  if (!e)
    throw new Error("Missing sort!");
  return e;
}
function yb(e, t, n, i) {
  const r = qt();
  return {
    sortedItems: b(() => {
      var a, o;
      return !n.value.length || e.disableSort ? t.value : XG(t.value, n.value, r.current.value, {
        transform: i == null ? void 0 : i.transform,
        sortFunctions: {
          ...e.customKeySort,
          ...(a = i == null ? void 0 : i.sortFunctions) == null ? void 0 : a.value
        },
        sortRawFunctions: (o = i == null ? void 0 : i.sortRawFunctions) == null ? void 0 : o.value
      });
    })
  };
}
function XG(e, t, n, i) {
  const r = new Intl.Collator(n, {
    sensitivity: "accent",
    usage: "sort"
  });
  return e.map((a) => [a, i != null && i.transform ? i.transform(a) : a]).sort((a, o) => {
    var l, u;
    for (let c = 0; c < t.length; c++) {
      let d = !1;
      const f = t[c].key, h = t[c].order ?? "asc";
      if (h === !1)
        continue;
      let m = a[1][f], g = o[1][f], p = a[0].raw, y = o[0].raw;
      if (h === "desc" && ([m, g] = [g, m], [p, y] = [y, p]), (l = i == null ? void 0 : i.sortRawFunctions) != null && l[f]) {
        const k = i.sortRawFunctions[f](p, y);
        if (k == null)
          continue;
        if (d = !0, k)
          return k;
      }
      if ((u = i == null ? void 0 : i.sortFunctions) != null && u[f]) {
        const k = i.sortFunctions[f](m, g);
        if (k == null)
          continue;
        if (d = !0, k)
          return k;
      }
      if (!d) {
        if (m instanceof Date && g instanceof Date)
          return m.getTime() - g.getTime();
        if ([m, g] = [m, g].map((k) => k != null ? k.toString().toLocaleLowerCase() : k), m !== g)
          return pd(m) && pd(g) ? 0 : pd(m) ? -1 : pd(g) ? 1 : !isNaN(m) && !isNaN(g) ? Number(m) - Number(g) : r.compare(m, g);
      }
    }
    return 0;
  }).map((a) => {
    let [o] = a;
    return o;
  });
}
const JG = B({
  items: {
    type: Array,
    default: () => []
  },
  itemValue: {
    type: [String, Array, Function],
    default: "id"
  },
  itemSelectable: {
    type: [String, Array, Function],
    default: null
  },
  returnObject: Boolean
}, "DataIterator-items");
function QG(e, t) {
  const n = e.returnObject ? t : hn(t, e.itemValue), i = hn(t, e.itemSelectable, !0);
  return {
    type: "item",
    value: n,
    selectable: i,
    raw: t
  };
}
function e8(e, t) {
  const n = [];
  for (const i of t)
    n.push(QG(e, i));
  return n;
}
function t8(e) {
  return {
    items: b(() => e8(e, e.items))
  };
}
const n8 = B({
  search: String,
  loading: Boolean,
  ...ke(),
  ...JG(),
  ...nI(),
  ...rI(),
  ...vb({
    itemsPerPage: 5
  }),
  ...UA(),
  ...hb(),
  ...cd(),
  ...je(),
  ...xr({
    transition: {
      component: Gu,
      hideOnLeave: !0
    }
  })
}, "VDataIterator"), i8 = J()({
  name: "VDataIterator",
  props: n8(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:groupBy": (e) => !0,
    "update:page": (e) => !0,
    "update:itemsPerPage": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:expanded": (e) => !0,
    "update:currentItems": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "groupBy"), r = G(e, "search"), {
      items: s
    } = t8(e), {
      filteredItems: a
    } = dd(e, s, r, {
      transform: (L) => L.raw
    }), {
      sortBy: o,
      multiSort: l,
      mustSort: u
    } = _m(e), {
      page: c,
      itemsPerPage: d
    } = gb(e), {
      toggleSort: f
    } = Sm({
      sortBy: o,
      multiSort: l,
      mustSort: u,
      page: c
    }), {
      sortByWithGroups: h,
      opened: m,
      extractRows: g,
      isGroupOpen: p,
      toggleGroup: y
    } = gm({
      groupBy: i,
      sortBy: o
    }), {
      sortedItems: k
    } = yb(e, a, h, {
      transform: (L) => L.raw
    }), {
      flatItems: T
    } = pm(k, i, m), _ = b(() => T.value.length), {
      startIndex: w,
      stopIndex: S,
      pageCount: C,
      prevPage: x,
      nextPage: A,
      setItemsPerPage: I,
      setPage: E
    } = pb({
      page: c,
      itemsPerPage: d,
      itemsLength: _
    }), {
      paginatedItems: P
    } = QA({
      items: T,
      startIndex: w,
      stopIndex: S,
      itemsPerPage: d
    }), V = b(() => g(P.value)), {
      isSelected: N,
      select: F,
      selectAll: $,
      toggleSelect: Z
    } = bm(e, {
      allItems: s,
      currentPage: V
    }), {
      isExpanded: j,
      toggleExpand: H
    } = vm(e);
    ym({
      page: c,
      itemsPerPage: d,
      sortBy: o,
      groupBy: i,
      search: r
    });
    const R = b(() => ({
      page: c.value,
      itemsPerPage: d.value,
      sortBy: o.value,
      pageCount: C.value,
      toggleSort: f,
      prevPage: x,
      nextPage: A,
      setPage: E,
      setItemsPerPage: I,
      isSelected: N,
      select: F,
      selectAll: $,
      toggleSelect: Z,
      isExpanded: j,
      toggleExpand: H,
      isGroupOpen: p,
      toggleGroup: y,
      items: V.value,
      groupedItems: P.value
    }));
    return re(() => v(e.tag, {
      class: ["v-data-iterator", {
        "v-data-iterator--loading": e.loading
      }, e.class],
      style: e.style
    }, {
      default: () => {
        var L, ne;
        return [(L = n.header) == null ? void 0 : L.call(n, R.value), v(Gn, {
          transition: e.transition
        }, {
          default: () => {
            var oe, we;
            return [e.loading ? v(Vc, {
              key: "loader",
              name: "v-data-iterator",
              active: !0
            }, {
              default: (ee) => {
                var K;
                return (K = n.loader) == null ? void 0 : K.call(n, ee);
              }
            }) : v("div", {
              key: "items"
            }, [P.value.length ? (we = n.default) == null ? void 0 : we.call(n, R.value) : (oe = n["no-data"]) == null ? void 0 : oe.call(n)])];
          }
        }), (ne = n.footer) == null ? void 0 : ne.call(n, R.value)];
      }
    })), {};
  }
});
function r8() {
  const e = X([]);
  tP(() => e.value = []);
  function t(n, i) {
    e.value[i] = n;
  }
  return {
    refs: e,
    updateRef: t
  };
}
const s8 = B({
  activeColor: String,
  start: {
    type: [Number, String],
    default: 1
  },
  modelValue: {
    type: Number,
    default: (e) => e.start
  },
  disabled: Boolean,
  length: {
    type: [Number, String],
    default: 1,
    validator: (e) => e % 1 === 0
  },
  totalVisible: [Number, String],
  firstIcon: {
    type: We,
    default: "$first"
  },
  prevIcon: {
    type: We,
    default: "$prev"
  },
  nextIcon: {
    type: We,
    default: "$next"
  },
  lastIcon: {
    type: We,
    default: "$last"
  },
  ariaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.root"
  },
  pageAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.page"
  },
  currentPageAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.currentPage"
  },
  firstAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.first"
  },
  previousAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.previous"
  },
  nextAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.next"
  },
  lastAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.last"
  },
  ellipsis: {
    type: String,
    default: "..."
  },
  showFirstLastPage: Boolean,
  ...Ni(),
  ...ke(),
  ..._n(),
  ...gn(),
  ...It(),
  ...Xr(),
  ...je({
    tag: "nav"
  }),
  ...Qe(),
  ...tr({
    variant: "text"
  })
}, "VPagination"), Ug = J()({
  name: "VPagination",
  props: s8(),
  emits: {
    "update:modelValue": (e) => !0,
    first: (e) => !0,
    prev: (e) => !0,
    next: (e) => !0,
    last: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const r = Ee(e, "modelValue"), {
      t: s,
      n: a
    } = qt(), {
      isRtl: o
    } = wn(), {
      themeClasses: l
    } = lt(e), {
      width: u
    } = Ar(), c = pe(-1);
    jt(void 0, {
      scoped: !0
    });
    const {
      resizeRef: d
    } = Sr((x) => {
      if (!x.length)
        return;
      const {
        target: A,
        contentRect: I
      } = x[0], E = A.querySelector(".v-pagination__list > *");
      if (!E)
        return;
      const P = I.width, V = E.offsetWidth + parseFloat(getComputedStyle(E).marginRight) * 2;
      c.value = g(P, V);
    }), f = b(() => parseInt(e.length, 10)), h = b(() => parseInt(e.start, 10)), m = b(() => e.totalVisible != null ? parseInt(e.totalVisible, 10) : c.value >= 0 ? c.value : g(u.value, 58));
    function g(x, A) {
      const I = e.showFirstLastPage ? 5 : 3;
      return Math.max(0, Math.floor(
        // Round to two decimal places to avoid floating point errors
        +((x - A * I) / A).toFixed(2)
      ));
    }
    const p = b(() => {
      if (f.value <= 0 || isNaN(f.value) || f.value > Number.MAX_SAFE_INTEGER)
        return [];
      if (m.value <= 0)
        return [];
      if (m.value === 1)
        return [r.value];
      if (f.value <= m.value)
        return Hr(f.value, h.value);
      const x = m.value % 2 === 0, A = x ? m.value / 2 : Math.floor(m.value / 2), I = x ? A : A + 1, E = f.value - A;
      if (I - r.value >= 0)
        return [...Hr(Math.max(1, m.value - 1), h.value), e.ellipsis, f.value];
      if (r.value - E >= (x ? 1 : 0)) {
        const P = m.value - 1, V = f.value - P + h.value;
        return [h.value, e.ellipsis, ...Hr(P, V)];
      } else {
        const P = Math.max(1, m.value - 3), V = P === 1 ? r.value : r.value - Math.ceil(P / 2) + h.value;
        return [h.value, e.ellipsis, ...Hr(P, V), e.ellipsis, f.value];
      }
    });
    function y(x, A, I) {
      x.preventDefault(), r.value = A, I && i(I, A);
    }
    const {
      refs: k,
      updateRef: T
    } = r8();
    jt({
      VPaginationBtn: {
        color: G(e, "color"),
        border: G(e, "border"),
        density: G(e, "density"),
        size: G(e, "size"),
        variant: G(e, "variant"),
        rounded: G(e, "rounded"),
        elevation: G(e, "elevation")
      }
    });
    const _ = b(() => p.value.map((x, A) => {
      const I = (E) => T(E, A);
      if (typeof x == "string")
        return {
          isActive: !1,
          key: `ellipsis-${A}`,
          page: x,
          props: {
            ref: I,
            ellipsis: !0,
            icon: !0,
            disabled: !0
          }
        };
      {
        const E = x === r.value;
        return {
          isActive: E,
          key: x,
          page: a(x),
          props: {
            ref: I,
            ellipsis: !1,
            icon: !0,
            disabled: !!e.disabled || +e.length < 2,
            color: E ? e.activeColor : e.color,
            "aria-current": E,
            "aria-label": s(E ? e.currentPageAriaLabel : e.pageAriaLabel, x),
            onClick: (P) => y(P, x)
          }
        };
      }
    })), w = b(() => {
      const x = !!e.disabled || r.value <= h.value, A = !!e.disabled || r.value >= h.value + f.value - 1;
      return {
        first: e.showFirstLastPage ? {
          icon: o.value ? e.lastIcon : e.firstIcon,
          onClick: (I) => y(I, h.value, "first"),
          disabled: x,
          "aria-label": s(e.firstAriaLabel),
          "aria-disabled": x
        } : void 0,
        prev: {
          icon: o.value ? e.nextIcon : e.prevIcon,
          onClick: (I) => y(I, r.value - 1, "prev"),
          disabled: x,
          "aria-label": s(e.previousAriaLabel),
          "aria-disabled": x
        },
        next: {
          icon: o.value ? e.prevIcon : e.nextIcon,
          onClick: (I) => y(I, r.value + 1, "next"),
          disabled: A,
          "aria-label": s(e.nextAriaLabel),
          "aria-disabled": A
        },
        last: e.showFirstLastPage ? {
          icon: o.value ? e.firstIcon : e.lastIcon,
          onClick: (I) => y(I, h.value + f.value - 1, "last"),
          disabled: A,
          "aria-label": s(e.lastAriaLabel),
          "aria-disabled": A
        } : void 0
      };
    });
    function S() {
      var A;
      const x = r.value - h.value;
      (A = k.value[x]) == null || A.$el.focus();
    }
    function C(x) {
      x.key === Iv.left && !e.disabled && r.value > +e.start ? (r.value = r.value - 1, He(S)) : x.key === Iv.right && !e.disabled && r.value < h.value + f.value - 1 && (r.value = r.value + 1, He(S));
    }
    return re(() => v(e.tag, {
      ref: d,
      class: ["v-pagination", l.value, e.class],
      style: e.style,
      role: "navigation",
      "aria-label": s(e.ariaLabel),
      onKeydown: C,
      "data-test": "v-pagination-root"
    }, {
      default: () => [v("ul", {
        class: "v-pagination__list"
      }, [e.showFirstLastPage && v("li", {
        key: "first",
        class: "v-pagination__first",
        "data-test": "v-pagination-first"
      }, [n.first ? n.first(w.value.first) : v(st, ie({
        _as: "VPaginationBtn"
      }, w.value.first), null)]), v("li", {
        key: "prev",
        class: "v-pagination__prev",
        "data-test": "v-pagination-prev"
      }, [n.prev ? n.prev(w.value.prev) : v(st, ie({
        _as: "VPaginationBtn"
      }, w.value.prev), null)]), _.value.map((x, A) => v("li", {
        key: x.key,
        class: ["v-pagination__item", {
          "v-pagination__item--is-active": x.isActive
        }],
        "data-test": "v-pagination-item"
      }, [n.item ? n.item(x) : v(st, ie({
        _as: "VPaginationBtn"
      }, x.props), {
        default: () => [x.page]
      })])), v("li", {
        key: "next",
        class: "v-pagination__next",
        "data-test": "v-pagination-next"
      }, [n.next ? n.next(w.value.next) : v(st, ie({
        _as: "VPaginationBtn"
      }, w.value.next), null)]), e.showFirstLastPage && v("li", {
        key: "last",
        class: "v-pagination__last",
        "data-test": "v-pagination-last"
      }, [n.last ? n.last(w.value.last) : v(st, ie({
        _as: "VPaginationBtn"
      }, w.value.last), null)])])]
    })), {};
  }
}), bb = B({
  prevIcon: {
    type: String,
    default: "$prev"
  },
  nextIcon: {
    type: String,
    default: "$next"
  },
  firstIcon: {
    type: String,
    default: "$first"
  },
  lastIcon: {
    type: String,
    default: "$last"
  },
  itemsPerPageText: {
    type: String,
    default: "$vuetify.dataFooter.itemsPerPageText"
  },
  pageText: {
    type: String,
    default: "$vuetify.dataFooter.pageText"
  },
  firstPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.firstPage"
  },
  prevPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.prevPage"
  },
  nextPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.nextPage"
  },
  lastPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.lastPage"
  },
  itemsPerPageOptions: {
    type: Array,
    default: () => [{
      value: 10,
      title: "10"
    }, {
      value: 25,
      title: "25"
    }, {
      value: 50,
      title: "50"
    }, {
      value: 100,
      title: "100"
    }, {
      value: -1,
      title: "$vuetify.dataFooter.itemsPerPageAll"
    }]
  },
  showCurrentPage: Boolean
}, "VDataTableFooter"), Ac = J()({
  name: "VDataTableFooter",
  props: bb(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: i
    } = qt(), {
      page: r,
      pageCount: s,
      startIndex: a,
      stopIndex: o,
      itemsLength: l,
      itemsPerPage: u,
      setItemsPerPage: c
    } = ZG(), d = b(() => e.itemsPerPageOptions.map((f) => typeof f == "number" ? {
      value: f,
      title: f === -1 ? i("$vuetify.dataFooter.itemsPerPageAll") : String(f)
    } : {
      ...f,
      title: isNaN(Number(f.title)) ? i(f.title) : f.title
    }));
    return re(() => {
      var h;
      const f = Ug.filterProps(e);
      return v("div", {
        class: "v-data-table-footer"
      }, [(h = n.prepend) == null ? void 0 : h.call(n), v("div", {
        class: "v-data-table-footer__items-per-page"
      }, [v("span", null, [i(e.itemsPerPageText)]), v(cb, {
        items: d.value,
        modelValue: u.value,
        "onUpdate:modelValue": (m) => c(Number(m)),
        density: "compact",
        variant: "outlined",
        "hide-details": !0
      }, null)]), v("div", {
        class: "v-data-table-footer__info"
      }, [v("div", null, [i(e.pageText, l.value ? a.value + 1 : 0, o.value, l.value)])]), v("div", {
        class: "v-data-table-footer__pagination"
      }, [v(Ug, ie({
        modelValue: r.value,
        "onUpdate:modelValue": (m) => r.value = m,
        density: "comfortable",
        "first-aria-label": e.firstPageLabel,
        "last-aria-label": e.lastPageLabel,
        length: s.value,
        "next-aria-label": e.nextPageLabel,
        "previous-aria-label": e.prevPageLabel,
        rounded: !0,
        "show-first-last-page": !0,
        "total-visible": e.showCurrentPage ? 1 : 0,
        variant: "plain"
      }, f), null)])]);
    }), {};
  }
}), oh = $P({
  align: {
    type: String,
    default: "start"
  },
  fixed: Boolean,
  fixedOffset: [Number, String],
  height: [Number, String],
  lastFixed: Boolean,
  noPadding: Boolean,
  tag: String,
  width: [Number, String],
  maxWidth: [Number, String],
  nowrap: Boolean
}, (e, t) => {
  let {
    slots: n
  } = t;
  const i = e.tag ?? "td";
  return v(i, {
    class: ["v-data-table__td", {
      "v-data-table-column--fixed": e.fixed,
      "v-data-table-column--last-fixed": e.lastFixed,
      "v-data-table-column--no-padding": e.noPadding,
      "v-data-table-column--nowrap": e.nowrap
    }, `v-data-table-column--align-${e.align}`],
    style: {
      height: _e(e.height),
      width: _e(e.width),
      maxWidth: _e(e.maxWidth),
      left: _e(e.fixedOffset || null)
    }
  }, {
    default: () => {
      var r;
      return [(r = n.default) == null ? void 0 : r.call(n)];
    }
  });
}), a8 = B({
  headers: Array
}, "DataTable-header"), oI = Symbol.for("vuetify:data-table-headers"), lI = {
  title: "",
  sortable: !1
}, o8 = {
  ...lI,
  width: 48
};
function l8() {
  const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).map((n) => ({
    element: n,
    priority: 0
  }));
  return {
    enqueue: (n, i) => {
      let r = !1;
      for (let s = 0; s < t.length; s++)
        if (t[s].priority > i) {
          t.splice(s, 0, {
            element: n,
            priority: i
          }), r = !0;
          break;
        }
      r || t.push({
        element: n,
        priority: i
      });
    },
    size: () => t.length,
    count: () => {
      let n = 0;
      if (!t.length)
        return 0;
      const i = Math.floor(t[0].priority);
      for (let r = 0; r < t.length; r++)
        Math.floor(t[r].priority) === i && (n += 1);
      return n;
    },
    dequeue: () => t.shift()
  };
}
function qg(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  if (!e.children)
    t.push(e);
  else
    for (const n of e.children)
      qg(n, t);
  return t;
}
function uI(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
  for (const n of e)
    n.key && t.add(n.key), n.children && uI(n.children, t);
  return t;
}
function u8(e) {
  if (e.key) {
    if (e.key === "data-table-group")
      return lI;
    if (["data-table-expand", "data-table-select"].includes(e.key))
      return o8;
  }
}
function wb(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return e.children ? Math.max(t, ...e.children.map((n) => wb(n, t + 1))) : t;
}
function c8(e) {
  let t = !1;
  function n(s) {
    let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (s)
      if (a && (s.fixed = !0), s.fixed)
        if (s.children)
          for (let o = s.children.length - 1; o >= 0; o--)
            n(s.children[o], !0);
        else
          t ? isNaN(+s.width) && hf(`Multiple fixed columns should have a static width (key: ${s.key})`) : s.lastFixed = !0, t = !0;
      else if (s.children)
        for (let o = s.children.length - 1; o >= 0; o--)
          n(s.children[o]);
      else
        t = !1;
  }
  for (let s = e.length - 1; s >= 0; s--)
    n(e[s]);
  function i(s) {
    let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!s)
      return a;
    if (s.children) {
      s.fixedOffset = a;
      for (const o of s.children)
        a = i(o, a);
    } else
      s.fixed && (s.fixedOffset = a, a += parseFloat(s.width || "0") || 0);
    return a;
  }
  let r = 0;
  for (const s of e)
    r = i(s, r);
}
function d8(e, t) {
  const n = [];
  let i = 0;
  const r = l8(e);
  for (; r.size() > 0; ) {
    let a = r.count();
    const o = [];
    let l = 1;
    for (; a > 0; ) {
      const {
        element: u,
        priority: c
      } = r.dequeue(), d = t - i - wb(u);
      if (o.push({
        ...u,
        rowspan: d ?? 1,
        colspan: u.children ? qg(u).length : 1
      }), u.children)
        for (const f of u.children) {
          const h = c % 1 + l / Math.pow(10, i + 2);
          r.enqueue(f, i + d + h);
        }
      l += 1, a -= 1;
    }
    i += 1, n.push(o);
  }
  return {
    columns: e.map((a) => qg(a)).flat(),
    headers: n
  };
}
function cI(e) {
  const t = [];
  for (const n of e) {
    const i = {
      ...u8(n),
      ...n
    }, r = i.key ?? (typeof i.value == "string" ? i.value : null), s = i.value ?? r ?? null, a = {
      ...i,
      key: r,
      value: s,
      sortable: i.sortable ?? (i.key != null || !!i.sort),
      children: i.children ? cI(i.children) : void 0
    };
    t.push(a);
  }
  return t;
}
function _b(e, t) {
  const n = X([]), i = X([]), r = X({}), s = X({}), a = X({});
  Wt(() => {
    var g, p, y;
    const u = (e.headers || Object.keys(e.items[0] ?? {}).map((k) => ({
      key: k,
      title: Rl(k)
    }))).slice(), c = uI(u);
    (g = t == null ? void 0 : t.groupBy) != null && g.value.length && !c.has("data-table-group") && u.unshift({
      key: "data-table-group",
      title: "Group"
    }), (p = t == null ? void 0 : t.showSelect) != null && p.value && !c.has("data-table-select") && u.unshift({
      key: "data-table-select"
    }), (y = t == null ? void 0 : t.showExpand) != null && y.value && !c.has("data-table-expand") && u.push({
      key: "data-table-expand"
    });
    const d = cI(u);
    c8(d);
    const f = Math.max(...d.map((k) => wb(k))) + 1, h = d8(d, f);
    n.value = h.headers, i.value = h.columns;
    const m = h.headers.flat(1);
    for (const k of m)
      k.key && (k.sortable && (k.sort && (r.value[k.key] = k.sort), k.sortRaw && (s.value[k.key] = k.sortRaw)), k.filter && (a.value[k.key] = k.filter));
  });
  const o = {
    headers: n,
    columns: i,
    sortFunctions: r,
    sortRawFunctions: s,
    filterFunctions: a
  };
  return Tt(oI, o), o;
}
function km() {
  const e = tt(oI);
  if (!e)
    throw new Error("Missing headers!");
  return e;
}
const dI = B({
  color: String,
  sticky: Boolean,
  disableSort: Boolean,
  multiSort: Boolean,
  sortAscIcon: {
    type: We,
    default: "$sortAsc"
  },
  sortDescIcon: {
    type: We,
    default: "$sortDesc"
  },
  headerProps: {
    type: Object
  },
  ...jl(),
  ...wh()
}, "VDataTableHeaders"), vo = J()({
  name: "VDataTableHeaders",
  props: dI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: i
    } = qt(), {
      toggleSort: r,
      sortBy: s,
      isSorted: a
    } = aI(), {
      someSelected: o,
      allSelected: l,
      selectAll: u,
      showSelectAll: c
    } = wm(), {
      columns: d,
      headers: f
    } = km(), {
      loaderClasses: h
    } = Oc(e);
    function m(x, A) {
      if (!(!e.sticky && !x.fixed))
        return {
          position: "sticky",
          left: x.fixed ? _e(x.fixedOffset) : void 0,
          top: e.sticky ? `calc(var(--v-table-header-height) * ${A})` : void 0
        };
    }
    function g(x) {
      const A = s.value.find((I) => I.key === x.key);
      return A ? A.order === "asc" ? e.sortAscIcon : e.sortDescIcon : e.sortAscIcon;
    }
    const {
      backgroundColorClasses: p,
      backgroundColorStyles: y
    } = gt(e, "color"), {
      displayClasses: k,
      mobile: T
    } = Ar(e), _ = b(() => ({
      headers: f.value,
      columns: d.value,
      toggleSort: r,
      isSorted: a,
      sortBy: s.value,
      someSelected: o.value,
      allSelected: l.value,
      selectAll: u,
      getSortIcon: g
    })), w = b(() => ["v-data-table__th", {
      "v-data-table__th--sticky": e.sticky
    }, k.value, h.value]), S = (x) => {
      let {
        column: A,
        x: I,
        y: E
      } = x;
      const P = A.key === "data-table-select" || A.key === "data-table-expand", V = ie(e.headerProps ?? {}, A.headerProps ?? {});
      return v(oh, ie({
        tag: "th",
        align: A.align,
        class: [{
          "v-data-table__th--sortable": A.sortable && !e.disableSort,
          "v-data-table__th--sorted": a(A),
          "v-data-table__th--fixed": A.fixed
        }, ...w.value],
        style: {
          width: _e(A.width),
          minWidth: _e(A.minWidth),
          maxWidth: _e(A.maxWidth),
          ...m(A, E)
        },
        colspan: A.colspan,
        rowspan: A.rowspan,
        onClick: A.sortable ? () => r(A) : void 0,
        fixed: A.fixed,
        nowrap: A.nowrap,
        lastFixed: A.lastFixed,
        noPadding: P
      }, V), {
        default: () => {
          var $;
          const N = `header.${A.key}`, F = {
            column: A,
            selectAll: u,
            isSorted: a,
            toggleSort: r,
            sortBy: s.value,
            someSelected: o.value,
            allSelected: l.value,
            getSortIcon: g
          };
          return n[N] ? n[N](F) : A.key === "data-table-select" ? (($ = n["header.data-table-select"]) == null ? void 0 : $.call(n, F)) ?? (c.value && v(Cs, {
            modelValue: l.value,
            indeterminate: o.value && !l.value,
            "onUpdate:modelValue": u
          }, null)) : v("div", {
            class: "v-data-table-header__content"
          }, [v("span", null, [A.title]), A.sortable && !e.disableSort && v(at, {
            key: "icon",
            class: "v-data-table-header__sort-icon",
            icon: g(A)
          }, null), e.multiSort && a(A) && v("div", {
            key: "badge",
            class: ["v-data-table-header__sort-badge", ...p.value],
            style: y.value
          }, [s.value.findIndex((Z) => Z.key === A.key) + 1])]);
        }
      });
    }, C = () => {
      const x = ie(e.headerProps ?? {} ?? {}), A = b(() => d.value.filter((E) => (E == null ? void 0 : E.sortable) && !e.disableSort)), I = b(() => {
        if (d.value.find((P) => P.key === "data-table-select") != null)
          return l.value ? "$checkboxOn" : o.value ? "$checkboxIndeterminate" : "$checkboxOff";
      });
      return v(oh, ie({
        tag: "th",
        class: [...w.value],
        colspan: f.value.length + 1
      }, x), {
        default: () => [v("div", {
          class: "v-data-table-header__content"
        }, [v(cb, {
          chips: !0,
          class: "v-data-table__td-sort-select",
          clearable: !0,
          density: "default",
          items: A.value,
          label: i("$vuetify.dataTable.sortBy"),
          multiple: e.multiSort,
          variant: "underlined",
          "onClick:clear": () => s.value = [],
          appendIcon: I.value,
          "onClick:append": () => u(!l.value)
        }, {
          ...n,
          chip: (E) => {
            var P;
            return v(ou, {
              onClick: (P = E.item.raw) != null && P.sortable ? () => r(E.item.raw) : void 0,
              onMousedown: (V) => {
                V.preventDefault(), V.stopPropagation();
              }
            }, {
              default: () => [E.item.title, v(at, {
                class: ["v-data-table__td-sort-icon", a(E.item.raw) && "v-data-table__td-sort-icon-active"],
                icon: g(E.item.raw),
                size: "small"
              }, null)]
            });
          }
        })])]
      });
    };
    re(() => T.value ? v("tr", null, [v(C, null, null)]) : v(De, null, [n.headers ? n.headers(_.value) : f.value.map((x, A) => v("tr", null, [x.map((I, E) => v(S, {
      column: I,
      x: E,
      y: A
    }, null))])), e.loading && v("tr", {
      class: "v-data-table-progress"
    }, [v("th", {
      colspan: d.value.length
    }, [v(Vc, {
      name: "v-data-table-progress",
      absolute: !0,
      active: !0,
      color: typeof e.loading == "boolean" ? void 0 : e.loading,
      indeterminate: !0
    }, {
      default: n.loader
    })])])]));
  }
}), f8 = B({
  item: {
    type: Object,
    required: !0
  }
}, "VDataTableGroupHeaderRow"), h8 = J()({
  name: "VDataTableGroupHeaderRow",
  props: f8(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isGroupOpen: i,
      toggleGroup: r,
      extractRows: s
    } = ZA(), {
      isSelected: a,
      isSomeSelected: o,
      select: l
    } = wm(), {
      columns: u
    } = km(), c = b(() => s([e.item]));
    return () => v("tr", {
      class: "v-data-table-group-header-row",
      style: {
        "--v-data-table-group-header-row-depth": e.item.depth
      }
    }, [u.value.map((d) => {
      var f, h;
      if (d.key === "data-table-group") {
        const m = i(e.item) ? "$expand" : "$next", g = () => r(e.item);
        return ((f = n["data-table-group"]) == null ? void 0 : f.call(n, {
          item: e.item,
          count: c.value.length,
          props: {
            icon: m,
            onClick: g
          }
        })) ?? v(oh, {
          class: "v-data-table-group-header-row__column"
        }, {
          default: () => [v(st, {
            size: "small",
            variant: "text",
            icon: m,
            onClick: g
          }, null), v("span", null, [e.item.value]), v("span", null, [_r("("), c.value.length, _r(")")])]
        });
      }
      if (d.key === "data-table-select") {
        const m = a(c.value), g = o(c.value) && !m, p = (y) => l(c.value, y);
        return ((h = n["data-table-select"]) == null ? void 0 : h.call(n, {
          props: {
            modelValue: m,
            indeterminate: g,
            "onUpdate:modelValue": p
          }
        })) ?? v("td", null, [v(Cs, {
          modelValue: m,
          indeterminate: g,
          "onUpdate:modelValue": p
        }, null)]);
      }
      return v("td", null, null);
    })]);
  }
}), m8 = B({
  index: Number,
  item: Object,
  cellProps: [Object, Function],
  onClick: ri(),
  onContextmenu: ri(),
  onDblclick: ri(),
  ...jl()
}, "VDataTableRow"), Sb = J()({
  name: "VDataTableRow",
  props: m8(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      displayClasses: i,
      mobile: r
    } = Ar(e, "v-data-table__tr"), {
      isSelected: s,
      toggleSelect: a,
      someSelected: o,
      allSelected: l,
      selectAll: u
    } = wm(), {
      isExpanded: c,
      toggleExpand: d
    } = GA(), {
      toggleSort: f,
      sortBy: h,
      isSorted: m
    } = aI(), {
      columns: g
    } = km();
    re(() => v("tr", {
      class: ["v-data-table__tr", {
        "v-data-table__tr--clickable": !!(e.onClick || e.onContextmenu || e.onDblclick)
      }, i.value],
      onClick: e.onClick,
      onContextmenu: e.onContextmenu,
      onDblclick: e.onDblclick
    }, [e.item && g.value.map((p, y) => {
      const k = e.item, T = `item.${p.key}`, _ = `header.${p.key}`, w = {
        index: e.index,
        item: k.raw,
        internalItem: k,
        value: Hu(k.columns, p.key),
        column: p,
        isSelected: s,
        toggleSelect: a,
        isExpanded: c,
        toggleExpand: d
      }, S = {
        column: p,
        selectAll: u,
        isSorted: m,
        toggleSort: f,
        sortBy: h.value,
        someSelected: o.value,
        allSelected: l.value,
        getSortIcon: () => ""
      }, C = typeof e.cellProps == "function" ? e.cellProps({
        index: w.index,
        item: w.item,
        internalItem: w.internalItem,
        value: w.value,
        column: p
      }) : e.cellProps, x = typeof p.cellProps == "function" ? p.cellProps({
        index: w.index,
        item: w.item,
        internalItem: w.internalItem,
        value: w.value
      }) : p.cellProps;
      return v(oh, ie({
        align: p.align,
        class: {
          "v-data-table__td--expanded-row": p.key === "data-table-expand",
          "v-data-table__td--select-row": p.key === "data-table-select"
        },
        fixed: p.fixed,
        fixedOffset: p.fixedOffset,
        lastFixed: p.lastFixed,
        maxWidth: r.value ? void 0 : p.maxWidth,
        noPadding: p.key === "data-table-select" || p.key === "data-table-expand",
        nowrap: p.nowrap,
        width: r.value ? void 0 : p.width
      }, C, x), {
        default: () => {
          var I, E, P, V, N;
          if (n[T] && !r.value)
            return (I = n[T]) == null ? void 0 : I.call(n, w);
          if (p.key === "data-table-select")
            return ((E = n["item.data-table-select"]) == null ? void 0 : E.call(n, w)) ?? v(Cs, {
              disabled: !k.selectable,
              modelValue: s([k]),
              onClick: Av(() => a(k), ["stop"])
            }, null);
          if (p.key === "data-table-expand")
            return ((P = n["item.data-table-expand"]) == null ? void 0 : P.call(n, w)) ?? v(st, {
              icon: c(k) ? "$collapse" : "$expand",
              size: "small",
              variant: "text",
              onClick: Av(() => d(k), ["stop"])
            }, null);
          const A = uh(w.value);
          return r.value ? v(De, null, [v("div", {
            class: "v-data-table__td-title"
          }, [((V = n[_]) == null ? void 0 : V.call(n, S)) ?? p.title]), v("div", {
            class: "v-data-table__td-value"
          }, [((N = n[T]) == null ? void 0 : N.call(n, w)) ?? A])]) : A;
        }
      });
    })]));
  }
}), fI = B({
  loading: [Boolean, String],
  loadingText: {
    type: String,
    default: "$vuetify.dataIterator.loadingText"
  },
  hideNoData: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  rowProps: [Object, Function],
  cellProps: [Object, Function],
  ...jl()
}, "VDataTableRows"), go = J()({
  name: "VDataTableRows",
  inheritAttrs: !1,
  props: fI(),
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      columns: r
    } = km(), {
      expandOnClick: s,
      toggleExpand: a,
      isExpanded: o
    } = GA(), {
      isSelected: l,
      toggleSelect: u
    } = wm(), {
      toggleGroup: c,
      isGroupOpen: d
    } = ZA(), {
      t: f
    } = qt(), {
      mobile: h
    } = Ar(e);
    return re(() => {
      var m, g;
      return e.loading && (!e.items.length || i.loading) ? v("tr", {
        class: "v-data-table-rows-loading",
        key: "loading"
      }, [v("td", {
        colspan: r.value.length
      }, [((m = i.loading) == null ? void 0 : m.call(i)) ?? f(e.loadingText)])]) : !e.loading && !e.items.length && !e.hideNoData ? v("tr", {
        class: "v-data-table-rows-no-data",
        key: "no-data"
      }, [v("td", {
        colspan: r.value.length
      }, [((g = i["no-data"]) == null ? void 0 : g.call(i)) ?? f(e.noDataText)])]) : v(De, null, [e.items.map((p, y) => {
        var _;
        if (p.type === "group") {
          const w = {
            index: y,
            item: p,
            columns: r.value,
            isExpanded: o,
            toggleExpand: a,
            isSelected: l,
            toggleSelect: u,
            toggleGroup: c,
            isGroupOpen: d
          };
          return i["group-header"] ? i["group-header"](w) : v(h8, ie({
            key: `group-header_${p.id}`,
            item: p
          }, uw(n, ":group-header", () => w)), i);
        }
        const k = {
          index: y,
          item: p.raw,
          internalItem: p,
          columns: r.value,
          isExpanded: o,
          toggleExpand: a,
          isSelected: l,
          toggleSelect: u
        }, T = {
          ...k,
          props: ie({
            key: `item_${p.key ?? p.index}`,
            onClick: s.value ? () => {
              a(p);
            } : void 0,
            index: y,
            item: p,
            cellProps: e.cellProps,
            mobile: h.value
          }, uw(n, ":row", () => k), typeof e.rowProps == "function" ? e.rowProps({
            item: k.item,
            index: k.index,
            internalItem: k.internalItem
          }) : e.rowProps)
        };
        return v(De, {
          key: T.props.key
        }, [i.item ? i.item(T) : v(Sb, T.props, i), o(p) && ((_ = i["expanded-row"]) == null ? void 0 : _.call(i, k))]);
      })]);
    }), {};
  }
});
const hI = B({
  fixedHeader: Boolean,
  fixedFooter: Boolean,
  height: [Number, String],
  hover: Boolean,
  ...ke(),
  ..._n(),
  ...je(),
  ...Qe()
}, "VTable"), po = J()({
  name: "VTable",
  props: hI(),
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const {
      themeClasses: r
    } = lt(e), {
      densityClasses: s
    } = Kn(e);
    return re(() => v(e.tag, {
      class: ["v-table", {
        "v-table--fixed-height": !!e.height,
        "v-table--fixed-header": e.fixedHeader,
        "v-table--fixed-footer": e.fixedFooter,
        "v-table--has-top": !!n.top,
        "v-table--has-bottom": !!n.bottom,
        "v-table--hover": e.hover
      }, r.value, s.value, e.class],
      style: e.style
    }, {
      default: () => {
        var a, o, l;
        return [(a = n.top) == null ? void 0 : a.call(n), n.default ? v("div", {
          class: "v-table__wrapper",
          style: {
            height: _e(e.height)
          }
        }, [v("table", null, [n.default()])]) : (o = n.wrapper) == null ? void 0 : o.call(n), (l = n.bottom) == null ? void 0 : l.call(n)];
      }
    })), {};
  }
}), v8 = B({
  items: {
    type: Array,
    default: () => []
  },
  itemValue: {
    type: [String, Array, Function],
    default: "id"
  },
  itemSelectable: {
    type: [String, Array, Function],
    default: null
  },
  rowProps: [Object, Function],
  cellProps: [Object, Function],
  returnObject: Boolean
}, "DataTable-items");
function g8(e, t, n, i) {
  const r = e.returnObject ? t : hn(t, e.itemValue), s = hn(t, e.itemSelectable, !0), a = i.reduce((o, l) => (l.key != null && (o[l.key] = hn(t, l.value)), o), {});
  return {
    type: "item",
    key: e.returnObject ? hn(t, e.itemValue) : r,
    index: n,
    value: r,
    selectable: s,
    columns: a,
    raw: t
  };
}
function p8(e, t, n) {
  return t.map((i, r) => g8(e, i, r, n));
}
function kb(e, t) {
  return {
    items: b(() => p8(e, e.items, t.value))
  };
}
const Cb = B({
  ...fI(),
  hideDefaultBody: Boolean,
  hideDefaultFooter: Boolean,
  hideDefaultHeader: Boolean,
  width: [String, Number],
  search: String,
  ...UA(),
  ...hb(),
  ...a8(),
  ...v8(),
  ...nI(),
  ...rI(),
  ...dI(),
  ...hI()
}, "DataTable"), y8 = B({
  ...vb(),
  ...Cb(),
  ...cd(),
  ...bb()
}, "VDataTable"), b8 = J()({
  name: "VDataTable",
  props: y8(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:page": (e) => !0,
    "update:itemsPerPage": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:groupBy": (e) => !0,
    "update:expanded": (e) => !0,
    "update:currentItems": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      groupBy: r
    } = mb(e), {
      sortBy: s,
      multiSort: a,
      mustSort: o
    } = _m(e), {
      page: l,
      itemsPerPage: u
    } = gb(e), {
      columns: c,
      headers: d,
      sortFunctions: f,
      sortRawFunctions: h,
      filterFunctions: m
    } = _b(e, {
      groupBy: r,
      showSelect: G(e, "showSelect"),
      showExpand: G(e, "showExpand")
    }), {
      items: g
    } = kb(e, c), p = G(e, "search"), {
      filteredItems: y
    } = dd(e, g, p, {
      transform: (K) => K.columns,
      customKeyFilter: m
    }), {
      toggleSort: k
    } = Sm({
      sortBy: s,
      multiSort: a,
      mustSort: o,
      page: l
    }), {
      sortByWithGroups: T,
      opened: _,
      extractRows: w,
      isGroupOpen: S,
      toggleGroup: C
    } = gm({
      groupBy: r,
      sortBy: s
    }), {
      sortedItems: x
    } = yb(e, y, T, {
      transform: (K) => K.columns,
      sortFunctions: f,
      sortRawFunctions: h
    }), {
      flatItems: A
    } = pm(x, r, _), I = b(() => A.value.length), {
      startIndex: E,
      stopIndex: P,
      pageCount: V,
      setItemsPerPage: N
    } = pb({
      page: l,
      itemsPerPage: u,
      itemsLength: I
    }), {
      paginatedItems: F
    } = QA({
      items: A,
      startIndex: E,
      stopIndex: P,
      itemsPerPage: u
    }), $ = b(() => w(F.value)), {
      isSelected: Z,
      select: j,
      selectAll: H,
      toggleSelect: R,
      someSelected: L,
      allSelected: ne
    } = bm(e, {
      allItems: g,
      currentPage: $
    }), {
      isExpanded: oe,
      toggleExpand: we
    } = vm(e);
    ym({
      page: l,
      itemsPerPage: u,
      sortBy: s,
      groupBy: r,
      search: p
    }), jt({
      VDataTableRows: {
        hideNoData: G(e, "hideNoData"),
        noDataText: G(e, "noDataText"),
        loading: G(e, "loading"),
        loadingText: G(e, "loadingText")
      }
    });
    const ee = b(() => ({
      page: l.value,
      itemsPerPage: u.value,
      sortBy: s.value,
      pageCount: V.value,
      toggleSort: k,
      setItemsPerPage: N,
      someSelected: L.value,
      allSelected: ne.value,
      isSelected: Z,
      select: j,
      selectAll: H,
      toggleSelect: R,
      isExpanded: oe,
      toggleExpand: we,
      isGroupOpen: S,
      toggleGroup: C,
      items: $.value.map((K) => K.raw),
      internalItems: $.value,
      groupedItems: F.value,
      columns: c.value,
      headers: d.value
    }));
    return re(() => {
      const K = Ac.filterProps(e), ue = vo.filterProps(e), ve = go.filterProps(e), Fe = po.filterProps(e);
      return v(po, ie({
        class: ["v-data-table", {
          "v-data-table--show-select": e.showSelect,
          "v-data-table--loading": e.loading
        }, e.class],
        style: e.style
      }, Fe), {
        top: () => {
          var he;
          return (he = i.top) == null ? void 0 : he.call(i, ee.value);
        },
        default: () => {
          var he, Oe, le, be, Pe, te;
          return i.default ? i.default(ee.value) : v(De, null, [(he = i.colgroup) == null ? void 0 : he.call(i, ee.value), !e.hideDefaultHeader && v("thead", {
            key: "thead"
          }, [v(vo, ue, i)]), (Oe = i.thead) == null ? void 0 : Oe.call(i, ee.value), !e.hideDefaultBody && v("tbody", null, [(le = i["body.prepend"]) == null ? void 0 : le.call(i, ee.value), i.body ? i.body(ee.value) : v(go, ie(n, ve, {
            items: F.value
          }), i), (be = i["body.append"]) == null ? void 0 : be.call(i, ee.value)]), (Pe = i.tbody) == null ? void 0 : Pe.call(i, ee.value), (te = i.tfoot) == null ? void 0 : te.call(i, ee.value)]);
        },
        bottom: () => i.bottom ? i.bottom(ee.value) : !e.hideDefaultFooter && v(De, null, [v(ld, null, null), v(Ac, K, {
          prepend: i["footer.prepend"]
        })])
      });
    }), {};
  }
}), w8 = B({
  ...Cb(),
  ...hb(),
  ...xA(),
  ...cd()
}, "VDataTableVirtual"), _8 = J()({
  name: "VDataTableVirtual",
  props: w8(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:groupBy": (e) => !0,
    "update:expanded": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      groupBy: r
    } = mb(e), {
      sortBy: s,
      multiSort: a,
      mustSort: o
    } = _m(e), {
      columns: l,
      headers: u,
      filterFunctions: c,
      sortFunctions: d,
      sortRawFunctions: f
    } = _b(e, {
      groupBy: r,
      showSelect: G(e, "showSelect"),
      showExpand: G(e, "showExpand")
    }), {
      items: h
    } = kb(e, l), m = G(e, "search"), {
      filteredItems: g
    } = dd(e, h, m, {
      transform: (ue) => ue.columns,
      customKeyFilter: c
    }), {
      toggleSort: p
    } = Sm({
      sortBy: s,
      multiSort: a,
      mustSort: o
    }), {
      sortByWithGroups: y,
      opened: k,
      extractRows: T,
      isGroupOpen: _,
      toggleGroup: w
    } = gm({
      groupBy: r,
      sortBy: s
    }), {
      sortedItems: S
    } = yb(e, g, y, {
      transform: (ue) => ue.columns,
      sortFunctions: d,
      sortRawFunctions: f
    }), {
      flatItems: C
    } = pm(S, r, k), x = b(() => T(C.value)), {
      isSelected: A,
      select: I,
      selectAll: E,
      toggleSelect: P,
      someSelected: V,
      allSelected: N
    } = bm(e, {
      allItems: x,
      currentPage: x
    }), {
      isExpanded: F,
      toggleExpand: $
    } = vm(e), {
      containerRef: Z,
      markerRef: j,
      paddingTop: H,
      paddingBottom: R,
      computedItems: L,
      handleItemResize: ne,
      handleScroll: oe,
      handleScrollend: we
    } = AA(e, C), ee = b(() => L.value.map((ue) => ue.raw));
    ym({
      sortBy: s,
      page: pe(1),
      itemsPerPage: pe(-1),
      groupBy: r,
      search: m
    }), jt({
      VDataTableRows: {
        hideNoData: G(e, "hideNoData"),
        noDataText: G(e, "noDataText"),
        loading: G(e, "loading"),
        loadingText: G(e, "loadingText")
      }
    });
    const K = b(() => ({
      sortBy: s.value,
      toggleSort: p,
      someSelected: V.value,
      allSelected: N.value,
      isSelected: A,
      select: I,
      selectAll: E,
      toggleSelect: P,
      isExpanded: F,
      toggleExpand: $,
      isGroupOpen: _,
      toggleGroup: w,
      items: x.value.map((ue) => ue.raw),
      internalItems: x.value,
      groupedItems: C.value,
      columns: l.value,
      headers: u.value
    }));
    re(() => {
      const ue = vo.filterProps(e), ve = go.filterProps(e), Fe = po.filterProps(e);
      return v(po, ie({
        class: ["v-data-table", {
          "v-data-table--loading": e.loading
        }, e.class],
        style: e.style
      }, Fe), {
        top: () => {
          var he;
          return (he = i.top) == null ? void 0 : he.call(i, K.value);
        },
        wrapper: () => {
          var he, Oe, le;
          return v("div", {
            ref: Z,
            onScrollPassive: oe,
            onScrollend: we,
            class: "v-table__wrapper",
            style: {
              height: _e(e.height)
            }
          }, [v("table", null, [(he = i.colgroup) == null ? void 0 : he.call(i, K.value), !e.hideDefaultHeader && v("thead", {
            key: "thead"
          }, [v(vo, ie(ue, {
            sticky: e.fixedHeader
          }), i)]), !e.hideDefaultBody && v("tbody", null, [v("tr", {
            ref: j,
            style: {
              height: _e(H.value),
              border: 0
            }
          }, [v("td", {
            colspan: l.value.length,
            style: {
              height: 0,
              border: 0
            }
          }, null)]), (Oe = i["body.prepend"]) == null ? void 0 : Oe.call(i, K.value), v(go, ie(n, ve, {
            items: ee.value
          }), {
            ...i,
            item: (be) => v(TA, {
              key: be.internalItem.index,
              renderless: !0,
              "onUpdate:height": (Pe) => ne(be.internalItem.index, Pe)
            }, {
              default: (Pe) => {
                var me;
                let {
                  itemRef: te
                } = Pe;
                return ((me = i.item) == null ? void 0 : me.call(i, {
                  ...be,
                  itemRef: te
                })) ?? v(Sb, ie(be.props, {
                  ref: te,
                  key: be.internalItem.index,
                  index: be.internalItem.index
                }), i);
              }
            })
          }), (le = i["body.append"]) == null ? void 0 : le.call(i, K.value), v("tr", {
            style: {
              height: _e(R.value),
              border: 0
            }
          }, [v("td", {
            colspan: l.value.length,
            style: {
              height: 0,
              border: 0
            }
          }, null)])])])]);
        },
        bottom: () => {
          var he;
          return (he = i.bottom) == null ? void 0 : he.call(i, K.value);
        }
      });
    });
  }
}), S8 = B({
  itemsLength: {
    type: [Number, String],
    required: !0
  },
  ...vb(),
  ...Cb(),
  ...bb()
}, "VDataTableServer"), k8 = J()({
  name: "VDataTableServer",
  props: S8(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:page": (e) => !0,
    "update:itemsPerPage": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:expanded": (e) => !0,
    "update:groupBy": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      groupBy: r
    } = mb(e), {
      sortBy: s,
      multiSort: a,
      mustSort: o
    } = _m(e), {
      page: l,
      itemsPerPage: u
    } = gb(e), c = b(() => parseInt(e.itemsLength, 10)), {
      columns: d,
      headers: f
    } = _b(e, {
      groupBy: r,
      showSelect: G(e, "showSelect"),
      showExpand: G(e, "showExpand")
    }), {
      items: h
    } = kb(e, d), {
      toggleSort: m
    } = Sm({
      sortBy: s,
      multiSort: a,
      mustSort: o,
      page: l
    }), {
      opened: g,
      isGroupOpen: p,
      toggleGroup: y,
      extractRows: k
    } = gm({
      groupBy: r,
      sortBy: s
    }), {
      pageCount: T,
      setItemsPerPage: _
    } = pb({
      page: l,
      itemsPerPage: u,
      itemsLength: c
    }), {
      flatItems: w
    } = pm(h, r, g), {
      isSelected: S,
      select: C,
      selectAll: x,
      toggleSelect: A,
      someSelected: I,
      allSelected: E
    } = bm(e, {
      allItems: h,
      currentPage: h
    }), {
      isExpanded: P,
      toggleExpand: V
    } = vm(e), N = b(() => k(h.value));
    ym({
      page: l,
      itemsPerPage: u,
      sortBy: s,
      groupBy: r,
      search: G(e, "search")
    }), Tt("v-data-table", {
      toggleSort: m,
      sortBy: s
    }), jt({
      VDataTableRows: {
        hideNoData: G(e, "hideNoData"),
        noDataText: G(e, "noDataText"),
        loading: G(e, "loading"),
        loadingText: G(e, "loadingText")
      }
    });
    const F = b(() => ({
      page: l.value,
      itemsPerPage: u.value,
      sortBy: s.value,
      pageCount: T.value,
      toggleSort: m,
      setItemsPerPage: _,
      someSelected: I.value,
      allSelected: E.value,
      isSelected: S,
      select: C,
      selectAll: x,
      toggleSelect: A,
      isExpanded: P,
      toggleExpand: V,
      isGroupOpen: p,
      toggleGroup: y,
      items: N.value.map(($) => $.raw),
      internalItems: N.value,
      groupedItems: w.value,
      columns: d.value,
      headers: f.value
    }));
    re(() => {
      const $ = Ac.filterProps(e), Z = vo.filterProps(e), j = go.filterProps(e), H = po.filterProps(e);
      return v(po, ie({
        class: ["v-data-table", {
          "v-data-table--loading": e.loading
        }, e.class],
        style: e.style
      }, H), {
        top: () => {
          var R;
          return (R = i.top) == null ? void 0 : R.call(i, F.value);
        },
        default: () => {
          var R, L, ne, oe, we, ee;
          return i.default ? i.default(F.value) : v(De, null, [(R = i.colgroup) == null ? void 0 : R.call(i, F.value), !e.hideDefaultHeader && v("thead", {
            key: "thead",
            class: "v-data-table__thead",
            role: "rowgroup"
          }, [v(vo, ie(Z, {
            sticky: e.fixedHeader
          }), i)]), (L = i.thead) == null ? void 0 : L.call(i, F.value), !e.hideDefaultBody && v("tbody", {
            class: "v-data-table__tbody",
            role: "rowgroup"
          }, [(ne = i["body.prepend"]) == null ? void 0 : ne.call(i, F.value), i.body ? i.body(F.value) : v(go, ie(n, j, {
            items: w.value
          }), i), (oe = i["body.append"]) == null ? void 0 : oe.call(i, F.value)]), (we = i.tbody) == null ? void 0 : we.call(i, F.value), (ee = i.tfoot) == null ? void 0 : ee.call(i, F.value)]);
        },
        bottom: () => i.bottom ? i.bottom(F.value) : !e.hideDefaultFooter && v(De, null, [v(ld, null, null), v(Ac, $, {
          prepend: i["footer.prepend"]
        })])
      });
    });
  }
});
const C8 = B({
  fluid: {
    type: Boolean,
    default: !1
  },
  ...ke(),
  ...je()
}, "VContainer"), T8 = J()({
  name: "VContainer",
  props: C8(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      rtlClasses: i
    } = wn();
    return re(() => v(e.tag, {
      class: ["v-container", {
        "v-container--fluid": e.fluid
      }, i.value, e.class],
      style: e.style
    }, n)), {};
  }
}), mI = (() => kh.reduce((e, t) => (e[t] = {
  type: [Boolean, String, Number],
  default: !1
}, e), {}))(), vI = (() => kh.reduce((e, t) => {
  const n = "offset" + Rl(t);
  return e[n] = {
    type: [String, Number],
    default: null
  }, e;
}, {}))(), gI = (() => kh.reduce((e, t) => {
  const n = "order" + Rl(t);
  return e[n] = {
    type: [String, Number],
    default: null
  }, e;
}, {}))(), L_ = {
  col: Object.keys(mI),
  offset: Object.keys(vI),
  order: Object.keys(gI)
};
function x8(e, t, n) {
  let i = e;
  if (!(n == null || n === !1)) {
    if (t) {
      const r = t.replace(e, "");
      i += `-${r}`;
    }
    return e === "col" && (i = "v-" + i), e === "col" && (n === "" || n === !0) || (i += `-${n}`), i.toLowerCase();
  }
}
const A8 = ["auto", "start", "end", "center", "baseline", "stretch"], I8 = B({
  cols: {
    type: [Boolean, String, Number],
    default: !1
  },
  ...mI,
  offset: {
    type: [String, Number],
    default: null
  },
  ...vI,
  order: {
    type: [String, Number],
    default: null
  },
  ...gI,
  alignSelf: {
    type: String,
    default: null,
    validator: (e) => A8.includes(e)
  },
  ...ke(),
  ...je()
}, "VCol"), E8 = J()({
  name: "VCol",
  props: I8(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = b(() => {
      const r = [];
      let s;
      for (s in L_)
        L_[s].forEach((o) => {
          const l = e[o], u = x8(s, o, l);
          u && r.push(u);
        });
      const a = r.some((o) => o.startsWith("v-col-"));
      return r.push({
        // Default to .v-col if no other col-{bp}-* classes generated nor `cols` specified.
        "v-col": !a || !e.cols,
        [`v-col-${e.cols}`]: e.cols,
        [`offset-${e.offset}`]: e.offset,
        [`order-${e.order}`]: e.order,
        [`align-self-${e.alignSelf}`]: e.alignSelf
      }), r;
    });
    return () => {
      var r;
      return oa(e.tag, {
        class: [i.value, e.class],
        style: e.style
      }, (r = n.default) == null ? void 0 : r.call(n));
    };
  }
}), Tb = ["start", "end", "center"], pI = ["space-between", "space-around", "space-evenly"];
function xb(e, t) {
  return kh.reduce((n, i) => {
    const r = e + Rl(i);
    return n[r] = t(), n;
  }, {});
}
const P8 = [...Tb, "baseline", "stretch"], yI = (e) => P8.includes(e), bI = xb("align", () => ({
  type: String,
  default: null,
  validator: yI
})), O8 = [...Tb, ...pI], wI = (e) => O8.includes(e), _I = xb("justify", () => ({
  type: String,
  default: null,
  validator: wI
})), V8 = [...Tb, ...pI, "stretch"], SI = (e) => V8.includes(e), kI = xb("alignContent", () => ({
  type: String,
  default: null,
  validator: SI
})), $_ = {
  align: Object.keys(bI),
  justify: Object.keys(_I),
  alignContent: Object.keys(kI)
}, D8 = {
  align: "align",
  justify: "justify",
  alignContent: "align-content"
};
function N8(e, t, n) {
  let i = D8[e];
  if (n != null) {
    if (t) {
      const r = t.replace(e, "");
      i += `-${r}`;
    }
    return i += `-${n}`, i.toLowerCase();
  }
}
const M8 = B({
  dense: Boolean,
  noGutters: Boolean,
  align: {
    type: String,
    default: null,
    validator: yI
  },
  ...bI,
  justify: {
    type: String,
    default: null,
    validator: wI
  },
  ..._I,
  alignContent: {
    type: String,
    default: null,
    validator: SI
  },
  ...kI,
  ...ke(),
  ...je()
}, "VRow"), R8 = J()({
  name: "VRow",
  props: M8(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = b(() => {
      const r = [];
      let s;
      for (s in $_)
        $_[s].forEach((a) => {
          const o = e[a], l = N8(s, a, o);
          l && r.push(l);
        });
      return r.push({
        "v-row--no-gutters": e.noGutters,
        "v-row--dense": e.dense,
        [`align-${e.align}`]: e.align,
        [`justify-${e.justify}`]: e.justify,
        [`align-content-${e.alignContent}`]: e.alignContent
      }), r;
    });
    return () => {
      var r;
      return oa(e.tag, {
        class: ["v-row", i.value, e.class],
        style: e.style
      }, (r = n.default) == null ? void 0 : r.call(n));
    };
  }
}), CI = Zr("v-spacer", "div", "VSpacer"), TI = B({
  active: {
    type: [String, Array],
    default: void 0
  },
  disabled: {
    type: [Boolean, String, Array],
    default: !1
  },
  nextIcon: {
    type: [String],
    default: "$next"
  },
  prevIcon: {
    type: [String],
    default: "$prev"
  },
  modeIcon: {
    type: [String],
    default: "$subgroup"
  },
  text: String,
  viewMode: {
    type: String,
    default: "month"
  }
}, "VDatePickerControls"), Gg = J()({
  name: "VDatePickerControls",
  props: TI(),
  emits: {
    "click:year": () => !0,
    "click:month": () => !0,
    "click:prev": () => !0,
    "click:next": () => !0,
    "click:text": () => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const i = b(() => Array.isArray(e.disabled) ? e.disabled.includes("text") : !!e.disabled), r = b(() => Array.isArray(e.disabled) ? e.disabled.includes("mode") : !!e.disabled), s = b(() => Array.isArray(e.disabled) ? e.disabled.includes("prev") : !!e.disabled), a = b(() => Array.isArray(e.disabled) ? e.disabled.includes("next") : !!e.disabled);
    function o() {
      n("click:prev");
    }
    function l() {
      n("click:next");
    }
    function u() {
      n("click:year");
    }
    function c() {
      n("click:month");
    }
    return re(() => v("div", {
      class: ["v-date-picker-controls"]
    }, [v(st, {
      class: "v-date-picker-controls__month-btn",
      disabled: i.value,
      text: e.text,
      variant: "text",
      rounded: !0,
      onClick: c
    }, null), v(st, {
      key: "mode-btn",
      class: "v-date-picker-controls__mode-btn",
      disabled: r.value,
      density: "comfortable",
      icon: e.modeIcon,
      variant: "text",
      onClick: u
    }, null), v(CI, {
      key: "mode-spacer"
    }, null), v("div", {
      key: "month-buttons",
      class: "v-date-picker-controls__month"
    }, [v(st, {
      disabled: s.value,
      icon: e.prevIcon,
      variant: "text",
      onClick: o
    }, null), v(st, {
      disabled: a.value,
      icon: e.nextIcon,
      variant: "text",
      onClick: l
    }, null)])])), {};
  }
});
const F8 = B({
  appendIcon: String,
  color: String,
  header: String,
  transition: String,
  onClick: ri()
}, "VDatePickerHeader"), Yg = J()({
  name: "VDatePickerHeader",
  props: F8(),
  emits: {
    click: () => !0,
    "click:append": () => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const {
      backgroundColorClasses: r,
      backgroundColorStyles: s
    } = gt(e, "color");
    function a() {
      n("click");
    }
    function o() {
      n("click:append");
    }
    return re(() => {
      const l = !!(i.default || e.header), u = !!(i.append || e.appendIcon);
      return v("div", {
        class: ["v-date-picker-header", {
          "v-date-picker-header--clickable": !!e.onClick
        }, r.value],
        style: s.value,
        onClick: a
      }, [i.prepend && v("div", {
        key: "prepend",
        class: "v-date-picker-header__prepend"
      }, [i.prepend()]), l && v(Gn, {
        key: "content",
        name: e.transition
      }, {
        default: () => {
          var c;
          return [v("div", {
            key: e.header,
            class: "v-date-picker-header__content"
          }, [((c = i.default) == null ? void 0 : c.call(i)) ?? e.header])];
        }
      }), u && v("div", {
        class: "v-date-picker-header__append"
      }, [i.append ? v(Ze, {
        key: "append-defaults",
        disabled: !e.appendIcon,
        defaults: {
          VBtn: {
            icon: e.appendIcon,
            variant: "text"
          }
        }
      }, {
        default: () => {
          var c;
          return [(c = i.append) == null ? void 0 : c.call(i)];
        }
      }) : v(st, {
        key: "append-btn",
        icon: e.appendIcon,
        variant: "text",
        onClick: o
      }, null)])]);
    }), {};
  }
});
const B8 = B({
  allowedDates: [Array, Function],
  disabled: Boolean,
  displayValue: null,
  modelValue: Array,
  month: [Number, String],
  max: null,
  min: null,
  showAdjacentMonths: Boolean,
  year: [Number, String],
  weekdays: {
    type: Array,
    default: () => [0, 1, 2, 3, 4, 5, 6]
  },
  weeksInMonth: {
    type: String,
    default: "dynamic"
  }
}, "calendar");
function L8(e) {
  const t = Mc(), n = Ee(e, "modelValue", [], (f) => Nt(f)), i = b(() => e.displayValue ? t.date(e.displayValue) : n.value.length > 0 ? t.date(n.value[0]) : e.min ? t.date(e.min) : Array.isArray(e.allowedDates) ? t.date(e.allowedDates[0]) : t.date()), r = Ee(e, "year", void 0, (f) => {
    const h = f != null ? Number(f) : t.getYear(i.value);
    return t.startOfYear(t.setYear(t.date(), h));
  }, (f) => t.getYear(f)), s = Ee(e, "month", void 0, (f) => {
    const h = f != null ? Number(f) : t.getMonth(i.value), m = t.setYear(t.startOfMonth(t.date()), t.getYear(r.value));
    return t.setMonth(m, h);
  }, (f) => t.getMonth(f)), a = b(() => {
    const f = t.getWeekArray(s.value), h = f.flat(), m = 6 * 7;
    if (e.weeksInMonth === "static" && h.length < m) {
      const g = h[h.length - 1];
      let p = [];
      for (let y = 1; y <= m - h.length; y++)
        p.push(t.addDays(g, y)), y % 7 === 0 && (f.push(p), p = []);
    }
    return f;
  });
  function o(f, h) {
    return f.filter((m) => e.weekdays.includes(t.toJsDate(m).getDay())).map((m, g) => {
      const p = t.toISO(m), y = !t.isSameMonth(m, s.value), k = t.isSameDay(m, t.startOfMonth(s.value)), T = t.isSameDay(m, t.endOfMonth(s.value)), _ = t.isSameDay(m, s.value);
      return {
        date: m,
        isoDate: p,
        formatted: t.format(m, "keyboardDate"),
        year: t.getYear(m),
        month: t.getMonth(m),
        isDisabled: d(m),
        isWeekStart: g % 7 === 0,
        isWeekEnd: g % 7 === 6,
        isToday: t.isSameDay(m, h),
        isAdjacent: y,
        isHidden: y && !e.showAdjacentMonths,
        isStart: k,
        isSelected: n.value.some((w) => t.isSameDay(m, w)),
        isEnd: T,
        isSame: _,
        localized: t.format(m, "dayOfMonth")
      };
    });
  }
  const l = b(() => {
    const f = t.startOfWeek(i.value), h = [];
    for (let g = 0; g <= 6; g++)
      h.push(t.addDays(f, g));
    const m = t.date();
    return o(h, m);
  }), u = b(() => {
    const f = a.value.flat(), h = t.date();
    return o(f, h);
  }), c = b(() => a.value.map((f) => f.length ? bV(t, f[0]) : null));
  function d(f) {
    if (e.disabled)
      return !0;
    const h = t.date(f);
    return e.min && t.isAfter(t.date(e.min), h) || e.max && t.isAfter(h, t.date(e.max)) ? !0 : Array.isArray(e.allowedDates) && e.allowedDates.length > 0 ? !e.allowedDates.some((m) => t.isSameDay(t.date(m), h)) : typeof e.allowedDates == "function" ? !e.allowedDates(h) : !1;
  }
  return {
    displayValue: i,
    daysInMonth: u,
    daysInWeek: l,
    genDays: o,
    model: n,
    weeksInMonth: a,
    weekNumbers: c
  };
}
const xI = B({
  color: String,
  hideWeekdays: Boolean,
  multiple: [Boolean, Number, String],
  showWeek: Boolean,
  transition: {
    type: String,
    default: "picker-transition"
  },
  reverseTransition: {
    type: String,
    default: "picker-reverse-transition"
  },
  ...B8()
}, "VDatePickerMonth"), Zg = J()({
  name: "VDatePickerMonth",
  props: xI(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:month": (e) => !0,
    "update:year": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const r = X(), {
      daysInMonth: s,
      model: a,
      weekNumbers: o
    } = L8(e), l = Mc(), u = pe(), c = pe(), d = pe(!1), f = b(() => d.value ? e.reverseTransition : e.transition);
    e.multiple === "range" && a.value.length > 0 && (u.value = a.value[0], a.value.length > 1 && (c.value = a.value[a.value.length - 1]));
    const h = b(() => {
      const y = ["number", "string"].includes(typeof e.multiple) ? Number(e.multiple) : 1 / 0;
      return a.value.length >= y;
    });
    fe(s, (y, k) => {
      k && (d.value = l.isBefore(y[0].date, k[0].date));
    });
    function m(y) {
      const k = l.startOfDay(y);
      if (!u.value)
        u.value = k, a.value = [u.value];
      else if (c.value)
        u.value = y, c.value = void 0, a.value = [u.value];
      else {
        if (l.isSameDay(k, u.value)) {
          u.value = void 0, a.value = [];
          return;
        } else
          l.isBefore(k, u.value) ? (c.value = l.endOfDay(u.value), u.value = k) : c.value = l.endOfDay(k);
        const T = l.getDiff(c.value, u.value, "days"), _ = [u.value];
        for (let w = 1; w < T; w++) {
          const S = l.addDays(u.value, w);
          _.push(S);
        }
        _.push(c.value), a.value = _;
      }
    }
    function g(y) {
      const k = a.value.findIndex((T) => l.isSameDay(T, y));
      if (k === -1)
        a.value = [...a.value, y];
      else {
        const T = [...a.value];
        T.splice(k, 1), a.value = T;
      }
    }
    function p(y) {
      e.multiple === "range" ? m(y) : e.multiple ? g(y) : a.value = [y];
    }
    return () => v("div", {
      class: "v-date-picker-month"
    }, [e.showWeek && v("div", {
      key: "weeks",
      class: "v-date-picker-month__weeks"
    }, [!e.hideWeekdays && v("div", {
      key: "hide-week-days",
      class: "v-date-picker-month__day"
    }, [_r("")]), o.value.map((y) => v("div", {
      class: ["v-date-picker-month__day", "v-date-picker-month__day--adjacent"]
    }, [y]))]), v(Gn, {
      name: f.value
    }, {
      default: () => {
        var y;
        return [v("div", {
          ref: r,
          key: (y = s.value[0].date) == null ? void 0 : y.toString(),
          class: "v-date-picker-month__days"
        }, [!e.hideWeekdays && l.getWeekdays().map((k) => v("div", {
          class: ["v-date-picker-month__day", "v-date-picker-month__weekday"]
        }, [k])), s.value.map((k, T) => {
          const _ = {
            props: {
              onClick: () => p(k.date)
            },
            item: k,
            i: T
          };
          return h.value && !k.isSelected && (k.isDisabled = !0), v("div", {
            class: ["v-date-picker-month__day", {
              "v-date-picker-month__day--adjacent": k.isAdjacent,
              "v-date-picker-month__day--hide-adjacent": k.isHidden,
              "v-date-picker-month__day--selected": k.isSelected,
              "v-date-picker-month__day--week-end": k.isWeekEnd,
              "v-date-picker-month__day--week-start": k.isWeekStart
            }],
            "data-v-date": k.isDisabled ? void 0 : k.isoDate
          }, [(e.showAdjacentMonths || !k.isAdjacent) && v(Ze, {
            defaults: {
              VBtn: {
                class: "v-date-picker-month__day-btn",
                color: (k.isSelected || k.isToday) && !k.isDisabled ? e.color : void 0,
                disabled: k.isDisabled,
                icon: !0,
                ripple: !1,
                text: k.localized,
                variant: k.isDisabled ? k.isToday ? "outlined" : "text" : k.isToday && !k.isSelected ? "outlined" : "flat",
                onClick: () => p(k.date)
              }
            }
          }, {
            default: () => {
              var w;
              return [((w = i.day) == null ? void 0 : w.call(i, _)) ?? v(st, _.props, null)];
            }
          })]);
        })])];
      }
    })]);
  }
});
const AI = B({
  color: String,
  height: [String, Number],
  min: null,
  max: null,
  modelValue: Number,
  year: Number
}, "VDatePickerMonths"), Kg = J()({
  name: "VDatePickerMonths",
  props: AI(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const r = Mc(), s = Ee(e, "modelValue"), a = b(() => {
      let o = r.startOfYear(r.date());
      return e.year && (o = r.setYear(o, e.year)), Hr(12).map((l) => {
        const u = r.format(o, "monthShort"), c = !!(e.min && r.isAfter(r.startOfMonth(r.date(e.min)), o) || e.max && r.isAfter(o, r.startOfMonth(r.date(e.max))));
        return o = r.getNextMonth(o), {
          isDisabled: c,
          text: u,
          value: l
        };
      });
    });
    return Wt(() => {
      s.value = s.value ?? r.getMonth(r.date());
    }), re(() => v("div", {
      class: "v-date-picker-months",
      style: {
        height: _e(e.height)
      }
    }, [v("div", {
      class: "v-date-picker-months__content"
    }, [a.value.map((o, l) => {
      var d;
      const u = {
        active: s.value === l,
        color: s.value === l ? e.color : void 0,
        disabled: o.isDisabled,
        rounded: !0,
        text: o.text,
        variant: s.value === o.value ? "flat" : "text",
        onClick: () => c(l)
      };
      function c(f) {
        if (s.value === f) {
          n("update:modelValue", s.value);
          return;
        }
        s.value = f;
      }
      return ((d = i.month) == null ? void 0 : d.call(i, {
        month: o,
        i: l,
        props: u
      })) ?? v(st, ie({
        key: "month"
      }, u), null);
    })])])), {};
  }
});
const II = B({
  color: String,
  height: [String, Number],
  min: null,
  max: null,
  modelValue: Number
}, "VDatePickerYears"), Xg = J()({
  name: "VDatePickerYears",
  props: II(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const r = Mc(), s = Ee(e, "modelValue"), a = b(() => {
      const l = r.getYear(r.date());
      let u = l - 100, c = l + 52;
      e.min && (u = r.getYear(r.date(e.min))), e.max && (c = r.getYear(r.date(e.max)));
      let d = r.startOfYear(r.date());
      return d = r.setYear(d, u), Hr(c - u + 1, u).map((f) => {
        const h = r.format(d, "year");
        return d = r.setYear(d, r.getYear(d) + 1), {
          text: h,
          value: f
        };
      });
    });
    Wt(() => {
      s.value = s.value ?? r.getYear(r.date());
    });
    const o = ff();
    return En(async () => {
      var l;
      await He(), (l = o.el) == null || l.scrollIntoView({
        block: "center"
      });
    }), re(() => v("div", {
      class: "v-date-picker-years",
      style: {
        height: _e(e.height)
      }
    }, [v("div", {
      class: "v-date-picker-years__content"
    }, [a.value.map((l, u) => {
      var d;
      const c = {
        ref: s.value === l.value ? o : void 0,
        active: s.value === l.value,
        color: s.value === l.value ? e.color : void 0,
        rounded: !0,
        text: l.text,
        variant: s.value === l.value ? "flat" : "text",
        onClick: () => {
          if (s.value === l.value) {
            n("update:modelValue", s.value);
            return;
          }
          s.value = l.value;
        }
      };
      return ((d = i.year) == null ? void 0 : d.call(i, {
        year: l,
        i: u,
        props: c
      })) ?? v(st, ie({
        key: "month"
      }, c), null);
    })])])), {};
  }
});
const $8 = Zr("v-picker-title"), EI = B({
  bgColor: String,
  landscape: Boolean,
  title: String,
  hideHeader: Boolean,
  ...mm()
}, "VPicker"), W_ = J()({
  name: "VPicker",
  props: EI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: r
    } = gt(G(e, "color"));
    return re(() => {
      const s = mo.filterProps(e), a = !!(e.title || n.title);
      return v(mo, ie(s, {
        color: e.bgColor,
        class: ["v-picker", {
          "v-picker--landscape": e.landscape,
          "v-picker--with-actions": !!n.actions
        }, e.class],
        style: e.style
      }), {
        default: () => {
          var o;
          return [!e.hideHeader && v("div", {
            key: "header",
            class: [i.value],
            style: [r.value]
          }, [a && v($8, {
            key: "picker-title"
          }, {
            default: () => {
              var l;
              return [((l = n.title) == null ? void 0 : l.call(n)) ?? e.title];
            }
          }), n.header && v("div", {
            class: "v-picker__header"
          }, [n.header()])]), v("div", {
            class: "v-picker__body"
          }, [(o = n.default) == null ? void 0 : o.call(n)]), n.actions && v(Ze, {
            defaults: {
              VBtn: {
                slim: !0,
                variant: "text"
              }
            }
          }, {
            default: () => [v("div", {
              class: "v-picker__actions"
            }, [n.actions()])]
          })];
        }
      });
    }), {};
  }
}), W8 = B({
  // TODO: implement in v3.5
  // calendarIcon: {
  //   type: String,
  //   default: '$calendar',
  // },
  // keyboardIcon: {
  //   type: String,
  //   default: '$edit',
  // },
  // inputMode: {
  //   type: String as PropType<'calendar' | 'keyboard'>,
  //   default: 'calendar',
  // },
  // inputText: {
  //   type: String,
  //   default: '$vuetify.datePicker.input.placeholder',
  // },
  // inputPlaceholder: {
  //   type: String,
  //   default: 'dd/mm/yyyy',
  // },
  header: {
    type: String,
    default: "$vuetify.datePicker.header"
  },
  ...TI(),
  ...xI({
    weeksInMonth: "static"
  }),
  ...an(AI(), ["modelValue"]),
  ...an(II(), ["modelValue"]),
  ...EI({
    title: "$vuetify.datePicker.title"
  }),
  modelValue: null
}, "VDatePicker"), j8 = J()({
  name: "VDatePicker",
  props: W8(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:month": (e) => !0,
    "update:year": (e) => !0,
    // 'update:inputMode': (date: any) => true,
    "update:viewMode": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const r = Mc(), {
      t: s
    } = qt(), a = Ee(e, "modelValue", void 0, (A) => Nt(A), (A) => e.multiple ? A : A[0]), o = Ee(e, "viewMode"), l = b(() => {
      var I;
      const A = r.date((I = a.value) == null ? void 0 : I[0]);
      return A && r.isValid(A) ? A : r.date();
    }), u = X(Number(e.month ?? r.getMonth(r.startOfMonth(l.value)))), c = X(Number(e.year ?? r.getYear(r.startOfYear(r.setMonth(l.value, u.value))))), d = pe(!1), f = b(() => e.multiple && a.value.length > 1 ? s("$vuetify.datePicker.itemsSelected", a.value.length) : a.value[0] && r.isValid(a.value[0]) ? r.format(r.date(a.value[0]), "normalDateWithWeekday") : s(e.header)), h = b(() => {
      let A = r.date();
      return A = r.setDate(A, 1), A = r.setMonth(A, u.value), A = r.setYear(A, c.value), r.format(A, "monthAndYear");
    }), m = b(() => `date-picker-header${d.value ? "-reverse" : ""}-transition`), g = b(() => {
      const A = r.date(e.min);
      return e.min && r.isValid(A) ? A : null;
    }), p = b(() => {
      const A = r.date(e.max);
      return e.max && r.isValid(A) ? A : null;
    }), y = b(() => {
      if (e.disabled)
        return !0;
      const A = [];
      if (o.value !== "month")
        A.push("prev", "next");
      else {
        let I = r.date();
        if (I = r.setYear(I, c.value), I = r.setMonth(I, u.value), g.value) {
          const E = r.addDays(r.startOfMonth(I), -1);
          r.isAfter(g.value, E) && A.push("prev");
        }
        if (p.value) {
          const E = r.addDays(r.endOfMonth(I), 1);
          r.isAfter(E, p.value) && A.push("next");
        }
      }
      return A;
    });
    function k() {
      u.value < 11 ? u.value++ : (c.value++, u.value = 0, x(c.value)), C(u.value);
    }
    function T() {
      u.value > 0 ? u.value-- : (c.value--, u.value = 11, x(c.value)), C(u.value);
    }
    function _() {
      o.value = "month";
    }
    function w() {
      o.value = o.value === "months" ? "month" : "months";
    }
    function S() {
      o.value = o.value === "year" ? "month" : "year";
    }
    function C(A) {
      o.value === "months" && w(), n("update:month", A);
    }
    function x(A) {
      o.value === "year" && S(), n("update:year", A);
    }
    return fe(a, (A, I) => {
      const E = r.date(Nt(I)[I.length - 1]), P = r.date(Nt(A)[A.length - 1]), V = r.getMonth(P), N = r.getYear(P);
      V !== u.value && (u.value = V, C(u.value)), N !== c.value && (c.value = N, x(c.value)), d.value = r.isBefore(E, P);
    }), re(() => {
      const A = W_.filterProps(e), I = Gg.filterProps(e), E = Yg.filterProps(e), P = Zg.filterProps(e), V = an(Kg.filterProps(e), ["modelValue"]), N = an(Xg.filterProps(e), ["modelValue"]), F = {
        header: f.value,
        transition: m.value
      };
      return v(W_, ie(A, {
        class: ["v-date-picker", `v-date-picker--${o.value}`, {
          "v-date-picker--show-week": e.showWeek
        }, e.class],
        style: e.style
      }), {
        title: () => {
          var $;
          return (($ = i.title) == null ? void 0 : $.call(i)) ?? v("div", {
            class: "v-date-picker__title"
          }, [s(e.title)]);
        },
        header: () => i.header ? v(Ze, {
          defaults: {
            VDatePickerHeader: {
              ...F
            }
          }
        }, {
          default: () => {
            var $;
            return [($ = i.header) == null ? void 0 : $.call(i, F)];
          }
        }) : v(Yg, ie({
          key: "header"
        }, E, F, {
          onClick: o.value !== "month" ? _ : void 0
        }), {
          ...i,
          default: void 0
        }),
        default: () => v(De, null, [v(Gg, ie(I, {
          disabled: y.value,
          text: h.value,
          "onClick:next": k,
          "onClick:prev": T,
          "onClick:month": w,
          "onClick:year": S
        }), null), v(Gu, {
          hideOnLeave: !0
        }, {
          default: () => [o.value === "months" ? v(Kg, ie({
            key: "date-picker-months"
          }, V, {
            modelValue: u.value,
            "onUpdate:modelValue": [($) => u.value = $, C],
            min: g.value,
            max: p.value,
            year: c.value
          }), null) : o.value === "year" ? v(Xg, ie({
            key: "date-picker-years"
          }, N, {
            modelValue: c.value,
            "onUpdate:modelValue": [($) => c.value = $, x],
            min: g.value,
            max: p.value
          }), null) : v(Zg, ie({
            key: "date-picker-month"
          }, P, {
            modelValue: a.value,
            "onUpdate:modelValue": ($) => a.value = $,
            month: u.value,
            "onUpdate:month": [($) => u.value = $, C],
            year: c.value,
            "onUpdate:year": [($) => c.value = $, x],
            min: g.value,
            max: p.value
          }), null)]
        })]),
        actions: i.actions
      });
    }), {};
  }
});
const H8 = B({
  actionText: String,
  bgColor: String,
  color: String,
  icon: We,
  image: String,
  justify: {
    type: String,
    default: "center"
  },
  headline: String,
  title: String,
  text: String,
  textWidth: {
    type: [Number, String],
    default: 500
  },
  href: String,
  to: String,
  ...ke(),
  ...Sn(),
  ...Xr({
    size: void 0
  }),
  ...Qe()
}, "VEmptyState"), z8 = J()({
  name: "VEmptyState",
  props: H8(),
  emits: {
    "click:action": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const {
      themeClasses: r
    } = lt(e), {
      backgroundColorClasses: s,
      backgroundColorStyles: a
    } = gt(G(e, "bgColor")), {
      dimensionStyles: o
    } = kn(e), {
      displayClasses: l
    } = Ar();
    function u(c) {
      n("click:action", c);
    }
    return re(() => {
      var p, y, k;
      const c = !!(i.actions || e.actionText), d = !!(i.headline || e.headline), f = !!(i.title || e.title), h = !!(i.text || e.text), m = !!(i.media || e.image || e.icon), g = e.size || (e.image ? 200 : 96);
      return v("div", {
        class: ["v-empty-state", {
          [`v-empty-state--${e.justify}`]: !0
        }, r.value, s.value, l.value, e.class],
        style: [a.value, o.value, e.style]
      }, [m && v("div", {
        key: "media",
        class: "v-empty-state__media"
      }, [i.media ? v(Ze, {
        key: "media-defaults",
        defaults: {
          VImg: {
            src: e.image,
            height: g
          },
          VIcon: {
            size: g,
            icon: e.icon
          }
        }
      }, {
        default: () => [i.media()]
      }) : v(De, null, [e.image ? v(ks, {
        key: "image",
        src: e.image,
        height: g
      }, null) : e.icon ? v(at, {
        key: "icon",
        color: e.color,
        size: g,
        icon: e.icon
      }, null) : void 0])]), d && v("div", {
        key: "headline",
        class: "v-empty-state__headline"
      }, [((p = i.headline) == null ? void 0 : p.call(i)) ?? e.headline]), f && v("div", {
        key: "title",
        class: "v-empty-state__title"
      }, [((y = i.title) == null ? void 0 : y.call(i)) ?? e.title]), h && v("div", {
        key: "text",
        class: "v-empty-state__text",
        style: {
          maxWidth: _e(e.textWidth)
        }
      }, [((k = i.text) == null ? void 0 : k.call(i)) ?? e.text]), i.default && v("div", {
        key: "content",
        class: "v-empty-state__content"
      }, [i.default()]), c && v("div", {
        key: "actions",
        class: "v-empty-state__actions"
      }, [v(Ze, {
        defaults: {
          VBtn: {
            class: "v-empty-state__action-btn",
            color: e.color,
            text: e.actionText
          }
        }
      }, {
        default: () => {
          var T;
          return [((T = i.actions) == null ? void 0 : T.call(i, {
            props: {
              onClick: u
            }
          })) ?? v(st, {
            onClick: u
          }, null)];
        }
      })])]);
    }), {};
  }
});
const PI = B({
  ...ke(),
  ...ab()
}, "VExpansionPanelText"), Jg = J()({
  name: "VExpansionPanelText",
  props: PI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = tt(Ic);
    if (!i)
      throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
    const {
      hasContent: r,
      onAfterLeave: s
    } = ob(e, i.isSelected);
    return re(() => v(vh, {
      onAfterLeave: s
    }, {
      default: () => {
        var a;
        return [Rt(v("div", {
          class: ["v-expansion-panel-text", e.class],
          style: e.style
        }, [n.default && r.value && v("div", {
          class: "v-expansion-panel-text__wrapper"
        }, [(a = n.default) == null ? void 0 : a.call(n)])]), [[Tr, i.isSelected.value]])];
      }
    })), {};
  }
}), OI = B({
  color: String,
  expandIcon: {
    type: We,
    default: "$expand"
  },
  collapseIcon: {
    type: We,
    default: "$collapse"
  },
  hideActions: Boolean,
  focusable: Boolean,
  static: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: !1
  },
  readonly: Boolean,
  ...ke()
}, "VExpansionPanelTitle"), Qg = J()({
  name: "VExpansionPanelTitle",
  directives: {
    Ripple: Vs
  },
  props: OI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = tt(Ic);
    if (!i)
      throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
    const {
      backgroundColorClasses: r,
      backgroundColorStyles: s
    } = gt(e, "color"), a = b(() => ({
      collapseIcon: e.collapseIcon,
      disabled: i.disabled.value,
      expanded: i.isSelected.value,
      expandIcon: e.expandIcon,
      readonly: e.readonly
    }));
    return re(() => {
      var o;
      return Rt(v("button", {
        class: ["v-expansion-panel-title", {
          "v-expansion-panel-title--active": i.isSelected.value,
          "v-expansion-panel-title--focusable": e.focusable,
          "v-expansion-panel-title--static": e.static
        }, r.value, e.class],
        style: [s.value, e.style],
        type: "button",
        tabindex: i.disabled.value ? -1 : void 0,
        disabled: i.disabled.value,
        "aria-expanded": i.isSelected.value,
        onClick: e.readonly ? void 0 : i.toggle
      }, [v("span", {
        class: "v-expansion-panel-title__overlay"
      }, null), (o = n.default) == null ? void 0 : o.call(n, a.value), !e.hideActions && v("span", {
        class: "v-expansion-panel-title__icon"
      }, [n.actions ? n.actions(a.value) : v(at, {
        icon: i.isSelected.value ? e.collapseIcon : e.expandIcon
      }, null)])]), [[Ei("ripple"), e.ripple]]);
    }), {};
  }
}), VI = B({
  title: String,
  text: String,
  bgColor: String,
  ...gn(),
  ...Oo(),
  ...It(),
  ...je(),
  ...OI(),
  ...PI()
}, "VExpansionPanel"), U8 = J()({
  name: "VExpansionPanel",
  props: VI(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Vo(e, Ic), {
      backgroundColorClasses: r,
      backgroundColorStyles: s
    } = gt(e, "bgColor"), {
      elevationClasses: a
    } = On(e), {
      roundedClasses: o
    } = Ht(e), l = b(() => (i == null ? void 0 : i.disabled.value) || e.disabled), u = b(() => i.group.items.value.reduce((f, h, m) => (i.group.selected.value.includes(h.id) && f.push(m), f), [])), c = b(() => {
      const f = i.group.items.value.findIndex((h) => h.id === i.id);
      return !i.isSelected.value && u.value.some((h) => h - f === 1);
    }), d = b(() => {
      const f = i.group.items.value.findIndex((h) => h.id === i.id);
      return !i.isSelected.value && u.value.some((h) => h - f === -1);
    });
    return Tt(Ic, i), re(() => {
      const f = !!(n.text || e.text), h = !!(n.title || e.title), m = Qg.filterProps(e), g = Jg.filterProps(e);
      return v(e.tag, {
        class: ["v-expansion-panel", {
          "v-expansion-panel--active": i.isSelected.value,
          "v-expansion-panel--before-active": c.value,
          "v-expansion-panel--after-active": d.value,
          "v-expansion-panel--disabled": l.value
        }, o.value, r.value, e.class],
        style: [s.value, e.style]
      }, {
        default: () => {
          var p;
          return [v("div", {
            class: ["v-expansion-panel__shadow", ...a.value]
          }, null), h && v(Qg, ie({
            key: "title"
          }, m), {
            default: () => [n.title ? n.title() : e.title]
          }), f && v(Jg, ie({
            key: "text"
          }, g), {
            default: () => [n.text ? n.text() : e.text]
          }), (p = n.default) == null ? void 0 : p.call(n)];
        }
      });
    }), {
      groupItem: i
    };
  }
}), Ic = Symbol.for("vuetify:v-expansion-panel"), q8 = ["default", "accordion", "inset", "popout"], G8 = B({
  flat: Boolean,
  ...Po(),
  ...VI(),
  ...Qe(),
  variant: {
    type: String,
    default: "default",
    validator: (e) => q8.includes(e)
  }
}, "VExpansionPanels"), Y8 = J()({
  name: "VExpansionPanels",
  props: G8(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      next: i,
      prev: r
    } = ha(e, Ic), {
      themeClasses: s
    } = lt(e), a = b(() => e.variant && `v-expansion-panels--variant-${e.variant}`);
    return jt({
      VExpansionPanel: {
        bgColor: G(e, "bgColor"),
        collapseIcon: G(e, "collapseIcon"),
        color: G(e, "color"),
        eager: G(e, "eager"),
        elevation: G(e, "elevation"),
        expandIcon: G(e, "expandIcon"),
        focusable: G(e, "focusable"),
        hideActions: G(e, "hideActions"),
        readonly: G(e, "readonly"),
        ripple: G(e, "ripple"),
        rounded: G(e, "rounded"),
        static: G(e, "static")
      }
    }), re(() => v(e.tag, {
      class: ["v-expansion-panels", {
        "v-expansion-panels--flat": e.flat,
        "v-expansion-panels--tile": e.tile
      }, s.value, a.value, e.class],
      style: e.style
    }, {
      default: () => {
        var o;
        return [(o = n.default) == null ? void 0 : o.call(n, {
          prev: r,
          next: i
        })];
      }
    })), {
      next: i,
      prev: r
    };
  }
});
const Z8 = B({
  app: Boolean,
  appear: Boolean,
  extended: Boolean,
  layout: Boolean,
  location: {
    type: String,
    default: "bottom end"
  },
  offset: Boolean,
  modelValue: {
    type: Boolean,
    default: !0
  },
  ...an(lm({
    active: !0
  }), ["location"]),
  ...bo(),
  ...xr({
    transition: "fab-transition"
  })
}, "VFab"), K8 = J()({
  name: "VFab",
  props: Z8(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), r = pe(56), s = X(), {
      resizeRef: a
    } = Sr((d) => {
      d.length && (r.value = d[0].target.clientHeight);
    }), o = b(() => e.app || e.absolute), l = b(() => o.value ? e.location.split(" ").shift() : !1), u = b(() => o.value ? e.location.split(" ")[1] ?? "end" : !1);
    vi(() => e.app, () => {
      const d = wo({
        id: e.name,
        order: b(() => parseInt(e.order, 10)),
        position: l,
        layoutSize: b(() => e.layout ? r.value + 24 : 0),
        elementSize: b(() => r.value + 24),
        active: b(() => e.app && i.value),
        absolute: G(e, "absolute")
      });
      Wt(() => {
        s.value = d.layoutItemStyles.value;
      });
    });
    const c = X();
    return re(() => {
      const d = st.filterProps(e);
      return v("div", {
        ref: c,
        class: ["v-fab", {
          "v-fab--absolute": e.absolute,
          "v-fab--app": !!e.app,
          "v-fab--extended": e.extended,
          "v-fab--offset": e.offset,
          [`v-fab--${l.value}`]: o.value,
          [`v-fab--${u.value}`]: o.value
        }, e.class],
        style: [e.app ? {
          ...s.value
        } : {
          height: "inherit",
          width: void 0
        }, e.style]
      }, [v("div", {
        class: "v-fab__container"
      }, [v(Gn, {
        appear: e.appear,
        transition: e.transition
      }, {
        default: () => [Rt(v(st, ie({
          ref: a
        }, d, {
          active: void 0,
          location: void 0
        }), n), [[Tr, e.active]])]
      })])]);
    }), {};
  }
});
const X8 = B({
  chips: Boolean,
  counter: Boolean,
  counterSizeString: {
    type: String,
    default: "$vuetify.fileInput.counterSize"
  },
  counterString: {
    type: String,
    default: "$vuetify.fileInput.counter"
  },
  hideInput: Boolean,
  multiple: Boolean,
  showSize: {
    type: [Boolean, Number, String],
    default: !1,
    validator: (e) => typeof e == "boolean" || [1e3, 1024].includes(Number(e))
  },
  ...As({
    prependIcon: "$file"
  }),
  modelValue: {
    type: [Array, Object],
    default: (e) => e.multiple ? [] : null,
    validator: (e) => Nt(e).every((t) => t != null && typeof t == "object")
  },
  ...Dc({
    clearable: !0
  })
}, "VFileInput"), J8 = J()({
  name: "VFileInput",
  inheritAttrs: !1,
  props: X8(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const {
      t: s
    } = qt(), a = Ee(e, "modelValue", e.modelValue, (A) => Nt(A), (A) => e.multiple || Array.isArray(e.modelValue) ? A : A[0] ?? null), {
      isFocused: o,
      focus: l,
      blur: u
    } = xs(e), c = b(() => typeof e.showSize != "boolean" ? e.showSize : void 0), d = b(() => (a.value ?? []).reduce((A, I) => {
      let {
        size: E = 0
      } = I;
      return A + E;
    }, 0)), f = b(() => Gb(d.value, c.value)), h = b(() => (a.value ?? []).map((A) => {
      const {
        name: I = "",
        size: E = 0
      } = A;
      return e.showSize ? `${I} (${Gb(E, c.value)})` : I;
    })), m = b(() => {
      var I;
      const A = ((I = a.value) == null ? void 0 : I.length) ?? 0;
      return e.showSize ? s(e.counterSizeString, A, f.value) : s(e.counterString, A);
    }), g = X(), p = X(), y = X(), k = b(() => o.value || e.active), T = b(() => ["plain", "underlined"].includes(e.variant));
    function _() {
      var A;
      y.value !== document.activeElement && ((A = y.value) == null || A.focus()), o.value || l();
    }
    function w(A) {
      var I;
      (I = y.value) == null || I.click();
    }
    function S(A) {
      i("mousedown:control", A);
    }
    function C(A) {
      var I;
      (I = y.value) == null || I.click(), i("click:control", A);
    }
    function x(A) {
      A.stopPropagation(), _(), He(() => {
        a.value = [], op(e["onClick:clear"], A);
      });
    }
    return fe(a, (A) => {
      (!Array.isArray(A) || !A.length) && y.value && (y.value.value = "");
    }), re(() => {
      const A = !!(r.counter || e.counter), I = !!(A || r.details), [E, P] = la(n), {
        modelValue: V,
        ...N
      } = Wn.filterProps(e), F = wp(e);
      return v(Wn, ie({
        ref: g,
        modelValue: a.value,
        "onUpdate:modelValue": ($) => a.value = $,
        class: ["v-file-input", {
          "v-file-input--chips": !!e.chips,
          "v-file-input--hide": e.hideInput,
          "v-input--plain-underlined": T.value
        }, e.class],
        style: e.style,
        "onClick:prepend": w
      }, E, N, {
        centerAffix: !T.value,
        focused: o.value
      }), {
        ...r,
        default: ($) => {
          let {
            id: Z,
            isDisabled: j,
            isDirty: H,
            isReadonly: R,
            isValid: L
          } = $;
          return v(Wl, ie({
            ref: p,
            "prepend-icon": e.prependIcon,
            onMousedown: S,
            onClick: C,
            "onClick:clear": x,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"]
          }, F, {
            id: Z.value,
            active: k.value || H.value,
            dirty: H.value || e.dirty,
            disabled: j.value,
            focused: o.value,
            error: L.value === !1
          }), {
            ...r,
            default: (ne) => {
              var ee;
              let {
                props: {
                  class: oe,
                  ...we
                }
              } = ne;
              return v(De, null, [v("input", ie({
                ref: y,
                type: "file",
                readonly: R.value,
                disabled: j.value,
                multiple: e.multiple,
                name: e.name,
                onClick: (K) => {
                  K.stopPropagation(), R.value && K.preventDefault(), _();
                },
                onChange: (K) => {
                  if (!K.target)
                    return;
                  const ue = K.target;
                  a.value = [...ue.files ?? []];
                },
                onFocus: _,
                onBlur: u
              }, we, P), null), v("div", {
                class: oe
              }, [!!((ee = a.value) != null && ee.length) && !e.hideInput && (r.selection ? r.selection({
                fileNames: h.value,
                totalBytes: d.value,
                totalBytesReadable: f.value
              }) : e.chips ? h.value.map((K) => v(ou, {
                key: K,
                size: "small",
                text: K
              }, null)) : h.value.join(", "))])]);
            }
          });
        },
        details: I ? ($) => {
          var Z, j;
          return v(De, null, [(Z = r.details) == null ? void 0 : Z.call(r, $), A && v(De, null, [v("span", null, null), v(gh, {
            active: !!((j = a.value) != null && j.length),
            value: m.value,
            disabled: e.disabled
          }, r.counter)])]);
        } : void 0
      });
    }), Qi({}, g, p, y);
  }
});
const Q8 = B({
  app: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: "auto"
  },
  ...Ni(),
  ...ke(),
  ...gn(),
  ...bo(),
  ...It(),
  ...je({
    tag: "footer"
  }),
  ...Qe()
}, "VFooter"), eY = J()({
  name: "VFooter",
  props: Q8(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      backgroundColorClasses: r,
      backgroundColorStyles: s
    } = gt(G(e, "color")), {
      borderClasses: a
    } = er(e), {
      elevationClasses: o
    } = On(e), {
      roundedClasses: l
    } = Ht(e), u = pe(32), {
      resizeRef: c
    } = Sr((m) => {
      m.length && (u.value = m[0].target.clientHeight);
    }), d = b(() => e.height === "auto" ? u.value : parseInt(e.height, 10)), {
      layoutItemStyles: f,
      layoutIsReady: h
    } = wo({
      id: e.name,
      order: b(() => parseInt(e.order, 10)),
      position: b(() => "bottom"),
      layoutSize: d,
      elementSize: b(() => e.height === "auto" ? void 0 : d.value),
      active: b(() => e.app),
      absolute: G(e, "absolute")
    });
    return re(() => v(e.tag, {
      ref: c,
      class: ["v-footer", i.value, r.value, a.value, o.value, l.value, e.class],
      style: [s.value, e.app ? f.value : {
        height: _e(e.height)
      }, e.style]
    }, n)), e.app ? h : {};
  }
}), tY = B({
  ...ke(),
  ...PO()
}, "VForm"), nY = J()({
  name: "VForm",
  props: tY(),
  emits: {
    "update:modelValue": (e) => !0,
    submit: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const r = OO(e), s = X();
    function a(l) {
      l.preventDefault(), r.reset();
    }
    function o(l) {
      const u = l, c = r.validate();
      u.then = c.then.bind(c), u.catch = c.catch.bind(c), u.finally = c.finally.bind(c), i("submit", u), u.defaultPrevented || c.then((d) => {
        var h;
        let {
          valid: f
        } = d;
        f && ((h = s.value) == null || h.submit());
      }), u.preventDefault();
    }
    return re(() => {
      var l;
      return v("form", {
        ref: s,
        class: ["v-form", e.class],
        style: e.style,
        novalidate: !0,
        onReset: a,
        onSubmit: o
      }, [(l = n.default) == null ? void 0 : l.call(n, r)]);
    }), Qi(r, s);
  }
}), iY = B({
  disabled: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  ...rb()
}, "VHover"), rY = J()({
  name: "VHover",
  props: iY(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), {
      runOpenDelay: r,
      runCloseDelay: s
    } = sb(e, (a) => !e.disabled && (i.value = a));
    return () => {
      var a;
      return (a = n.default) == null ? void 0 : a.call(n, {
        isHovering: i.value,
        props: {
          onMouseenter: r,
          onMouseleave: s
        }
      });
    };
  }
});
const sY = B({
  color: String,
  direction: {
    type: String,
    default: "vertical",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  side: {
    type: String,
    default: "end",
    validator: (e) => ["start", "end", "both"].includes(e)
  },
  mode: {
    type: String,
    default: "intersect",
    validator: (e) => ["intersect", "manual"].includes(e)
  },
  margin: [Number, String],
  loadMoreText: {
    type: String,
    default: "$vuetify.infiniteScroll.loadMore"
  },
  emptyText: {
    type: String,
    default: "$vuetify.infiniteScroll.empty"
  },
  ...Sn(),
  ...je()
}, "VInfiniteScroll"), j_ = Pi({
  name: "VInfiniteScrollIntersect",
  props: {
    side: {
      type: String,
      required: !0
    },
    rootRef: null,
    rootMargin: String
  },
  emits: {
    intersect: (e, t) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const {
      intersectionRef: i,
      isIntersecting: r
    } = yh((s) => {
    }, e.rootMargin ? {
      rootMargin: e.rootMargin
    } : void 0);
    return fe(r, async (s) => {
      n("intersect", e.side, s);
    }), re(() => v("div", {
      class: "v-infinite-scroll-intersect",
      ref: i
    }, [_r("")])), {};
  }
}), aY = J()({
  name: "VInfiniteScroll",
  props: sY(),
  emits: {
    load: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const r = X(), s = pe("ok"), a = pe("ok"), o = b(() => _e(e.margin)), l = pe(!1);
    function u(w) {
      if (!r.value)
        return;
      const S = e.direction === "vertical" ? "scrollTop" : "scrollLeft";
      r.value[S] = w;
    }
    function c() {
      if (!r.value)
        return 0;
      const w = e.direction === "vertical" ? "scrollTop" : "scrollLeft";
      return r.value[w];
    }
    function d() {
      if (!r.value)
        return 0;
      const w = e.direction === "vertical" ? "scrollHeight" : "scrollWidth";
      return r.value[w];
    }
    function f() {
      if (!r.value)
        return 0;
      const w = e.direction === "vertical" ? "clientHeight" : "clientWidth";
      return r.value[w];
    }
    En(() => {
      r.value && (e.side === "start" ? u(d()) : e.side === "both" && u(d() / 2 - f() / 2));
    });
    function h(w, S) {
      w === "start" ? s.value = S : w === "end" && (a.value = S);
    }
    function m(w) {
      return w === "start" ? s.value : a.value;
    }
    let g = 0;
    function p(w, S) {
      l.value = S, l.value && y(w);
    }
    function y(w) {
      if (e.mode !== "manual" && !l.value)
        return;
      const S = m(w);
      if (!r.value || ["empty", "loading"].includes(S))
        return;
      g = d(), h(w, "loading");
      function C(x) {
        h(w, x), He(() => {
          x === "empty" || x === "error" || (x === "ok" && w === "start" && u(d() - g + c()), e.mode !== "manual" && He(() => {
            window.requestAnimationFrame(() => {
              window.requestAnimationFrame(() => {
                window.requestAnimationFrame(() => {
                  y(w);
                });
              });
            });
          }));
        });
      }
      i("load", {
        side: w,
        done: C
      });
    }
    const {
      t: k
    } = qt();
    function T(w, S) {
      var A, I, E, P, V;
      if (e.side !== w && e.side !== "both")
        return;
      const C = () => y(w), x = {
        side: w,
        props: {
          onClick: C,
          color: e.color
        }
      };
      return S === "error" ? (A = n.error) == null ? void 0 : A.call(n, x) : S === "empty" ? ((I = n.empty) == null ? void 0 : I.call(n, x)) ?? v("div", null, [k(e.emptyText)]) : e.mode === "manual" ? S === "loading" ? ((E = n.loading) == null ? void 0 : E.call(n, x)) ?? v(Nl, {
        indeterminate: !0,
        color: e.color
      }, null) : ((P = n["load-more"]) == null ? void 0 : P.call(n, x)) ?? v(st, {
        variant: "outlined",
        color: e.color,
        onClick: C
      }, {
        default: () => [k(e.loadMoreText)]
      }) : ((V = n.loading) == null ? void 0 : V.call(n, x)) ?? v(Nl, {
        indeterminate: !0,
        color: e.color
      }, null);
    }
    const {
      dimensionStyles: _
    } = kn(e);
    re(() => {
      const w = e.tag, S = e.side === "start" || e.side === "both", C = e.side === "end" || e.side === "both", x = e.mode === "intersect";
      return v(w, {
        ref: r,
        class: ["v-infinite-scroll", `v-infinite-scroll--${e.direction}`, {
          "v-infinite-scroll--start": S,
          "v-infinite-scroll--end": C
        }],
        style: _.value
      }, {
        default: () => {
          var A;
          return [v("div", {
            class: "v-infinite-scroll__side"
          }, [T("start", s.value)]), r.value && S && x && v(j_, {
            key: "start",
            side: "start",
            onIntersect: p,
            rootRef: r.value,
            rootMargin: o.value
          }, null), (A = n.default) == null ? void 0 : A.call(n), r.value && C && x && v(j_, {
            key: "end",
            side: "end",
            onIntersect: p,
            rootRef: r.value,
            rootMargin: o.value
          }, null), v("div", {
            class: "v-infinite-scroll__side"
          }, [T("end", a.value)])];
        }
      });
    });
  }
});
const DI = Symbol.for("vuetify:v-item-group"), oY = B({
  ...ke(),
  ...Po({
    selectedClass: "v-item--selected"
  }),
  ...je(),
  ...Qe()
}, "VItemGroup"), lY = J()({
  name: "VItemGroup",
  props: oY(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      isSelected: r,
      select: s,
      next: a,
      prev: o,
      selected: l
    } = ha(e, DI);
    return () => v(e.tag, {
      class: ["v-item-group", i.value, e.class],
      style: e.style
    }, {
      default: () => {
        var u;
        return [(u = n.default) == null ? void 0 : u.call(n, {
          isSelected: r,
          select: s,
          next: a,
          prev: o,
          selected: l.value
        })];
      }
    });
  }
}), uY = J()({
  name: "VItem",
  props: Oo(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isSelected: i,
      select: r,
      toggle: s,
      selectedClass: a,
      value: o,
      disabled: l
    } = Vo(e, DI);
    return () => {
      var u;
      return (u = n.default) == null ? void 0 : u.call(n, {
        isSelected: i.value,
        selectedClass: a.value,
        select: r,
        toggle: s,
        value: o.value,
        disabled: l.value
      });
    };
  }
});
const cY = Zr("v-kbd");
const dY = B({
  ...ke(),
  ...Sn(),
  ...YS()
}, "VLayout"), fY = J()({
  name: "VLayout",
  props: dY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      layoutClasses: i,
      layoutStyles: r,
      getLayoutItem: s,
      items: a,
      layoutRef: o
    } = KS(e), {
      dimensionStyles: l
    } = kn(e);
    return re(() => v("div", {
      ref: o,
      class: [i.value, e.class],
      style: [l.value, r.value, e.style]
    }, [v(tS, null, {
      default: () => {
        var u;
        return [v(De, null, [(u = n.default) == null ? void 0 : u.call(n)])];
      }
    })])), {
      getLayoutItem: s,
      items: a
    };
  }
});
const hY = B({
  position: {
    type: String,
    required: !0
  },
  size: {
    type: [Number, String],
    default: 300
  },
  modelValue: Boolean,
  ...ke(),
  ...bo()
}, "VLayoutItem"), mY = J()({
  name: "VLayoutItem",
  props: hY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      layoutItemStyles: i,
      layoutIsReady: r
    } = wo({
      id: e.name,
      order: b(() => parseInt(e.order, 10)),
      position: G(e, "position"),
      elementSize: G(e, "size"),
      layoutSize: G(e, "size"),
      active: G(e, "modelValue"),
      absolute: G(e, "absolute")
    });
    return re(() => {
      var s;
      return v("div", {
        class: ["v-layout-item", e.class],
        style: [i.value, e.style]
      }, [(s = n.default) == null ? void 0 : s.call(n)]);
    }), r;
  }
}), vY = B({
  modelValue: Boolean,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  ...ke(),
  ...Sn(),
  ...je(),
  ...xr({
    transition: "fade-transition"
  })
}, "VLazy"), gY = J()({
  name: "VLazy",
  directives: {
    intersect: Nc
  },
  props: vY(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      dimensionStyles: i
    } = kn(e), r = Ee(e, "modelValue");
    function s(a) {
      r.value || (r.value = a);
    }
    return re(() => Rt(v(e.tag, {
      class: ["v-lazy", e.class],
      style: [i.value, e.style]
    }, {
      default: () => [r.value && v(Gn, {
        transition: e.transition,
        appear: !0
      }, {
        default: () => {
          var a;
          return [(a = n.default) == null ? void 0 : a.call(n)];
        }
      })]
    }), [[Ei("intersect"), {
      handler: s,
      options: e.options
    }, null]])), {};
  }
});
const pY = B({
  locale: String,
  fallbackLocale: String,
  messages: Object,
  rtl: {
    type: Boolean,
    default: void 0
  },
  ...ke()
}, "VLocaleProvider"), yY = J()({
  name: "VLocaleProvider",
  props: pY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      rtlClasses: i
    } = SO(e);
    return re(() => {
      var r;
      return v("div", {
        class: ["v-locale-provider", i.value, e.class],
        style: e.style
      }, [(r = n.default) == null ? void 0 : r.call(n)]);
    }), {};
  }
});
const bY = B({
  scrollable: Boolean,
  ...ke(),
  ...Sn(),
  ...je({
    tag: "main"
  })
}, "VMain"), wY = J()({
  name: "VMain",
  props: bY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      dimensionStyles: i
    } = kn(e), {
      mainStyles: r,
      layoutIsReady: s
    } = ZS(), {
      ssrBootStyles: a
    } = Io();
    return re(() => v(e.tag, {
      class: ["v-main", {
        "v-main--scrollable": e.scrollable
      }, e.class],
      style: [r.value, a.value, i.value, e.style]
    }, {
      default: () => {
        var o, l;
        return [e.scrollable ? v("div", {
          class: "v-main__scroller"
        }, [(o = n.default) == null ? void 0 : o.call(n)]) : (l = n.default) == null ? void 0 : l.call(n)];
      }
    })), s;
  }
});
function _Y(e) {
  let {
    rootEl: t,
    isSticky: n,
    layoutItemStyles: i
  } = e;
  const r = pe(!1), s = pe(0), a = b(() => {
    const u = typeof r.value == "boolean" ? "top" : r.value;
    return [n.value ? {
      top: "auto",
      bottom: "auto",
      height: void 0
    } : void 0, r.value ? {
      [u]: _e(s.value)
    } : {
      top: i.value.top
    }];
  });
  En(() => {
    fe(n, (u) => {
      u ? window.addEventListener("scroll", l, {
        passive: !0
      }) : window.removeEventListener("scroll", l);
    }, {
      immediate: !0
    });
  }), ai(() => {
    window.removeEventListener("scroll", l);
  });
  let o = 0;
  function l() {
    const u = o > window.scrollY ? "up" : "down", c = t.value.getBoundingClientRect(), d = parseFloat(i.value.top ?? 0), f = window.scrollY - Math.max(0, s.value - d), h = c.height + Math.max(s.value, d) - window.scrollY - window.innerHeight, m = parseFloat(getComputedStyle(t.value).getPropertyValue("--v-body-scroll-y")) || 0;
    c.height < window.innerHeight - d ? (r.value = "top", s.value = d) : u === "up" && r.value === "bottom" || u === "down" && r.value === "top" ? (s.value = window.scrollY + c.top - m, r.value = !0) : u === "down" && h <= 0 ? (s.value = 0, r.value = "bottom") : u === "up" && f <= 0 && (m ? r.value !== "top" && (s.value = -f + m + d, r.value = "top") : (s.value = c.top + f, r.value = "top")), o = window.scrollY;
  }
  return {
    isStuck: r,
    stickyStyles: a
  };
}
const SY = 100, kY = 20;
function H_(e) {
  const t = 1.41421356237;
  return (e < 0 ? -1 : 1) * Math.sqrt(Math.abs(e)) * t;
}
function z_(e) {
  if (e.length < 2)
    return 0;
  if (e.length === 2)
    return e[1].t === e[0].t ? 0 : (e[1].d - e[0].d) / (e[1].t - e[0].t);
  let t = 0;
  for (let n = e.length - 1; n > 0; n--) {
    if (e[n].t === e[n - 1].t)
      continue;
    const i = H_(t), r = (e[n].d - e[n - 1].d) / (e[n].t - e[n - 1].t);
    t += (r - i) * Math.abs(r), n === e.length - 1 && (t *= 0.5);
  }
  return H_(t) * 1e3;
}
function CY() {
  const e = {};
  function t(r) {
    Array.from(r.changedTouches).forEach((s) => {
      (e[s.identifier] ?? (e[s.identifier] = new dP(kY))).push([r.timeStamp, s]);
    });
  }
  function n(r) {
    Array.from(r.changedTouches).forEach((s) => {
      delete e[s.identifier];
    });
  }
  function i(r) {
    var u;
    const s = (u = e[r]) == null ? void 0 : u.values().reverse();
    if (!s)
      throw new Error(`No samples for touch id ${r}`);
    const a = s[0], o = [], l = [];
    for (const c of s) {
      if (a[0] - c[0] > SY)
        break;
      o.push({
        t: c[0],
        d: c[1].clientX
      }), l.push({
        t: c[0],
        d: c[1].clientY
      });
    }
    return {
      x: z_(o),
      y: z_(l),
      get direction() {
        const {
          x: c,
          y: d
        } = this, [f, h] = [Math.abs(c), Math.abs(d)];
        return f > h && c >= 0 ? "right" : f > h && c <= 0 ? "left" : h > f && d >= 0 ? "down" : h > f && d <= 0 ? "up" : TY();
      }
    };
  }
  return {
    addMovement: t,
    endTouch: n,
    getVelocity: i
  };
}
function TY() {
  throw new Error();
}
function xY(e) {
  let {
    el: t,
    isActive: n,
    isTemporary: i,
    width: r,
    touchless: s,
    position: a
  } = e;
  En(() => {
    window.addEventListener("touchstart", k, {
      passive: !0
    }), window.addEventListener("touchmove", T, {
      passive: !1
    }), window.addEventListener("touchend", _, {
      passive: !0
    });
  }), ai(() => {
    window.removeEventListener("touchstart", k), window.removeEventListener("touchmove", T), window.removeEventListener("touchend", _);
  });
  const o = b(() => ["left", "right"].includes(a.value)), {
    addMovement: l,
    endTouch: u,
    getVelocity: c
  } = CY();
  let d = !1;
  const f = pe(!1), h = pe(0), m = pe(0);
  let g;
  function p(S, C) {
    return (a.value === "left" ? S : a.value === "right" ? document.documentElement.clientWidth - S : a.value === "top" ? S : a.value === "bottom" ? document.documentElement.clientHeight - S : jo()) - (C ? r.value : 0);
  }
  function y(S) {
    let C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const x = a.value === "left" ? (S - m.value) / r.value : a.value === "right" ? (document.documentElement.clientWidth - S - m.value) / r.value : a.value === "top" ? (S - m.value) / r.value : a.value === "bottom" ? (document.documentElement.clientHeight - S - m.value) / r.value : jo();
    return C ? Math.max(0, Math.min(1, x)) : x;
  }
  function k(S) {
    if (s.value)
      return;
    const C = S.changedTouches[0].clientX, x = S.changedTouches[0].clientY, A = 25, I = a.value === "left" ? C < A : a.value === "right" ? C > document.documentElement.clientWidth - A : a.value === "top" ? x < A : a.value === "bottom" ? x > document.documentElement.clientHeight - A : jo(), E = n.value && (a.value === "left" ? C < r.value : a.value === "right" ? C > document.documentElement.clientWidth - r.value : a.value === "top" ? x < r.value : a.value === "bottom" ? x > document.documentElement.clientHeight - r.value : jo());
    (I || E || n.value && i.value) && (g = [C, x], m.value = p(o.value ? C : x, n.value), h.value = y(o.value ? C : x), d = m.value > -20 && m.value < 80, u(S), l(S));
  }
  function T(S) {
    const C = S.changedTouches[0].clientX, x = S.changedTouches[0].clientY;
    if (d) {
      if (!S.cancelable) {
        d = !1;
        return;
      }
      const I = Math.abs(C - g[0]), E = Math.abs(x - g[1]);
      (o.value ? I > E && I > 3 : E > I && E > 3) ? (f.value = !0, d = !1) : (o.value ? E : I) > 3 && (d = !1);
    }
    if (!f.value)
      return;
    S.preventDefault(), l(S);
    const A = y(o.value ? C : x, !1);
    h.value = Math.max(0, Math.min(1, A)), A > 1 ? m.value = p(o.value ? C : x, !0) : A < 0 && (m.value = p(o.value ? C : x, !1));
  }
  function _(S) {
    if (d = !1, !f.value)
      return;
    l(S), f.value = !1;
    const C = c(S.changedTouches[0].identifier), x = Math.abs(C.x), A = Math.abs(C.y);
    (o.value ? x > A && x > 400 : A > x && A > 3) ? n.value = C.direction === ({
      left: "right",
      right: "left",
      top: "down",
      bottom: "up"
    }[a.value] || jo()) : n.value = h.value > 0.5;
  }
  const w = b(() => f.value ? {
    transform: a.value === "left" ? `translateX(calc(-100% + ${h.value * r.value}px))` : a.value === "right" ? `translateX(calc(100% - ${h.value * r.value}px))` : a.value === "top" ? `translateY(calc(-100% + ${h.value * r.value}px))` : a.value === "bottom" ? `translateY(calc(100% - ${h.value * r.value}px))` : jo(),
    transition: "none"
  } : void 0);
  return vi(f, () => {
    var x, A;
    const S = ((x = t.value) == null ? void 0 : x.style.transform) ?? null, C = ((A = t.value) == null ? void 0 : A.style.transition) ?? null;
    Wt(() => {
      var I, E, P, V;
      (E = t.value) == null || E.style.setProperty("transform", ((I = w.value) == null ? void 0 : I.transform) || "none"), (V = t.value) == null || V.style.setProperty("transition", ((P = w.value) == null ? void 0 : P.transition) || null);
    }), jn(() => {
      var I, E;
      (I = t.value) == null || I.style.setProperty("transform", S), (E = t.value) == null || E.style.setProperty("transition", C);
    });
  }), {
    isDragging: f,
    dragProgress: h,
    dragStyles: w
  };
}
function jo() {
  throw new Error();
}
const AY = ["start", "end", "left", "right", "top", "bottom"], IY = B({
  color: String,
  disableResizeWatcher: Boolean,
  disableRouteWatcher: Boolean,
  expandOnHover: Boolean,
  floating: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  permanent: Boolean,
  rail: {
    type: Boolean,
    default: null
  },
  railWidth: {
    type: [Number, String],
    default: 56
  },
  scrim: {
    type: [Boolean, String],
    default: !0
  },
  image: String,
  temporary: Boolean,
  persistent: Boolean,
  touchless: Boolean,
  width: {
    type: [Number, String],
    default: 256
  },
  location: {
    type: String,
    default: "start",
    validator: (e) => AY.includes(e)
  },
  sticky: Boolean,
  ...Ni(),
  ...ke(),
  ...rb(),
  ...jl({
    mobile: null
  }),
  ...gn(),
  ...bo(),
  ...It(),
  ...je({
    tag: "nav"
  }),
  ...Qe()
}, "VNavigationDrawer"), EY = J()({
  name: "VNavigationDrawer",
  props: IY(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:rail": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const {
      isRtl: s
    } = wn(), {
      themeClasses: a
    } = lt(e), {
      borderClasses: o
    } = er(e), {
      backgroundColorClasses: l,
      backgroundColorStyles: u
    } = gt(G(e, "color")), {
      elevationClasses: c
    } = On(e), {
      displayClasses: d,
      mobile: f
    } = Ar(e), {
      roundedClasses: h
    } = Ht(e), m = $x(), g = Ee(e, "modelValue", null, (ne) => !!ne), {
      ssrBootStyles: p
    } = Io(), {
      scopeId: y
    } = Do(), k = X(), T = pe(!1), {
      runOpenDelay: _,
      runCloseDelay: w
    } = sb(e, (ne) => {
      T.value = ne;
    }), S = b(() => e.rail && e.expandOnHover && T.value ? Number(e.width) : Number(e.rail ? e.railWidth : e.width)), C = b(() => Ov(e.location, s.value)), x = b(() => e.persistent), A = b(() => !e.permanent && (f.value || e.temporary)), I = b(() => e.sticky && !A.value && C.value !== "bottom");
    vi(() => e.expandOnHover && e.rail != null, () => {
      fe(T, (ne) => i("update:rail", !ne));
    }), vi(() => !e.disableResizeWatcher, () => {
      fe(A, (ne) => !e.permanent && He(() => g.value = !ne));
    }), vi(() => !e.disableRouteWatcher && !!m, () => {
      fe(m.currentRoute, () => A.value && (g.value = !1));
    }), fe(() => e.permanent, (ne) => {
      ne && (g.value = !0);
    }), e.modelValue == null && !A.value && (g.value = e.permanent || !f.value);
    const {
      isDragging: E,
      dragProgress: P
    } = xY({
      el: k,
      isActive: g,
      isTemporary: A,
      width: S,
      touchless: G(e, "touchless"),
      position: C
    }), V = b(() => {
      const ne = A.value ? 0 : e.rail && e.expandOnHover ? Number(e.railWidth) : S.value;
      return E.value ? ne * P.value : ne;
    }), N = b(() => ["top", "bottom"].includes(e.location) ? 0 : S.value), {
      layoutItemStyles: F,
      layoutItemScrimStyles: $,
      layoutIsReady: Z
    } = wo({
      id: e.name,
      order: b(() => parseInt(e.order, 10)),
      position: C,
      layoutSize: V,
      elementSize: N,
      active: b(() => g.value || E.value),
      disableTransitions: b(() => E.value),
      absolute: b(() => (
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        e.absolute || I.value && typeof j.value != "string"
      ))
    }), {
      isStuck: j,
      stickyStyles: H
    } = _Y({
      rootEl: k,
      isSticky: I,
      layoutItemStyles: F
    }), R = gt(b(() => typeof e.scrim == "string" ? e.scrim : null)), L = b(() => ({
      ...E.value ? {
        opacity: P.value * 0.2,
        transition: "none"
      } : void 0,
      ...$.value
    }));
    return jt({
      VList: {
        bgColor: "transparent"
      }
    }), re(() => {
      const ne = r.image || e.image;
      return v(De, null, [v(e.tag, ie({
        ref: k,
        onMouseenter: _,
        onMouseleave: w,
        class: ["v-navigation-drawer", `v-navigation-drawer--${C.value}`, {
          "v-navigation-drawer--expand-on-hover": e.expandOnHover,
          "v-navigation-drawer--floating": e.floating,
          "v-navigation-drawer--is-hovering": T.value,
          "v-navigation-drawer--rail": e.rail,
          "v-navigation-drawer--temporary": A.value,
          "v-navigation-drawer--persistent": x.value,
          "v-navigation-drawer--active": g.value,
          "v-navigation-drawer--sticky": I.value
        }, a.value, l.value, o.value, d.value, c.value, h.value, e.class],
        style: [u.value, F.value, p.value, H.value, e.style, ["top", "bottom"].includes(C.value) ? {
          height: "auto"
        } : {}]
      }, y, n), {
        default: () => {
          var oe, we, ee;
          return [ne && v("div", {
            key: "image",
            class: "v-navigation-drawer__img"
          }, [r.image ? v(Ze, {
            key: "image-defaults",
            disabled: !e.image,
            defaults: {
              VImg: {
                alt: "",
                cover: !0,
                height: "inherit",
                src: e.image
              }
            }
          }, r.image) : v(ks, {
            key: "image-img",
            alt: "",
            cover: !0,
            height: "inherit",
            src: e.image
          }, null)]), r.prepend && v("div", {
            class: "v-navigation-drawer__prepend"
          }, [(oe = r.prepend) == null ? void 0 : oe.call(r)]), v("div", {
            class: "v-navigation-drawer__content"
          }, [(we = r.default) == null ? void 0 : we.call(r)]), r.append && v("div", {
            class: "v-navigation-drawer__append"
          }, [(ee = r.append) == null ? void 0 : ee.call(r)])];
        }
      }), v(na, {
        name: "fade-transition"
      }, {
        default: () => [A.value && (E.value || g.value) && !!e.scrim && v("div", ie({
          class: ["v-navigation-drawer__scrim", R.backgroundColorClasses.value],
          style: [L.value, R.backgroundColorStyles.value],
          onClick: () => {
            x.value || (g.value = !1);
          }
        }, y), null)]
      })]);
    }), Z.then(() => ({
      isStuck: j
    }));
  }
}), PY = Pi({
  name: "VNoSsr",
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = wA();
    return () => {
      var r;
      return i.value && ((r = n.default) == null ? void 0 : r.call(n));
    };
  }
});
const OY = B({
  autofocus: Boolean,
  divider: String,
  focusAll: Boolean,
  label: {
    type: String,
    default: "$vuetify.input.otp"
  },
  length: {
    type: [Number, String],
    default: 6
  },
  modelValue: {
    type: [Number, String],
    default: void 0
  },
  placeholder: String,
  type: {
    type: String,
    default: "number"
  },
  ...Sn(),
  ...Pc(),
  ...ch(Dc({
    variant: "outlined"
  }), ["baseColor", "bgColor", "class", "color", "disabled", "error", "loading", "rounded", "style", "theme", "variant"])
}, "VOtpInput"), VY = J()({
  name: "VOtpInput",
  props: OY(),
  emits: {
    finish: (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const {
      dimensionStyles: s
    } = kn(e), {
      isFocused: a,
      focus: o,
      blur: l
    } = xs(e), u = Ee(e, "modelValue", "", (x) => x == null ? [] : String(x).split(""), (x) => x.join("")), {
      t: c
    } = qt(), d = b(() => Number(e.length)), f = b(() => Array(d.value).fill(0)), h = X(-1), m = X(), g = X([]), p = b(() => g.value[h.value]);
    function y() {
      if (C(p.value.value)) {
        p.value.value = "";
        return;
      }
      const x = u.value.slice(), A = p.value.value;
      x[h.value] = A;
      let I = null;
      h.value > u.value.length ? I = u.value.length + 1 : h.value + 1 !== d.value && (I = "next"), u.value = x, I && gl(m.value, I);
    }
    function k(x) {
      const A = u.value.slice(), I = h.value;
      let E = null;
      ["ArrowLeft", "ArrowRight", "Backspace", "Delete"].includes(x.key) && (x.preventDefault(), x.key === "ArrowLeft" ? E = "prev" : x.key === "ArrowRight" ? E = "next" : ["Backspace", "Delete"].includes(x.key) && (A[h.value] = "", u.value = A, h.value > 0 && x.key === "Backspace" ? E = "prev" : requestAnimationFrame(() => {
        var P;
        (P = g.value[I]) == null || P.select();
      })), requestAnimationFrame(() => {
        E != null && gl(m.value, E);
      }));
    }
    function T(x, A) {
      var E, P;
      A.preventDefault(), A.stopPropagation();
      const I = ((E = A == null ? void 0 : A.clipboardData) == null ? void 0 : E.getData("Text")) ?? "";
      C(I) || (u.value = I.split(""), (P = g.value) == null || P[x].blur());
    }
    function _() {
      u.value = [];
    }
    function w(x, A) {
      o(), h.value = A;
    }
    function S() {
      l(), h.value = -1;
    }
    function C(x) {
      return e.type === "number" && /[^0-9]/g.test(x);
    }
    return jt({
      VField: {
        color: b(() => e.color),
        bgColor: b(() => e.color),
        baseColor: b(() => e.baseColor),
        disabled: b(() => e.disabled),
        error: b(() => e.error),
        variant: b(() => e.variant)
      }
    }, {
      scoped: !0
    }), fe(u, (x) => {
      x.length === d.value && i("finish", x.join(""));
    }, {
      deep: !0
    }), fe(h, (x) => {
      x < 0 || He(() => {
        var A;
        (A = g.value[x]) == null || A.select();
      });
    }), re(() => {
      var I;
      const [x, A] = la(n);
      return v("div", ie({
        class: ["v-otp-input", {
          "v-otp-input--divided": !!e.divider
        }, e.class],
        style: [e.style]
      }, x), [v("div", {
        ref: m,
        class: "v-otp-input__content",
        style: [s.value]
      }, [f.value.map((E, P) => v(De, null, [e.divider && P !== 0 && v("span", {
        class: "v-otp-input__divider"
      }, [e.divider]), v(Wl, {
        focused: a.value && e.focusAll || h.value === P,
        key: P
      }, {
        ...r,
        loader: void 0,
        default: () => v("input", {
          ref: (V) => g.value[P] = V,
          "aria-label": c(e.label, P + 1),
          autofocus: P === 0 && e.autofocus,
          autocomplete: "one-time-code",
          class: ["v-otp-input__field"],
          disabled: e.disabled,
          inputmode: e.type === "number" ? "numeric" : "text",
          min: e.type === "number" ? 0 : void 0,
          maxlength: "1",
          placeholder: e.placeholder,
          type: e.type === "number" ? "text" : e.type,
          value: u.value[P],
          onInput: y,
          onFocus: (V) => w(V, P),
          onBlur: S,
          onKeydown: k,
          onPaste: (V) => T(P, V)
        }, null)
      })])), v("input", ie({
        class: "v-otp-input-input",
        type: "hidden"
      }, A, {
        value: u.value.join("")
      }), null), v(Gr, {
        contained: !0,
        "content-class": "v-otp-input__loader",
        "model-value": !!e.loading,
        persistent: !0
      }, {
        default: () => {
          var E;
          return [((E = r.loader) == null ? void 0 : E.call(r)) ?? v(Nl, {
            color: typeof e.loading == "boolean" ? void 0 : e.loading,
            indeterminate: !0,
            size: "24",
            width: "2"
          }, null)];
        }
      }), (I = r.default) == null ? void 0 : I.call(r)])]);
    }), {
      blur: () => {
        var x;
        (x = g.value) == null || x.some((A) => A.blur());
      },
      focus: () => {
        var x;
        (x = g.value) == null || x[0].focus();
      },
      reset: _,
      isFocused: a
    };
  }
});
function DY(e) {
  return Math.floor(Math.abs(e)) * Math.sign(e);
}
const NY = B({
  scale: {
    type: [Number, String],
    default: 0.5
  },
  ...ke()
}, "VParallax"), MY = J()({
  name: "VParallax",
  props: NY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      intersectionRef: i,
      isIntersecting: r
    } = yh(), {
      resizeRef: s,
      contentRect: a
    } = Sr(), {
      height: o
    } = Ar(), l = X();
    Wt(() => {
      var h;
      i.value = s.value = (h = l.value) == null ? void 0 : h.$el;
    });
    let u;
    fe(r, (h) => {
      h ? (u = fp(i.value), u = u === document.scrollingElement ? document : u, u.addEventListener("scroll", f, {
        passive: !0
      }), f()) : u.removeEventListener("scroll", f);
    }), ai(() => {
      u == null || u.removeEventListener("scroll", f);
    }), fe(o, f), fe(() => {
      var h;
      return (h = a.value) == null ? void 0 : h.height;
    }, f);
    const c = b(() => 1 - Xt(+e.scale));
    let d = -1;
    function f() {
      r.value && (cancelAnimationFrame(d), d = requestAnimationFrame(() => {
        var w;
        const h = ((w = l.value) == null ? void 0 : w.$el).querySelector(".v-img__img");
        if (!h)
          return;
        const m = u instanceof Document ? document.documentElement.clientHeight : u.clientHeight, g = u instanceof Document ? window.scrollY : u.scrollTop, p = i.value.getBoundingClientRect().top + g, y = a.value.height, k = p + (y - m) / 2, T = DY((g - k) * c.value), _ = Math.max(1, (c.value * (m - y) + y) / y);
        h.style.setProperty("transform", `translateY(${T}px) scale(${_})`);
      }));
    }
    return re(() => v(ks, {
      class: ["v-parallax", {
        "v-parallax--active": r.value
      }, e.class],
      style: e.style,
      ref: l,
      cover: !0,
      onLoadstart: f,
      onLoad: f
    }, n)), {};
  }
}), RY = B({
  ...um({
    falseIcon: "$radioOff",
    trueIcon: "$radioOn"
  })
}, "VRadio"), FY = J()({
  name: "VRadio",
  props: RY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => v(co, ie(e, {
      class: ["v-radio", e.class],
      style: e.style,
      type: "radio"
    }), n)), {};
  }
});
const BY = B({
  height: {
    type: [Number, String],
    default: "auto"
  },
  ...As(),
  ...an(Qy(), ["multiple"]),
  trueIcon: {
    type: We,
    default: "$radioOn"
  },
  falseIcon: {
    type: We,
    default: "$radioOff"
  },
  type: {
    type: String,
    default: "radio"
  }
}, "VRadioGroup"), LY = J()({
  name: "VRadioGroup",
  inheritAttrs: !1,
  props: BY(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const r = Pn(), s = b(() => e.id || `radio-group-${r}`), a = Ee(e, "modelValue");
    return re(() => {
      const [o, l] = la(n), u = Wn.filterProps(e), c = co.filterProps(e), d = i.label ? i.label({
        label: e.label,
        props: {
          for: s.value
        }
      }) : e.label;
      return v(Wn, ie({
        class: ["v-radio-group", e.class],
        style: e.style
      }, o, u, {
        modelValue: a.value,
        "onUpdate:modelValue": (f) => a.value = f,
        id: s.value
      }), {
        ...i,
        default: (f) => {
          let {
            id: h,
            messagesId: m,
            isDisabled: g,
            isReadonly: p
          } = f;
          return v(De, null, [d && v(Ll, {
            id: h.value
          }, {
            default: () => [d]
          }), v(Xx, ie(c, {
            id: h.value,
            "aria-describedby": m.value,
            defaultsTarget: "VRadio",
            trueIcon: e.trueIcon,
            falseIcon: e.falseIcon,
            type: e.type,
            disabled: g.value,
            readonly: p.value,
            "aria-labelledby": d ? h.value : void 0,
            multiple: !1
          }, l, {
            modelValue: a.value,
            "onUpdate:modelValue": (y) => a.value = y
          }), i)]);
        }
      });
    }), {};
  }
}), $Y = B({
  ...Pc(),
  ...As(),
  ...WA(),
  strict: Boolean,
  modelValue: {
    type: Array,
    default: () => [0, 0]
  }
}, "VRangeSlider"), WY = J()({
  name: "VRangeSlider",
  props: $Y(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    end: (e) => !0,
    start: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const r = X(), s = X(), a = X(), {
      rtlClasses: o
    } = wn();
    function l(I) {
      if (!r.value || !s.value)
        return;
      const E = jg(I, r.value.$el, e.direction), P = jg(I, s.value.$el, e.direction), V = Math.abs(E), N = Math.abs(P);
      return V < N || V === N && E < 0 ? r.value.$el : s.value.$el;
    }
    const u = jA(e), c = Ee(e, "modelValue", void 0, (I) => I != null && I.length ? I.map((E) => u.roundValue(E)) : [0, 0]), {
      activeThumbRef: d,
      hasLabels: f,
      max: h,
      min: m,
      mousePressed: g,
      onSliderMousedown: p,
      onSliderTouchstart: y,
      position: k,
      trackContainerRef: T,
      readonly: _
    } = HA({
      props: e,
      steps: u,
      onSliderStart: () => {
        i("start", c.value);
      },
      onSliderEnd: (I) => {
        var V;
        let {
          value: E
        } = I;
        const P = d.value === ((V = r.value) == null ? void 0 : V.$el) ? [E, c.value[1]] : [c.value[0], E];
        !e.strict && P[0] < P[1] && (c.value = P), i("end", c.value);
      },
      onSliderMove: (I) => {
        var N, F, $, Z;
        let {
          value: E
        } = I;
        const [P, V] = c.value;
        !e.strict && P === V && P !== m.value && (d.value = E > P ? (N = s.value) == null ? void 0 : N.$el : (F = r.value) == null ? void 0 : F.$el, ($ = d.value) == null || $.focus()), d.value === ((Z = r.value) == null ? void 0 : Z.$el) ? c.value = [Math.min(E, V), V] : c.value = [P, Math.max(P, E)];
      },
      getActiveThumb: l
    }), {
      isFocused: w,
      focus: S,
      blur: C
    } = xs(e), x = b(() => k(c.value[0])), A = b(() => k(c.value[1]));
    return re(() => {
      const I = Wn.filterProps(e), E = !!(e.label || n.label || n.prepend);
      return v(Wn, ie({
        class: ["v-slider", "v-range-slider", {
          "v-slider--has-labels": !!n["tick-label"] || f.value,
          "v-slider--focused": w.value,
          "v-slider--pressed": g.value,
          "v-slider--disabled": e.disabled
        }, o.value, e.class],
        style: e.style,
        ref: a
      }, I, {
        focused: w.value
      }), {
        ...n,
        prepend: E ? (P) => {
          var V, N;
          return v(De, null, [((V = n.label) == null ? void 0 : V.call(n, P)) ?? (e.label ? v(Ll, {
            class: "v-slider__label",
            text: e.label
          }, null) : void 0), (N = n.prepend) == null ? void 0 : N.call(n, P)]);
        } : void 0,
        default: (P) => {
          var F, $;
          let {
            id: V,
            messagesId: N
          } = P;
          return v("div", {
            class: "v-slider__container",
            onMousedown: _.value ? void 0 : p,
            onTouchstartPassive: _.value ? void 0 : y
          }, [v("input", {
            id: `${V.value}_start`,
            name: e.name || V.value,
            disabled: !!e.disabled,
            readonly: !!e.readonly,
            tabindex: "-1",
            value: c.value[0]
          }, null), v("input", {
            id: `${V.value}_stop`,
            name: e.name || V.value,
            disabled: !!e.disabled,
            readonly: !!e.readonly,
            tabindex: "-1",
            value: c.value[1]
          }, null), v(zA, {
            ref: T,
            start: x.value,
            stop: A.value
          }, {
            "tick-label": n["tick-label"]
          }), v(Hg, {
            ref: r,
            "aria-describedby": N.value,
            focused: w && d.value === ((F = r.value) == null ? void 0 : F.$el),
            modelValue: c.value[0],
            "onUpdate:modelValue": (Z) => c.value = [Z, c.value[1]],
            onFocus: (Z) => {
              var j, H, R, L;
              S(), d.value = (j = r.value) == null ? void 0 : j.$el, c.value[0] === c.value[1] && c.value[1] === m.value && Z.relatedTarget !== ((H = s.value) == null ? void 0 : H.$el) && ((R = r.value) == null || R.$el.blur(), (L = s.value) == null || L.$el.focus());
            },
            onBlur: () => {
              C(), d.value = void 0;
            },
            min: m.value,
            max: c.value[1],
            position: x.value,
            ripple: e.ripple
          }, {
            "thumb-label": n["thumb-label"]
          }), v(Hg, {
            ref: s,
            "aria-describedby": N.value,
            focused: w && d.value === (($ = s.value) == null ? void 0 : $.$el),
            modelValue: c.value[1],
            "onUpdate:modelValue": (Z) => c.value = [c.value[0], Z],
            onFocus: (Z) => {
              var j, H, R, L;
              S(), d.value = (j = s.value) == null ? void 0 : j.$el, c.value[0] === c.value[1] && c.value[0] === h.value && Z.relatedTarget !== ((H = r.value) == null ? void 0 : H.$el) && ((R = s.value) == null || R.$el.blur(), (L = r.value) == null || L.$el.focus());
            },
            onBlur: () => {
              C(), d.value = void 0;
            },
            min: c.value[0],
            max: h.value,
            position: A.value,
            ripple: e.ripple
          }, {
            "thumb-label": n["thumb-label"]
          })]);
        }
      });
    }), {};
  }
});
const jY = B({
  name: String,
  itemAriaLabel: {
    type: String,
    default: "$vuetify.rating.ariaLabel.item"
  },
  activeColor: String,
  color: String,
  clearable: Boolean,
  disabled: Boolean,
  emptyIcon: {
    type: We,
    default: "$ratingEmpty"
  },
  fullIcon: {
    type: We,
    default: "$ratingFull"
  },
  halfIncrements: Boolean,
  hover: Boolean,
  length: {
    type: [Number, String],
    default: 5
  },
  readonly: Boolean,
  modelValue: {
    type: [Number, String],
    default: 0
  },
  itemLabels: Array,
  itemLabelPosition: {
    type: String,
    default: "top",
    validator: (e) => ["top", "bottom"].includes(e)
  },
  ripple: Boolean,
  ...ke(),
  ..._n(),
  ...Xr(),
  ...je(),
  ...Qe()
}, "VRating"), HY = J()({
  name: "VRating",
  props: jY(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: i
    } = qt(), {
      themeClasses: r
    } = lt(e), s = Ee(e, "modelValue"), a = b(() => Xt(parseFloat(s.value), 0, +e.length)), o = b(() => Hr(Number(e.length), 1)), l = b(() => o.value.flatMap((g) => e.halfIncrements ? [g - 0.5, g] : [g])), u = pe(-1), c = b(() => l.value.map((g) => {
      const p = e.hover && u.value > -1, y = a.value >= g, k = u.value >= g, _ = (p ? k : y) ? e.fullIcon : e.emptyIcon, w = e.activeColor ?? e.color, S = y || k ? w : e.color;
      return {
        isFilled: y,
        isHovered: k,
        icon: _,
        color: S
      };
    })), d = b(() => [0, ...l.value].map((g) => {
      function p() {
        u.value = g;
      }
      function y() {
        u.value = -1;
      }
      function k() {
        e.disabled || e.readonly || (s.value = a.value === g && e.clearable ? 0 : g);
      }
      return {
        onMouseenter: e.hover ? p : void 0,
        onMouseleave: e.hover ? y : void 0,
        onClick: k
      };
    })), f = b(() => e.name ?? `v-rating-${Pn()}`);
    function h(g) {
      var x, A;
      let {
        value: p,
        index: y,
        showStar: k = !0
      } = g;
      const {
        onMouseenter: T,
        onMouseleave: _,
        onClick: w
      } = d.value[y + 1], S = `${f.value}-${String(p).replace(".", "-")}`, C = {
        color: (x = c.value[y]) == null ? void 0 : x.color,
        density: e.density,
        disabled: e.disabled,
        icon: (A = c.value[y]) == null ? void 0 : A.icon,
        ripple: e.ripple,
        size: e.size,
        variant: "plain"
      };
      return v(De, null, [v("label", {
        for: S,
        class: {
          "v-rating__item--half": e.halfIncrements && p % 1 > 0,
          "v-rating__item--full": e.halfIncrements && p % 1 === 0
        },
        onMouseenter: T,
        onMouseleave: _,
        onClick: w
      }, [v("span", {
        class: "v-rating__hidden"
      }, [i(e.itemAriaLabel, p, e.length)]), k ? n.item ? n.item({
        ...c.value[y],
        props: C,
        value: p,
        index: y,
        rating: a.value
      }) : v(st, ie({
        "aria-label": i(e.itemAriaLabel, p, e.length)
      }, C), null) : void 0]), v("input", {
        class: "v-rating__hidden",
        name: f.value,
        id: S,
        type: "radio",
        value: p,
        checked: a.value === p,
        tabindex: -1,
        readonly: e.readonly,
        disabled: e.disabled
      }, null)]);
    }
    function m(g) {
      return n["item-label"] ? n["item-label"](g) : g.label ? v("span", null, [g.label]) : v("span", null, [_r("")]);
    }
    return re(() => {
      var p;
      const g = !!((p = e.itemLabels) != null && p.length) || n["item-label"];
      return v(e.tag, {
        class: ["v-rating", {
          "v-rating--hover": e.hover,
          "v-rating--readonly": e.readonly
        }, r.value, e.class],
        style: e.style
      }, {
        default: () => [v(h, {
          value: 0,
          index: -1,
          showStar: !1
        }, null), o.value.map((y, k) => {
          var T, _;
          return v("div", {
            class: "v-rating__wrapper"
          }, [g && e.itemLabelPosition === "top" ? m({
            value: y,
            index: k,
            label: (T = e.itemLabels) == null ? void 0 : T[k]
          }) : void 0, v("div", {
            class: "v-rating__item"
          }, [e.halfIncrements ? v(De, null, [v(h, {
            value: y - 0.5,
            index: k * 2
          }, null), v(h, {
            value: y,
            index: k * 2 + 1
          }, null)]) : v(h, {
            value: y,
            index: k
          }, null)]), g && e.itemLabelPosition === "bottom" ? m({
            value: y,
            index: k,
            label: (_ = e.itemLabels) == null ? void 0 : _[k]
          }) : void 0]);
        })]
      });
    }), {};
  }
});
const zY = {
  actions: "button@2",
  article: "heading, paragraph",
  avatar: "avatar",
  button: "button",
  card: "image, heading",
  "card-avatar": "image, list-item-avatar",
  chip: "chip",
  "date-picker": "list-item, heading, divider, date-picker-options, date-picker-days, actions",
  "date-picker-options": "text, avatar@2",
  "date-picker-days": "avatar@28",
  divider: "divider",
  heading: "heading",
  image: "image",
  "list-item": "text",
  "list-item-avatar": "avatar, text",
  "list-item-two-line": "sentences",
  "list-item-avatar-two-line": "avatar, sentences",
  "list-item-three-line": "paragraph",
  "list-item-avatar-three-line": "avatar, paragraph",
  ossein: "ossein",
  paragraph: "text@3",
  sentences: "text@2",
  subtitle: "text",
  table: "table-heading, table-thead, table-tbody, table-tfoot",
  "table-heading": "chip, text",
  "table-thead": "heading@6",
  "table-tbody": "table-row-divider@6",
  "table-row-divider": "table-row, divider",
  "table-row": "text@6",
  "table-tfoot": "text@2, avatar@2",
  text: "text"
};
function UY(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return v("div", {
    class: ["v-skeleton-loader__bone", `v-skeleton-loader__${e}`]
  }, [t]);
}
function U_(e) {
  const [t, n] = e.split("@");
  return Array.from({
    length: n
  }).map(() => Cm(t));
}
function Cm(e) {
  let t = [];
  if (!e)
    return t;
  const n = zY[e];
  if (e !== n) {
    if (e.includes(","))
      return q_(e);
    if (e.includes("@"))
      return U_(e);
    n.includes(",") ? t = q_(n) : n.includes("@") ? t = U_(n) : n && t.push(Cm(n));
  }
  return [UY(e, t)];
}
function q_(e) {
  return e.replace(/\s/g, "").split(",").map(Cm);
}
const qY = B({
  boilerplate: Boolean,
  color: String,
  loading: Boolean,
  loadingText: {
    type: String,
    default: "$vuetify.loading"
  },
  type: {
    type: [String, Array],
    default: "ossein"
  },
  ...Sn(),
  ...gn(),
  ...Qe()
}, "VSkeletonLoader"), GY = J()({
  name: "VSkeletonLoader",
  props: qY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: r
    } = gt(G(e, "color")), {
      dimensionStyles: s
    } = kn(e), {
      elevationClasses: a
    } = On(e), {
      themeClasses: o
    } = lt(e), {
      t: l
    } = qt(), u = b(() => Cm(Nt(e.type).join(",")));
    return re(() => {
      var d;
      const c = !n.default || e.loading;
      return v("div", {
        class: ["v-skeleton-loader", {
          "v-skeleton-loader--boilerplate": e.boilerplate
        }, o.value, i.value, a.value],
        style: [r.value, c ? s.value : {}],
        "aria-busy": e.boilerplate ? void 0 : c,
        "aria-live": e.boilerplate ? void 0 : "polite",
        "aria-label": e.boilerplate ? void 0 : l(e.loadingText),
        role: e.boilerplate ? void 0 : "alert"
      }, [c ? u.value : (d = n.default) == null ? void 0 : d.call(n)]);
    }), {};
  }
}), YY = J()({
  name: "VSlideGroupItem",
  props: Oo(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Vo(e, tA);
    return () => {
      var r;
      return (r = n.default) == null ? void 0 : r.call(n, {
        isSelected: i.isSelected.value,
        select: i.select,
        toggle: i.toggle,
        selectedClass: i.selectedClass.value
      });
    };
  }
});
function ZY(e) {
  const t = pe(e);
  let n = -1;
  function i() {
    clearInterval(n);
  }
  function r() {
    i(), He(() => t.value = e);
  }
  function s(a) {
    const o = a ? getComputedStyle(a) : {
      transitionDuration: 0.2
    }, l = parseFloat(o.transitionDuration) * 1e3 || 200;
    if (i(), t.value <= 0)
      return;
    const u = performance.now();
    n = window.setInterval(() => {
      const c = performance.now() - u + l;
      t.value = Math.max(e - c, 0), t.value <= 0 && i();
    }, l);
  }
  return jn(i), {
    clear: i,
    time: t,
    start: s,
    reset: r
  };
}
const KY = B({
  multiLine: Boolean,
  text: String,
  timer: [Boolean, String],
  timeout: {
    type: [Number, String],
    default: 5e3
  },
  vertical: Boolean,
  ...ua({
    location: "bottom"
  }),
  ...su(),
  ...It(),
  ...tr(),
  ...Qe(),
  ...an(ud({
    transition: "v-snackbar-transition"
  }), ["persistent", "noClickAnimation", "scrim", "scrollStrategy"])
}, "VSnackbar"), XY = J()({
  name: "VSnackbar",
  props: KY(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), {
      positionClasses: r
    } = au(e), {
      scopeId: s
    } = Do(), {
      themeClasses: a
    } = lt(e), {
      colorClasses: o,
      colorStyles: l,
      variantClasses: u
    } = Eo(e), {
      roundedClasses: c
    } = Ht(e), d = ZY(Number(e.timeout)), f = X(), h = X(), m = pe(!1), g = pe(0), p = X(), y = tt(Ku, void 0);
    vi(() => !!y, () => {
      const I = ZS();
      Wt(() => {
        p.value = I.mainStyles.value;
      });
    }), fe(i, T), fe(() => e.timeout, T), En(() => {
      i.value && T();
    });
    let k = -1;
    function T() {
      d.reset(), window.clearTimeout(k);
      const I = Number(e.timeout);
      if (!i.value || I === -1)
        return;
      const E = sp(h.value);
      d.start(E), k = window.setTimeout(() => {
        i.value = !1;
      }, I);
    }
    function _() {
      d.reset(), window.clearTimeout(k);
    }
    function w() {
      m.value = !0, _();
    }
    function S() {
      m.value = !1, T();
    }
    function C(I) {
      g.value = I.touches[0].clientY;
    }
    function x(I) {
      Math.abs(g.value - I.changedTouches[0].clientY) > 50 && (i.value = !1);
    }
    const A = b(() => e.location.split(" ").reduce((I, E) => (I[`v-snackbar--${E}`] = !0, I), {}));
    return re(() => {
      const I = Gr.filterProps(e), E = !!(n.default || n.text || e.text);
      return v(Gr, ie({
        ref: f,
        class: ["v-snackbar", {
          "v-snackbar--active": i.value,
          "v-snackbar--multi-line": e.multiLine && !e.vertical,
          "v-snackbar--timer": !!e.timer,
          "v-snackbar--vertical": e.vertical
        }, A.value, r.value, e.class],
        style: [p.value, e.style]
      }, I, {
        modelValue: i.value,
        "onUpdate:modelValue": (P) => i.value = P,
        contentProps: ie({
          class: ["v-snackbar__wrapper", a.value, o.value, c.value, u.value],
          style: [l.value],
          onPointerenter: w,
          onPointerleave: S
        }, I.contentProps),
        persistent: !0,
        noClickAnimation: !0,
        scrim: !1,
        scrollStrategy: "none",
        _disableGlobalStack: !0,
        onTouchstartPassive: C,
        onTouchend: x
      }, s), {
        default: () => {
          var P, V;
          return [fa(!1, "v-snackbar"), e.timer && !m.value && v("div", {
            key: "timer",
            class: "v-snackbar__timer"
          }, [v(bh, {
            ref: h,
            color: typeof e.timer == "string" ? e.timer : "info",
            max: e.timeout,
            "model-value": d.time.value
          }, null)]), E && v("div", {
            key: "content",
            class: "v-snackbar__content",
            role: "status",
            "aria-live": "polite"
          }, [((P = n.text) == null ? void 0 : P.call(n)) ?? e.text, (V = n.default) == null ? void 0 : V.call(n)]), n.actions && v(Ze, {
            defaults: {
              VBtn: {
                variant: "text",
                ripple: !1,
                slim: !0
              }
            }
          }, {
            default: () => [v("div", {
              class: "v-snackbar__actions"
            }, [n.actions({
              isActive: i
            })])]
          })];
        },
        activator: n.activator
      });
    }), Qi({}, f);
  }
}), NI = B({
  autoDraw: Boolean,
  autoDrawDuration: [Number, String],
  autoDrawEasing: {
    type: String,
    default: "ease"
  },
  color: String,
  gradient: {
    type: Array,
    default: () => []
  },
  gradientDirection: {
    type: String,
    validator: (e) => ["top", "bottom", "left", "right"].includes(e),
    default: "top"
  },
  height: {
    type: [String, Number],
    default: 75
  },
  labels: {
    type: Array,
    default: () => []
  },
  labelSize: {
    type: [Number, String],
    default: 7
  },
  lineWidth: {
    type: [String, Number],
    default: 4
  },
  id: String,
  itemValue: {
    type: String,
    default: "value"
  },
  modelValue: {
    type: Array,
    default: () => []
  },
  min: [String, Number],
  max: [String, Number],
  padding: {
    type: [String, Number],
    default: 8
  },
  showLabels: Boolean,
  smooth: Boolean,
  width: {
    type: [Number, String],
    default: 300
  }
}, "Line"), MI = B({
  autoLineWidth: Boolean,
  ...NI()
}, "VBarline"), G_ = J()({
  name: "VBarline",
  props: MI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Pn(), r = b(() => e.id || `barline-${i}`), s = b(() => Number(e.autoDrawDuration) || 500), a = b(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), o = b(() => parseFloat(e.lineWidth) || 4), l = b(() => Math.max(e.modelValue.length * o.value, Number(e.width))), u = b(() => ({
      minX: 0,
      maxX: l.value,
      minY: 0,
      maxY: parseInt(e.height, 10)
    })), c = b(() => e.modelValue.map((g) => hn(g, e.itemValue, g)));
    function d(g, p) {
      const {
        minX: y,
        maxX: k,
        minY: T,
        maxY: _
      } = p, w = g.length;
      let S = e.max != null ? Number(e.max) : Math.max(...g), C = e.min != null ? Number(e.min) : Math.min(...g);
      C > 0 && e.min == null && (C = 0), S < 0 && e.max == null && (S = 0);
      const x = k / w, A = (_ - T) / (S - C || 1), I = _ - Math.abs(C * A);
      return g.map((E, P) => {
        const V = Math.abs(A * E);
        return {
          x: y + P * x,
          y: I - V + +(E < 0) * V,
          height: V,
          value: E
        };
      });
    }
    const f = b(() => {
      const g = [], p = d(c.value, u.value), y = p.length;
      for (let k = 0; g.length < y; k++) {
        const T = p[k];
        let _ = e.labels[k];
        _ || (_ = typeof T == "object" ? T.value : T), g.push({
          x: T.x,
          value: String(_)
        });
      }
      return g;
    }), h = b(() => d(c.value, u.value)), m = b(() => (Math.abs(h.value[0].x - h.value[1].x) - o.value) / 2);
    re(() => {
      const g = e.gradient.slice().length ? e.gradient.slice().reverse() : [""];
      return v("svg", {
        display: "block"
      }, [v("defs", null, [v("linearGradient", {
        id: r.value,
        gradientUnits: "userSpaceOnUse",
        x1: e.gradientDirection === "left" ? "100%" : "0",
        y1: e.gradientDirection === "top" ? "100%" : "0",
        x2: e.gradientDirection === "right" ? "100%" : "0",
        y2: e.gradientDirection === "bottom" ? "100%" : "0"
      }, [g.map((p, y) => v("stop", {
        offset: y / Math.max(g.length - 1, 1),
        "stop-color": p || "currentColor"
      }, null))])]), v("clipPath", {
        id: `${r.value}-clip`
      }, [h.value.map((p) => v("rect", {
        x: p.x + m.value,
        y: p.y,
        width: o.value,
        height: p.height,
        rx: typeof e.smooth == "number" ? e.smooth : e.smooth ? 2 : 0,
        ry: typeof e.smooth == "number" ? e.smooth : e.smooth ? 2 : 0
      }, [e.autoDraw && v(De, null, [v("animate", {
        attributeName: "y",
        from: p.y + p.height,
        to: p.y,
        dur: `${s.value}ms`,
        fill: "freeze"
      }, null), v("animate", {
        attributeName: "height",
        from: "0",
        to: p.height,
        dur: `${s.value}ms`,
        fill: "freeze"
      }, null)])]))]), a.value && v("g", {
        key: "labels",
        style: {
          textAnchor: "middle",
          dominantBaseline: "mathematical",
          fill: "currentColor"
        }
      }, [f.value.map((p, y) => {
        var k;
        return v("text", {
          x: p.x + m.value + o.value / 2,
          y: parseInt(e.height, 10) - 2 + (parseInt(e.labelSize, 10) || 7 * 0.75),
          "font-size": Number(e.labelSize) || 7
        }, [((k = n.label) == null ? void 0 : k.call(n, {
          index: y,
          value: p.value
        })) ?? p.value]);
      })]), v("g", {
        "clip-path": `url(#${r.value}-clip)`,
        fill: `url(#${r.value})`
      }, [v("rect", {
        x: 0,
        y: 0,
        width: Math.max(e.modelValue.length * o.value, Number(e.width)),
        height: e.height
      }, null)])]);
    });
  }
});
function JY(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 75;
  if (e.length === 0)
    return "";
  const r = e.shift(), s = e[e.length - 1];
  return (n ? `M${r.x} ${i - r.x + 2} L${r.x} ${r.y}` : `M${r.x} ${r.y}`) + e.map((a, o) => {
    const l = e[o + 1], u = e[o - 1] || r, c = l && QY(l, a, u);
    if (!l || c)
      return `L${a.x} ${a.y}`;
    const d = Math.min(Y_(u, a), Y_(l, a)), h = d / 2 < t ? d / 2 : t, m = Z_(u, a, h), g = Z_(l, a, h);
    return `L${m.x} ${m.y}S${a.x} ${a.y} ${g.x} ${g.y}`;
  }).join("") + (n ? `L${s.x} ${i - r.x + 2} Z` : "");
}
function Rd(e) {
  return parseInt(e, 10);
}
function QY(e, t, n) {
  return Rd(e.x + n.x) === Rd(2 * t.x) && Rd(e.y + n.y) === Rd(2 * t.y);
}
function Y_(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function Z_(e, t, n) {
  const i = {
    x: e.x - t.x,
    y: e.y - t.y
  }, r = Math.sqrt(i.x * i.x + i.y * i.y), s = {
    x: i.x / r,
    y: i.y / r
  };
  return {
    x: t.x + s.x * n,
    y: t.y + s.y * n
  };
}
const RI = B({
  fill: Boolean,
  ...NI()
}, "VTrendline"), K_ = J()({
  name: "VTrendline",
  props: RI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Pn(), r = b(() => e.id || `trendline-${i}`), s = b(() => Number(e.autoDrawDuration) || (e.fill ? 500 : 2e3)), a = X(0), o = X(null);
    function l(p, y) {
      const {
        minX: k,
        maxX: T,
        minY: _,
        maxY: w
      } = y, S = p.length, C = e.max != null ? Number(e.max) : Math.max(...p), x = e.min != null ? Number(e.min) : Math.min(...p), A = (T - k) / (S - 1), I = (w - _) / (C - x || 1);
      return p.map((E, P) => ({
        x: k + P * A,
        y: w - (E - x) * I,
        value: E
      }));
    }
    const u = b(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), c = b(() => parseFloat(e.lineWidth) || 4), d = b(() => Number(e.width)), f = b(() => {
      const p = Number(e.padding);
      return {
        minX: p,
        maxX: d.value - p,
        minY: p,
        maxY: parseInt(e.height, 10) - p
      };
    }), h = b(() => e.modelValue.map((p) => hn(p, e.itemValue, p))), m = b(() => {
      const p = [], y = l(h.value, f.value), k = y.length;
      for (let T = 0; p.length < k; T++) {
        const _ = y[T];
        let w = e.labels[T];
        w || (w = typeof _ == "object" ? _.value : _), p.push({
          x: _.x,
          value: String(w)
        });
      }
      return p;
    });
    fe(() => e.modelValue, async () => {
      if (await He(), !e.autoDraw || !o.value)
        return;
      const p = o.value, y = p.getTotalLength();
      e.fill ? (p.style.transformOrigin = "bottom center", p.style.transition = "none", p.style.transform = "scaleY(0)", p.getBoundingClientRect(), p.style.transition = `transform ${s.value}ms ${e.autoDrawEasing}`, p.style.transform = "scaleY(1)") : (p.style.strokeDasharray = `${y}`, p.style.strokeDashoffset = `${y}`, p.getBoundingClientRect(), p.style.transition = `stroke-dashoffset ${s.value}ms ${e.autoDrawEasing}`, p.style.strokeDashoffset = "0"), a.value = y;
    }, {
      immediate: !0
    });
    function g(p) {
      return JY(l(h.value, f.value), e.smooth ? 8 : Number(e.smooth), p, parseInt(e.height, 10));
    }
    re(() => {
      var y;
      const p = e.gradient.slice().length ? e.gradient.slice().reverse() : [""];
      return v("svg", {
        display: "block",
        "stroke-width": parseFloat(e.lineWidth) ?? 4
      }, [v("defs", null, [v("linearGradient", {
        id: r.value,
        gradientUnits: "userSpaceOnUse",
        x1: e.gradientDirection === "left" ? "100%" : "0",
        y1: e.gradientDirection === "top" ? "100%" : "0",
        x2: e.gradientDirection === "right" ? "100%" : "0",
        y2: e.gradientDirection === "bottom" ? "100%" : "0"
      }, [p.map((k, T) => v("stop", {
        offset: T / Math.max(p.length - 1, 1),
        "stop-color": k || "currentColor"
      }, null))])]), u.value && v("g", {
        key: "labels",
        style: {
          textAnchor: "middle",
          dominantBaseline: "mathematical",
          fill: "currentColor"
        }
      }, [m.value.map((k, T) => {
        var _;
        return v("text", {
          x: k.x + c.value / 2 + c.value / 2,
          y: parseInt(e.height, 10) - 4 + (parseInt(e.labelSize, 10) || 7 * 0.75),
          "font-size": Number(e.labelSize) || 7
        }, [((_ = n.label) == null ? void 0 : _.call(n, {
          index: T,
          value: k.value
        })) ?? k.value]);
      })]), v("path", {
        ref: o,
        d: g(e.fill),
        fill: e.fill ? `url(#${r.value})` : "none",
        stroke: e.fill ? "none" : `url(#${r.value})`
      }, null), e.fill && v("path", {
        d: g(!1),
        fill: "none",
        stroke: e.color ?? ((y = e.gradient) == null ? void 0 : y[0])
      }, null)]);
    });
  }
}), e7 = B({
  type: {
    type: String,
    default: "trend"
  },
  ...MI(),
  ...RI()
}, "VSparkline"), t7 = J()({
  name: "VSparkline",
  props: e7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      textColorClasses: i,
      textColorStyles: r
    } = $n(G(e, "color")), s = b(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), a = b(() => {
      let o = parseInt(e.height, 10);
      return s.value && (o += parseInt(e.labelSize, 10) * 1.5), o;
    });
    re(() => {
      const o = e.type === "trend" ? K_ : G_, l = e.type === "trend" ? K_.filterProps(e) : G_.filterProps(e);
      return v(o, ie({
        key: e.type,
        class: i.value,
        style: r.value,
        viewBox: `0 0 ${e.width} ${parseInt(a.value, 10)}`
      }, l), n);
    });
  }
});
const n7 = B({
  ...ke(),
  ...CA({
    offset: 8,
    minWidth: 0,
    openDelay: 0,
    closeDelay: 100,
    location: "top center",
    transition: "scale-transition"
  })
}, "VSpeedDial"), i7 = J()({
  name: "VSpeedDial",
  props: n7(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), r = X(), s = b(() => {
      const [o, l = "center"] = e.location.split(" ");
      return `${o} ${l}`;
    }), a = b(() => ({
      [`v-speed-dial__content--${s.value.replace(" ", "-")}`]: !0
    }));
    return re(() => {
      const o = Ml.filterProps(e);
      return v(Ml, ie(o, {
        modelValue: i.value,
        "onUpdate:modelValue": (l) => i.value = l,
        class: e.class,
        style: e.style,
        contentClass: ["v-speed-dial__content", a.value],
        location: s.value,
        ref: r,
        transition: "fade-transition"
      }), {
        ...n,
        default: (l) => v(Ze, {
          defaults: {
            VBtn: {
              size: "small"
            }
          }
        }, {
          default: () => [v(Gn, {
            appear: !0,
            group: !0,
            transition: e.transition
          }, {
            default: () => {
              var u;
              return [(u = n.default) == null ? void 0 : u.call(n, l)];
            }
          })]
        })
      });
    }), {};
  }
});
const FI = B({
  color: String,
  disabled: {
    type: [Boolean, String],
    default: !1
  },
  prevText: {
    type: String,
    default: "$vuetify.stepper.prev"
  },
  nextText: {
    type: String,
    default: "$vuetify.stepper.next"
  }
}, "VStepperActions"), BI = J()({
  name: "VStepperActions",
  props: FI(),
  emits: {
    "click:prev": () => !0,
    "click:next": () => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const {
      t: r
    } = qt();
    function s() {
      n("click:prev");
    }
    function a() {
      n("click:next");
    }
    return re(() => {
      const o = {
        onClick: s
      }, l = {
        onClick: a
      };
      return v("div", {
        class: "v-stepper-actions"
      }, [v(Ze, {
        defaults: {
          VBtn: {
            disabled: ["prev", !0].includes(e.disabled),
            text: r(e.prevText),
            variant: "text"
          }
        }
      }, {
        default: () => {
          var u;
          return [((u = i.prev) == null ? void 0 : u.call(i, {
            props: o
          })) ?? v(st, o, null)];
        }
      }), v(Ze, {
        defaults: {
          VBtn: {
            color: e.color,
            disabled: ["next", !0].includes(e.disabled),
            text: r(e.nextText),
            variant: "tonal"
          }
        }
      }, {
        default: () => {
          var u;
          return [((u = i.next) == null ? void 0 : u.call(i, {
            props: l
          })) ?? v(st, l, null)];
        }
      })]);
    }), {};
  }
}), LI = Zr("v-stepper-header");
const r7 = B({
  color: String,
  title: String,
  subtitle: String,
  complete: Boolean,
  completeIcon: {
    type: String,
    default: "$complete"
  },
  editable: Boolean,
  editIcon: {
    type: String,
    default: "$edit"
  },
  error: Boolean,
  errorIcon: {
    type: String,
    default: "$error"
  },
  icon: String,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  rules: {
    type: Array,
    default: () => []
  }
}, "StepperItem"), s7 = B({
  ...r7(),
  ...Oo()
}, "VStepperItem"), $I = J()({
  name: "VStepperItem",
  directives: {
    Ripple: Vs
  },
  props: s7(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Vo(e, HI, !0), r = b(() => (i == null ? void 0 : i.value.value) ?? e.value), s = b(() => e.rules.every((f) => f() === !0)), a = b(() => !e.disabled && e.editable), o = b(() => !e.disabled && e.editable), l = b(() => e.error || !s.value), u = b(() => e.complete || e.rules.length > 0 && s.value), c = b(() => l.value ? e.errorIcon : u.value ? e.completeIcon : i.isSelected.value && e.editable ? e.editIcon : e.icon), d = b(() => ({
      canEdit: o.value,
      hasError: l.value,
      hasCompleted: u.value,
      title: e.title,
      subtitle: e.subtitle,
      step: r.value,
      value: e.value
    }));
    return re(() => {
      var p, y, k;
      const f = (!i || i.isSelected.value || u.value || o.value) && !l.value && !e.disabled, h = !!(e.title != null || n.title), m = !!(e.subtitle != null || n.subtitle);
      function g() {
        i == null || i.toggle();
      }
      return Rt(v("button", {
        class: ["v-stepper-item", {
          "v-stepper-item--complete": u.value,
          "v-stepper-item--disabled": e.disabled,
          "v-stepper-item--error": l.value
        }, i == null ? void 0 : i.selectedClass.value],
        disabled: !e.editable,
        onClick: g
      }, [a.value && fa(!0, "v-stepper-item"), v(Ji, {
        key: "stepper-avatar",
        class: "v-stepper-item__avatar",
        color: f ? e.color : void 0,
        size: 24
      }, {
        default: () => {
          var T;
          return [((T = n.icon) == null ? void 0 : T.call(n, d.value)) ?? (c.value ? v(at, {
            icon: c.value
          }, null) : r.value)];
        }
      }), v("div", {
        class: "v-stepper-item__content"
      }, [h && v("div", {
        key: "title",
        class: "v-stepper-item__title"
      }, [((p = n.title) == null ? void 0 : p.call(n, d.value)) ?? e.title]), m && v("div", {
        key: "subtitle",
        class: "v-stepper-item__subtitle"
      }, [((y = n.subtitle) == null ? void 0 : y.call(n, d.value)) ?? e.subtitle]), (k = n.default) == null ? void 0 : k.call(n, d.value)])]), [[Ei("ripple"), e.ripple && e.editable, null]]);
    }), {};
  }
}), a7 = Symbol.for("vuetify:v-stepper"), o7 = B({
  ...an(fm(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
}, "VStepperWindow"), WI = J()({
  name: "VStepperWindow",
  props: o7(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = tt(a7, null), r = Ee(e, "modelValue"), s = b({
      get() {
        var a;
        return r.value != null || !i ? r.value : (a = i.items.value.find((o) => i.selected.value.includes(o.id))) == null ? void 0 : a.value;
      },
      set(a) {
        r.value = a;
      }
    });
    return re(() => {
      const a = fo.filterProps(e);
      return v(fo, ie({
        _as: "VStepperWindow"
      }, a, {
        modelValue: s.value,
        "onUpdate:modelValue": (o) => s.value = o,
        class: ["v-stepper-window", e.class],
        style: e.style,
        mandatory: !1,
        touch: !1
      }), n);
    }), {};
  }
}), l7 = B({
  ...hm()
}, "VStepperWindowItem"), jI = J()({
  name: "VStepperWindowItem",
  props: l7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => {
      const i = ho.filterProps(e);
      return v(ho, ie({
        _as: "VStepperWindowItem"
      }, i, {
        class: ["v-stepper-window-item", e.class],
        style: e.style
      }), n);
    }), {};
  }
}), HI = Symbol.for("vuetify:v-stepper"), u7 = B({
  altLabels: Boolean,
  bgColor: String,
  editable: Boolean,
  hideActions: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: String,
    default: "title"
  },
  itemValue: {
    type: String,
    default: "value"
  },
  mobile: Boolean,
  nonLinear: Boolean,
  flat: Boolean
}, "Stepper"), c7 = B({
  ...u7(),
  ...Po({
    mandatory: "force",
    selectedClass: "v-stepper-item--selected"
  }),
  ...mm(),
  ...ch(FI(), ["prevText", "nextText"])
}, "VStepper"), d7 = J()({
  name: "VStepper",
  props: c7(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      items: i,
      next: r,
      prev: s,
      selected: a
    } = ha(e, HI), {
      color: o,
      editable: l,
      prevText: u,
      nextText: c
    } = lh(e), d = b(() => e.items.map((m, g) => {
      const p = hn(m, e.itemTitle, m), y = hn(m, e.itemValue, g + 1);
      return {
        title: p,
        value: y,
        raw: m
      };
    })), f = b(() => i.value.findIndex((m) => a.value.includes(m.id))), h = b(() => e.disabled ? e.disabled : f.value === 0 ? "prev" : f.value === i.value.length - 1 ? "next" : !1);
    return jt({
      VStepperItem: {
        editable: l,
        prevText: u,
        nextText: c
      },
      VStepperActions: {
        color: o,
        disabled: h,
        prevText: u,
        nextText: c
      }
    }), re(() => {
      const m = mo.filterProps(e), g = !!(n.header || e.items.length), p = e.items.length > 0, y = !e.hideActions && !!(p || n.actions);
      return v(mo, ie(m, {
        color: e.bgColor,
        class: ["v-stepper", {
          "v-stepper--alt-labels": e.altLabels,
          "v-stepper--flat": e.flat,
          "v-stepper--non-linear": e.nonLinear,
          "v-stepper--mobile": e.mobile
        }, e.class],
        style: e.style
      }), {
        default: () => {
          var k, T;
          return [g && v(LI, {
            key: "stepper-header"
          }, {
            default: () => [d.value.map((_, w) => {
              let {
                raw: S,
                ...C
              } = _;
              return v(De, null, [!!w && v(ld, null, null), v($I, C, {
                default: n[`header-item.${C.value}`] ?? n.header,
                icon: n.icon,
                title: n.title,
                subtitle: n.subtitle
              })]);
            })]
          }), p && v(WI, {
            key: "stepper-window"
          }, {
            default: () => [d.value.map((_) => v(jI, {
              value: _.value
            }, {
              default: () => {
                var w, S;
                return ((w = n[`item.${_.value}`]) == null ? void 0 : w.call(n, _)) ?? ((S = n.item) == null ? void 0 : S.call(n, _));
              }
            }))]
          }), (k = n.default) == null ? void 0 : k.call(n, {
            prev: s,
            next: r
          }), y && (((T = n.actions) == null ? void 0 : T.call(n, {
            next: r,
            prev: s
          })) ?? v(BI, {
            key: "stepper-actions",
            "onClick:prev": s,
            "onClick:next": r
          }, n))];
        }
      });
    }), {
      prev: s,
      next: r
    };
  }
});
const f7 = B({
  indeterminate: Boolean,
  inset: Boolean,
  flat: Boolean,
  loading: {
    type: [Boolean, String],
    default: !1
  },
  ...As(),
  ...um()
}, "VSwitch"), h7 = J()({
  name: "VSwitch",
  inheritAttrs: !1,
  props: f7(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:indeterminate": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const r = Ee(e, "indeterminate"), s = Ee(e, "modelValue"), {
      loaderClasses: a
    } = Oc(e), {
      isFocused: o,
      focus: l,
      blur: u
    } = xs(e), c = X(), d = ft && window.matchMedia("(forced-colors: active)").matches, f = b(() => typeof e.loading == "string" && e.loading !== "" ? e.loading : e.color), h = Pn(), m = b(() => e.id || `switch-${h}`);
    function g() {
      r.value && (r.value = !1);
    }
    function p(y) {
      var k, T;
      y.stopPropagation(), y.preventDefault(), (T = (k = c.value) == null ? void 0 : k.input) == null || T.click();
    }
    return re(() => {
      const [y, k] = la(n), T = Wn.filterProps(e), _ = co.filterProps(e);
      return v(Wn, ie({
        class: ["v-switch", {
          "v-switch--flat": e.flat
        }, {
          "v-switch--inset": e.inset
        }, {
          "v-switch--indeterminate": r.value
        }, a.value, e.class]
      }, y, T, {
        modelValue: s.value,
        "onUpdate:modelValue": (w) => s.value = w,
        id: m.value,
        focused: o.value,
        style: e.style
      }), {
        ...i,
        default: (w) => {
          let {
            id: S,
            messagesId: C,
            isDisabled: x,
            isReadonly: A,
            isValid: I
          } = w;
          const E = {
            model: s,
            isValid: I
          };
          return v(co, ie({
            ref: c
          }, _, {
            modelValue: s.value,
            "onUpdate:modelValue": [(P) => s.value = P, g],
            id: S.value,
            "aria-describedby": C.value,
            type: "checkbox",
            "aria-checked": r.value ? "mixed" : void 0,
            disabled: x.value,
            readonly: A.value,
            onFocus: l,
            onBlur: u
          }, k), {
            ...i,
            default: (P) => {
              let {
                backgroundColorClasses: V,
                backgroundColorStyles: N
              } = P;
              return v("div", {
                class: ["v-switch__track", d ? void 0 : V.value],
                style: N.value,
                onClick: p
              }, [i["track-true"] && v("div", {
                key: "prepend",
                class: "v-switch__track-true"
              }, [i["track-true"](E)]), i["track-false"] && v("div", {
                key: "append",
                class: "v-switch__track-false"
              }, [i["track-false"](E)])]);
            },
            input: (P) => {
              let {
                inputNode: V,
                icon: N,
                backgroundColorClasses: F,
                backgroundColorStyles: $
              } = P;
              return v(De, null, [V, v("div", {
                class: ["v-switch__thumb", {
                  "v-switch__thumb--filled": N || e.loading
                }, e.inset || d ? void 0 : F.value],
                style: e.inset ? void 0 : $.value
              }, [i.thumb ? v(Ze, {
                defaults: {
                  VIcon: {
                    icon: N,
                    size: "x-small"
                  }
                }
              }, {
                default: () => [i.thumb({
                  ...E,
                  icon: N
                })]
              }) : v(mp, null, {
                default: () => [e.loading ? v(Vc, {
                  name: "v-switch",
                  active: !0,
                  color: I.value === !1 ? void 0 : f.value
                }, {
                  default: (Z) => i.loader ? i.loader(Z) : v(Nl, {
                    active: Z.isActive,
                    color: Z.color,
                    indeterminate: !0,
                    size: "16",
                    width: "2"
                  }, null)
                }) : N && v(at, {
                  key: String(N),
                  icon: N,
                  size: "x-small"
                }, null)]
              })])]);
            }
          });
        }
      });
    }), {};
  }
});
const m7 = B({
  color: String,
  height: [Number, String],
  window: Boolean,
  ...ke(),
  ...gn(),
  ...bo(),
  ...It(),
  ...je(),
  ...Qe()
}, "VSystemBar"), v7 = J()({
  name: "VSystemBar",
  props: m7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      backgroundColorClasses: r,
      backgroundColorStyles: s
    } = gt(G(e, "color")), {
      elevationClasses: a
    } = On(e), {
      roundedClasses: o
    } = Ht(e), {
      ssrBootStyles: l
    } = Io(), u = b(() => e.height ?? (e.window ? 32 : 24)), {
      layoutItemStyles: c
    } = wo({
      id: e.name,
      order: b(() => parseInt(e.order, 10)),
      position: pe("top"),
      layoutSize: u,
      elementSize: u,
      active: b(() => !0),
      absolute: G(e, "absolute")
    });
    return re(() => v(e.tag, {
      class: ["v-system-bar", {
        "v-system-bar--window": e.window
      }, i.value, r.value, a.value, o.value, e.class],
      style: [s.value, c.value, l.value, e.style]
    }, n)), {};
  }
});
const Ab = Symbol.for("vuetify:v-tabs"), g7 = B({
  fixed: Boolean,
  sliderColor: String,
  hideSlider: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  ...an(lm({
    selectedClass: "v-tab--selected",
    variant: "text"
  }), ["active", "block", "flat", "location", "position", "symbol"])
}, "VTab"), zI = J()({
  name: "VTab",
  props: g7(),
  setup(e, t) {
    let {
      slots: n,
      attrs: i
    } = t;
    const {
      textColorClasses: r,
      textColorStyles: s
    } = $n(e, "sliderColor"), a = X(), o = X(), l = b(() => e.direction === "horizontal"), u = b(() => {
      var d, f;
      return ((f = (d = a.value) == null ? void 0 : d.group) == null ? void 0 : f.isSelected.value) ?? !1;
    });
    function c(d) {
      var h, m;
      let {
        value: f
      } = d;
      if (f) {
        const g = (m = (h = a.value) == null ? void 0 : h.$el.parentElement) == null ? void 0 : m.querySelector(".v-tab--selected .v-tab__slider"), p = o.value;
        if (!g || !p)
          return;
        const y = getComputedStyle(g).color, k = g.getBoundingClientRect(), T = p.getBoundingClientRect(), _ = l.value ? "x" : "y", w = l.value ? "X" : "Y", S = l.value ? "right" : "bottom", C = l.value ? "width" : "height", x = k[_], A = T[_], I = x > A ? k[S] - T[S] : k[_] - T[_], E = Math.sign(I) > 0 ? l.value ? "right" : "bottom" : Math.sign(I) < 0 ? l.value ? "left" : "top" : "center", V = (Math.abs(I) + (Math.sign(I) < 0 ? k[C] : T[C])) / Math.max(k[C], T[C]) || 0, N = k[C] / T[C] || 0, F = 1.5;
        Na(p, {
          backgroundColor: [y, "currentcolor"],
          transform: [`translate${w}(${I}px) scale${w}(${N})`, `translate${w}(${I / F}px) scale${w}(${(V - 1) / F + 1})`, "none"],
          transformOrigin: Array(3).fill(E)
        }, {
          duration: 225,
          easing: qu
        });
      }
    }
    return re(() => {
      const d = st.filterProps(e);
      return v(st, ie({
        symbol: Ab,
        ref: a,
        class: ["v-tab", e.class],
        style: e.style,
        tabindex: u.value ? 0 : -1,
        role: "tab",
        "aria-selected": String(u.value),
        active: !1
      }, d, i, {
        block: e.fixed,
        maxWidth: e.fixed ? 300 : void 0,
        "onGroup:selected": c
      }), {
        ...n,
        default: () => {
          var f;
          return v(De, null, [((f = n.default) == null ? void 0 : f.call(n)) ?? e.text, !e.hideSlider && v("div", {
            ref: o,
            class: ["v-tab__slider", r.value],
            style: s.value
          }, null)]);
        }
      });
    }), Qi({}, a);
  }
});
const p7 = B({
  ...an(fm(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
}, "VTabsWindow"), UI = J()({
  name: "VTabsWindow",
  props: p7(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = tt(Ab, null), r = Ee(e, "modelValue"), s = b({
      get() {
        var a;
        return r.value != null || !i ? r.value : (a = i.items.value.find((o) => i.selected.value.includes(o.id))) == null ? void 0 : a.value;
      },
      set(a) {
        r.value = a;
      }
    });
    return re(() => {
      const a = fo.filterProps(e);
      return v(fo, ie({
        _as: "VTabsWindow"
      }, a, {
        modelValue: s.value,
        "onUpdate:modelValue": (o) => s.value = o,
        class: ["v-tabs-window", e.class],
        style: e.style,
        mandatory: !1,
        touch: !1
      }), n);
    }), {};
  }
}), y7 = B({
  ...hm()
}, "VTabsWindowItem"), qI = J()({
  name: "VTabsWindowItem",
  props: y7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => {
      const i = ho.filterProps(e);
      return v(ho, ie({
        _as: "VTabsWindowItem"
      }, i, {
        class: ["v-tabs-window-item", e.class],
        style: e.style
      }), n);
    }), {};
  }
});
function b7(e) {
  return e ? e.map((t) => zu(t) ? t : {
    text: t,
    value: t
  }) : [];
}
const w7 = B({
  alignTabs: {
    type: String,
    default: "start"
  },
  color: String,
  fixedTabs: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  stacked: Boolean,
  bgColor: String,
  grow: Boolean,
  height: {
    type: [Number, String],
    default: void 0
  },
  hideSlider: Boolean,
  sliderColor: String,
  ...eb({
    mandatory: "force",
    selectedClass: "v-tab-item--selected"
  }),
  ..._n(),
  ...je()
}, "VTabs"), _7 = J()({
  name: "VTabs",
  props: w7(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const r = Ee(e, "modelValue"), s = b(() => b7(e.items)), {
      densityClasses: a
    } = Kn(e), {
      backgroundColorClasses: o,
      backgroundColorStyles: l
    } = gt(G(e, "bgColor")), {
      scopeId: u
    } = Do();
    return jt({
      VTab: {
        color: G(e, "color"),
        direction: G(e, "direction"),
        stacked: G(e, "stacked"),
        fixed: G(e, "fixedTabs"),
        sliderColor: G(e, "sliderColor"),
        hideSlider: G(e, "hideSlider")
      }
    }), re(() => {
      const c = Tc.filterProps(e), d = !!(i.window || e.items.length > 0);
      return v(De, null, [v(Tc, ie(c, {
        modelValue: r.value,
        "onUpdate:modelValue": (f) => r.value = f,
        class: ["v-tabs", `v-tabs--${e.direction}`, `v-tabs--align-tabs-${e.alignTabs}`, {
          "v-tabs--fixed-tabs": e.fixedTabs,
          "v-tabs--grow": e.grow,
          "v-tabs--stacked": e.stacked
        }, a.value, o.value, e.class],
        style: [{
          "--v-tabs-height": _e(e.height)
        }, l.value, e.style],
        role: "tablist",
        symbol: Ab
      }, u, n), {
        default: () => {
          var f;
          return [((f = i.default) == null ? void 0 : f.call(i)) ?? s.value.map((h) => {
            var m;
            return ((m = i.tab) == null ? void 0 : m.call(i, {
              item: h
            })) ?? v(zI, ie(h, {
              key: h.text,
              value: h.value
            }), {
              default: () => {
                var g;
                return (g = i[`tab.${h.value}`]) == null ? void 0 : g.call(i, {
                  item: h
                });
              }
            });
          })];
        }
      }), d && v(UI, ie({
        modelValue: r.value,
        "onUpdate:modelValue": (f) => r.value = f,
        key: "tabs-window"
      }, u), {
        default: () => {
          var f;
          return [s.value.map((h) => {
            var m;
            return ((m = i.item) == null ? void 0 : m.call(i, {
              item: h
            })) ?? v(qI, {
              value: h.value
            }, {
              default: () => {
                var g;
                return (g = i[`item.${h.value}`]) == null ? void 0 : g.call(i, {
                  item: h
                });
              }
            });
          }), (f = i.window) == null ? void 0 : f.call(i)];
        }
      })]);
    }), {};
  }
});
const S7 = B({
  autoGrow: Boolean,
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: Function,
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  noResize: Boolean,
  rows: {
    type: [Number, String],
    default: 5,
    validator: (e) => !isNaN(parseFloat(e))
  },
  maxRows: {
    type: [Number, String],
    validator: (e) => !isNaN(parseFloat(e))
  },
  suffix: String,
  modelModifiers: Object,
  ...As(),
  ...Dc()
}, "VTextarea"), k7 = J()({
  name: "VTextarea",
  directives: {
    Intersect: Nc
  },
  inheritAttrs: !1,
  props: S7(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const s = Ee(e, "modelValue"), {
      isFocused: a,
      focus: o,
      blur: l
    } = xs(e), u = b(() => typeof e.counterValue == "function" ? e.counterValue(s.value) : (s.value || "").toString().length), c = b(() => {
      if (n.maxlength)
        return n.maxlength;
      if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string"))
        return e.counter;
    });
    function d(E, P) {
      var V, N;
      !e.autofocus || !E || (N = (V = P[0].target) == null ? void 0 : V.focus) == null || N.call(V);
    }
    const f = X(), h = X(), m = pe(""), g = X(), p = b(() => e.persistentPlaceholder || a.value || e.active);
    function y() {
      var E;
      g.value !== document.activeElement && ((E = g.value) == null || E.focus()), a.value || o();
    }
    function k(E) {
      y(), i("click:control", E);
    }
    function T(E) {
      i("mousedown:control", E);
    }
    function _(E) {
      E.stopPropagation(), y(), He(() => {
        s.value = "", op(e["onClick:clear"], E);
      });
    }
    function w(E) {
      var V;
      const P = E.target;
      if (s.value = P.value, (V = e.modelModifiers) != null && V.trim) {
        const N = [P.selectionStart, P.selectionEnd];
        He(() => {
          P.selectionStart = N[0], P.selectionEnd = N[1];
        });
      }
    }
    const S = X(), C = X(+e.rows), x = b(() => ["plain", "underlined"].includes(e.variant));
    Wt(() => {
      e.autoGrow || (C.value = +e.rows);
    });
    function A() {
      e.autoGrow && He(() => {
        if (!S.value || !h.value)
          return;
        const E = getComputedStyle(S.value), P = getComputedStyle(h.value.$el), V = parseFloat(E.getPropertyValue("--v-field-padding-top")) + parseFloat(E.getPropertyValue("--v-input-padding-top")) + parseFloat(E.getPropertyValue("--v-field-padding-bottom")), N = S.value.scrollHeight, F = parseFloat(E.lineHeight), $ = Math.max(parseFloat(e.rows) * F + V, parseFloat(P.getPropertyValue("--v-input-control-height"))), Z = parseFloat(e.maxRows) * F + V || 1 / 0, j = Xt(N ?? 0, $, Z);
        C.value = Math.floor((j - V) / F), m.value = _e(j);
      });
    }
    En(A), fe(s, A), fe(() => e.rows, A), fe(() => e.maxRows, A), fe(() => e.density, A);
    let I;
    return fe(S, (E) => {
      E ? (I = new ResizeObserver(A), I.observe(S.value)) : I == null || I.disconnect();
    }), ai(() => {
      I == null || I.disconnect();
    }), re(() => {
      const E = !!(r.counter || e.counter || e.counterValue), P = !!(E || r.details), [V, N] = la(n), {
        modelValue: F,
        ...$
      } = Wn.filterProps(e), Z = wp(e);
      return v(Wn, ie({
        ref: f,
        modelValue: s.value,
        "onUpdate:modelValue": (j) => s.value = j,
        class: ["v-textarea v-text-field", {
          "v-textarea--prefixed": e.prefix,
          "v-textarea--suffixed": e.suffix,
          "v-text-field--prefixed": e.prefix,
          "v-text-field--suffixed": e.suffix,
          "v-textarea--auto-grow": e.autoGrow,
          "v-textarea--no-resize": e.noResize || e.autoGrow,
          "v-input--plain-underlined": x.value
        }, e.class],
        style: e.style
      }, V, $, {
        centerAffix: C.value === 1 && !x.value,
        focused: a.value
      }), {
        ...r,
        default: (j) => {
          let {
            id: H,
            isDisabled: R,
            isDirty: L,
            isReadonly: ne,
            isValid: oe
          } = j;
          return v(Wl, ie({
            ref: h,
            style: {
              "--v-textarea-control-height": m.value
            },
            onClick: k,
            onMousedown: T,
            "onClick:clear": _,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"]
          }, Z, {
            id: H.value,
            active: p.value || L.value,
            centerAffix: C.value === 1 && !x.value,
            dirty: L.value || e.dirty,
            disabled: R.value,
            focused: a.value,
            error: oe.value === !1
          }), {
            ...r,
            default: (we) => {
              let {
                props: {
                  class: ee,
                  ...K
                }
              } = we;
              return v(De, null, [e.prefix && v("span", {
                class: "v-text-field__prefix"
              }, [e.prefix]), Rt(v("textarea", ie({
                ref: g,
                class: ee,
                value: s.value,
                onInput: w,
                autofocus: e.autofocus,
                readonly: ne.value,
                disabled: R.value,
                placeholder: e.placeholder,
                rows: e.rows,
                name: e.name,
                onFocus: y,
                onBlur: l
              }, K, N), null), [[Ei("intersect"), {
                handler: d
              }, null, {
                once: !0
              }]]), e.autoGrow && Rt(v("textarea", {
                class: [ee, "v-textarea__sizer"],
                id: `${K.id}-sizer`,
                "onUpdate:modelValue": (ue) => s.value = ue,
                ref: S,
                readonly: !0,
                "aria-hidden": "true"
              }, null), [[nP, s.value]]), e.suffix && v("span", {
                class: "v-text-field__suffix"
              }, [e.suffix])]);
            }
          });
        },
        details: P ? (j) => {
          var H;
          return v(De, null, [(H = r.details) == null ? void 0 : H.call(r, j), E && v(De, null, [v("span", null, null), v(gh, {
            active: e.persistentCounter || a.value,
            value: u.value,
            max: c.value,
            disabled: e.disabled
          }, r.counter)])]);
        } : void 0
      });
    }), Qi({}, f, h, g);
  }
});
const C7 = B({
  withBackground: Boolean,
  ...ke(),
  ...Qe(),
  ...je()
}, "VThemeProvider"), T7 = J()({
  name: "VThemeProvider",
  props: C7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e);
    return () => {
      var r;
      return e.withBackground ? v(e.tag, {
        class: ["v-theme-provider", i.value, e.class],
        style: e.style
      }, {
        default: () => {
          var s;
          return [(s = n.default) == null ? void 0 : s.call(n)];
        }
      }) : (r = n.default) == null ? void 0 : r.call(n);
    };
  }
});
const x7 = B({
  dotColor: String,
  fillDot: Boolean,
  hideDot: Boolean,
  icon: We,
  iconColor: String,
  lineColor: String,
  ...ke(),
  ...It(),
  ...Xr(),
  ...gn()
}, "VTimelineDivider"), A7 = J()({
  name: "VTimelineDivider",
  props: x7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      sizeClasses: i,
      sizeStyles: r
    } = $l(e, "v-timeline-divider__dot"), {
      backgroundColorStyles: s,
      backgroundColorClasses: a
    } = gt(G(e, "dotColor")), {
      roundedClasses: o
    } = Ht(e, "v-timeline-divider__dot"), {
      elevationClasses: l
    } = On(e), {
      backgroundColorClasses: u,
      backgroundColorStyles: c
    } = gt(G(e, "lineColor"));
    return re(() => v("div", {
      class: ["v-timeline-divider", {
        "v-timeline-divider--fill-dot": e.fillDot
      }, e.class],
      style: e.style
    }, [v("div", {
      class: ["v-timeline-divider__before", u.value],
      style: c.value
    }, null), !e.hideDot && v("div", {
      key: "dot",
      class: ["v-timeline-divider__dot", l.value, o.value, i.value],
      style: r.value
    }, [v("div", {
      class: ["v-timeline-divider__inner-dot", a.value, o.value],
      style: s.value
    }, [n.default ? v(Ze, {
      key: "icon-defaults",
      disabled: !e.icon,
      defaults: {
        VIcon: {
          color: e.iconColor,
          icon: e.icon,
          size: e.size
        }
      }
    }, n.default) : v(at, {
      key: "icon",
      color: e.iconColor,
      icon: e.icon,
      size: e.size
    }, null)])]), v("div", {
      class: ["v-timeline-divider__after", u.value],
      style: c.value
    }, null)])), {};
  }
}), GI = B({
  density: String,
  dotColor: String,
  fillDot: Boolean,
  hideDot: Boolean,
  hideOpposite: {
    type: Boolean,
    default: void 0
  },
  icon: We,
  iconColor: String,
  lineInset: [Number, String],
  ...ke(),
  ...Sn(),
  ...gn(),
  ...It(),
  ...Xr(),
  ...je()
}, "VTimelineItem"), I7 = J()({
  name: "VTimelineItem",
  props: GI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      dimensionStyles: i
    } = kn(e), r = pe(0), s = X();
    return fe(s, (a) => {
      var o;
      a && (r.value = ((o = a.$el.querySelector(".v-timeline-divider__dot")) == null ? void 0 : o.getBoundingClientRect().width) ?? 0);
    }, {
      flush: "post"
    }), re(() => {
      var a, o;
      return v("div", {
        class: ["v-timeline-item", {
          "v-timeline-item--fill-dot": e.fillDot
        }, e.class],
        style: [{
          "--v-timeline-dot-size": _e(r.value),
          "--v-timeline-line-inset": e.lineInset ? `calc(var(--v-timeline-dot-size) / 2 + ${_e(e.lineInset)})` : _e(0)
        }, e.style]
      }, [v("div", {
        class: "v-timeline-item__body",
        style: i.value
      }, [(a = n.default) == null ? void 0 : a.call(n)]), v(A7, {
        ref: s,
        hideDot: e.hideDot,
        icon: e.icon,
        iconColor: e.iconColor,
        size: e.size,
        elevation: e.elevation,
        dotColor: e.dotColor,
        fillDot: e.fillDot,
        rounded: e.rounded
      }, {
        default: n.icon
      }), e.density !== "compact" && v("div", {
        class: "v-timeline-item__opposite"
      }, [!e.hideOpposite && ((o = n.opposite) == null ? void 0 : o.call(n))])]);
    }), {};
  }
}), E7 = B({
  align: {
    type: String,
    default: "center",
    validator: (e) => ["center", "start"].includes(e)
  },
  direction: {
    type: String,
    default: "vertical",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  justify: {
    type: String,
    default: "auto",
    validator: (e) => ["auto", "center"].includes(e)
  },
  side: {
    type: String,
    validator: (e) => e == null || ["start", "end"].includes(e)
  },
  lineThickness: {
    type: [String, Number],
    default: 2
  },
  lineColor: String,
  truncateLine: {
    type: String,
    validator: (e) => ["start", "end", "both"].includes(e)
  },
  ...ch(GI({
    lineInset: 0
  }), ["dotColor", "fillDot", "hideOpposite", "iconColor", "lineInset", "size"]),
  ...ke(),
  ..._n(),
  ...je(),
  ...Qe()
}, "VTimeline"), P7 = J()({
  name: "VTimeline",
  props: E7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      densityClasses: r
    } = Kn(e), {
      rtlClasses: s
    } = wn();
    jt({
      VTimelineDivider: {
        lineColor: G(e, "lineColor")
      },
      VTimelineItem: {
        density: G(e, "density"),
        dotColor: G(e, "dotColor"),
        fillDot: G(e, "fillDot"),
        hideOpposite: G(e, "hideOpposite"),
        iconColor: G(e, "iconColor"),
        lineColor: G(e, "lineColor"),
        lineInset: G(e, "lineInset"),
        size: G(e, "size")
      }
    });
    const a = b(() => {
      const l = e.side ? e.side : e.density !== "default" ? "end" : null;
      return l && `v-timeline--side-${l}`;
    }), o = b(() => {
      const l = ["v-timeline--truncate-line-start", "v-timeline--truncate-line-end"];
      switch (e.truncateLine) {
        case "both":
          return l;
        case "start":
          return l[0];
        case "end":
          return l[1];
        default:
          return null;
      }
    });
    return re(() => v(e.tag, {
      class: ["v-timeline", `v-timeline--${e.direction}`, `v-timeline--align-${e.align}`, `v-timeline--justify-${e.justify}`, o.value, {
        "v-timeline--inset-line": !!e.lineInset
      }, i.value, r.value, a.value, s.value, e.class],
      style: [{
        "--v-timeline-line-thickness": _e(e.lineThickness)
      }, e.style]
    }, n)), {};
  }
}), O7 = B({
  ...ke(),
  ...tr({
    variant: "text"
  })
}, "VToolbarItems"), V7 = J()({
  name: "VToolbarItems",
  props: O7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return jt({
      VBtn: {
        color: G(e, "color"),
        height: "inherit",
        variant: G(e, "variant")
      }
    }), re(() => {
      var i;
      return v("div", {
        class: ["v-toolbar-items", e.class],
        style: e.style
      }, [(i = n.default) == null ? void 0 : i.call(n)]);
    }), {};
  }
});
const D7 = B({
  id: String,
  text: String,
  ...an(ud({
    closeOnBack: !1,
    location: "end",
    locationStrategy: "connected",
    eager: !0,
    minWidth: 0,
    offset: 10,
    openOnClick: !1,
    openOnHover: !0,
    origin: "auto",
    scrim: !1,
    scrollStrategy: "reposition",
    transition: !1
  }), ["absolute", "persistent"])
}, "VTooltip"), YI = J()({
  name: "VTooltip",
  props: D7(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), {
      scopeId: r
    } = Do(), s = Pn(), a = b(() => e.id || `v-tooltip-${s}`), o = X(), l = b(() => e.location.split(" ").length > 1 ? e.location : e.location + " center"), u = b(() => e.origin === "auto" || e.origin === "overlap" || e.origin.split(" ").length > 1 || e.location.split(" ").length > 1 ? e.origin : e.origin + " center"), c = b(() => e.transition ? e.transition : i.value ? "scale-transition" : "fade-transition"), d = b(() => ie({
      "aria-describedby": a.value
    }, e.activatorProps));
    return re(() => {
      const f = Gr.filterProps(e);
      return v(Gr, ie({
        ref: o,
        class: ["v-tooltip", e.class],
        style: e.style,
        id: a.value
      }, f, {
        modelValue: i.value,
        "onUpdate:modelValue": (h) => i.value = h,
        transition: c.value,
        absolute: !0,
        location: l.value,
        origin: u.value,
        persistent: !0,
        role: "tooltip",
        activatorProps: d.value,
        _disableGlobalStack: !0
      }, r), {
        activator: n.activator,
        default: function() {
          var p;
          for (var h = arguments.length, m = new Array(h), g = 0; g < h; g++)
            m[g] = arguments[g];
          return ((p = n.default) == null ? void 0 : p.call(n, ...m)) ?? e.text;
        }
      });
    }), Qi({}, o);
  }
}), N7 = J()({
  name: "VValidation",
  props: FS(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = BS(e, "validation");
    return () => {
      var r;
      return (r = n.default) == null ? void 0 : r.call(n, i);
    };
  }
}), T9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VAlert: c6,
  VAlertTitle: Zx,
  VApp: Fq,
  VAppBar: Hq,
  VAppBarNavIcon: a6,
  VAppBarTitle: o6,
  VAutocomplete: C5,
  VAvatar: Ji,
  VBadge: x5,
  VBanner: E5,
  VBannerActions: IA,
  VBannerText: EA,
  VBottomNavigation: O5,
  VBottomSheet: D5,
  VBreadcrumbs: F5,
  VBreadcrumbsDivider: OA,
  VBreadcrumbsItem: VA,
  VBtn: st,
  VBtnGroup: Og,
  VBtnToggle: Yq,
  VCard: j5,
  VCardActions: DA,
  VCardItem: RA,
  VCardSubtitle: NA,
  VCardText: FA,
  VCardTitle: MA,
  VCarousel: X5,
  VCarouselItem: Q5,
  VCheckbox: v6,
  VCheckboxBtn: Cs,
  VChip: ou,
  VChipGroup: w6,
  VClassIcon: bp,
  VCode: eG,
  VCol: E8,
  VColorPicker: jG,
  VCombobox: UG,
  VComponentIcon: Mv,
  VConfirmEdit: GG,
  VContainer: T8,
  VCounter: gh,
  VDataIterator: i8,
  VDataTable: b8,
  VDataTableFooter: Ac,
  VDataTableHeaders: vo,
  VDataTableRow: Sb,
  VDataTableRows: go,
  VDataTableServer: k8,
  VDataTableVirtual: _8,
  VDatePicker: j8,
  VDatePickerControls: Gg,
  VDatePickerHeader: Yg,
  VDatePickerMonth: Zg,
  VDatePickerMonths: Kg,
  VDatePickerYears: Xg,
  VDefaultsProvider: Ze,
  VDialog: Lg,
  VDialogBottomTransition: ZP,
  VDialogTopTransition: KP,
  VDialogTransition: mh,
  VDivider: ld,
  VEmptyState: z8,
  VExpandTransition: vh,
  VExpandXTransition: gp,
  VExpansionPanel: U8,
  VExpansionPanelText: Jg,
  VExpansionPanelTitle: Qg,
  VExpansionPanels: Y8,
  VFab: K8,
  VFabTransition: YP,
  VFadeTransition: Gu,
  VField: Wl,
  VFieldLabel: vu,
  VFileInput: J8,
  VFooter: eY,
  VForm: nY,
  VHover: rY,
  VIcon: at,
  VImg: ks,
  VInfiniteScroll: aY,
  VInput: Wn,
  VItem: uY,
  VItemGroup: lY,
  VKbd: cY,
  VLabel: Ll,
  VLayout: fY,
  VLayoutItem: mY,
  VLazy: gY,
  VLigatureIcon: fO,
  VList: cm,
  VListGroup: Mg,
  VListImg: H6,
  VListItem: Ts,
  VListItemAction: U6,
  VListItemMedia: G6,
  VListItemSubtitle: cA,
  VListItemTitle: dA,
  VListSubheader: fA,
  VLocaleProvider: yY,
  VMain: wY,
  VMenu: Ml,
  VMessages: MS,
  VNavigationDrawer: EY,
  VNoSsr: PY,
  VOtpInput: VY,
  VOverlay: Gr,
  VPagination: Ug,
  VParallax: MY,
  VProgressCircular: Nl,
  VProgressLinear: bh,
  VRadio: FY,
  VRadioGroup: LY,
  VRangeSlider: WY,
  VRating: HY,
  VResponsive: Eg,
  VRow: R8,
  VScaleTransition: mp,
  VScrollXReverseTransition: JP,
  VScrollXTransition: XP,
  VScrollYReverseTransition: eO,
  VScrollYTransition: QP,
  VSelect: cb,
  VSelectionControl: co,
  VSelectionControlGroup: Xx,
  VSheet: mo,
  VSkeletonLoader: GY,
  VSlideGroup: Tc,
  VSlideGroupItem: YY,
  VSlideXReverseTransition: nO,
  VSlideXTransition: tO,
  VSlideYReverseTransition: iO,
  VSlideYTransition: vp,
  VSlider: zg,
  VSnackbar: XY,
  VSpacer: CI,
  VSparkline: t7,
  VSpeedDial: i7,
  VStepper: d7,
  VStepperActions: BI,
  VStepperHeader: LI,
  VStepperItem: $I,
  VStepperWindow: WI,
  VStepperWindowItem: jI,
  VSvgIcon: yp,
  VSwitch: h7,
  VSystemBar: v7,
  VTab: zI,
  VTable: po,
  VTabs: _7,
  VTabsWindow: UI,
  VTabsWindowItem: qI,
  VTextField: gi,
  VTextarea: k7,
  VThemeProvider: T7,
  VTimeline: P7,
  VTimelineItem: I7,
  VToolbar: Pg,
  VToolbarItems: V7,
  VToolbarTitle: Xy,
  VTooltip: YI,
  VValidation: N7,
  VVirtualScroll: dm,
  VWindow: fo,
  VWindowItem: ho
}, Symbol.toStringTag, { value: "Module" }));
function M7(e, t) {
  const n = t.modifiers || {}, i = t.value, {
    once: r,
    immediate: s,
    ...a
  } = n, o = !Object.keys(a).length, {
    handler: l,
    options: u
  } = typeof i == "object" ? i : {
    handler: i,
    options: {
      attributes: (a == null ? void 0 : a.attr) ?? o,
      characterData: (a == null ? void 0 : a.char) ?? o,
      childList: (a == null ? void 0 : a.child) ?? o,
      subtree: (a == null ? void 0 : a.sub) ?? o
    }
  }, c = new MutationObserver(function() {
    let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], f = arguments.length > 1 ? arguments[1] : void 0;
    l == null || l(d, f), r && ZI(e, t);
  });
  s && (l == null || l([], c)), e._mutate = Object(e._mutate), e._mutate[t.instance.$.uid] = {
    observer: c
  }, c.observe(e, u);
}
function ZI(e, t) {
  var n;
  (n = e._mutate) != null && n[t.instance.$.uid] && (e._mutate[t.instance.$.uid].observer.disconnect(), delete e._mutate[t.instance.$.uid]);
}
const R7 = {
  mounted: M7,
  unmounted: ZI
};
function F7(e, t) {
  var r, s;
  const n = t.value, i = {
    passive: !((r = t.modifiers) != null && r.active)
  };
  window.addEventListener("resize", n, i), e._onResize = Object(e._onResize), e._onResize[t.instance.$.uid] = {
    handler: n,
    options: i
  }, (s = t.modifiers) != null && s.quiet || n();
}
function B7(e, t) {
  var r;
  if (!((r = e._onResize) != null && r[t.instance.$.uid]))
    return;
  const {
    handler: n,
    options: i
  } = e._onResize[t.instance.$.uid];
  window.removeEventListener("resize", n, i), delete e._onResize[t.instance.$.uid];
}
const L7 = {
  mounted: F7,
  unmounted: B7
};
function KI(e, t) {
  const {
    self: n = !1
  } = t.modifiers ?? {}, i = t.value, r = typeof i == "object" && i.options || {
    passive: !0
  }, s = typeof i == "function" || "handleEvent" in i ? i : i.handler, a = n ? e : t.arg ? document.querySelector(t.arg) : window;
  a && (a.addEventListener("scroll", s, r), e._onScroll = Object(e._onScroll), e._onScroll[t.instance.$.uid] = {
    handler: s,
    options: r,
    // Don't reference self
    target: n ? void 0 : a
  });
}
function XI(e, t) {
  var s;
  if (!((s = e._onScroll) != null && s[t.instance.$.uid]))
    return;
  const {
    handler: n,
    options: i,
    target: r = e
  } = e._onScroll[t.instance.$.uid];
  r.removeEventListener("scroll", n, i), delete e._onScroll[t.instance.$.uid];
}
function $7(e, t) {
  t.value !== t.oldValue && (XI(e, t), KI(e, t));
}
const W7 = {
  mounted: KI,
  unmounted: XI,
  updated: $7
};
function j7(e, t) {
  const n = typeof e == "string" ? tn(e) : e, i = H7(n, t);
  return {
    mounted: i,
    updated: i,
    unmounted(r) {
      nS(null, r);
    }
  };
}
function H7(e, t) {
  return function(n, i, r) {
    var d, f, h;
    const s = typeof t == "function" ? t(i) : t, a = ((d = i.value) == null ? void 0 : d.text) ?? i.value ?? (s == null ? void 0 : s.text), o = zu(i.value) ? i.value : {}, l = () => a ?? n.innerHTML, u = (r.ctx === i.instance.$ ? (f = z7(r, i.instance.$)) == null ? void 0 : f.provides : (h = r.ctx) == null ? void 0 : h.provides) ?? i.instance.$.provides, c = oa(e, ie(s, o), l);
    c.appContext = Object.assign(/* @__PURE__ */ Object.create(null), i.instance.$.appContext, {
      provides: u
    }), nS(c, n);
  };
}
function z7(e, t) {
  const n = /* @__PURE__ */ new Set(), i = (s) => {
    var a, o;
    for (const l of s) {
      if (!l)
        continue;
      if (l === e)
        return !0;
      n.add(l);
      let u;
      if (l.suspense ? u = i([l.ssContent]) : Array.isArray(l.children) ? u = i(l.children) : (a = l.component) != null && a.vnode && (u = i([(o = l.component) == null ? void 0 : o.subTree])), u)
        return u;
      n.delete(l);
    }
    return !1;
  };
  if (!i([t.subTree]))
    throw new Error("Could not find original vnode");
  const r = Array.from(n).reverse();
  for (const s of r)
    if (s.component)
      return s.component;
  return t;
}
const U7 = j7(YI, (e) => {
  var t;
  return {
    activator: "parent",
    location: ((t = e.arg) == null ? void 0 : t.replace("-", " ")) ?? "top",
    text: typeof e.value == "boolean" ? void 0 : e.value
  };
}), x9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ClickOutside: kA,
  Intersect: Nc,
  Mutate: R7,
  Resize: L7,
  Ripple: Vs,
  Scroll: W7,
  Tooltip: U7,
  Touch: db
}, Symbol.toStringTag, { value: "Module" }));
export {
  Z7 as V,
  C9 as a,
  T9 as b,
  nl as c,
  x9 as d,
  jp as g,
  Y7 as i
};
