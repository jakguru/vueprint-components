var Fb = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
};
var Lm = (e, t, n) => (Fb(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Bb = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, Lb = (e, t, n, i) => (Fb(e, t, "write to private field"), i ? i.call(e, n) : t.set(e, n), n);
import { shallowRef as pe, Fragment as De, reactive as ti, computed as w, watchEffect as Wt, toRefs as sh, capitalize as Nl, isVNode as BE, Comment as LE, readonly as Ml, unref as Ct, warn as xc, ref as X, provide as Tt, inject as tt, defineComponent as ah, camelize as X_, h as oa, getCurrentInstance as Xg, TransitionGroup as Jg, Transition as na, createVNode as v, mergeProps as se, withDirectives as Rt, vShow as Cr, watch as fe, isRef as ia, toRef as G, Text as $E, onScopeDispose as Wn, effectScope as Qg, toRaw as si, onBeforeUnmount as ai, markRaw as WE, onBeforeMount as J_, onMounted as jn, nextTick as He, resolveDirective as Ei, cloneVNode as jE, onDeactivated as HE, onActivated as zE, resolveComponent as Nn, openBlock as af, createBlock as of, toHandlers as UE, withCtx as Rn, createTextVNode as wr, createCommentVNode as qE, toDisplayString as ep, getCurrentScope as GE, createSlots as YE, renderList as ZE, renderSlot as ns, normalizeProps as Rs, guardReactiveProps as Fs, toValue as Pn, onUnmounted as Q_, withModifiers as Cv, createElementVNode as KE, Suspense as eS, onUpdated as XE, resolveDynamicComponent as JE, Teleport as QE, onBeforeUpdate as eO, vModelText as tO, render as tS } from "vue";
const ft = typeof window < "u", tp = ft && "IntersectionObserver" in window, nO = ft && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0), $b = ft && "EyeDropper" in window;
function Wb(e, t, n) {
  iO(e, t), t.set(e, n);
}
function iO(e, t) {
  if (t.has(e))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function rO(e, t, n) {
  return e.set(nS(e, t), n), n;
}
function pa(e, t) {
  return e.get(nS(e, t));
}
function nS(e, t, n) {
  if (typeof e == "function" ? e === t : e.has(t))
    return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
function iS(e, t, n) {
  const i = t.length - 1;
  if (i < 0)
    return e === void 0 ? n : e;
  for (let r = 0; r < i; r++) {
    if (e == null)
      return n;
    e = e[t[r]];
  }
  return e == null || e[t[i]] === void 0 ? n : e[t[i]];
}
function Gr(e, t) {
  if (e === t)
    return !0;
  if (e instanceof Date && t instanceof Date && e.getTime() !== t.getTime() || e !== Object(e) || t !== Object(t))
    return !1;
  const n = Object.keys(e);
  return n.length !== Object.keys(t).length ? !1 : n.every((i) => Gr(e[i], t[i]));
}
function $u(e, t, n) {
  return e == null || !t || typeof t != "string" ? n : e[t] !== void 0 ? e[t] : (t = t.replace(/\[(\w+)\]/g, ".$1"), t = t.replace(/^\./, ""), iS(e, t.split("."), n));
}
function dn(e, t, n) {
  if (t === !0)
    return e === void 0 ? n : e;
  if (t == null || typeof t == "boolean")
    return n;
  if (e !== Object(e)) {
    if (typeof t != "function")
      return n;
    const r = t(e, n);
    return typeof r > "u" ? n : r;
  }
  if (typeof t == "string")
    return $u(e, t, n);
  if (Array.isArray(t))
    return iS(e, t, n);
  if (typeof t != "function")
    return n;
  const i = t(e, n);
  return typeof i > "u" ? n : i;
}
function jr(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return Array.from({
    length: e
  }, (n, i) => t + i);
}
function _e(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
  if (!(e == null || e === ""))
    return isNaN(+e) ? String(e) : isFinite(+e) ? `${Number(e)}${t}` : void 0;
}
function Wu(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function np(e) {
  if (e && "$el" in e) {
    const t = e.$el;
    return (t == null ? void 0 : t.nodeType) === Node.TEXT_NODE ? t.nextElementSibling : t;
  }
  return e;
}
const jb = Object.freeze({
  enter: 13,
  tab: 9,
  delete: 46,
  esc: 27,
  space: 32,
  up: 38,
  down: 40,
  left: 37,
  right: 39,
  end: 35,
  home: 36,
  del: 46,
  backspace: 8,
  insert: 45,
  pageup: 33,
  pagedown: 34,
  shift: 16
}), Tv = Object.freeze({
  enter: "Enter",
  tab: "Tab",
  delete: "Delete",
  esc: "Escape",
  space: "Space",
  up: "ArrowUp",
  down: "ArrowDown",
  left: "ArrowLeft",
  right: "ArrowRight",
  end: "End",
  home: "Home",
  del: "Delete",
  backspace: "Backspace",
  insert: "Insert",
  pageup: "PageUp",
  pagedown: "PageDown",
  shift: "Shift"
});
function rS(e) {
  return Object.keys(e);
}
function Da(e, t) {
  return t.every((n) => e.hasOwnProperty(n));
}
function sS(e, t) {
  const n = {}, i = new Set(Object.keys(e));
  for (const r of t)
    i.has(r) && (n[r] = e[r]);
  return n;
}
function xv(e, t, n) {
  const i = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  for (const s in e)
    t.some((a) => a instanceof RegExp ? a.test(s) : a === s) && !(n != null && n.some((a) => a === s)) ? i[s] = e[s] : r[s] = e[s];
  return [i, r];
}
function sn(e, t) {
  const n = {
    ...e
  };
  return t.forEach((i) => delete n[i]), n;
}
function oh(e, t) {
  const n = {};
  return t.forEach((i) => n[i] = e[i]), n;
}
const aS = /^on[^a-z]/, lh = (e) => aS.test(e), sO = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"], aO = ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Escape", "Tab", " "];
function oO(e) {
  return e.isComposing && aO.includes(e.key);
}
function la(e) {
  const [t, n] = xv(e, [aS]), i = sn(t, sO), [r, s] = xv(n, ["class", "style", "id", /^data-/]);
  return Object.assign(r, t), Object.assign(s, i), [r, s];
}
function Nt(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function lO(e, t) {
  let n = 0;
  const i = function() {
    for (var r = arguments.length, s = new Array(r), a = 0; a < r; a++)
      s[a] = arguments[a];
    clearTimeout(n), n = setTimeout(() => e(...s), Ct(t));
  };
  return i.clear = () => {
    clearTimeout(n);
  }, i.immediate = e, i;
}
function Xt(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.max(t, Math.min(n, e));
}
function Hb(e) {
  const t = e.toString().trim();
  return t.includes(".") ? t.length - t.indexOf(".") - 1 : 0;
}
function zb(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  return e + n.repeat(Math.max(0, t - e.length));
}
function Ub(e, t) {
  return (arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0").repeat(Math.max(0, t - e.length)) + e;
}
function uO(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  const n = [];
  let i = 0;
  for (; i < e.length; )
    n.push(e.substr(i, t)), i += t;
  return n;
}
function qb(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
  if (e < t)
    return `${e} B`;
  const n = t === 1024 ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"];
  let i = -1;
  for (; Math.abs(e) >= t && i < n.length - 1; )
    e /= t, ++i;
  return `${e.toFixed(1)} ${n[i]}B`;
}
function qn() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;
  const i = {};
  for (const r in e)
    i[r] = e[r];
  for (const r in t) {
    const s = e[r], a = t[r];
    if (Wu(s) && Wu(a)) {
      i[r] = qn(s, a, n);
      continue;
    }
    if (Array.isArray(s) && Array.isArray(a) && n) {
      i[r] = n(s, a);
      continue;
    }
    i[r] = a;
  }
  return i;
}
function oS(e) {
  return e.map((t) => t.type === De ? oS(t.children) : t).flat();
}
function $a() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  if ($a.cache.has(e))
    return $a.cache.get(e);
  const t = e.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
  return $a.cache.set(e, t), t;
}
$a.cache = /* @__PURE__ */ new Map();
function Zo(e, t) {
  if (!t || typeof t != "object")
    return [];
  if (Array.isArray(t))
    return t.map((n) => Zo(e, n)).flat(1);
  if (t.suspense)
    return Zo(e, t.ssContent);
  if (Array.isArray(t.children))
    return t.children.map((n) => Zo(e, n)).flat(1);
  if (t.component) {
    if (Object.getOwnPropertySymbols(t.component.provides).includes(e))
      return [t.component];
    if (t.component.subTree)
      return Zo(e, t.component.subTree).flat(1);
  }
  return [];
}
var fd = /* @__PURE__ */ new WeakMap(), No = /* @__PURE__ */ new WeakMap();
class cO {
  constructor(t) {
    Wb(this, fd, []), Wb(this, No, 0), this.size = t;
  }
  push(t) {
    pa(fd, this)[pa(No, this)] = t, rO(No, this, (pa(No, this) + 1) % this.size);
  }
  values() {
    return pa(fd, this).slice(pa(No, this)).concat(pa(fd, this).slice(0, pa(No, this)));
  }
}
function dO(e) {
  return "touches" in e ? {
    clientX: e.touches[0].clientX,
    clientY: e.touches[0].clientY
  } : {
    clientX: e.clientX,
    clientY: e.clientY
  };
}
function ip(e) {
  const t = ti({}), n = w(e);
  return Wt(() => {
    for (const i in n.value)
      t[i] = n.value[i];
  }, {
    flush: "sync"
  }), sh(t);
}
function lf(e, t) {
  return e.includes(t);
}
function lS(e) {
  return e[2].toLowerCase() + e.slice(3);
}
const ri = () => [Function, Array];
function Gb(e, t) {
  return t = "on" + Nl(t), !!(e[t] || e[`${t}Once`] || e[`${t}Capture`] || e[`${t}OnceCapture`] || e[`${t}CaptureOnce`]);
}
function rp(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  if (Array.isArray(e))
    for (const r of e)
      r(...n);
  else
    typeof e == "function" && e(...n);
}
function ju(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  const n = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map((i) => `${i}${t ? ':not([tabindex="-1"])' : ""}:not([disabled])`).join(", ");
  return [...e.querySelectorAll(n)];
}
function uS(e, t, n) {
  let i, r = e.indexOf(document.activeElement);
  const s = t === "next" ? 1 : -1;
  do
    r += s, i = e[r];
  while ((!i || i.offsetParent == null || !((n == null ? void 0 : n(i)) ?? !0)) && r < e.length && r >= 0);
  return i;
}
function ml(e, t) {
  var i, r, s, a;
  const n = ju(e);
  if (!t)
    (e === document.activeElement || !e.contains(document.activeElement)) && ((i = n[0]) == null || i.focus());
  else if (t === "first")
    (r = n[0]) == null || r.focus();
  else if (t === "last")
    (s = n.at(-1)) == null || s.focus();
  else if (typeof t == "number")
    (a = n[t]) == null || a.focus();
  else {
    const o = uS(n, t);
    o ? o.focus() : ml(e, t === "next" ? "first" : "last");
  }
}
function hd(e) {
  return e == null || typeof e == "string" && e.trim() === "";
}
function cS() {
}
function vl(e, t) {
  if (!(ft && typeof CSS < "u" && typeof CSS.supports < "u" && CSS.supports(`selector(${t})`)))
    return null;
  try {
    return !!e && e.matches(t);
  } catch {
    return null;
  }
}
function uh(e) {
  return e.some((t) => BE(t) ? t.type === LE ? !1 : t.type !== De || uh(t.children) : !0) ? e : null;
}
function fO(e, t) {
  if (!ft || e === 0)
    return t(), () => {
    };
  const n = window.setTimeout(t, e);
  return () => window.clearTimeout(n);
}
function Yb(e, t) {
  const n = pe();
  return Wt(() => {
    n.value = e();
  }, {
    flush: "sync",
    ...t
  }), Ml(n);
}
function hO(e, t) {
  const n = e.clientX, i = e.clientY, r = t.getBoundingClientRect(), s = r.left, a = r.top, o = r.right, l = r.bottom;
  return n >= s && n <= o && i >= a && i <= l;
}
function uf() {
  const e = pe(), t = (n) => {
    e.value = n;
  };
  return Object.defineProperty(t, "value", {
    enumerable: !0,
    get: () => e.value,
    set: (n) => e.value = n
  }), Object.defineProperty(t, "el", {
    enumerable: !0,
    get: () => np(e.value)
  }), t;
}
const dS = ["top", "bottom"], mO = ["start", "end", "left", "right"];
function Av(e, t) {
  let [n, i] = e.split(" ");
  return i || (i = lf(dS, n) ? "start" : lf(mO, n) ? "top" : "center"), {
    side: Iv(n, t),
    align: Iv(i, t)
  };
}
function Iv(e, t) {
  return e === "start" ? t ? "right" : "left" : e === "end" ? t ? "left" : "right" : e;
}
function $m(e) {
  return {
    side: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[e.side],
    align: e.align
  };
}
function Wm(e) {
  return {
    side: e.side,
    align: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[e.align]
  };
}
function Zb(e) {
  return {
    side: e.align,
    align: e.side
  };
}
function Kb(e) {
  return lf(dS, e.side) ? "y" : "x";
}
class Wa {
  constructor(t) {
    let {
      x: n,
      y: i,
      width: r,
      height: s
    } = t;
    this.x = n, this.y = i, this.width = r, this.height = s;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
}
function Xb(e, t) {
  return {
    x: {
      before: Math.max(0, t.left - e.left),
      after: Math.max(0, e.right - t.right)
    },
    y: {
      before: Math.max(0, t.top - e.top),
      after: Math.max(0, e.bottom - t.bottom)
    }
  };
}
function fS(e) {
  return Array.isArray(e) ? new Wa({
    x: e[0],
    y: e[1],
    width: 0,
    height: 0
  }) : e.getBoundingClientRect();
}
function sp(e) {
  const t = e.getBoundingClientRect(), n = getComputedStyle(e), i = n.transform;
  if (i) {
    let r, s, a, o, l;
    if (i.startsWith("matrix3d("))
      r = i.slice(9, -1).split(/, /), s = +r[0], a = +r[5], o = +r[12], l = +r[13];
    else if (i.startsWith("matrix("))
      r = i.slice(7, -1).split(/, /), s = +r[0], a = +r[3], o = +r[4], l = +r[5];
    else
      return new Wa(t);
    const u = n.transformOrigin, c = t.x - o - (1 - s) * parseFloat(u), d = t.y - l - (1 - a) * parseFloat(u.slice(u.indexOf(" ") + 1)), f = s ? t.width / s : e.offsetWidth + 1, h = a ? t.height / a : e.offsetHeight + 1;
    return new Wa({
      x: c,
      y: d,
      width: f,
      height: h
    });
  } else
    return new Wa(t);
}
function Na(e, t, n) {
  if (typeof e.animate > "u")
    return {
      finished: Promise.resolve()
    };
  let i;
  try {
    i = e.animate(t, n);
  } catch {
    return {
      finished: Promise.resolve()
    };
  }
  return typeof i.finished > "u" && (i.finished = new Promise((r) => {
    i.onfinish = () => {
      r(i);
    };
  })), i;
}
const Dd = /* @__PURE__ */ new WeakMap();
function vO(e, t) {
  Object.keys(t).forEach((n) => {
    if (lh(n)) {
      const i = lS(n), r = Dd.get(e);
      if (t[n] == null)
        r == null || r.forEach((s) => {
          const [a, o] = s;
          a === i && (e.removeEventListener(i, o), r.delete(s));
        });
      else if (!r || ![...r].some((s) => s[0] === i && s[1] === t[n])) {
        e.addEventListener(i, t[n]);
        const s = r || /* @__PURE__ */ new Set();
        s.add([i, t[n]]), Dd.has(e) || Dd.set(e, s);
      }
    } else
      t[n] == null ? e.removeAttribute(n) : e.setAttribute(n, t[n]);
  });
}
function gO(e, t) {
  Object.keys(t).forEach((n) => {
    if (lh(n)) {
      const i = lS(n), r = Dd.get(e);
      r == null || r.forEach((s) => {
        const [a, o] = s;
        a === i && (e.removeEventListener(i, o), r.delete(s));
      });
    } else
      e.removeAttribute(n);
  });
}
const Mo = 2.4, Jb = 0.2126729, Qb = 0.7151522, ew = 0.072175, pO = 0.55, yO = 0.58, bO = 0.57, wO = 0.62, md = 0.03, tw = 1.45, _O = 5e-4, SO = 1.25, kO = 1.25, nw = 0.078, iw = 12.82051282051282, vd = 0.06, rw = 1e-3;
function sw(e, t) {
  const n = (e.r / 255) ** Mo, i = (e.g / 255) ** Mo, r = (e.b / 255) ** Mo, s = (t.r / 255) ** Mo, a = (t.g / 255) ** Mo, o = (t.b / 255) ** Mo;
  let l = n * Jb + i * Qb + r * ew, u = s * Jb + a * Qb + o * ew;
  if (l <= md && (l += (md - l) ** tw), u <= md && (u += (md - u) ** tw), Math.abs(u - l) < _O)
    return 0;
  let c;
  if (u > l) {
    const d = (u ** pO - l ** yO) * SO;
    c = d < rw ? 0 : d < nw ? d - d * iw * vd : d - vd;
  } else {
    const d = (u ** wO - l ** bO) * kO;
    c = d > -rw ? 0 : d > -nw ? d - d * iw * vd : d + vd;
  }
  return c * 100;
}
function gr(e) {
  xc(`Vuetify: ${e}`);
}
function cf(e) {
  xc(`Vuetify error: ${e}`);
}
function CO(e, t) {
  t = Array.isArray(t) ? t.slice(0, -1).map((n) => `'${n}'`).join(", ") + ` or '${t.at(-1)}'` : `'${t}'`, xc(`[Vuetify UPGRADE] '${e}' is deprecated, use ${t} instead.`);
}
const df = 0.20689655172413793, TO = (e) => e > df ** 3 ? Math.cbrt(e) : e / (3 * df ** 2) + 4 / 29, xO = (e) => e > df ? e ** 3 : 3 * df ** 2 * (e - 4 / 29);
function hS(e) {
  const t = TO, n = t(e[1]);
  return [116 * n - 16, 500 * (t(e[0] / 0.95047) - n), 200 * (n - t(e[2] / 1.08883))];
}
function mS(e) {
  const t = xO, n = (e[0] + 16) / 116;
  return [t(n + e[1] / 500) * 0.95047, t(n), t(n - e[2] / 200) * 1.08883];
}
const AO = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]], IO = (e) => e <= 31308e-7 ? e * 12.92 : 1.055 * e ** (1 / 2.4) - 0.055, EO = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]], OO = (e) => e <= 0.04045 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4;
function vS(e) {
  const t = Array(3), n = IO, i = AO;
  for (let r = 0; r < 3; ++r)
    t[r] = Math.round(Xt(n(i[r][0] * e[0] + i[r][1] * e[1] + i[r][2] * e[2])) * 255);
  return {
    r: t[0],
    g: t[1],
    b: t[2]
  };
}
function ap(e) {
  let {
    r: t,
    g: n,
    b: i
  } = e;
  const r = [0, 0, 0], s = OO, a = EO;
  t = s(t / 255), n = s(n / 255), i = s(i / 255);
  for (let o = 0; o < 3; ++o)
    r[o] = a[o][0] * t + a[o][1] * n + a[o][2] * i;
  return r;
}
function Ev(e) {
  return !!e && /^(#|var\(--|(rgb|hsl)a?\()/.test(e);
}
function PO(e) {
  return Ev(e) && !/^((rgb|hsl)a?\()?var\(--/.test(e);
}
const aw = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/, VO = {
  rgb: (e, t, n, i) => ({
    r: e,
    g: t,
    b: n,
    a: i
  }),
  rgba: (e, t, n, i) => ({
    r: e,
    g: t,
    b: n,
    a: i
  }),
  hsl: (e, t, n, i) => ow({
    h: e,
    s: t,
    l: n,
    a: i
  }),
  hsla: (e, t, n, i) => ow({
    h: e,
    s: t,
    l: n,
    a: i
  }),
  hsv: (e, t, n, i) => ps({
    h: e,
    s: t,
    v: n,
    a: i
  }),
  hsva: (e, t, n, i) => ps({
    h: e,
    s: t,
    v: n,
    a: i
  })
};
function Hi(e) {
  if (typeof e == "number")
    return (isNaN(e) || e < 0 || e > 16777215) && gr(`'${e}' is not a valid hex color`), {
      r: (e & 16711680) >> 16,
      g: (e & 65280) >> 8,
      b: e & 255
    };
  if (typeof e == "string" && aw.test(e)) {
    const {
      groups: t
    } = e.match(aw), {
      fn: n,
      values: i
    } = t, r = i.split(/,\s*/).map((s) => s.endsWith("%") && ["hsl", "hsla", "hsv", "hsva"].includes(n) ? parseFloat(s) / 100 : parseFloat(s));
    return VO[n](...r);
  } else if (typeof e == "string") {
    let t = e.startsWith("#") ? e.slice(1) : e;
    [3, 4].includes(t.length) ? t = t.split("").map((i) => i + i).join("") : [6, 8].includes(t.length) || gr(`'${e}' is not a valid hex(a) color`);
    const n = parseInt(t, 16);
    return (isNaN(n) || n < 0 || n > 4294967295) && gr(`'${e}' is not a valid hex(a) color`), wS(t);
  } else if (typeof e == "object") {
    if (Da(e, ["r", "g", "b"]))
      return e;
    if (Da(e, ["h", "s", "l"]))
      return ps(op(e));
    if (Da(e, ["h", "s", "v"]))
      return ps(e);
  }
  throw new TypeError(`Invalid color: ${e == null ? e : String(e) || e.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
}
function ps(e) {
  const {
    h: t,
    s: n,
    v: i,
    a: r
  } = e, s = (o) => {
    const l = (o + t / 60) % 6;
    return i - i * n * Math.max(Math.min(l, 4 - l, 1), 0);
  }, a = [s(5), s(3), s(1)].map((o) => Math.round(o * 255));
  return {
    r: a[0],
    g: a[1],
    b: a[2],
    a: r
  };
}
function ow(e) {
  return ps(op(e));
}
function ch(e) {
  if (!e)
    return {
      h: 0,
      s: 1,
      v: 1,
      a: 1
    };
  const t = e.r / 255, n = e.g / 255, i = e.b / 255, r = Math.max(t, n, i), s = Math.min(t, n, i);
  let a = 0;
  r !== s && (r === t ? a = 60 * (0 + (n - i) / (r - s)) : r === n ? a = 60 * (2 + (i - t) / (r - s)) : r === i && (a = 60 * (4 + (t - n) / (r - s)))), a < 0 && (a = a + 360);
  const o = r === 0 ? 0 : (r - s) / r, l = [a, o, r];
  return {
    h: l[0],
    s: l[1],
    v: l[2],
    a: e.a
  };
}
function gS(e) {
  const {
    h: t,
    s: n,
    v: i,
    a: r
  } = e, s = i - i * n / 2, a = s === 1 || s === 0 ? 0 : (i - s) / Math.min(s, 1 - s);
  return {
    h: t,
    s: a,
    l: s,
    a: r
  };
}
function op(e) {
  const {
    h: t,
    s: n,
    l: i,
    a: r
  } = e, s = i + n * Math.min(i, 1 - i), a = s === 0 ? 0 : 2 - 2 * i / s;
  return {
    h: t,
    s: a,
    v: s,
    a: r
  };
}
function pS(e) {
  let {
    r: t,
    g: n,
    b: i,
    a: r
  } = e;
  return r === void 0 ? `rgb(${t}, ${n}, ${i})` : `rgba(${t}, ${n}, ${i}, ${r})`;
}
function yS(e) {
  return pS(ps(e));
}
function gd(e) {
  const t = Math.round(e).toString(16);
  return ("00".substr(0, 2 - t.length) + t).toUpperCase();
}
function bS(e) {
  let {
    r: t,
    g: n,
    b: i,
    a: r
  } = e;
  return `#${[gd(t), gd(n), gd(i), r !== void 0 ? gd(Math.round(r * 255)) : ""].join("")}`;
}
function wS(e) {
  e = DO(e);
  let [t, n, i, r] = uO(e, 2).map((s) => parseInt(s, 16));
  return r = r === void 0 ? r : r / 255, {
    r: t,
    g: n,
    b: i,
    a: r
  };
}
function _S(e) {
  const t = wS(e);
  return ch(t);
}
function SS(e) {
  return bS(ps(e));
}
function DO(e) {
  return e.startsWith("#") && (e = e.slice(1)), e = e.replace(/([^0-9a-f])/gi, "F"), (e.length === 3 || e.length === 4) && (e = e.split("").map((t) => t + t).join("")), e.length !== 6 && (e = zb(zb(e, 6), 8, "F")), e;
}
function NO(e, t) {
  const n = hS(ap(e));
  return n[0] = n[0] + t * 10, vS(mS(n));
}
function MO(e, t) {
  const n = hS(ap(e));
  return n[0] = n[0] - t * 10, vS(mS(n));
}
function Ov(e) {
  const t = Hi(e);
  return ap(t)[1];
}
function RO(e, t) {
  const n = Ov(e), i = Ov(t), r = Math.max(n, i), s = Math.min(n, i);
  return (r + 0.05) / (s + 0.05);
}
function kS(e) {
  const t = Math.abs(sw(Hi(0), Hi(e)));
  return Math.abs(sw(Hi(16777215), Hi(e))) > Math.min(t, 50) ? "#fff" : "#000";
}
function B(e, t) {
  return (n) => Object.keys(e).reduce((i, r) => {
    const a = typeof e[r] == "object" && e[r] != null && !Array.isArray(e[r]) ? e[r] : {
      type: e[r]
    };
    return n && r in n ? i[r] = {
      ...a,
      default: n[r]
    } : i[r] = a, t && !i[r].source && (i[r].source = t), i;
  }, {});
}
const ke = B({
  class: [String, Array, Object],
  style: {
    type: [String, Array, Object],
    default: null
  }
}, "component"), gl = Symbol.for("vuetify:defaults");
function FO(e) {
  return X(e);
}
function lp() {
  const e = tt(gl);
  if (!e)
    throw new Error("[Vuetify] Could not find defaults instance");
  return e;
}
function jt(e, t) {
  const n = lp(), i = X(e), r = w(() => {
    if (Ct(t == null ? void 0 : t.disabled))
      return n.value;
    const a = Ct(t == null ? void 0 : t.scoped), o = Ct(t == null ? void 0 : t.reset), l = Ct(t == null ? void 0 : t.root);
    if (i.value == null && !(a || o || l))
      return n.value;
    let u = qn(i.value, {
      prev: n.value
    });
    if (a)
      return u;
    if (o || l) {
      const c = Number(o || 1 / 0);
      for (let d = 0; d <= c && !(!u || !("prev" in u)); d++)
        u = u.prev;
      return u && typeof l == "string" && l in u && (u = qn(qn(u, {
        prev: u
      }), u[l])), u;
    }
    return u.prev ? qn(u.prev, u) : u;
  });
  return Tt(gl, r), r;
}
function BO(e, t) {
  var n, i;
  return typeof ((n = e.props) == null ? void 0 : n[t]) < "u" || typeof ((i = e.props) == null ? void 0 : i[$a(t)]) < "u";
}
function CS() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : lp();
  const i = Ut("useDefaults");
  if (t = t ?? i.type.name ?? i.type.__name, !t)
    throw new Error("[Vuetify] Could not determine component name");
  const r = w(() => {
    var l;
    return (l = n.value) == null ? void 0 : l[e._as ?? t];
  }), s = new Proxy(e, {
    get(l, u) {
      var d, f, h, m, g, p, y;
      const c = Reflect.get(l, u);
      return u === "class" || u === "style" ? [(d = r.value) == null ? void 0 : d[u], c].filter((k) => k != null) : typeof u == "string" && !BO(i.vnode, u) ? ((f = r.value) == null ? void 0 : f[u]) !== void 0 ? (h = r.value) == null ? void 0 : h[u] : ((g = (m = n.value) == null ? void 0 : m.global) == null ? void 0 : g[u]) !== void 0 ? (y = (p = n.value) == null ? void 0 : p.global) == null ? void 0 : y[u] : c : c;
    }
  }), a = pe();
  Wt(() => {
    if (r.value) {
      const l = Object.entries(r.value).filter((u) => {
        let [c] = u;
        return c.startsWith(c[0].toUpperCase());
      });
      a.value = l.length ? Object.fromEntries(l) : void 0;
    } else
      a.value = void 0;
  });
  function o() {
    const l = HO(gl, i);
    Tt(gl, w(() => a.value ? qn((l == null ? void 0 : l.value) ?? {}, a.value) : l == null ? void 0 : l.value));
  }
  return {
    props: s,
    provideSubDefaults: o
  };
}
function up() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
  const {
    props: n,
    provideSubDefaults: i
  } = CS(e, t);
  return i(), n;
}
function Oi(e) {
  if (e._setup = e._setup ?? e.setup, !e.name)
    return gr("The component is missing an explicit name, unable to generate default prop value"), e;
  if (e._setup) {
    e.props = B(e.props ?? {}, e.name)();
    const t = Object.keys(e.props).filter((n) => n !== "class" && n !== "style");
    e.filterProps = function(i) {
      return sS(i, t);
    }, e.props._as = String, e.setup = function(i, r) {
      const s = lp();
      if (!s.value)
        return e._setup(i, r);
      const {
        props: a,
        provideSubDefaults: o
      } = CS(i, i._as ?? e.name, s), l = e._setup(a, r);
      return o(), l;
    };
  }
  return e;
}
function J() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
  return (t) => (e ? Oi : ah)(t);
}
function LO(e, t) {
  return t.props = e, t;
}
function Yr(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div", n = arguments.length > 2 ? arguments[2] : void 0;
  return J()({
    name: n ?? Nl(X_(e.replace(/__/g, "-"))),
    props: {
      tag: {
        type: String,
        default: t
      },
      ...ke()
    },
    setup(i, r) {
      let {
        slots: s
      } = r;
      return () => {
        var a;
        return oa(i.tag, {
          class: [e, i.class],
          style: i.style
        }, (a = s.default) == null ? void 0 : a.call(s));
      };
    }
  });
}
function TS(e) {
  if (typeof e.getRootNode != "function") {
    for (; e.parentNode; )
      e = e.parentNode;
    return e !== document ? null : document;
  }
  const t = e.getRootNode();
  return t !== document && t.getRootNode({
    composed: !0
  }) !== document ? null : t;
}
const Hu = "cubic-bezier(0.4, 0, 0.2, 1)", $O = "cubic-bezier(0.0, 0, 0.2, 1)", WO = "cubic-bezier(0.4, 0, 1, 1)";
function lw(e, t, n) {
  return Object.keys(e).filter((i) => lh(i) && i.endsWith(t)).reduce((i, r) => (i[r.slice(0, -t.length)] = (s) => e[r](s, n(s)), i), {});
}
function Ut(e, t) {
  const n = Xg();
  if (!n)
    throw new Error(`[Vuetify] ${e} ${t || "must be called from inside a setup function"}`);
  return n;
}
function Zr() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
  const t = Ut(e).type;
  return $a((t == null ? void 0 : t.aliasName) || (t == null ? void 0 : t.name));
}
let xS = 0, Nd = /* @__PURE__ */ new WeakMap();
function An() {
  const e = Ut("getUid");
  if (Nd.has(e))
    return Nd.get(e);
  {
    const t = xS++;
    return Nd.set(e, t), t;
  }
}
An.reset = () => {
  xS = 0, Nd = /* @__PURE__ */ new WeakMap();
};
function cp(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  for (; e; ) {
    if (t ? jO(e) : dp(e))
      return e;
    e = e.parentElement;
  }
  return document.scrollingElement;
}
function ff(e, t) {
  const n = [];
  if (t && e && !t.contains(e))
    return n;
  for (; e && (dp(e) && n.push(e), e !== t); )
    e = e.parentElement;
  return n;
}
function dp(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE)
    return !1;
  const t = window.getComputedStyle(e);
  return t.overflowY === "scroll" || t.overflowY === "auto" && e.scrollHeight > e.clientHeight;
}
function jO(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE)
    return !1;
  const t = window.getComputedStyle(e);
  return ["scroll", "auto"].includes(t.overflowY);
}
function HO(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ut("injectSelf");
  const {
    provides: n
  } = t;
  if (n && e in n)
    return n[e];
}
function zO(e) {
  for (; e; ) {
    if (window.getComputedStyle(e).position === "fixed")
      return !0;
    e = e.offsetParent;
  }
  return !1;
}
function ie(e) {
  const t = Ut("useRender");
  t.render = e;
}
const UO = B({
  disabled: Boolean,
  group: Boolean,
  hideOnLeave: Boolean,
  leaveAbsolute: Boolean,
  mode: String,
  origin: String
}, "transition");
function Pi(e, t, n) {
  return J()({
    name: e,
    props: UO({
      mode: n,
      origin: t
    }),
    setup(i, r) {
      let {
        slots: s
      } = r;
      const a = {
        onBeforeEnter(o) {
          i.origin && (o.style.transformOrigin = i.origin);
        },
        onLeave(o) {
          if (i.leaveAbsolute) {
            const {
              offsetTop: l,
              offsetLeft: u,
              offsetWidth: c,
              offsetHeight: d
            } = o;
            o._transitionInitialStyles = {
              position: o.style.position,
              top: o.style.top,
              left: o.style.left,
              width: o.style.width,
              height: o.style.height
            }, o.style.position = "absolute", o.style.top = `${l}px`, o.style.left = `${u}px`, o.style.width = `${c}px`, o.style.height = `${d}px`;
          }
          i.hideOnLeave && o.style.setProperty("display", "none", "important");
        },
        onAfterLeave(o) {
          if (i.leaveAbsolute && (o != null && o._transitionInitialStyles)) {
            const {
              position: l,
              top: u,
              left: c,
              width: d,
              height: f
            } = o._transitionInitialStyles;
            delete o._transitionInitialStyles, o.style.position = l || "", o.style.top = u || "", o.style.left = c || "", o.style.width = d || "", o.style.height = f || "";
          }
        }
      };
      return () => {
        const o = i.group ? Jg : na;
        return oa(o, {
          name: i.disabled ? "" : e,
          css: !i.disabled,
          ...i.group ? void 0 : {
            mode: i.mode
          },
          ...i.disabled ? {} : a
        }, s.default);
      };
    }
  });
}
function AS(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
  return J()({
    name: e,
    props: {
      mode: {
        type: String,
        default: n
      },
      disabled: Boolean,
      group: Boolean
    },
    setup(i, r) {
      let {
        slots: s
      } = r;
      const a = i.group ? Jg : na;
      return () => oa(a, {
        name: i.disabled ? "" : e,
        css: !i.disabled,
        // mode: props.mode, // TODO: vuejs/vue-next#3104
        ...i.disabled ? {} : t
      }, s.default);
    }
  });
}
function IS() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) ? "width" : "height", i = X_(`offset-${n}`);
  return {
    onBeforeEnter(a) {
      a._parent = a.parentNode, a._initialStyle = {
        transition: a.style.transition,
        overflow: a.style.overflow,
        [n]: a.style[n]
      };
    },
    onEnter(a) {
      const o = a._initialStyle;
      a.style.setProperty("transition", "none", "important"), a.style.overflow = "hidden";
      const l = `${a[i]}px`;
      a.style[n] = "0", a.offsetHeight, a.style.transition = o.transition, e && a._parent && a._parent.classList.add(e), requestAnimationFrame(() => {
        a.style[n] = l;
      });
    },
    onAfterEnter: s,
    onEnterCancelled: s,
    onLeave(a) {
      a._initialStyle = {
        transition: "",
        overflow: a.style.overflow,
        [n]: a.style[n]
      }, a.style.overflow = "hidden", a.style[n] = `${a[i]}px`, a.offsetHeight, requestAnimationFrame(() => a.style[n] = "0");
    },
    onAfterLeave: r,
    onLeaveCancelled: r
  };
  function r(a) {
    e && a._parent && a._parent.classList.remove(e), s(a);
  }
  function s(a) {
    const o = a._initialStyle[n];
    a.style.overflow = a._initialStyle.overflow, o != null && (a.style[n] = o), delete a._initialStyle;
  }
}
const qO = B({
  target: [Object, Array]
}, "v-dialog-transition"), dh = J()({
  name: "VDialogTransition",
  props: qO(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = {
      onBeforeEnter(r) {
        r.style.pointerEvents = "none", r.style.visibility = "hidden";
      },
      async onEnter(r, s) {
        var f;
        await new Promise((h) => requestAnimationFrame(h)), await new Promise((h) => requestAnimationFrame(h)), r.style.visibility = "";
        const {
          x: a,
          y: o,
          sx: l,
          sy: u,
          speed: c
        } = cw(e.target, r), d = Na(r, [{
          transform: `translate(${a}px, ${o}px) scale(${l}, ${u})`,
          opacity: 0
        }, {}], {
          duration: 225 * c,
          easing: $O
        });
        (f = uw(r)) == null || f.forEach((h) => {
          Na(h, [{
            opacity: 0
          }, {
            opacity: 0,
            offset: 0.33
          }, {}], {
            duration: 225 * 2 * c,
            easing: Hu
          });
        }), d.finished.then(() => s());
      },
      onAfterEnter(r) {
        r.style.removeProperty("pointer-events");
      },
      onBeforeLeave(r) {
        r.style.pointerEvents = "none";
      },
      async onLeave(r, s) {
        var f;
        await new Promise((h) => requestAnimationFrame(h));
        const {
          x: a,
          y: o,
          sx: l,
          sy: u,
          speed: c
        } = cw(e.target, r);
        Na(r, [{}, {
          transform: `translate(${a}px, ${o}px) scale(${l}, ${u})`,
          opacity: 0
        }], {
          duration: 125 * c,
          easing: WO
        }).finished.then(() => s()), (f = uw(r)) == null || f.forEach((h) => {
          Na(h, [{}, {
            opacity: 0,
            offset: 0.2
          }, {
            opacity: 0
          }], {
            duration: 125 * 2 * c,
            easing: Hu
          });
        });
      },
      onAfterLeave(r) {
        r.style.removeProperty("pointer-events");
      }
    };
    return () => e.target ? v(na, se({
      name: "dialog-transition"
    }, i, {
      css: !1
    }), n) : v(na, {
      name: "dialog-transition"
    }, n);
  }
});
function uw(e) {
  var n;
  const t = (n = e.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) == null ? void 0 : n.children;
  return t && [...t];
}
function cw(e, t) {
  const n = fS(e), i = sp(t), [r, s] = getComputedStyle(t).transformOrigin.split(" ").map((y) => parseFloat(y)), [a, o] = getComputedStyle(t).getPropertyValue("--v-overlay-anchor-origin").split(" ");
  let l = n.left + n.width / 2;
  a === "left" || o === "left" ? l -= n.width / 2 : (a === "right" || o === "right") && (l += n.width / 2);
  let u = n.top + n.height / 2;
  a === "top" || o === "top" ? u -= n.height / 2 : (a === "bottom" || o === "bottom") && (u += n.height / 2);
  const c = n.width / i.width, d = n.height / i.height, f = Math.max(1, c, d), h = c / f || 0, m = d / f || 0, g = i.width * i.height / (window.innerWidth * window.innerHeight), p = g > 0.12 ? Math.min(1.5, (g - 0.12) * 10 + 1) : 1;
  return {
    x: l - (r + i.left),
    y: u - (s + i.top),
    sx: h,
    sy: m,
    speed: p
  };
}
const GO = Pi("fab-transition", "center center", "out-in"), YO = Pi("dialog-bottom-transition"), ZO = Pi("dialog-top-transition"), zu = Pi("fade-transition"), fp = Pi("scale-transition"), KO = Pi("scroll-x-transition"), XO = Pi("scroll-x-reverse-transition"), JO = Pi("scroll-y-transition"), QO = Pi("scroll-y-reverse-transition"), eP = Pi("slide-x-transition"), tP = Pi("slide-x-reverse-transition"), hp = Pi("slide-y-transition"), nP = Pi("slide-y-reverse-transition"), fh = AS("expand-transition", IS()), mp = AS("expand-x-transition", IS("", !0)), Tr = B({
  transition: {
    type: [Boolean, String, Object],
    default: "fade-transition",
    validator: (e) => e !== !0
  }
}, "transition"), Gn = (e, t) => {
  let {
    slots: n
  } = t;
  const {
    transition: i,
    disabled: r,
    group: s,
    ...a
  } = e, {
    component: o = s ? Jg : na,
    ...l
  } = typeof i == "object" ? i : {};
  return oa(o, se(typeof i == "string" ? {
    name: r ? "" : i
  } : l, typeof i == "string" ? {} : Object.fromEntries(Object.entries({
    disabled: r,
    group: s
  }).filter((u) => {
    let [c, d] = u;
    return d !== void 0;
  })), a), n);
}, iP = B({
  active: Boolean,
  disabled: Boolean,
  max: [Number, String],
  value: {
    type: [Number, String],
    default: 0
  },
  ...ke(),
  ...Tr({
    transition: {
      component: hp
    }
  })
}, "VCounter"), hh = J()({
  name: "VCounter",
  functional: !0,
  props: iP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = w(() => e.max ? `${e.value} / ${e.max}` : String(e.value));
    return ie(() => v(Gn, {
      transition: e.transition
    }, {
      default: () => [Rt(v("div", {
        class: ["v-counter", {
          "text-error": e.max && !e.disabled && parseFloat(e.value) > parseFloat(e.max)
        }, e.class],
        style: e.style
      }, [n.default ? n.default({
        counter: i.value,
        max: e.max,
        value: e.value
      }) : i.value]), [[Cr, e.active]])]
    })), {};
  }
});
const Uu = Symbol.for("vuetify:theme"), Qe = B({
  theme: String
}, "theme");
function dw() {
  return {
    defaultTheme: "light",
    variations: {
      colors: [],
      lighten: 0,
      darken: 0
    },
    themes: {
      light: {
        dark: !1,
        colors: {
          background: "#FFFFFF",
          surface: "#FFFFFF",
          "surface-bright": "#FFFFFF",
          "surface-light": "#EEEEEE",
          "surface-variant": "#424242",
          "on-surface-variant": "#EEEEEE",
          primary: "#1867C0",
          "primary-darken-1": "#1F5592",
          secondary: "#48A9A6",
          "secondary-darken-1": "#018786",
          error: "#B00020",
          info: "#2196F3",
          success: "#4CAF50",
          warning: "#FB8C00"
        },
        variables: {
          "border-color": "#000000",
          "border-opacity": 0.12,
          "high-emphasis-opacity": 0.87,
          "medium-emphasis-opacity": 0.6,
          "disabled-opacity": 0.38,
          "idle-opacity": 0.04,
          "hover-opacity": 0.04,
          "focus-opacity": 0.12,
          "selected-opacity": 0.08,
          "activated-opacity": 0.12,
          "pressed-opacity": 0.12,
          "dragged-opacity": 0.08,
          "theme-kbd": "#212529",
          "theme-on-kbd": "#FFFFFF",
          "theme-code": "#F5F5F5",
          "theme-on-code": "#000000"
        }
      },
      dark: {
        dark: !0,
        colors: {
          background: "#121212",
          surface: "#212121",
          "surface-bright": "#ccbfd6",
          "surface-light": "#424242",
          "surface-variant": "#a3a3a3",
          "on-surface-variant": "#424242",
          primary: "#2196F3",
          "primary-darken-1": "#277CC1",
          secondary: "#54B6B2",
          "secondary-darken-1": "#48A9A6",
          error: "#CF6679",
          info: "#2196F3",
          success: "#4CAF50",
          warning: "#FB8C00"
        },
        variables: {
          "border-color": "#FFFFFF",
          "border-opacity": 0.12,
          "high-emphasis-opacity": 1,
          "medium-emphasis-opacity": 0.7,
          "disabled-opacity": 0.5,
          "idle-opacity": 0.1,
          "hover-opacity": 0.04,
          "focus-opacity": 0.12,
          "selected-opacity": 0.08,
          "activated-opacity": 0.12,
          "pressed-opacity": 0.16,
          "dragged-opacity": 0.08,
          "theme-kbd": "#212529",
          "theme-on-kbd": "#FFFFFF",
          "theme-code": "#343434",
          "theme-on-code": "#CCCCCC"
        }
      }
    }
  };
}
function rP() {
  var i, r;
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : dw();
  const t = dw();
  if (!e)
    return {
      ...t,
      isDisabled: !0
    };
  const n = {};
  for (const [s, a] of Object.entries(e.themes ?? {})) {
    const o = a.dark || s === "dark" ? (i = t.themes) == null ? void 0 : i.dark : (r = t.themes) == null ? void 0 : r.light;
    n[s] = qn(o, a);
  }
  return qn(t, {
    ...e,
    themes: n
  });
}
function sP(e) {
  const t = rP(e), n = X(t.defaultTheme), i = X(t.themes), r = w(() => {
    const c = {};
    for (const [d, f] of Object.entries(i.value)) {
      const h = c[d] = {
        ...f,
        colors: {
          ...f.colors
        }
      };
      if (t.variations)
        for (const m of t.variations.colors) {
          const g = h.colors[m];
          if (g)
            for (const p of ["lighten", "darken"]) {
              const y = p === "lighten" ? NO : MO;
              for (const k of jr(t.variations[p], 1))
                h.colors[`${m}-${p}-${k}`] = bS(y(Hi(g), k));
            }
        }
      for (const m of Object.keys(h.colors)) {
        if (/^on-[a-z]/.test(m) || h.colors[`on-${m}`])
          continue;
        const g = `on-${m}`, p = Hi(h.colors[m]);
        h.colors[g] = kS(p);
      }
    }
    return c;
  }), s = w(() => r.value[n.value]), a = w(() => {
    var m;
    const c = [];
    (m = s.value) != null && m.dark && ya(c, ":root", ["color-scheme: dark"]), ya(c, ":root", fw(s.value));
    for (const [g, p] of Object.entries(r.value))
      ya(c, `.v-theme--${g}`, [`color-scheme: ${p.dark ? "dark" : "normal"}`, ...fw(p)]);
    const d = [], f = [], h = new Set(Object.values(r.value).flatMap((g) => Object.keys(g.colors)));
    for (const g of h)
      /^on-[a-z]/.test(g) ? ya(f, `.${g}`, [`color: rgb(var(--v-theme-${g})) !important`]) : (ya(d, `.bg-${g}`, [`--v-theme-overlay-multiplier: var(--v-theme-${g}-overlay-multiplier)`, `background-color: rgb(var(--v-theme-${g})) !important`, `color: rgb(var(--v-theme-on-${g})) !important`]), ya(f, `.text-${g}`, [`color: rgb(var(--v-theme-${g})) !important`]), ya(f, `.border-${g}`, [`--v-border-color: var(--v-theme-${g})`]));
    return c.push(...d, ...f), c.map((g, p) => p === 0 ? g : `    ${g}`).join("");
  });
  function o() {
    return {
      style: [{
        children: a.value,
        id: "vuetify-theme-stylesheet",
        nonce: t.cspNonce || !1
      }]
    };
  }
  function l(c) {
    if (t.isDisabled)
      return;
    const d = c._context.provides.usehead;
    if (d)
      if (d.push) {
        const f = d.push(o);
        ft && fe(a, () => {
          f.patch(o);
        });
      } else
        ft ? (d.addHeadObjs(w(o)), Wt(() => d.updateDOM())) : d.addHeadObjs(o());
    else {
      let h = function() {
        if (typeof document < "u" && !f) {
          const m = document.createElement("style");
          m.type = "text/css", m.id = "vuetify-theme-stylesheet", t.cspNonce && m.setAttribute("nonce", t.cspNonce), f = m, document.head.appendChild(f);
        }
        f && (f.innerHTML = a.value);
      }, f = ft ? document.getElementById("vuetify-theme-stylesheet") : null;
      ft ? fe(a, h, {
        immediate: !0
      }) : h();
    }
  }
  const u = w(() => t.isDisabled ? void 0 : `v-theme--${n.value}`);
  return {
    install: l,
    isDisabled: t.isDisabled,
    name: n,
    themes: i,
    current: s,
    computedThemes: r,
    themeClasses: u,
    styles: a,
    global: {
      name: n,
      current: s
    }
  };
}
function lt(e) {
  Ut("provideTheme");
  const t = tt(Uu, null);
  if (!t)
    throw new Error("Could not find Vuetify theme injection");
  const n = w(() => e.theme ?? t.name.value), i = w(() => t.themes.value[n.value]), r = w(() => t.isDisabled ? void 0 : `v-theme--${n.value}`), s = {
    ...t,
    name: n,
    current: i,
    themeClasses: r
  };
  return Tt(Uu, s), s;
}
function ES() {
  Ut("useTheme");
  const e = tt(Uu, null);
  if (!e)
    throw new Error("Could not find Vuetify theme injection");
  return e;
}
function ya(e, t, n) {
  e.push(`${t} {
`, ...n.map((i) => `  ${i};
`), `}
`);
}
function fw(e) {
  const t = e.dark ? 2 : 1, n = e.dark ? 1 : 2, i = [];
  for (const [r, s] of Object.entries(e.colors)) {
    const a = Hi(s);
    i.push(`--v-theme-${r}: ${a.r},${a.g},${a.b}`), r.startsWith("on-") || i.push(`--v-theme-${r}-overlay-multiplier: ${Ov(s) > 0.18 ? t : n}`);
  }
  for (const [r, s] of Object.entries(e.variables)) {
    const a = typeof s == "string" && s.startsWith("#") ? Hi(s) : void 0, o = a ? `${a.r}, ${a.g}, ${a.b}` : void 0;
    i.push(`--v-${r}: ${o ?? s}`);
  }
  return i;
}
const aP = B({
  text: String,
  onClick: ri(),
  ...ke(),
  ...Qe()
}, "VLabel"), Rl = J()({
  name: "VLabel",
  props: aP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ie(() => {
      var i;
      return v("label", {
        class: ["v-label", {
          "v-label--clickable": !!e.onClick
        }, e.class],
        style: e.style,
        onClick: e.onClick
      }, [e.text, (i = n.default) == null ? void 0 : i.call(n)]);
    }), {};
  }
}), oP = B({
  floating: Boolean,
  ...ke()
}, "VFieldLabel"), fu = J()({
  name: "VFieldLabel",
  props: oP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ie(() => v(Rl, {
      class: ["v-field-label", {
        "v-field-label--floating": e.floating
      }, e.class],
      style: e.style,
      "aria-hidden": e.floating || void 0
    }, n)), {};
  }
}), lP = B({
  defaults: Object,
  disabled: Boolean,
  reset: [Number, String],
  root: [Boolean, String],
  scoped: Boolean
}, "VDefaultsProvider"), Ze = J(!1)({
  name: "VDefaultsProvider",
  props: lP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      defaults: i,
      disabled: r,
      reset: s,
      root: a,
      scoped: o
    } = sh(e);
    return jt(i, {
      reset: s,
      root: a,
      scoped: o,
      disabled: r
    }), () => {
      var l;
      return (l = n.default) == null ? void 0 : l.call(n);
    };
  }
});
function vp(e) {
  return ip(() => {
    const t = [], n = {};
    if (e.value.background)
      if (Ev(e.value.background)) {
        if (n.backgroundColor = e.value.background, !e.value.text && PO(e.value.background)) {
          const i = Hi(e.value.background);
          if (i.a == null || i.a === 1) {
            const r = kS(i);
            n.color = r, n.caretColor = r;
          }
        }
      } else
        t.push(`bg-${e.value.background}`);
    return e.value.text && (Ev(e.value.text) ? (n.color = e.value.text, n.caretColor = e.value.text) : t.push(`text-${e.value.text}`)), {
      colorClasses: t,
      colorStyles: n
    };
  });
}
function Ln(e, t) {
  const n = w(() => ({
    text: ia(e) ? e.value : t ? e[t] : null
  })), {
    colorClasses: i,
    colorStyles: r
  } = vp(n);
  return {
    textColorClasses: i,
    textColorStyles: r
  };
}
function gt(e, t) {
  const n = w(() => ({
    background: ia(e) ? e.value : t ? e[t] : null
  })), {
    colorClasses: i,
    colorStyles: r
  } = vp(n);
  return {
    backgroundColorClasses: i,
    backgroundColorStyles: r
  };
}
const uP = {
  collapse: "mdi-chevron-up",
  complete: "mdi-check",
  cancel: "mdi-close-circle",
  close: "mdi-close",
  delete: "mdi-close-circle",
  // delete (e.g. v-chip close)
  clear: "mdi-close-circle",
  success: "mdi-check-circle",
  info: "mdi-information",
  warning: "mdi-alert-circle",
  error: "mdi-close-circle",
  prev: "mdi-chevron-left",
  next: "mdi-chevron-right",
  checkboxOn: "mdi-checkbox-marked",
  checkboxOff: "mdi-checkbox-blank-outline",
  checkboxIndeterminate: "mdi-minus-box",
  delimiter: "mdi-circle",
  // for carousel
  sortAsc: "mdi-arrow-up",
  sortDesc: "mdi-arrow-down",
  expand: "mdi-chevron-down",
  menu: "mdi-menu",
  subgroup: "mdi-menu-down",
  dropdown: "mdi-menu-down",
  radioOn: "mdi-radiobox-marked",
  radioOff: "mdi-radiobox-blank",
  edit: "mdi-pencil",
  ratingEmpty: "mdi-star-outline",
  ratingFull: "mdi-star",
  ratingHalf: "mdi-star-half-full",
  loading: "mdi-cached",
  first: "mdi-page-first",
  last: "mdi-page-last",
  unfold: "mdi-unfold-more-horizontal",
  file: "mdi-paperclip",
  plus: "mdi-plus",
  minus: "mdi-minus",
  calendar: "mdi-calendar",
  treeviewCollapse: "mdi-menu-down",
  treeviewExpand: "mdi-menu-right",
  eyeDropper: "mdi-eyedropper"
}, cP = {
  // Not using mergeProps here, functional components merge props by default (?)
  component: (e) => oa(pp, {
    ...e,
    class: "mdi"
  })
}, We = [String, Function, Object, Array], Pv = Symbol.for("vuetify:icons"), mh = B({
  icon: {
    type: We
  },
  // Could not remove this and use makeTagProps, types complained because it is not required
  tag: {
    type: String,
    required: !0
  }
}, "icon"), Vv = J()({
  name: "VComponentIcon",
  props: mh(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      const i = e.icon;
      return v(e.tag, null, {
        default: () => {
          var r;
          return [e.icon ? v(i, null, null) : (r = n.default) == null ? void 0 : r.call(n)];
        }
      });
    };
  }
}), gp = Oi({
  name: "VSvgIcon",
  inheritAttrs: !1,
  props: mh(),
  setup(e, t) {
    let {
      attrs: n
    } = t;
    return () => v(e.tag, se(n, {
      style: null
    }), {
      default: () => [v("svg", {
        class: "v-icon__svg",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        role: "img",
        "aria-hidden": "true"
      }, [Array.isArray(e.icon) ? e.icon.map((i) => Array.isArray(i) ? v("path", {
        d: i[0],
        "fill-opacity": i[1]
      }, null) : v("path", {
        d: i
      }, null)) : v("path", {
        d: e.icon
      }, null)])]
    });
  }
}), dP = Oi({
  name: "VLigatureIcon",
  props: mh(),
  setup(e) {
    return () => v(e.tag, null, {
      default: () => [e.icon]
    });
  }
}), pp = Oi({
  name: "VClassIcon",
  props: mh(),
  setup(e) {
    return () => v(e.tag, {
      class: e.icon
    }, null);
  }
});
function fP() {
  return {
    svg: {
      component: gp
    },
    class: {
      component: pp
    }
  };
}
function hP(e) {
  const t = fP(), n = (e == null ? void 0 : e.defaultSet) ?? "mdi";
  return n === "mdi" && !t.mdi && (t.mdi = cP), qn({
    defaultSet: n,
    sets: t,
    aliases: {
      ...uP,
      /* eslint-disable max-len */
      vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", 0.6]],
      "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z",
      "vuetify-play": ["m6.376 13.184-4.11-7.192C1.505 4.66 2.467 3 4.003 3h8.532l-.953 1.576-.006.01-.396.677c-.429.732-.214 1.507.194 2.015.404.503 1.092.878 1.869.806a3.72 3.72 0 0 1 1.005.022c.276.053.434.143.523.237.138.146.38.635-.25 2.09-.893 1.63-1.553 1.722-1.847 1.677-.213-.033-.468-.158-.756-.406a4.95 4.95 0 0 1-.8-.927c-.39-.564-1.04-.84-1.66-.846-.625-.006-1.316.27-1.693.921l-.478.826-.911 1.506Z", ["M9.093 11.552c.046-.079.144-.15.32-.148a.53.53 0 0 1 .43.207c.285.414.636.847 1.046 1.2.405.35.914.662 1.516.754 1.334.205 2.502-.698 3.48-2.495l.014-.028.013-.03c.687-1.574.774-2.852-.005-3.675-.37-.391-.861-.586-1.333-.676a5.243 5.243 0 0 0-1.447-.044c-.173.016-.393-.073-.54-.257-.145-.18-.127-.316-.082-.392l.393-.672L14.287 3h5.71c1.536 0 2.499 1.659 1.737 2.992l-7.997 13.996c-.768 1.344-2.706 1.344-3.473 0l-3.037-5.314 1.377-2.278.004-.006.004-.007.481-.831Z", 0.6]]
      /* eslint-enable max-len */
    }
  }, e);
}
const mP = (e) => {
  const t = tt(Pv);
  if (!t)
    throw new Error("Missing Vuetify Icons provide!");
  return {
    iconData: w(() => {
      var l;
      const i = Ct(e);
      if (!i)
        return {
          component: Vv
        };
      let r = i;
      if (typeof r == "string" && (r = r.trim(), r.startsWith("$") && (r = (l = t.aliases) == null ? void 0 : l[r.slice(1)])), r || gr(`Could not find aliased icon "${i}"`), Array.isArray(r))
        return {
          component: gp,
          icon: r
        };
      if (typeof r != "string")
        return {
          component: Vv,
          icon: r
        };
      const s = Object.keys(t.sets).find((u) => typeof r == "string" && r.startsWith(`${u}:`)), a = s ? r.slice(s.length + 1) : r;
      return {
        component: t.sets[s ?? t.defaultSet].component,
        icon: a
      };
    })
  };
}, vP = ["x-small", "small", "default", "large", "x-large"], Kr = B({
  size: {
    type: [String, Number],
    default: "default"
  }
}, "size");
function Fl(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zr();
  return ip(() => {
    let n, i;
    return lf(vP, e.size) ? n = `${t}--size-${e.size}` : e.size && (i = {
      width: _e(e.size),
      height: _e(e.size)
    }), {
      sizeClasses: n,
      sizeStyles: i
    };
  });
}
const je = B({
  tag: {
    type: String,
    default: "div"
  }
}, "tag"), gP = B({
  color: String,
  disabled: Boolean,
  start: Boolean,
  end: Boolean,
  icon: We,
  ...ke(),
  ...Kr(),
  ...je({
    tag: "i"
  }),
  ...Qe()
}, "VIcon"), at = J()({
  name: "VIcon",
  props: gP(),
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const r = X(), {
      themeClasses: s
    } = lt(e), {
      iconData: a
    } = mP(w(() => r.value || e.icon)), {
      sizeClasses: o
    } = Fl(e), {
      textColorClasses: l,
      textColorStyles: u
    } = Ln(G(e, "color"));
    return ie(() => {
      var f, h;
      const c = (f = i.default) == null ? void 0 : f.call(i);
      c && (r.value = (h = oS(c).filter((m) => m.type === $E && m.children && typeof m.children == "string")[0]) == null ? void 0 : h.children);
      const d = !!(n.onClick || n.onClickOnce);
      return v(a.value.component, {
        tag: e.tag,
        icon: a.value.icon,
        class: ["v-icon", "notranslate", s.value, o.value, l.value, {
          "v-icon--clickable": d,
          "v-icon--disabled": e.disabled,
          "v-icon--start": e.start,
          "v-icon--end": e.end
        }, e.class],
        style: [o.value ? void 0 : {
          fontSize: _e(e.size),
          height: _e(e.size),
          width: _e(e.size)
        }, u.value, e.style],
        role: d ? "button" : void 0,
        "aria-hidden": !d,
        tabindex: d ? e.disabled ? -1 : 0 : void 0
      }, {
        default: () => [c]
      });
    }), {};
  }
});
function vi(e, t) {
  let n;
  function i() {
    n = Qg(), n.run(() => t.length ? t(() => {
      n == null || n.stop(), i();
    }) : t());
  }
  fe(e, (r) => {
    r && !n ? i() : r || (n == null || n.stop(), n = void 0);
  }, {
    immediate: !0
  }), Wn(() => {
    n == null || n.stop();
  });
}
function Ee(e, t, n) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (d) => d, r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (d) => d;
  const s = Ut("useProxiedModel"), a = X(e[t] !== void 0 ? e[t] : n), o = $a(t), u = o !== t ? w(() => {
    var d, f, h, m;
    return e[t], !!(((d = s.vnode.props) != null && d.hasOwnProperty(t) || (f = s.vnode.props) != null && f.hasOwnProperty(o)) && ((h = s.vnode.props) != null && h.hasOwnProperty(`onUpdate:${t}`) || (m = s.vnode.props) != null && m.hasOwnProperty(`onUpdate:${o}`)));
  }) : w(() => {
    var d, f;
    return e[t], !!((d = s.vnode.props) != null && d.hasOwnProperty(t) && ((f = s.vnode.props) != null && f.hasOwnProperty(`onUpdate:${t}`)));
  });
  vi(() => !u.value, () => {
    fe(() => e[t], (d) => {
      a.value = d;
    });
  });
  const c = w({
    get() {
      const d = e[t];
      return i(u.value ? d : a.value);
    },
    set(d) {
      const f = r(d), h = si(u.value ? e[t] : a.value);
      h === f || i(h) === d || (a.value = f, s == null || s.emit(`update:${t}`, f));
    }
  });
  return Object.defineProperty(c, "externalValue", {
    get: () => u.value ? e[t] : a.value
  }), c;
}
const pP = {
  badge: "Badge",
  open: "Open",
  close: "Close",
  dismiss: "Dismiss",
  confirmEdit: {
    ok: "OK",
    cancel: "Cancel"
  },
  dataIterator: {
    noResultsText: "No matching records found",
    loadingText: "Loading items..."
  },
  dataTable: {
    itemsPerPageText: "Rows per page:",
    ariaLabel: {
      sortDescending: "Sorted descending.",
      sortAscending: "Sorted ascending.",
      sortNone: "Not sorted.",
      activateNone: "Activate to remove sorting.",
      activateDescending: "Activate to sort descending.",
      activateAscending: "Activate to sort ascending."
    },
    sortBy: "Sort by"
  },
  dataFooter: {
    itemsPerPageText: "Items per page:",
    itemsPerPageAll: "All",
    nextPage: "Next page",
    prevPage: "Previous page",
    firstPage: "First page",
    lastPage: "Last page",
    pageText: "{0}-{1} of {2}"
  },
  dateRangeInput: {
    divider: "to"
  },
  datePicker: {
    itemsSelected: "{0} selected",
    range: {
      title: "Select dates",
      header: "Enter dates"
    },
    title: "Select date",
    header: "Enter date",
    input: {
      placeholder: "Enter date"
    }
  },
  noDataText: "No data available",
  carousel: {
    prev: "Previous visual",
    next: "Next visual",
    ariaLabel: {
      delimiter: "Carousel slide {0} of {1}"
    }
  },
  calendar: {
    moreEvents: "{0} more",
    today: "Today"
  },
  input: {
    clear: "Clear {0}",
    prependAction: "{0} prepended action",
    appendAction: "{0} appended action",
    otp: "Please enter OTP character {0}"
  },
  fileInput: {
    counter: "{0} files",
    counterSize: "{0} files ({1} in total)"
  },
  timePicker: {
    am: "AM",
    pm: "PM",
    title: "Select Time"
  },
  pagination: {
    ariaLabel: {
      root: "Pagination Navigation",
      next: "Next page",
      previous: "Previous page",
      page: "Go to page {0}",
      currentPage: "Page {0}, Current page",
      first: "First page",
      last: "Last page"
    }
  },
  stepper: {
    next: "Next",
    prev: "Previous"
  },
  rating: {
    ariaLabel: {
      item: "Rating {0} of {1}"
    }
  },
  loading: "Loading...",
  infiniteScroll: {
    loadMore: "Load more",
    empty: "No more"
  }
}, hw = "$vuetify.", mw = (e, t) => e.replace(/\{(\d+)\}/g, (n, i) => String(t[+i])), OS = (e, t, n) => function(i) {
  for (var r = arguments.length, s = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)
    s[a - 1] = arguments[a];
  if (!i.startsWith(hw))
    return mw(i, s);
  const o = i.replace(hw, ""), l = e.value && n.value[e.value], u = t.value && n.value[t.value];
  let c = $u(l, o, null);
  return c || (gr(`Translation key "${i}" not found in "${e.value}", trying fallback locale`), c = $u(u, o, null)), c || (cf(`Translation key "${i}" not found in fallback`), c = i), typeof c != "string" && (cf(`Translation key "${i}" has a non-string value`), c = i), mw(c, s);
};
function PS(e, t) {
  return (n, i) => new Intl.NumberFormat([e.value, t.value], i).format(n);
}
function jm(e, t, n) {
  const i = Ee(e, t, e[t] ?? n.value);
  return i.value = e[t] ?? n.value, fe(n, (r) => {
    e[t] == null && (i.value = n.value);
  }), i;
}
function VS(e) {
  return (t) => {
    const n = jm(t, "locale", e.current), i = jm(t, "fallback", e.fallback), r = jm(t, "messages", e.messages);
    return {
      name: "vuetify",
      current: n,
      fallback: i,
      messages: r,
      t: OS(n, i, r),
      n: PS(n, i),
      provide: VS({
        current: n,
        fallback: i,
        messages: r
      })
    };
  };
}
function yP(e) {
  const t = pe((e == null ? void 0 : e.locale) ?? "en"), n = pe((e == null ? void 0 : e.fallback) ?? "en"), i = X({
    en: pP,
    ...e == null ? void 0 : e.messages
  });
  return {
    name: "vuetify",
    current: t,
    fallback: n,
    messages: i,
    t: OS(t, n, i),
    n: PS(t, n),
    provide: VS({
      current: t,
      fallback: n,
      messages: i
    })
  };
}
const pl = Symbol.for("vuetify:locale");
function bP(e) {
  return e.name != null;
}
function wP(e) {
  const t = e != null && e.adapter && bP(e == null ? void 0 : e.adapter) ? e == null ? void 0 : e.adapter : yP(e), n = kP(t, e);
  return {
    ...t,
    ...n
  };
}
function qt() {
  const e = tt(pl);
  if (!e)
    throw new Error("[Vuetify] Could not find injected locale instance");
  return e;
}
function _P(e) {
  const t = tt(pl);
  if (!t)
    throw new Error("[Vuetify] Could not find injected locale instance");
  const n = t.provide(e), i = CP(n, t.rtl, e), r = {
    ...n,
    ...i
  };
  return Tt(pl, r), r;
}
function SP() {
  return {
    af: !1,
    ar: !0,
    bg: !1,
    ca: !1,
    ckb: !1,
    cs: !1,
    de: !1,
    el: !1,
    en: !1,
    es: !1,
    et: !1,
    fa: !0,
    fi: !1,
    fr: !1,
    hr: !1,
    hu: !1,
    he: !0,
    id: !1,
    it: !1,
    ja: !1,
    km: !1,
    ko: !1,
    lv: !1,
    lt: !1,
    nl: !1,
    no: !1,
    pl: !1,
    pt: !1,
    ro: !1,
    ru: !1,
    sk: !1,
    sl: !1,
    srCyrl: !1,
    srLatn: !1,
    sv: !1,
    th: !1,
    tr: !1,
    az: !1,
    uk: !1,
    vi: !1,
    zhHans: !1,
    zhHant: !1
  };
}
function kP(e, t) {
  const n = X((t == null ? void 0 : t.rtl) ?? SP()), i = w(() => n.value[e.current.value] ?? !1);
  return {
    isRtl: i,
    rtl: n,
    rtlClasses: w(() => `v-locale--is-${i.value ? "rtl" : "ltr"}`)
  };
}
function CP(e, t, n) {
  const i = w(() => n.rtl ?? t.value[e.current.value] ?? !1);
  return {
    isRtl: i,
    rtl: t,
    rtlClasses: w(() => `v-locale--is-${i.value ? "rtl" : "ltr"}`)
  };
}
function yn() {
  const e = tt(pl);
  if (!e)
    throw new Error("[Vuetify] Could not find injected rtl instance");
  return {
    isRtl: e.isRtl,
    rtlClasses: e.rtlClasses
  };
}
function DS(e) {
  const {
    t
  } = qt();
  function n(i) {
    let {
      name: r
    } = i;
    const s = {
      prepend: "prependAction",
      prependInner: "prependAction",
      append: "appendAction",
      appendInner: "appendAction",
      clear: "clear"
    }[r], a = e[`onClick:${r}`], o = a && s ? t(`$vuetify.input.${s}`, e.label ?? "") : void 0;
    return v(at, {
      icon: e[`${r}Icon`],
      "aria-label": o,
      onClick: a
    }, null);
  }
  return {
    InputIcon: n
  };
}
const Ac = B({
  focused: Boolean,
  "onUpdate:focused": ri()
}, "focus");
function Cs(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zr();
  const n = Ee(e, "focused"), i = w(() => ({
    [`${t}--focused`]: n.value
  }));
  function r() {
    n.value = !0;
  }
  function s() {
    n.value = !1;
  }
  return {
    focusClasses: i,
    isFocused: n,
    focus: r,
    blur: s
  };
}
function vh(e, t) {
  const n = X(), i = pe(!1);
  if (tp) {
    const r = new IntersectionObserver((s) => {
      e == null || e(s, r), i.value = !!s.find((a) => a.isIntersecting);
    }, t);
    ai(() => {
      r.disconnect();
    }), fe(n, (s, a) => {
      a && (r.unobserve(a), i.value = !1), s && r.observe(s);
    }, {
      flush: "post"
    });
  }
  return {
    intersectionRef: n,
    isIntersecting: i
  };
}
const vw = {
  center: "center",
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
}, ua = B({
  location: String
}, "location");
function po(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 ? arguments[2] : void 0;
  const {
    isRtl: i
  } = yn();
  return {
    locationStyles: w(() => {
      if (!e.location)
        return {};
      const {
        side: s,
        align: a
      } = Av(e.location.split(" ").length > 1 ? e.location : `${e.location} center`, i.value);
      function o(u) {
        return n ? n(u) : 0;
      }
      const l = {};
      return s !== "center" && (t ? l[vw[s]] = `calc(100% - ${o(s)}px)` : l[s] = 0), a !== "center" ? t ? l[vw[a]] = `calc(100% - ${o(a)}px)` : l[a] = 0 : (s === "center" ? l.top = l.left = "50%" : l[{
        top: "left",
        bottom: "left",
        left: "top",
        right: "top"
      }[s]] = "50%", l.transform = {
        top: "translateX(-50%)",
        bottom: "translateX(-50%)",
        left: "translateY(-50%)",
        right: "translateY(-50%)",
        center: "translate(-50%, -50%)"
      }[s]), l;
    })
  };
}
const It = B({
  rounded: {
    type: [Boolean, Number, String],
    default: void 0
  },
  tile: Boolean
}, "rounded");
function Ht(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zr();
  return {
    roundedClasses: w(() => {
      const i = ia(e) ? e.value : e.rounded, r = ia(e) ? e.value : e.tile, s = [];
      if (i === !0 || i === "")
        s.push(`${t}--rounded`);
      else if (typeof i == "string" || i === 0)
        for (const a of String(i).split(" "))
          s.push(`rounded-${a}`);
      else
        (r || i === !1) && s.push("rounded-0");
      return s;
    })
  };
}
const TP = B({
  absolute: Boolean,
  active: {
    type: Boolean,
    default: !0
  },
  bgColor: String,
  bgOpacity: [Number, String],
  bufferValue: {
    type: [Number, String],
    default: 0
  },
  bufferColor: String,
  bufferOpacity: [Number, String],
  clickable: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: 4
  },
  indeterminate: Boolean,
  max: {
    type: [Number, String],
    default: 100
  },
  modelValue: {
    type: [Number, String],
    default: 0
  },
  opacity: [Number, String],
  reverse: Boolean,
  stream: Boolean,
  striped: Boolean,
  roundedBar: Boolean,
  ...ke(),
  ...ua({
    location: "top"
  }),
  ...It(),
  ...je(),
  ...Qe()
}, "VProgressLinear"), gh = J()({
  name: "VProgressLinear",
  props: TP(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), {
      isRtl: r,
      rtlClasses: s
    } = yn(), {
      themeClasses: a
    } = lt(e), {
      locationStyles: o
    } = po(e), {
      textColorClasses: l,
      textColorStyles: u
    } = Ln(e, "color"), {
      backgroundColorClasses: c,
      backgroundColorStyles: d
    } = gt(w(() => e.bgColor || e.color)), {
      backgroundColorClasses: f,
      backgroundColorStyles: h
    } = gt(w(() => e.bufferColor || e.bgColor || e.color)), {
      backgroundColorClasses: m,
      backgroundColorStyles: g
    } = gt(e, "color"), {
      roundedClasses: p
    } = Ht(e), {
      intersectionRef: y,
      isIntersecting: k
    } = vh(), T = w(() => parseFloat(e.max)), _ = w(() => parseFloat(e.height)), b = w(() => Xt(parseFloat(e.bufferValue) / T.value * 100, 0, 100)), S = w(() => Xt(parseFloat(i.value) / T.value * 100, 0, 100)), C = w(() => r.value !== e.reverse), x = w(() => e.indeterminate ? "fade-transition" : "slide-x-transition");
    function A(I) {
      if (!y.value)
        return;
      const {
        left: E,
        right: O,
        width: V
      } = y.value.getBoundingClientRect(), N = C.value ? V - I.clientX + (O - V) : I.clientX - E;
      i.value = Math.round(N / V * T.value);
    }
    return ie(() => v(e.tag, {
      ref: y,
      class: ["v-progress-linear", {
        "v-progress-linear--absolute": e.absolute,
        "v-progress-linear--active": e.active && k.value,
        "v-progress-linear--reverse": C.value,
        "v-progress-linear--rounded": e.rounded,
        "v-progress-linear--rounded-bar": e.roundedBar,
        "v-progress-linear--striped": e.striped
      }, p.value, a.value, s.value, e.class],
      style: [{
        bottom: e.location === "bottom" ? 0 : void 0,
        top: e.location === "top" ? 0 : void 0,
        height: e.active ? _e(_.value) : 0,
        "--v-progress-linear-height": _e(_.value),
        ...e.absolute ? o.value : {}
      }, e.style],
      role: "progressbar",
      "aria-hidden": e.active ? "false" : "true",
      "aria-valuemin": "0",
      "aria-valuemax": e.max,
      "aria-valuenow": e.indeterminate ? void 0 : S.value,
      onClick: e.clickable && A
    }, {
      default: () => [e.stream && v("div", {
        key: "stream",
        class: ["v-progress-linear__stream", l.value],
        style: {
          ...u.value,
          [C.value ? "left" : "right"]: _e(-_.value),
          borderTop: `${_e(_.value / 2)} dotted`,
          opacity: parseFloat(e.bufferOpacity),
          top: `calc(50% - ${_e(_.value / 4)})`,
          width: _e(100 - b.value, "%"),
          "--v-progress-linear-stream-to": _e(_.value * (C.value ? 1 : -1))
        }
      }, null), v("div", {
        class: ["v-progress-linear__background", c.value],
        style: [d.value, {
          opacity: parseFloat(e.bgOpacity),
          width: e.stream ? 0 : void 0
        }]
      }, null), v("div", {
        class: ["v-progress-linear__buffer", f.value],
        style: [h.value, {
          opacity: parseFloat(e.bufferOpacity),
          width: _e(b.value, "%")
        }]
      }, null), v(na, {
        name: x.value
      }, {
        default: () => [e.indeterminate ? v("div", {
          class: "v-progress-linear__indeterminate"
        }, [["long", "short"].map((I) => v("div", {
          key: I,
          class: ["v-progress-linear__indeterminate", I, m.value],
          style: g.value
        }, null))]) : v("div", {
          class: ["v-progress-linear__determinate", m.value],
          style: [g.value, {
            width: _e(S.value, "%")
          }]
        }, null)]
      }), n.default && v("div", {
        class: "v-progress-linear__content"
      }, [n.default({
        value: S.value,
        buffer: b.value
      })])]
    })), {};
  }
}), ph = B({
  loading: [Boolean, String]
}, "loader");
function Ic(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zr();
  return {
    loaderClasses: w(() => ({
      [`${t}--loading`]: e.loading
    }))
  };
}
function Ec(e, t) {
  var i;
  let {
    slots: n
  } = t;
  return v("div", {
    class: `${e.name}__loader`
  }, [((i = n.default) == null ? void 0 : i.call(n, {
    color: e.color,
    isActive: e.active
  })) || v(gh, {
    absolute: e.absolute,
    active: e.active,
    color: e.color,
    height: "2",
    indeterminate: !0
  }, null)]);
}
const xP = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"], Oc = B({
  appendInnerIcon: We,
  bgColor: String,
  clearable: Boolean,
  clearIcon: {
    type: We,
    default: "$clear"
  },
  active: Boolean,
  centerAffix: {
    type: Boolean,
    default: void 0
  },
  color: String,
  baseColor: String,
  dirty: Boolean,
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  flat: Boolean,
  label: String,
  persistentClear: Boolean,
  prependInnerIcon: We,
  reverse: Boolean,
  singleLine: Boolean,
  variant: {
    type: String,
    default: "filled",
    validator: (e) => xP.includes(e)
  },
  "onClick:clear": ri(),
  "onClick:appendInner": ri(),
  "onClick:prependInner": ri(),
  ...ke(),
  ...ph(),
  ...It(),
  ...Qe()
}, "VField"), Bl = J()({
  name: "VField",
  inheritAttrs: !1,
  props: {
    id: String,
    ...Ac(),
    ...Oc()
  },
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const {
      themeClasses: s
    } = lt(e), {
      loaderClasses: a
    } = Ic(e), {
      focusClasses: o,
      isFocused: l,
      focus: u,
      blur: c
    } = Cs(e), {
      InputIcon: d
    } = DS(e), {
      roundedClasses: f
    } = Ht(e), {
      rtlClasses: h
    } = yn(), m = w(() => e.dirty || e.active), g = w(() => !e.singleLine && !!(e.label || r.label)), p = An(), y = w(() => e.id || `input-${p}`), k = w(() => `${y.value}-messages`), T = X(), _ = X(), b = X(), S = w(() => ["plain", "underlined"].includes(e.variant)), {
      backgroundColorClasses: C,
      backgroundColorStyles: x
    } = gt(G(e, "bgColor")), {
      textColorClasses: A,
      textColorStyles: I
    } = Ln(w(() => e.error || e.disabled ? void 0 : m.value && l.value ? e.color : e.baseColor));
    fe(m, (N) => {
      if (g.value) {
        const F = T.value.$el, $ = _.value.$el;
        requestAnimationFrame(() => {
          const Z = sp(F), j = $.getBoundingClientRect(), H = j.x - Z.x, R = j.y - Z.y - (Z.height / 2 - j.height / 2), L = j.width / 0.75, ne = Math.abs(L - Z.width) > 1 ? {
            maxWidth: _e(L)
          } : void 0, oe = getComputedStyle(F), we = getComputedStyle($), ee = parseFloat(oe.transitionDuration) * 1e3 || 150, K = parseFloat(we.getPropertyValue("--v-field-label-scale")), ue = we.getPropertyValue("color");
          F.style.visibility = "visible", $.style.visibility = "hidden", Na(F, {
            transform: `translate(${H}px, ${R}px) scale(${K})`,
            color: ue,
            ...ne
          }, {
            duration: ee,
            easing: Hu,
            direction: N ? "normal" : "reverse"
          }).finished.then(() => {
            F.style.removeProperty("visibility"), $.style.removeProperty("visibility");
          });
        });
      }
    }, {
      flush: "post"
    });
    const E = w(() => ({
      isActive: m,
      isFocused: l,
      controlRef: b,
      blur: c,
      focus: u
    }));
    function O(N) {
      N.target !== document.activeElement && N.preventDefault();
    }
    function V(N) {
      var F;
      N.key !== "Enter" && N.key !== " " || (N.preventDefault(), N.stopPropagation(), (F = e["onClick:clear"]) == null || F.call(e, new MouseEvent("click")));
    }
    return ie(() => {
      var H, R, L;
      const N = e.variant === "outlined", F = !!(r["prepend-inner"] || e.prependInnerIcon), $ = !!(e.clearable || r.clear), Z = !!(r["append-inner"] || e.appendInnerIcon || $), j = () => r.label ? r.label({
        ...E.value,
        label: e.label,
        props: {
          for: y.value
        }
      }) : e.label;
      return v("div", se({
        class: ["v-field", {
          "v-field--active": m.value,
          "v-field--appended": Z,
          "v-field--center-affix": e.centerAffix ?? !S.value,
          "v-field--disabled": e.disabled,
          "v-field--dirty": e.dirty,
          "v-field--error": e.error,
          "v-field--flat": e.flat,
          "v-field--has-background": !!e.bgColor,
          "v-field--persistent-clear": e.persistentClear,
          "v-field--prepended": F,
          "v-field--reverse": e.reverse,
          "v-field--single-line": e.singleLine,
          "v-field--no-label": !j(),
          [`v-field--variant-${e.variant}`]: !0
        }, s.value, C.value, o.value, a.value, f.value, h.value, e.class],
        style: [x.value, e.style],
        onClick: O
      }, n), [v("div", {
        class: "v-field__overlay"
      }, null), v(Ec, {
        name: "v-field",
        active: !!e.loading,
        color: e.error ? "error" : typeof e.loading == "string" ? e.loading : e.color
      }, {
        default: r.loader
      }), F && v("div", {
        key: "prepend",
        class: "v-field__prepend-inner"
      }, [e.prependInnerIcon && v(d, {
        key: "prepend-icon",
        name: "prependInner"
      }, null), (H = r["prepend-inner"]) == null ? void 0 : H.call(r, E.value)]), v("div", {
        class: "v-field__field",
        "data-no-activator": ""
      }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(e.variant) && g.value && v(fu, {
        key: "floating-label",
        ref: _,
        class: [A.value],
        floating: !0,
        for: y.value,
        style: I.value
      }, {
        default: () => [j()]
      }), v(fu, {
        ref: T,
        for: y.value
      }, {
        default: () => [j()]
      }), (R = r.default) == null ? void 0 : R.call(r, {
        ...E.value,
        props: {
          id: y.value,
          class: "v-field__input",
          "aria-describedby": k.value
        },
        focus: u,
        blur: c
      })]), $ && v(mp, {
        key: "clear"
      }, {
        default: () => [Rt(v("div", {
          class: "v-field__clearable",
          onMousedown: (ne) => {
            ne.preventDefault(), ne.stopPropagation();
          }
        }, [v(Ze, {
          defaults: {
            VIcon: {
              icon: e.clearIcon
            }
          }
        }, {
          default: () => [r.clear ? r.clear({
            ...E.value,
            props: {
              onKeydown: V,
              onFocus: u,
              onBlur: c,
              onClick: e["onClick:clear"]
            }
          }) : v(d, {
            name: "clear",
            onKeydown: V,
            onFocus: u,
            onBlur: c
          }, null)]
        })]), [[Cr, e.dirty]])]
      }), Z && v("div", {
        key: "append",
        class: "v-field__append-inner"
      }, [(L = r["append-inner"]) == null ? void 0 : L.call(r, E.value), e.appendInnerIcon && v(d, {
        key: "append-icon",
        name: "appendInner"
      }, null)]), v("div", {
        class: ["v-field__outline", A.value],
        style: I.value
      }, [N && v(De, null, [v("div", {
        class: "v-field__outline__start"
      }, null), g.value && v("div", {
        class: "v-field__outline__notch"
      }, [v(fu, {
        ref: _,
        floating: !0,
        for: y.value
      }, {
        default: () => [j()]
      })]), v("div", {
        class: "v-field__outline__end"
      }, null)]), S.value && g.value && v(fu, {
        ref: _,
        floating: !0,
        for: y.value
      }, {
        default: () => [j()]
      })])]);
    }), {
      controlRef: b
    };
  }
});
function yp(e) {
  const t = Object.keys(Bl.props).filter((n) => !lh(n) && n !== "class" && n !== "style");
  return sS(e, t);
}
const AP = B({
  active: Boolean,
  color: String,
  messages: {
    type: [Array, String],
    default: () => []
  },
  ...ke(),
  ...Tr({
    transition: {
      component: hp,
      leaveAbsolute: !0,
      group: !0
    }
  })
}, "VMessages"), NS = J()({
  name: "VMessages",
  props: AP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = w(() => Nt(e.messages)), {
      textColorClasses: r,
      textColorStyles: s
    } = Ln(w(() => e.color));
    return ie(() => v(Gn, {
      transition: e.transition,
      tag: "div",
      class: ["v-messages", r.value, e.class],
      style: [s.value, e.style],
      role: "alert",
      "aria-live": "polite"
    }, {
      default: () => [e.active && i.value.map((a, o) => v("div", {
        class: "v-messages__message",
        key: `${o}-${i.value}`
      }, [n.message ? n.message({
        message: a
      }) : a]))]
    })), {};
  }
}), IP = [null, "default", "comfortable", "compact"], bn = B({
  density: {
    type: String,
    default: "default",
    validator: (e) => IP.includes(e)
  }
}, "density");
function Kn(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zr();
  return {
    densityClasses: w(() => `${t}--density-${e.density}`)
  };
}
const wn = B({
  height: [Number, String],
  maxHeight: [Number, String],
  maxWidth: [Number, String],
  minHeight: [Number, String],
  minWidth: [Number, String],
  width: [Number, String]
}, "dimension");
function _n(e) {
  return {
    dimensionStyles: w(() => {
      const n = {}, i = _e(e.height), r = _e(e.maxHeight), s = _e(e.maxWidth), a = _e(e.minHeight), o = _e(e.minWidth), l = _e(e.width);
      return i != null && (n.height = i), r != null && (n.maxHeight = r), s != null && (n.maxWidth = s), a != null && (n.minHeight = a), o != null && (n.minWidth = o), l != null && (n.width = l), n;
    })
  };
}
const MS = Symbol.for("vuetify:form"), EP = B({
  disabled: Boolean,
  fastFail: Boolean,
  readonly: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  validateOn: {
    type: String,
    default: "input"
  }
}, "form");
function OP(e) {
  const t = Ee(e, "modelValue"), n = w(() => e.disabled), i = w(() => e.readonly), r = pe(!1), s = X([]), a = X([]);
  async function o() {
    const c = [];
    let d = !0;
    a.value = [], r.value = !0;
    for (const f of s.value) {
      const h = await f.validate();
      if (h.length > 0 && (d = !1, c.push({
        id: f.id,
        errorMessages: h
      })), !d && e.fastFail)
        break;
    }
    return a.value = c, r.value = !1, {
      valid: d,
      errors: a.value
    };
  }
  function l() {
    s.value.forEach((c) => c.reset());
  }
  function u() {
    s.value.forEach((c) => c.resetValidation());
  }
  return fe(s, () => {
    let c = 0, d = 0;
    const f = [];
    for (const h of s.value)
      h.isValid === !1 ? (d++, f.push({
        id: h.id,
        errorMessages: h.errorMessages
      })) : h.isValid === !0 && c++;
    a.value = f, t.value = d > 0 ? !1 : c === s.value.length ? !0 : null;
  }, {
    deep: !0,
    flush: "post"
  }), Tt(MS, {
    register: (c) => {
      let {
        id: d,
        vm: f,
        validate: h,
        reset: m,
        resetValidation: g
      } = c;
      s.value.some((p) => p.id === d) && gr(`Duplicate input name "${d}"`), s.value.push({
        id: d,
        validate: h,
        reset: m,
        resetValidation: g,
        vm: WE(f),
        isValid: null,
        errorMessages: []
      });
    },
    unregister: (c) => {
      s.value = s.value.filter((d) => d.id !== c);
    },
    update: (c, d, f) => {
      const h = s.value.find((m) => m.id === c);
      h && (h.isValid = d, h.errorMessages = f);
    },
    isDisabled: n,
    isReadonly: i,
    isValidating: r,
    isValid: t,
    items: s,
    validateOn: G(e, "validateOn")
  }), {
    errors: a,
    isDisabled: n,
    isReadonly: i,
    isValidating: r,
    isValid: t,
    items: s,
    validate: o,
    reset: l,
    resetValidation: u
  };
}
function yh() {
  return tt(MS, null);
}
const RS = B({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  errorMessages: {
    type: [Array, String],
    default: () => []
  },
  maxErrors: {
    type: [Number, String],
    default: 1
  },
  name: String,
  label: String,
  readonly: {
    type: Boolean,
    default: null
  },
  rules: {
    type: Array,
    default: () => []
  },
  modelValue: null,
  validateOn: String,
  validationValue: null,
  ...Ac()
}, "validation");
function FS(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zr(), n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : An();
  const i = Ee(e, "modelValue"), r = w(() => e.validationValue === void 0 ? i.value : e.validationValue), s = yh(), a = X([]), o = pe(!0), l = w(() => !!(Nt(i.value === "" ? null : i.value).length || Nt(r.value === "" ? null : r.value).length)), u = w(() => !!(e.disabled ?? (s == null ? void 0 : s.isDisabled.value))), c = w(() => !!(e.readonly ?? (s == null ? void 0 : s.isReadonly.value))), d = w(() => {
    var b;
    return (b = e.errorMessages) != null && b.length ? Nt(e.errorMessages).concat(a.value).slice(0, Math.max(0, +e.maxErrors)) : a.value;
  }), f = w(() => {
    let b = (e.validateOn ?? (s == null ? void 0 : s.validateOn.value)) || "input";
    b === "lazy" && (b = "input lazy");
    const S = new Set((b == null ? void 0 : b.split(" ")) ?? []);
    return {
      blur: S.has("blur") || S.has("input"),
      input: S.has("input"),
      submit: S.has("submit"),
      lazy: S.has("lazy")
    };
  }), h = w(() => {
    var b;
    return e.error || (b = e.errorMessages) != null && b.length ? !1 : e.rules.length ? o.value ? a.value.length || f.value.lazy ? null : !0 : !a.value.length : !0;
  }), m = pe(!1), g = w(() => ({
    [`${t}--error`]: h.value === !1,
    [`${t}--dirty`]: l.value,
    [`${t}--disabled`]: u.value,
    [`${t}--readonly`]: c.value
  })), p = Ut("validation"), y = w(() => e.name ?? Ct(n));
  J_(() => {
    s == null || s.register({
      id: y.value,
      vm: p,
      validate: _,
      reset: k,
      resetValidation: T
    });
  }), ai(() => {
    s == null || s.unregister(y.value);
  }), jn(async () => {
    f.value.lazy || await _(!0), s == null || s.update(y.value, h.value, d.value);
  }), vi(() => f.value.input, () => {
    fe(r, () => {
      if (r.value != null)
        _();
      else if (e.focused) {
        const b = fe(() => e.focused, (S) => {
          S || _(), b();
        });
      }
    });
  }), vi(() => f.value.blur, () => {
    fe(() => e.focused, (b) => {
      b || _();
    });
  }), fe([h, d], () => {
    s == null || s.update(y.value, h.value, d.value);
  });
  async function k() {
    i.value = null, await He(), await T();
  }
  async function T() {
    o.value = !0, f.value.lazy ? a.value = [] : await _(!0);
  }
  async function _() {
    let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const S = [];
    m.value = !0;
    for (const C of e.rules) {
      if (S.length >= +(e.maxErrors ?? 1))
        break;
      const A = await (typeof C == "function" ? C : () => C)(r.value);
      if (A !== !0) {
        if (A !== !1 && typeof A != "string") {
          console.warn(`${A} is not a valid value. Rule functions must return boolean true or a string.`);
          continue;
        }
        S.push(A || "");
      }
    }
    return a.value = S, m.value = !1, o.value = b, a.value;
  }
  return {
    errorMessages: d,
    isDirty: l,
    isDisabled: u,
    isReadonly: c,
    isPristine: o,
    isValid: h,
    isValidating: m,
    reset: k,
    resetValidation: T,
    validate: _,
    validationClasses: g
  };
}
const Ts = B({
  id: String,
  appendIcon: We,
  centerAffix: {
    type: Boolean,
    default: !0
  },
  prependIcon: We,
  hideDetails: [Boolean, String],
  hideSpinButtons: Boolean,
  hint: String,
  persistentHint: Boolean,
  messages: {
    type: [Array, String],
    default: () => []
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (e) => ["horizontal", "vertical"].includes(e)
  },
  "onClick:prepend": ri(),
  "onClick:append": ri(),
  ...ke(),
  ...bn(),
  ...oh(wn(), ["maxWidth", "minWidth", "width"]),
  ...Qe(),
  ...RS()
}, "VInput"), $n = J()({
  name: "VInput",
  props: {
    ...Ts()
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i,
      emit: r
    } = t;
    const {
      densityClasses: s
    } = Kn(e), {
      dimensionStyles: a
    } = _n(e), {
      themeClasses: o
    } = lt(e), {
      rtlClasses: l
    } = yn(), {
      InputIcon: u
    } = DS(e), c = An(), d = w(() => e.id || `input-${c}`), f = w(() => `${d.value}-messages`), {
      errorMessages: h,
      isDirty: m,
      isDisabled: g,
      isReadonly: p,
      isPristine: y,
      isValid: k,
      isValidating: T,
      reset: _,
      resetValidation: b,
      validate: S,
      validationClasses: C
    } = FS(e, "v-input", d), x = w(() => ({
      id: d,
      messagesId: f,
      isDirty: m,
      isDisabled: g,
      isReadonly: p,
      isPristine: y,
      isValid: k,
      isValidating: T,
      reset: _,
      resetValidation: b,
      validate: S
    })), A = w(() => {
      var I;
      return (I = e.errorMessages) != null && I.length || !y.value && h.value.length ? h.value : e.hint && (e.persistentHint || e.focused) ? e.hint : e.messages;
    });
    return ie(() => {
      var N, F, $, Z;
      const I = !!(i.prepend || e.prependIcon), E = !!(i.append || e.appendIcon), O = A.value.length > 0, V = !e.hideDetails || e.hideDetails === "auto" && (O || !!i.details);
      return v("div", {
        class: ["v-input", `v-input--${e.direction}`, {
          "v-input--center-affix": e.centerAffix,
          "v-input--hide-spin-buttons": e.hideSpinButtons
        }, s.value, o.value, l.value, C.value, e.class],
        style: [a.value, e.style]
      }, [I && v("div", {
        key: "prepend",
        class: "v-input__prepend"
      }, [(N = i.prepend) == null ? void 0 : N.call(i, x.value), e.prependIcon && v(u, {
        key: "prepend-icon",
        name: "prepend"
      }, null)]), i.default && v("div", {
        class: "v-input__control"
      }, [(F = i.default) == null ? void 0 : F.call(i, x.value)]), E && v("div", {
        key: "append",
        class: "v-input__append"
      }, [e.appendIcon && v(u, {
        key: "append-icon",
        name: "append"
      }, null), ($ = i.append) == null ? void 0 : $.call(i, x.value)]), V && v("div", {
        class: "v-input__details"
      }, [v(NS, {
        id: f.value,
        active: O,
        messages: A.value
      }, {
        message: i.message
      }), (Z = i.details) == null ? void 0 : Z.call(i, x.value)])]);
    }), {
      reset: _,
      resetValidation: b,
      validate: S,
      isValid: k,
      errorMessages: h
    };
  }
}), Hm = Symbol("Forwarded refs");
function zm(e, t) {
  let n = e;
  for (; n; ) {
    const i = Reflect.getOwnPropertyDescriptor(n, t);
    if (i)
      return i;
    n = Object.getPrototypeOf(n);
  }
}
function Qi(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return e[Hm] = n, new Proxy(e, {
    get(r, s) {
      if (Reflect.has(r, s))
        return Reflect.get(r, s);
      if (!(typeof s == "symbol" || s.startsWith("$") || s.startsWith("__"))) {
        for (const a of n)
          if (a.value && Reflect.has(a.value, s)) {
            const o = Reflect.get(a.value, s);
            return typeof o == "function" ? o.bind(a.value) : o;
          }
      }
    },
    has(r, s) {
      if (Reflect.has(r, s))
        return !0;
      if (typeof s == "symbol" || s.startsWith("$") || s.startsWith("__"))
        return !1;
      for (const a of n)
        if (a.value && Reflect.has(a.value, s))
          return !0;
      return !1;
    },
    set(r, s, a) {
      if (Reflect.has(r, s))
        return Reflect.set(r, s, a);
      if (typeof s == "symbol" || s.startsWith("$") || s.startsWith("__"))
        return !1;
      for (const o of n)
        if (o.value && Reflect.has(o.value, s))
          return Reflect.set(o.value, s, a);
      return !1;
    },
    getOwnPropertyDescriptor(r, s) {
      var o;
      const a = Reflect.getOwnPropertyDescriptor(r, s);
      if (a)
        return a;
      if (!(typeof s == "symbol" || s.startsWith("$") || s.startsWith("__"))) {
        for (const l of n) {
          if (!l.value)
            continue;
          const u = zm(l.value, s) ?? ("_" in l.value ? zm((o = l.value._) == null ? void 0 : o.setupState, s) : void 0);
          if (u)
            return u;
        }
        for (const l of n) {
          const u = l.value && l.value[Hm];
          if (!u)
            continue;
          const c = u.slice();
          for (; c.length; ) {
            const d = c.shift(), f = zm(d.value, s);
            if (f)
              return f;
            const h = d.value && d.value[Hm];
            h && c.push(...h);
          }
        }
      }
    }
  });
}
function PP(e, t) {
  if (!tp)
    return;
  const n = t.modifiers || {}, i = t.value, {
    handler: r,
    options: s
  } = typeof i == "object" ? i : {
    handler: i,
    options: {}
  }, a = new IntersectionObserver(function() {
    var d;
    let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], l = arguments.length > 1 ? arguments[1] : void 0;
    const u = (d = e._observe) == null ? void 0 : d[t.instance.$.uid];
    if (!u)
      return;
    const c = o.some((f) => f.isIntersecting);
    r && (!n.quiet || u.init) && (!n.once || c || u.init) && r(c, o, l), c && n.once ? BS(e, t) : u.init = !0;
  }, s);
  e._observe = Object(e._observe), e._observe[t.instance.$.uid] = {
    init: !1,
    observer: a
  }, a.observe(e);
}
function BS(e, t) {
  var i;
  const n = (i = e._observe) == null ? void 0 : i[t.instance.$.uid];
  n && (n.observer.unobserve(e), delete e._observe[t.instance.$.uid]);
}
const Pc = {
  mounted: PP,
  unmounted: BS
}, VP = ["color", "file", "time", "date", "datetime-local", "week", "month"], bh = B({
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: [Number, Function],
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  suffix: String,
  role: String,
  type: {
    type: String,
    default: "text"
  },
  modelModifiers: Object,
  ...Ts(),
  ...Oc()
}, "VTextField"), gi = J()({
  name: "VTextField",
  directives: {
    Intersect: Pc
  },
  inheritAttrs: !1,
  props: bh(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const s = Ee(e, "modelValue"), {
      isFocused: a,
      focus: o,
      blur: l
    } = Cs(e), u = w(() => typeof e.counterValue == "function" ? e.counterValue(s.value) : typeof e.counterValue == "number" ? e.counterValue : (s.value ?? "").toString().length), c = w(() => {
      if (n.maxlength)
        return n.maxlength;
      if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string"))
        return e.counter;
    }), d = w(() => ["plain", "underlined"].includes(e.variant));
    function f(S, C) {
      var x, A;
      !e.autofocus || !S || (A = (x = C[0].target) == null ? void 0 : x.focus) == null || A.call(x);
    }
    const h = X(), m = X(), g = X(), p = w(() => VP.includes(e.type) || e.persistentPlaceholder || a.value || e.active);
    function y() {
      var S;
      g.value !== document.activeElement && ((S = g.value) == null || S.focus()), a.value || o();
    }
    function k(S) {
      i("mousedown:control", S), S.target !== g.value && (y(), S.preventDefault());
    }
    function T(S) {
      y(), i("click:control", S);
    }
    function _(S) {
      S.stopPropagation(), y(), He(() => {
        s.value = null, rp(e["onClick:clear"], S);
      });
    }
    function b(S) {
      var x;
      const C = S.target;
      if (s.value = C.value, (x = e.modelModifiers) != null && x.trim && ["text", "search", "password", "tel", "url"].includes(e.type)) {
        const A = [C.selectionStart, C.selectionEnd];
        He(() => {
          C.selectionStart = A[0], C.selectionEnd = A[1];
        });
      }
    }
    return ie(() => {
      const S = !!(r.counter || e.counter !== !1 && e.counter != null), C = !!(S || r.details), [x, A] = la(n), {
        modelValue: I,
        ...E
      } = $n.filterProps(e), O = yp(e);
      return v($n, se({
        ref: h,
        modelValue: s.value,
        "onUpdate:modelValue": (V) => s.value = V,
        class: ["v-text-field", {
          "v-text-field--prefixed": e.prefix,
          "v-text-field--suffixed": e.suffix,
          "v-input--plain-underlined": d.value
        }, e.class],
        style: e.style
      }, x, E, {
        centerAffix: !d.value,
        focused: a.value
      }), {
        ...r,
        default: (V) => {
          let {
            id: N,
            isDisabled: F,
            isDirty: $,
            isReadonly: Z,
            isValid: j
          } = V;
          return v(Bl, se({
            ref: m,
            onMousedown: k,
            onClick: T,
            "onClick:clear": _,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"],
            role: e.role
          }, O, {
            id: N.value,
            active: p.value || $.value,
            dirty: $.value || e.dirty,
            disabled: F.value,
            focused: a.value,
            error: j.value === !1
          }), {
            ...r,
            default: (H) => {
              let {
                props: {
                  class: R,
                  ...L
                }
              } = H;
              const ne = Rt(v("input", se({
                ref: g,
                value: s.value,
                onInput: b,
                autofocus: e.autofocus,
                readonly: Z.value,
                disabled: F.value,
                name: e.name,
                placeholder: e.placeholder,
                size: 1,
                type: e.type,
                onFocus: y,
                onBlur: l
              }, L, A), null), [[Ei("intersect"), {
                handler: f
              }, null, {
                once: !0
              }]]);
              return v(De, null, [e.prefix && v("span", {
                class: "v-text-field__prefix"
              }, [v("span", {
                class: "v-text-field__prefix__text"
              }, [e.prefix])]), r.default ? v("div", {
                class: R,
                "data-no-activator": ""
              }, [r.default(), ne]) : jE(ne, {
                class: R
              }), e.suffix && v("span", {
                class: "v-text-field__suffix"
              }, [v("span", {
                class: "v-text-field__suffix__text"
              }, [e.suffix])])]);
            }
          });
        },
        details: C ? (V) => {
          var N;
          return v(De, null, [(N = r.details) == null ? void 0 : N.call(r, V), S && v(De, null, [v("span", null, null), v(hh, {
            active: e.persistentCounter || a.value,
            value: u.value,
            max: c.value,
            disabled: e.disabled
          }, r.counter)])]);
        } : void 0
      });
    }), Qi({}, h, m, g);
  }
}), qu = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AG: 0,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AS: 0,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BD: 0,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BR: 0,
  BS: 0,
  BT: 0,
  BW: 0,
  BY: 1,
  BZ: 0,
  CA: 0,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CO: 0,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DM: 0,
  DO: 0,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  ET: 0,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  "GB-alt-variant": 0,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  GT: 0,
  GU: 0,
  HK: 0,
  HN: 0,
  HR: 1,
  HU: 1,
  ID: 0,
  IE: 1,
  IL: 0,
  IN: 0,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JM: 0,
  JO: 6,
  JP: 0,
  KE: 0,
  KG: 1,
  KH: 0,
  KR: 0,
  KW: 6,
  KZ: 1,
  LA: 0,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MH: 0,
  MK: 1,
  MM: 0,
  MN: 1,
  MO: 0,
  MQ: 1,
  MT: 0,
  MV: 5,
  MX: 0,
  MY: 1,
  MZ: 0,
  NI: 0,
  NL: 1,
  NO: 1,
  NP: 0,
  NZ: 1,
  OM: 6,
  PA: 0,
  PE: 0,
  PH: 0,
  PK: 0,
  PL: 1,
  PR: 0,
  PT: 0,
  PY: 0,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SA: 0,
  SD: 6,
  SE: 1,
  SG: 0,
  SI: 1,
  SK: 1,
  SM: 1,
  SV: 0,
  SY: 6,
  TH: 0,
  TJ: 1,
  TM: 1,
  TR: 1,
  TT: 0,
  TW: 0,
  UA: 1,
  UM: 0,
  US: 0,
  UY: 1,
  UZ: 1,
  VA: 1,
  VE: 0,
  VI: 0,
  VN: 1,
  WS: 0,
  XK: 1,
  YE: 0,
  ZA: 0,
  ZW: 0
};
function DP(e, t) {
  const n = [];
  let i = [];
  const r = LS(e), s = $S(e), a = (r.getDay() - qu[t.slice(-2).toUpperCase()] + 7) % 7, o = (s.getDay() - qu[t.slice(-2).toUpperCase()] + 7) % 7;
  for (let l = 0; l < a; l++) {
    const u = new Date(r);
    u.setDate(u.getDate() - (a - l)), i.push(u);
  }
  for (let l = 1; l <= s.getDate(); l++) {
    const u = new Date(e.getFullYear(), e.getMonth(), l);
    i.push(u), i.length === 7 && (n.push(i), i = []);
  }
  for (let l = 1; l < 7 - o; l++) {
    const u = new Date(s);
    u.setDate(u.getDate() + l), i.push(u);
  }
  return i.length > 0 && n.push(i), n;
}
function NP(e, t) {
  const n = new Date(e);
  for (; n.getDay() !== (qu[t.slice(-2).toUpperCase()] ?? 0); )
    n.setDate(n.getDate() - 1);
  return n;
}
function MP(e, t) {
  const n = new Date(e), i = ((qu[t.slice(-2).toUpperCase()] ?? 0) + 6) % 7;
  for (; n.getDay() !== i; )
    n.setDate(n.getDate() + 1);
  return n;
}
function LS(e) {
  return new Date(e.getFullYear(), e.getMonth(), 1);
}
function $S(e) {
  return new Date(e.getFullYear(), e.getMonth() + 1, 0);
}
function RP(e) {
  const t = e.split("-").map(Number);
  return new Date(t[0], t[1] - 1, t[2]);
}
const FP = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/;
function WS(e) {
  if (e == null)
    return /* @__PURE__ */ new Date();
  if (e instanceof Date)
    return e;
  if (typeof e == "string") {
    let t;
    if (FP.test(e))
      return RP(e);
    if (t = Date.parse(e), !isNaN(t))
      return new Date(t);
  }
  return null;
}
const gw = new Date(2e3, 0, 2);
function BP(e) {
  const t = qu[e.slice(-2).toUpperCase()];
  return jr(7).map((n) => {
    const i = new Date(gw);
    return i.setDate(gw.getDate() + t + n), new Intl.DateTimeFormat(e, {
      weekday: "narrow"
    }).format(i);
  });
}
function LP(e, t, n, i) {
  const r = WS(e) ?? /* @__PURE__ */ new Date(), s = i == null ? void 0 : i[t];
  if (typeof s == "function")
    return s(r, t, n);
  let a = {};
  switch (t) {
    case "fullDate":
      a = {
        year: "numeric",
        month: "long",
        day: "numeric"
      };
      break;
    case "fullDateWithWeekday":
      a = {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      };
      break;
    case "normalDate":
      const o = r.getDate(), l = new Intl.DateTimeFormat(n, {
        month: "long"
      }).format(r);
      return `${o} ${l}`;
    case "normalDateWithWeekday":
      a = {
        weekday: "short",
        day: "numeric",
        month: "short"
      };
      break;
    case "shortDate":
      a = {
        month: "short",
        day: "numeric"
      };
      break;
    case "year":
      a = {
        year: "numeric"
      };
      break;
    case "month":
      a = {
        month: "long"
      };
      break;
    case "monthShort":
      a = {
        month: "short"
      };
      break;
    case "monthAndYear":
      a = {
        month: "long",
        year: "numeric"
      };
      break;
    case "monthAndDate":
      a = {
        month: "long",
        day: "numeric"
      };
      break;
    case "weekday":
      a = {
        weekday: "long"
      };
      break;
    case "weekdayShort":
      a = {
        weekday: "short"
      };
      break;
    case "dayOfMonth":
      return new Intl.NumberFormat(n).format(r.getDate());
    case "hours12h":
      a = {
        hour: "numeric",
        hour12: !0
      };
      break;
    case "hours24h":
      a = {
        hour: "numeric",
        hour12: !1
      };
      break;
    case "minutes":
      a = {
        minute: "numeric"
      };
      break;
    case "seconds":
      a = {
        second: "numeric"
      };
      break;
    case "fullTime":
      a = {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullTime12h":
      a = {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullTime24h":
      a = {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    case "fullDateTime":
      a = {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullDateTime12h":
      a = {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullDateTime24h":
      a = {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    case "keyboardDate":
      a = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit"
      };
      break;
    case "keyboardDateTime":
      a = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    case "keyboardDateTime12h":
      a = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "keyboardDateTime24h":
      a = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    default:
      a = s ?? {
        timeZone: "UTC",
        timeZoneName: "short"
      };
  }
  return new Intl.DateTimeFormat(n, a).format(r);
}
function $P(e, t) {
  const n = e.toJsDate(t), i = n.getFullYear(), r = Ub(String(n.getMonth() + 1), 2, "0"), s = Ub(String(n.getDate()), 2, "0");
  return `${i}-${r}-${s}`;
}
function WP(e) {
  const [t, n, i] = e.split("-").map(Number);
  return new Date(t, n - 1, i);
}
function jP(e, t) {
  const n = new Date(e);
  return n.setMinutes(n.getMinutes() + t), n;
}
function HP(e, t) {
  const n = new Date(e);
  return n.setHours(n.getHours() + t), n;
}
function zP(e, t) {
  const n = new Date(e);
  return n.setDate(n.getDate() + t), n;
}
function UP(e, t) {
  const n = new Date(e);
  return n.setDate(n.getDate() + t * 7), n;
}
function qP(e, t) {
  const n = new Date(e);
  return n.setDate(1), n.setMonth(n.getMonth() + t), n;
}
function GP(e) {
  return e.getFullYear();
}
function YP(e) {
  return e.getMonth();
}
function ZP(e) {
  return e.getDate();
}
function KP(e) {
  return new Date(e.getFullYear(), e.getMonth() + 1, 1);
}
function XP(e) {
  return new Date(e.getFullYear(), e.getMonth() - 1, 1);
}
function JP(e) {
  return e.getHours();
}
function QP(e) {
  return e.getMinutes();
}
function eV(e) {
  return new Date(e.getFullYear(), 0, 1);
}
function tV(e) {
  return new Date(e.getFullYear(), 11, 31);
}
function nV(e, t) {
  return hf(e, t[0]) && sV(e, t[1]);
}
function iV(e) {
  const t = new Date(e);
  return t instanceof Date && !isNaN(t.getTime());
}
function hf(e, t) {
  return e.getTime() > t.getTime();
}
function rV(e, t) {
  return hf(Dv(e), Dv(t));
}
function sV(e, t) {
  return e.getTime() < t.getTime();
}
function pw(e, t) {
  return e.getTime() === t.getTime();
}
function aV(e, t) {
  return e.getDate() === t.getDate() && e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear();
}
function oV(e, t) {
  return e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear();
}
function lV(e, t) {
  return e.getFullYear() === t.getFullYear();
}
function uV(e, t, n) {
  const i = new Date(e), r = new Date(t);
  switch (n) {
    case "years":
      return i.getFullYear() - r.getFullYear();
    case "quarters":
      return Math.floor((i.getMonth() - r.getMonth() + (i.getFullYear() - r.getFullYear()) * 12) / 4);
    case "months":
      return i.getMonth() - r.getMonth() + (i.getFullYear() - r.getFullYear()) * 12;
    case "weeks":
      return Math.floor((i.getTime() - r.getTime()) / (1e3 * 60 * 60 * 24 * 7));
    case "days":
      return Math.floor((i.getTime() - r.getTime()) / (1e3 * 60 * 60 * 24));
    case "hours":
      return Math.floor((i.getTime() - r.getTime()) / (1e3 * 60 * 60));
    case "minutes":
      return Math.floor((i.getTime() - r.getTime()) / (1e3 * 60));
    case "seconds":
      return Math.floor((i.getTime() - r.getTime()) / 1e3);
    default:
      return i.getTime() - r.getTime();
  }
}
function cV(e, t) {
  const n = new Date(e);
  return n.setHours(t), n;
}
function dV(e, t) {
  const n = new Date(e);
  return n.setMinutes(t), n;
}
function fV(e, t) {
  const n = new Date(e);
  return n.setMonth(t), n;
}
function hV(e, t) {
  const n = new Date(e);
  return n.setDate(t), n;
}
function mV(e, t) {
  const n = new Date(e);
  return n.setFullYear(t), n;
}
function Dv(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 0, 0, 0, 0);
}
function vV(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 23, 59, 59, 999);
}
class gV {
  constructor(t) {
    this.locale = t.locale, this.formats = t.formats;
  }
  date(t) {
    return WS(t);
  }
  toJsDate(t) {
    return t;
  }
  toISO(t) {
    return $P(this, t);
  }
  parseISO(t) {
    return WP(t);
  }
  addMinutes(t, n) {
    return jP(t, n);
  }
  addHours(t, n) {
    return HP(t, n);
  }
  addDays(t, n) {
    return zP(t, n);
  }
  addWeeks(t, n) {
    return UP(t, n);
  }
  addMonths(t, n) {
    return qP(t, n);
  }
  getWeekArray(t) {
    return DP(t, this.locale);
  }
  startOfWeek(t) {
    return NP(t, this.locale);
  }
  endOfWeek(t) {
    return MP(t, this.locale);
  }
  startOfMonth(t) {
    return LS(t);
  }
  endOfMonth(t) {
    return $S(t);
  }
  format(t, n) {
    return LP(t, n, this.locale, this.formats);
  }
  isEqual(t, n) {
    return pw(t, n);
  }
  isValid(t) {
    return iV(t);
  }
  isWithinRange(t, n) {
    return nV(t, n);
  }
  isAfter(t, n) {
    return hf(t, n);
  }
  isAfterDay(t, n) {
    return rV(t, n);
  }
  isBefore(t, n) {
    return !hf(t, n) && !pw(t, n);
  }
  isSameDay(t, n) {
    return aV(t, n);
  }
  isSameMonth(t, n) {
    return oV(t, n);
  }
  isSameYear(t, n) {
    return lV(t, n);
  }
  setMinutes(t, n) {
    return dV(t, n);
  }
  setHours(t, n) {
    return cV(t, n);
  }
  setMonth(t, n) {
    return fV(t, n);
  }
  setDate(t, n) {
    return hV(t, n);
  }
  setYear(t, n) {
    return mV(t, n);
  }
  getDiff(t, n, i) {
    return uV(t, n, i);
  }
  getWeekdays() {
    return BP(this.locale);
  }
  getYear(t) {
    return GP(t);
  }
  getMonth(t) {
    return YP(t);
  }
  getDate(t) {
    return ZP(t);
  }
  getNextMonth(t) {
    return KP(t);
  }
  getPreviousMonth(t) {
    return XP(t);
  }
  getHours(t) {
    return JP(t);
  }
  getMinutes(t) {
    return QP(t);
  }
  startOfDay(t) {
    return Dv(t);
  }
  endOfDay(t) {
    return vV(t);
  }
  startOfYear(t) {
    return eV(t);
  }
  endOfYear(t) {
    return tV(t);
  }
}
const jS = Symbol.for("vuetify:date-options"), yw = Symbol.for("vuetify:date-adapter");
function pV(e, t) {
  const n = qn({
    adapter: gV,
    locale: {
      af: "af-ZA",
      // ar: '', # not the same value for all variants
      bg: "bg-BG",
      ca: "ca-ES",
      ckb: "",
      cs: "cs-CZ",
      de: "de-DE",
      el: "el-GR",
      en: "en-US",
      // es: '', # not the same value for all variants
      et: "et-EE",
      fa: "fa-IR",
      fi: "fi-FI",
      // fr: '', #not the same value for all variants
      hr: "hr-HR",
      hu: "hu-HU",
      he: "he-IL",
      id: "id-ID",
      it: "it-IT",
      ja: "ja-JP",
      ko: "ko-KR",
      lv: "lv-LV",
      lt: "lt-LT",
      nl: "nl-NL",
      no: "no-NO",
      pl: "pl-PL",
      pt: "pt-PT",
      ro: "ro-RO",
      ru: "ru-RU",
      sk: "sk-SK",
      sl: "sl-SI",
      srCyrl: "sr-SP",
      srLatn: "sr-SP",
      sv: "sv-SE",
      th: "th-TH",
      tr: "tr-TR",
      az: "az-AZ",
      uk: "uk-UA",
      vi: "vi-VN",
      zhHans: "zh-CN",
      zhHant: "zh-TW"
    }
  }, e);
  return {
    options: n,
    instance: HS(n, t)
  };
}
function HS(e, t) {
  const n = ti(typeof e.adapter == "function" ? new e.adapter({
    locale: e.locale[t.current.value] ?? t.current.value,
    formats: e.formats
  }) : e.adapter);
  return fe(t.current, (i) => {
    n.locale = e.locale[i] ?? i ?? n.locale;
  }), n;
}
function Vc() {
  const e = tt(jS);
  if (!e)
    throw new Error("[Vuetify] Could not find injected date options");
  const t = qt();
  return HS(e, t);
}
function yV(e, t) {
  const n = e.toJsDate(t);
  let i = n.getFullYear(), r = new Date(i, 0, 1);
  if (n < r)
    i = i - 1, r = new Date(i, 0, 1);
  else {
    const o = new Date(i + 1, 0, 1);
    n >= o && (i = i + 1, r = o);
  }
  const s = Math.abs(n.getTime() - r.getTime()), a = Math.ceil(s / (1e3 * 60 * 60 * 24));
  return Math.floor(a / 7) + 1;
}
const wh = ["sm", "md", "lg", "xl", "xxl"], Nv = Symbol.for("vuetify:display"), bw = {
  mobileBreakpoint: "lg",
  thresholds: {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920,
    xxl: 2560
  }
}, bV = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : bw;
  return qn(bw, e);
};
function ww(e) {
  return ft && !e ? window.innerWidth : typeof e == "object" && e.clientWidth || 0;
}
function _w(e) {
  return ft && !e ? window.innerHeight : typeof e == "object" && e.clientHeight || 0;
}
function Sw(e) {
  const t = ft && !e ? window.navigator.userAgent : "ssr";
  function n(m) {
    return !!t.match(m);
  }
  const i = n(/android/i), r = n(/iphone|ipad|ipod/i), s = n(/cordova/i), a = n(/electron/i), o = n(/chrome/i), l = n(/edge/i), u = n(/firefox/i), c = n(/opera/i), d = n(/win/i), f = n(/mac/i), h = n(/linux/i);
  return {
    android: i,
    ios: r,
    cordova: s,
    electron: a,
    chrome: o,
    edge: l,
    firefox: u,
    opera: c,
    win: d,
    mac: f,
    linux: h,
    touch: nO,
    ssr: t === "ssr"
  };
}
function wV(e, t) {
  const {
    thresholds: n,
    mobileBreakpoint: i
  } = bV(e), r = pe(_w(t)), s = pe(Sw(t)), a = ti({}), o = pe(ww(t));
  function l() {
    r.value = _w(), o.value = ww();
  }
  function u() {
    l(), s.value = Sw();
  }
  return Wt(() => {
    const c = o.value < n.sm, d = o.value < n.md && !c, f = o.value < n.lg && !(d || c), h = o.value < n.xl && !(f || d || c), m = o.value < n.xxl && !(h || f || d || c), g = o.value >= n.xxl, p = c ? "xs" : d ? "sm" : f ? "md" : h ? "lg" : m ? "xl" : "xxl", y = typeof i == "number" ? i : n[i], k = o.value < y;
    a.xs = c, a.sm = d, a.md = f, a.lg = h, a.xl = m, a.xxl = g, a.smAndUp = !c, a.mdAndUp = !(c || d), a.lgAndUp = !(c || d || f), a.xlAndUp = !(c || d || f || h), a.smAndDown = !(f || h || m || g), a.mdAndDown = !(h || m || g), a.lgAndDown = !(m || g), a.xlAndDown = !g, a.name = p, a.height = r.value, a.width = o.value, a.mobile = k, a.mobileBreakpoint = i, a.platform = s.value, a.thresholds = n;
  }), ft && window.addEventListener("resize", l, {
    passive: !0
  }), {
    ...sh(a),
    update: u,
    ssr: !!t
  };
}
const Ll = B({
  mobile: {
    type: Boolean,
    default: !1
  },
  mobileBreakpoint: [Number, String]
}, "display");
function xr() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zr();
  const n = tt(Nv);
  if (!n)
    throw new Error("Could not find Vuetify display injection");
  const i = w(() => {
    if (e.mobile != null)
      return e.mobile;
    if (!e.mobileBreakpoint)
      return n.mobile.value;
    const s = typeof e.mobileBreakpoint == "number" ? e.mobileBreakpoint : n.thresholds.value[e.mobileBreakpoint];
    return n.width.value < s;
  }), r = w(() => t ? {
    [`${t}--mobile`]: i.value
  } : {});
  return {
    ...n,
    displayClasses: r,
    mobile: i
  };
}
const zS = Symbol.for("vuetify:goto");
function US() {
  return {
    container: void 0,
    duration: 300,
    layout: !1,
    offset: 0,
    easing: "easeInOutCubic",
    patterns: {
      linear: (e) => e,
      easeInQuad: (e) => e ** 2,
      easeOutQuad: (e) => e * (2 - e),
      easeInOutQuad: (e) => e < 0.5 ? 2 * e ** 2 : -1 + (4 - 2 * e) * e,
      easeInCubic: (e) => e ** 3,
      easeOutCubic: (e) => --e ** 3 + 1,
      easeInOutCubic: (e) => e < 0.5 ? 4 * e ** 3 : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1,
      easeInQuart: (e) => e ** 4,
      easeOutQuart: (e) => 1 - --e ** 4,
      easeInOutQuart: (e) => e < 0.5 ? 8 * e ** 4 : 1 - 8 * --e ** 4,
      easeInQuint: (e) => e ** 5,
      easeOutQuint: (e) => 1 + --e ** 5,
      easeInOutQuint: (e) => e < 0.5 ? 16 * e ** 5 : 1 + 16 * --e ** 5
    }
  };
}
function _V(e) {
  return bp(e) ?? (document.scrollingElement || document.body);
}
function bp(e) {
  return typeof e == "string" ? document.querySelector(e) : np(e);
}
function Um(e, t, n) {
  if (typeof e == "number")
    return t && n ? -e : e;
  let i = bp(e), r = 0;
  for (; i; )
    r += t ? i.offsetLeft : i.offsetTop, i = i.offsetParent;
  return r;
}
function SV(e, t) {
  return {
    rtl: t.isRtl,
    options: qn(US(), e)
  };
}
async function kw(e, t, n, i) {
  const r = n ? "scrollLeft" : "scrollTop", s = qn((i == null ? void 0 : i.options) ?? US(), t), a = i == null ? void 0 : i.rtl.value, o = (typeof e == "number" ? e : bp(e)) ?? 0, l = s.container === "parent" && o instanceof HTMLElement ? o.parentElement : _V(s.container), u = typeof s.easing == "function" ? s.easing : s.patterns[s.easing];
  if (!u)
    throw new TypeError(`Easing function "${s.easing}" not found.`);
  let c;
  if (typeof o == "number")
    c = Um(o, n, a);
  else if (c = Um(o, n, a) - Um(l, n, a), s.layout) {
    const m = window.getComputedStyle(o).getPropertyValue("--v-layout-top");
    m && (c -= parseInt(m, 10));
  }
  c += s.offset, c = CV(l, c, !!a, !!n);
  const d = l[r] ?? 0;
  if (c === d)
    return Promise.resolve(c);
  const f = performance.now();
  return new Promise((h) => requestAnimationFrame(function m(g) {
    const y = (g - f) / s.duration, k = Math.floor(d + (c - d) * u(Xt(y, 0, 1)));
    if (l[r] = k, y >= 1 && Math.abs(k - l[r]) < 10)
      return h(c);
    if (y > 2)
      return gr("Scroll target is not reachable"), h(l[r]);
    requestAnimationFrame(m);
  }));
}
function kV() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const t = tt(zS), {
    isRtl: n
  } = yn();
  if (!t)
    throw new Error("[Vuetify] Could not find injected goto instance");
  const i = {
    ...t,
    // can be set via VLocaleProvider
    rtl: w(() => t.rtl.value || n.value)
  };
  async function r(s, a) {
    return kw(s, qn(e, a), !1, i);
  }
  return r.horizontal = async (s, a) => kw(s, qn(e, a), !0, i), r;
}
function CV(e, t, n, i) {
  const {
    scrollWidth: r,
    scrollHeight: s
  } = e, [a, o] = e === document.scrollingElement ? [window.innerWidth, window.innerHeight] : [e.offsetWidth, e.offsetHeight];
  let l, u;
  return i ? n ? (l = -(r - a), u = 0) : (l = 0, u = r - a) : (l = 0, u = s + -o), Math.max(Math.min(t, u), l);
}
function _r(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
  const n = uf(), i = X();
  if (ft) {
    const r = new ResizeObserver((s) => {
      e == null || e(s, r), s.length && (t === "content" ? i.value = s[0].contentRect : i.value = s[0].target.getBoundingClientRect());
    });
    ai(() => {
      r.disconnect();
    }), fe(() => n.el, (s, a) => {
      a && (r.unobserve(a), i.value = void 0), s && r.observe(s);
    }, {
      flush: "post"
    });
  }
  return {
    resizeRef: n,
    contentRect: Ml(i)
  };
}
const Gu = Symbol.for("vuetify:layout"), qS = Symbol.for("vuetify:layout-item"), Cw = 1e3, GS = B({
  overlaps: {
    type: Array,
    default: () => []
  },
  fullHeight: Boolean
}, "layout"), yo = B({
  name: {
    type: String
  },
  order: {
    type: [Number, String],
    default: 0
  },
  absolute: Boolean
}, "layout-item");
function YS() {
  const e = tt(Gu);
  if (!e)
    throw new Error("[Vuetify] Could not find injected layout");
  return {
    layoutIsReady: He(),
    getLayoutItem: e.getLayoutItem,
    mainRect: e.mainRect,
    mainStyles: e.mainStyles
  };
}
function bo(e) {
  const t = tt(Gu);
  if (!t)
    throw new Error("[Vuetify] Could not find injected layout");
  const n = e.id ?? `layout-item-${An()}`, i = Ut("useLayoutItem");
  Tt(qS, {
    id: n
  });
  const r = pe(!1);
  HE(() => r.value = !0), zE(() => r.value = !1);
  const s = He(), {
    layoutItemStyles: a,
    layoutItemScrimStyles: o
  } = t.register(i, {
    ...e,
    active: w(() => r.value ? !1 : e.active.value),
    id: n
  });
  return ai(() => t.unregister(n)), {
    layoutItemStyles: a,
    layoutRect: t.layoutRect,
    layoutItemScrimStyles: o,
    layoutIsReady: s
  };
}
const TV = (e, t, n, i) => {
  let r = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  };
  const s = [{
    id: "",
    layer: {
      ...r
    }
  }];
  for (const a of e) {
    const o = t.get(a), l = n.get(a), u = i.get(a);
    if (!o || !l || !u)
      continue;
    const c = {
      ...r,
      [o.value]: parseInt(r[o.value], 10) + (u.value ? parseInt(l.value, 10) : 0)
    };
    s.push({
      id: a,
      layer: c
    }), r = c;
  }
  return s;
};
function ZS(e) {
  const t = tt(Gu, null), n = w(() => t ? t.rootZIndex.value - 100 : Cw), i = X([]), r = ti(/* @__PURE__ */ new Map()), s = ti(/* @__PURE__ */ new Map()), a = ti(/* @__PURE__ */ new Map()), o = ti(/* @__PURE__ */ new Map()), l = ti(/* @__PURE__ */ new Map()), {
    resizeRef: u,
    contentRect: c
  } = _r(), d = Yb(() => {
    const b = [...new Set([...a.values()].map((C) => C.value))].sort((C, x) => C - x), S = [];
    for (const C of b) {
      const x = i.value.filter((A) => {
        var I;
        return ((I = a.get(A)) == null ? void 0 : I.value) === C;
      });
      S.push(...x);
    }
    return TV(S, r, s, o);
  }), f = w(() => !Array.from(l.values()).some((b) => b.value)), h = w(() => d.value[d.value.length - 1].layer), m = w(() => ({
    "--v-layout-left": _e(h.value.left),
    "--v-layout-right": _e(h.value.right),
    "--v-layout-top": _e(h.value.top),
    "--v-layout-bottom": _e(h.value.bottom),
    ...f.value ? void 0 : {
      transition: "none"
    }
  })), g = Yb(() => d.value.slice(1).map((b, S) => {
    let {
      id: C
    } = b;
    const {
      layer: x
    } = d.value[S], A = s.get(C), I = r.get(C);
    return {
      id: C,
      ...x,
      size: Number(A.value),
      position: I.value
    };
  })), p = (b) => g.value.find((S) => S.id === b), y = Ut("createLayout"), k = He();
  Tt(Gu, {
    register: (b, S) => {
      let {
        id: C,
        order: x,
        position: A,
        layoutSize: I,
        elementSize: E,
        active: O,
        disableTransitions: V,
        absolute: N
      } = S;
      a.set(C, x), r.set(C, A), s.set(C, I), o.set(C, O), V && l.set(C, V);
      const $ = Zo(qS, y == null ? void 0 : y.vnode).indexOf(b);
      $ > -1 ? i.value.splice($, 0, C) : i.value.push(C);
      const Z = w(() => g.value.findIndex((L) => L.id === C)), j = w(() => n.value + d.value.length * 2 - Z.value * 2), H = w(() => {
        const L = A.value === "left" || A.value === "right", ne = A.value === "right", oe = A.value === "bottom", we = E.value ?? I.value, ee = we === 0 ? "%" : "px", K = {
          [A.value]: 0,
          zIndex: j.value,
          transform: `translate${L ? "X" : "Y"}(${(O.value ? 0 : -(we === 0 ? 100 : we)) * (ne || oe ? -1 : 1)}${ee})`,
          position: N.value || n.value !== Cw ? "absolute" : "fixed",
          ...f.value ? void 0 : {
            transition: "none"
          }
        };
        if (Z.value < 0)
          throw new Error(`Layout item "${C}" is missing`);
        const ue = g.value[Z.value];
        if (!ue)
          throw new Error(`[Vuetify] Could not find layout item "${C}"`);
        return {
          ...K,
          height: L ? `calc(100% - ${ue.top}px - ${ue.bottom}px)` : E.value ? `${E.value}px` : void 0,
          left: ne ? void 0 : `${ue.left}px`,
          right: ne ? `${ue.right}px` : void 0,
          top: A.value !== "bottom" ? `${ue.top}px` : void 0,
          bottom: A.value !== "top" ? `${ue.bottom}px` : void 0,
          width: L ? E.value ? `${E.value}px` : void 0 : `calc(100% - ${ue.left}px - ${ue.right}px)`
        };
      }), R = w(() => ({
        zIndex: j.value - 1
      }));
      return {
        layoutItemStyles: H,
        layoutItemScrimStyles: R,
        zIndex: j
      };
    },
    unregister: (b) => {
      a.delete(b), r.delete(b), s.delete(b), o.delete(b), l.delete(b), i.value = i.value.filter((S) => S !== b);
    },
    mainRect: h,
    mainStyles: m,
    getLayoutItem: p,
    items: g,
    layoutRect: c,
    rootZIndex: n,
    layoutIsReady: k
  });
  const T = w(() => ["v-layout", {
    "v-layout--full-height": e.fullHeight
  }]), _ = w(() => ({
    zIndex: t ? n.value : void 0,
    position: t ? "relative" : void 0,
    overflow: t ? "hidden" : void 0
  }));
  return {
    layoutClasses: T,
    layoutStyles: _,
    getLayoutItem: p,
    items: g,
    layoutRect: c,
    layoutIsReady: k,
    layoutRef: u
  };
}
function KS() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    blueprint: t,
    ...n
  } = e, i = qn(t, n), {
    aliases: r = {},
    components: s = {},
    directives: a = {}
  } = i, o = FO(i.defaults), l = wV(i.display, i.ssr), u = sP(i.theme), c = hP(i.icons), d = wP(i.locale), f = pV(i.date, d), h = SV(i.goTo, d);
  return {
    install: (g) => {
      for (const p in a)
        g.directive(p, a[p]);
      for (const p in s)
        g.component(p, s[p]);
      for (const p in r)
        g.component(p, Oi({
          ...r[p],
          name: p,
          aliasName: r[p].name
        }));
      if (u.install(g), g.provide(gl, o), g.provide(Nv, l), g.provide(Uu, u), g.provide(Pv, c), g.provide(pl, d), g.provide(jS, f.options), g.provide(yw, f.instance), g.provide(zS, h), ft && i.ssr)
        if (g.$nuxt)
          g.$nuxt.hook("app:suspense:resolve", () => {
            l.update();
          });
        else {
          const {
            mount: p
          } = g;
          g.mount = function() {
            const y = p(...arguments);
            return He(() => l.update()), g.mount = p, y;
          };
        }
      An.reset(), g.mixin({
        computed: {
          $vuetify() {
            return ti({
              defaults: Ro.call(this, gl),
              display: Ro.call(this, Nv),
              theme: Ro.call(this, Uu),
              icons: Ro.call(this, Pv),
              locale: Ro.call(this, pl),
              date: Ro.call(this, yw)
            });
          }
        }
      });
    },
    defaults: o,
    display: l,
    theme: u,
    icons: c,
    locale: d,
    date: f,
    goTo: h
  };
}
const xV = "3.6.7";
KS.version = xV;
function Ro(e) {
  var i, r;
  const t = this.$, n = ((i = t.parent) == null ? void 0 : i.provides) ?? ((r = t.vnode.appContext) == null ? void 0 : r.provides);
  if (n && e in n)
    return n[e];
}
var fi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function AV(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function IV(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function i() {
      return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(e, i);
    Object.defineProperty(n, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return e[i];
      }
    });
  }), n;
}
var XS = {}, JS = {}, QS = {}, ek = {}, fr = {};
const EV = {}, OV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: EV
}, Symbol.toStringTag, { value: "Module" })), PV = /* @__PURE__ */ IV(OV);
Object.defineProperty(fr, "__esModule", { value: !0 });
fr.getCrypto = fr.getRootWebCrypto = fr.getWebCrypto = fr.getNodeCrypto = void 0;
var wp = function() {
  if (!(typeof window < "u" && window.crypto))
    return typeof window > "u" && typeof crypto < "u" ? void 0 : PV;
};
fr.getNodeCrypto = wp;
var _p = function() {
  if (typeof window < "u" && window.crypto)
    return window.crypto.subtle;
  if (typeof window > "u" && typeof crypto < "u")
    return crypto.subtle;
};
fr.getWebCrypto = _p;
var tk = function() {
  if (typeof window < "u" && window.crypto)
    return window.crypto;
  if (typeof window > "u" && typeof crypto < "u")
    return crypto;
};
fr.getRootWebCrypto = tk;
var nk = function() {
  var e = _p(), t = wp();
  return typeof t < "u" ? { name: "nodeCrypto", crypto: t } : typeof e < "u" ? { name: "webCrypto", crypto: e } : { name: void 0 };
};
fr.getCrypto = nk;
fr.default = { getNodeCrypto: wp, getWebCrypto: _p, getRootWebCrypto: tk, getCrypto: nk };
(function(e) {
  var t = fi && fi.__createBinding || (Object.create ? function(u, c, d, f) {
    f === void 0 && (f = d), Object.defineProperty(u, f, { enumerable: !0, get: function() {
      return c[d];
    } });
  } : function(u, c, d, f) {
    f === void 0 && (f = d), u[f] = c[d];
  }), n = fi && fi.__setModuleDefault || (Object.create ? function(u, c) {
    Object.defineProperty(u, "default", { enumerable: !0, value: c });
  } : function(u, c) {
    u.default = c;
  }), i = fi && fi.__importStar || function(u) {
    if (u && u.__esModule)
      return u;
    var c = {};
    if (u != null)
      for (var d in u)
        d !== "default" && Object.prototype.hasOwnProperty.call(u, d) && t(c, u, d);
    return n(c, u), c;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getRandomBytes = e.getRandomSampledString = e.getRandomAsciiString = e.getRandomString = void 0;
  var r = i(fr), s = function(u) {
    for (var c = (0, e.getRandomBytes)(u), d = (0, e.getRandomBytes)(u), f = "", h = 0; h < u; h++)
      d[h] = d[h] % 3, c[h] = d[h] === 0 ? c[h] % 10 + 48 : c[h] % 26 + (d[h] === 1 ? 65 : 97), f += String.fromCharCode(c[h]);
    return f;
  };
  e.getRandomString = s;
  var a = function(u) {
    for (var c = (0, e.getRandomBytes)(u), d = "", f = 0; f < u; f++)
      c[f] = c[f] % 94 + 32, d += String.fromCharCode(c[f]);
    return d;
  };
  e.getRandomAsciiString = a;
  var o = function(u, c) {
    var d = c.length;
    if (d === 0)
      return "";
    for (var f = (0, e.getRandomBytes)(u), h = "", m = 0; m < u; m++)
      h += c[f[m] % d];
    return h;
  };
  e.getRandomSampledString = o;
  var l = function(u) {
    var c = r.getRootWebCrypto(), d = r.getNodeCrypto();
    if (typeof c < "u" && typeof c.getRandomValues == "function") {
      var f = new Uint8Array(u);
      return c.getRandomValues(f), f;
    } else {
      if (typeof d < "u")
        return new Uint8Array(d.randomBytes(u));
      throw new Error("UnsupportedEnvironment");
    }
  };
  e.getRandomBytes = l;
})(ek);
(function(e) {
  var t = fi && fi.__createBinding || (Object.create ? function(s, a, o, l) {
    l === void 0 && (l = o), Object.defineProperty(s, l, { enumerable: !0, get: function() {
      return a[o];
    } });
  } : function(s, a, o, l) {
    l === void 0 && (l = o), s[l] = a[o];
  }), n = fi && fi.__setModuleDefault || (Object.create ? function(s, a) {
    Object.defineProperty(s, "default", { enumerable: !0, value: a });
  } : function(s, a) {
    s.default = a;
  }), i = fi && fi.__importStar || function(s) {
    if (s && s.__esModule)
      return s;
    var a = {};
    if (s != null)
      for (var o in s)
        o !== "default" && Object.prototype.hasOwnProperty.call(s, o) && t(a, s, o);
    return n(a, s), a;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getRandomSampledString = e.getRandomString = e.getRandomAsciiString = e.getRandomBytes = void 0;
  var r = i(ek);
  e.getRandomBytes = r.getRandomBytes, e.getRandomAsciiString = r.getRandomAsciiString, e.getRandomString = r.getRandomString, e.getRandomSampledString = r.getRandomSampledString, e.default = { getRandomBytes: e.getRandomBytes, getRandomAsciiString: e.getRandomAsciiString, getRandomString: e.getRandomString, getRandomSampledString: e.getRandomSampledString };
})(QS);
(function(e) {
  var t = fi && fi.__importDefault || function(y) {
    return y && y.__esModule ? y : { default: y };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.generateMultiple = e.generate = void 0;
  var n = t(QS), i = 256, r = void 0, s = new Uint8Array(), a = function() {
    (r === void 0 || r >= s.length) && (r = 0, s = n.default.getRandomBytes(i));
    var y = s[r];
    return r += 1, y;
  }, o = function(y) {
    for (var k = a(); k >= 256 - 256 % y; )
      k = a();
    return k % y;
  }, l = "abcdefghijklmnopqrstuvwxyz", u = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", c = "0123456789", d = "\\!@#$%^&*()+_-=}{[]|:;\"/?.><,`~'", f = /[ilLI|`oO0]/g, h = [
    { name: "lowercase", rule: /[a-z]/ },
    { name: "uppercase", rule: /[A-Z]/ },
    { name: "numbers", rule: /[0-9]/ },
    { name: "symbols", rule: /[\\!@#$%^&*()+_\-=}{[\]|:;"/?.><,`~']/ }
  ], m = function(y, k) {
    for (var T = "", _ = y.length, b = k.length, S = 0; S < _; S++)
      T += k[o(b)];
    if (y.strict) {
      var C = h.every(function(x) {
        if (y[x.name || "uppercase"] == !1)
          return !0;
        if (x.name === "symbols" && typeof y[x.name] == "string") {
          var A = new RegExp("[".concat(y[x.name], "]"));
          return A.test(T);
        }
        return x.rule.test(T);
      });
      if (!C)
        return m(y, k);
    }
    return T;
  }, g = function(y) {
    if (y = y || {}, Object.prototype.hasOwnProperty.call(y, "length") || (y.length = 10), Object.prototype.hasOwnProperty.call(y, "numbers") || (y.numbers = !1), Object.prototype.hasOwnProperty.call(y, "symbols") || (y.symbols = !1), Object.prototype.hasOwnProperty.call(y, "exclude") || (y.exclude = ""), Object.prototype.hasOwnProperty.call(y, "uppercase") || (y.uppercase = !0), Object.prototype.hasOwnProperty.call(y, "lowercase") || (y.lowercase = !0), Object.prototype.hasOwnProperty.call(y, "excludeSimilarCharacters") || (y.excludeSimilarCharacters = !1), Object.prototype.hasOwnProperty.call(y, "strict") || (y.strict = !1), y.strict) {
      var k = 1 + (y.numbers ? 1 : 0) + (y.symbols ? 1 : 0) + (y.uppercase ? 1 : 0);
      if (k > y.length)
        throw new TypeError("Length must correlate with strict guidelines");
    }
    var T = "";
    if (y.lowercase && (T += l), y.uppercase && (T += u), y.numbers && (T += c), y.symbols && (typeof y.symbols == "string" ? T += y.symbols : T += d), !T)
      throw new TypeError("At least one rule for pools must be true");
    y.excludeSimilarCharacters && (T = T.replace(f, ""));
    for (var _ = y.exclude.length; _--; )
      T = T.replace(y.exclude[_], "");
    return m(y, T);
  };
  e.generate = g;
  var p = function(y, k) {
    for (var T = [], _ = 0; _ < y; _++)
      T.push((0, e.generate)(k));
    return T;
  };
  e.generateMultiple = p;
})(JS);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.generateMultiple = e.generate = void 0;
  var t = JS;
  Object.defineProperty(e, "generate", { enumerable: !0, get: function() {
    return t.generate;
  } }), Object.defineProperty(e, "generateMultiple", { enumerable: !0, get: function() {
    return t.generateMultiple;
  } }), e.default = { generate: t.generate, generateMultiple: t.generateMultiple };
})(XS);
const VV = /* @__PURE__ */ AV(XS), DV = ah({
  name: "VPPasswordField",
  props: {
    ...gi.props,
    /**
     * Whether to show the password generator button
     */
    showGenerator: {
      type: Boolean,
      default: !1
    },
    /**
     * The length of the password to generate
     */
    generatePasswordLength: {
      type: Number,
      default: 12
    },
    /**
     * Whether to include numbers in the generated password
     */
    generatePasswordWithNumbers: {
      type: Boolean,
      default: !0
    },
    /**
     * Whether to include symbols in the generated password
     */
    generatePasswordWithSymbols: {
      type: Boolean,
      default: !0
    },
    /**
     * Whether to include uppercase characters in the generated password
     */
    generatePasswordWithUppercase: {
      type: Boolean,
      default: !0
    },
    /**
     * Whether to exclude similar characters in the generated password
     */
    generatePasswordExcludingSimilarCharacters: {
      type: Boolean,
      default: !0
    }
  },
  emits: [
    ...Object.keys({ ...gi.emits }),
    /**
     * Emitted when the password generator button is clicked
     */
    "generate-password"
  ],
  setup(e, { emit: t }) {
    const n = X("password"), i = w(() => e.generatePasswordLength), r = w(
      () => e.generatePasswordWithNumbers
    ), s = w(
      () => e.generatePasswordWithSymbols
    ), a = w(
      () => e.generatePasswordWithUppercase
    ), o = w(
      () => e.generatePasswordExcludingSimilarCharacters
    ), l = w(
      () => n.value === "password" ? "mdi-eye-lock-open-outline" : "mdi-eye-off-outline"
    ), u = () => {
      n.value = n.value === "password" ? "text" : "password";
    }, c = () => {
      const p = VV.generate({
        length: i.value,
        numbers: r.value,
        symbols: s.value,
        uppercase: a.value,
        excludeSimilarCharacters: o.value
      });
      n.value = "text", t("generate-password", p), t("update:modelValue", p);
    }, d = w(() => e), f = up(d.value, "VTextField"), h = w(() => ({
      ...f,
      type: n.value,
      "append-inner-icon": void 0
    })), m = w(() => {
      const p = {};
      return Object.keys({ ...gi.emits }).forEach((y) => {
        p[y] = (k) => t(y, k);
      }), p;
    }), g = X(void 0);
    return {
      updatedProps: h,
      updatedEmitters: m,
      field: g,
      onGeneratePassword: c,
      passwordFieldTypeIcon: l,
      togglePasswordFieldType: u
    };
  }
});
const Sp = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [i, r] of t)
    n[i] = r;
  return n;
};
function NV(e, t, n, i, r, s) {
  const a = Nn("v-icon"), o = Nn("v-btn"), l = Nn("v-text-field");
  return af(), of(l, se({ ref: "field" }, e.updatedProps, { class: "vp-password-field" }, UE(e.updatedEmitters)), {
    "append-inner": Rn(() => [
      e.showGenerator ? (af(), of(o, {
        key: 0,
        icon: "",
        onClick: e.onGeneratePassword,
        variant: "plain",
        density: "compact"
      }, {
        default: Rn(() => [
          v(a, null, {
            default: Rn(() => [
              wr("mdi-form-textbox-password")
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["onClick"])) : qE("", !0),
      v(o, {
        icon: "",
        onClick: e.togglePasswordFieldType,
        variant: "plain",
        density: "compact"
      }, {
        default: Rn(() => [
          v(a, null, {
            default: Rn(() => [
              wr(ep(e.passwordFieldTypeIcon), 1)
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["onClick"])
    ]),
    _: 1
  }, 16);
}
const ik = /* @__PURE__ */ Sp(DV, [["render", NV]]);
function rk(e) {
  return GE() ? (Wn(e), !0) : !1;
}
function _h(e) {
  return typeof e == "function" ? e() : Ct(e);
}
const kp = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const MV = Object.prototype.toString, RV = (e) => MV.call(e) === "[object Object]", FV = () => {
};
function BV(e) {
  let t;
  function n() {
    return t || (t = e()), t;
  }
  return n.reset = async () => {
    const i = t;
    t = void 0, i && await i;
  }, n;
}
function LV(e, t, n = {}) {
  const {
    immediate: i = !0
  } = n, r = X(!1);
  let s = null;
  function a() {
    s && (clearTimeout(s), s = null);
  }
  function o() {
    r.value = !1, a();
  }
  function l(...u) {
    a(), r.value = !0, s = setTimeout(() => {
      r.value = !1, s = null, e(...u);
    }, _h(t));
  }
  return i && (r.value = !0, kp && l()), rk(o), {
    isPending: Ml(r),
    start: l,
    stop: o
  };
}
function $V(e) {
  var t;
  const n = _h(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
const WV = kp ? window : void 0, sk = kp ? window.navigator : void 0;
function ak(...e) {
  let t, n, i, r;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([n, i, r] = e, t = WV) : [t, n, i, r] = e, !t)
    return FV;
  Array.isArray(n) || (n = [n]), Array.isArray(i) || (i = [i]);
  const s = [], a = () => {
    s.forEach((c) => c()), s.length = 0;
  }, o = (c, d, f, h) => (c.addEventListener(d, f, h), () => c.removeEventListener(d, f, h)), l = fe(
    () => [$V(t), _h(r)],
    ([c, d]) => {
      if (a(), !c)
        return;
      const f = RV(d) ? { ...d } : d;
      s.push(
        ...n.flatMap((h) => i.map((m) => o(c, h, m, f)))
      );
    },
    { immediate: !0, flush: "post" }
  ), u = () => {
    l(), a();
  };
  return rk(u), u;
}
function jV() {
  const e = X(!1), t = Xg();
  return t && jn(() => {
    e.value = !0;
  }, t), e;
}
function ok(e) {
  const t = jV();
  return w(() => (t.value, !!e()));
}
function Tw(e, t = {}) {
  const {
    controls: n = !1,
    navigator: i = sk
  } = t, r = ok(() => i && "permissions" in i);
  let s;
  const a = typeof e == "string" ? { name: e } : e, o = X(), l = () => {
    s && (o.value = s.state);
  }, u = BV(async () => {
    if (r.value) {
      if (!s)
        try {
          s = await i.permissions.query(a), ak(s, "change", l), l();
        } catch {
          o.value = "prompt";
        }
      return s;
    }
  });
  return u(), n ? {
    state: o,
    isSupported: r,
    query: u
  } : o;
}
function HV(e = {}) {
  const {
    navigator: t = sk,
    read: n = !1,
    source: i,
    copiedDuring: r = 1500,
    legacy: s = !1
  } = e, a = ok(() => t && "clipboard" in t), o = Tw("clipboard-read"), l = Tw("clipboard-write"), u = w(() => a.value || s), c = X(""), d = X(!1), f = LV(() => d.value = !1, r);
  function h() {
    a.value && y(o.value) ? t.clipboard.readText().then((k) => {
      c.value = k;
    }) : c.value = p();
  }
  u.value && n && ak(["copy", "cut"], h);
  async function m(k = _h(i)) {
    u.value && k != null && (a.value && y(l.value) ? await t.clipboard.writeText(k) : g(k), c.value = k, d.value = !0, f.start());
  }
  function g(k) {
    const T = document.createElement("textarea");
    T.value = k ?? "", T.style.position = "absolute", T.style.opacity = "0", document.body.appendChild(T), T.select(), document.execCommand("copy"), T.remove();
  }
  function p() {
    var k, T, _;
    return (_ = (T = (k = document == null ? void 0 : document.getSelection) == null ? void 0 : k.call(document)) == null ? void 0 : T.toString()) != null ? _ : "";
  }
  function y(k) {
    return k === "granted" || k === "prompt";
  }
  return {
    isSupported: u,
    text: c,
    copied: d,
    copy: m
  };
}
const xs = (e, t = "#34495E", n = "#41B883") => (...i) => {
  if (typeof window > "u" && (typeof ServiceWorkerGlobalScope > "u" || !(self instanceof ServiceWorkerGlobalScope))) {
    console.log(`[${e}]`, ...i);
    return;
  }
  if (typeof ServiceWorkerGlobalScope < "u" && self instanceof ServiceWorkerGlobalScope && !e.startsWith("[") && !e.endsWith("]")) {
    e = `[${e}]`;
    const r = t;
    t = n, n = r;
  }
  console.groupCollapsed(
    `%c${e}`,
    `background-color: ${n}; color: ${t}; padding: 2px 4px;`,
    ...i
  ), console.debug(new Error("stack").stack.split(`
`).slice(2).join(`
`)), console.groupEnd();
}, xw = xs("VPTextFieldCopyable"), lk = [
  "readonly",
  "value",
  "model-value",
  "modelValue",
  "hide-details",
  "append-inner-icon",
  "hideDetails",
  "appendInnerIcon",
  "onClick:prependInner"
], zV = (e = {}) => {
  const t = {};
  for (const n in gi.props)
    lk.includes(n) || (t[n] = gi.props[n]);
  return {
    ...t,
    ...e
  };
}, UV = ah({
  name: "VPTextFieldCopyable",
  props: zV({
    /**
     * The value to be copied to the clipboard
     * @model
     */
    value: {
      type: String,
      default: ""
    }
  }),
  emits: [
    /**
     * Emitted when the value is successfully copied to the clipboard
     * 
     * @property {string} value - The value that was copied
     */
    "copied",
    /**
     * Emitted when the value fails to be copied to the clipboard
     */
    "copy-failed",
    ...Object.keys({ ...gi.emits })
  ],
  setup(e, { emit: t }) {
    const n = w(() => e.value), { copy: i, copied: r, isSupported: s, text: a } = HV(), o = async () => {
      await i(n.value), r.value && a.value === n.value ? (t("copied", r.value), xw(`Copied: ${r.value}`)) : (t("copy-failed"), xw(`Failed to copy: ${n.value}`));
    }, l = up(e, "VTextField"), u = w(() => {
      const c = {};
      for (const d in gi.props)
        lk.includes(d) || (c[d] = l[d]);
      return c;
    });
    return {
      copy: o,
      isSupported: s,
      bound: u
    };
  }
});
function qV(e, t, n, i, r, s) {
  const a = Nn("v-text-field");
  return af(), of(a, se({
    readonly: "",
    "model-value": e.value,
    "hide-details": "",
    "append-inner-icon": "mdi-content-copy"
  }, e.bound, { "onClick:appendInner": e.copy }), YE({ _: 2 }, [
    ZE(e.$slots, (o, l) => ({
      name: l,
      fn: Rn((u) => [
        ns(e.$slots, l, Rs(Fs(u)))
      ])
    }))
  ]), 1040, ["model-value", "onClick:appendInner"]);
}
const GV = /* @__PURE__ */ Sp(UV, [["render", qV]]);
function YV() {
  return uk().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function uk() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
}
const ZV = typeof Proxy == "function", KV = "devtools-plugin:setup", XV = "plugin:settings:set";
let Fo, Mv;
function JV() {
  var e;
  return Fo !== void 0 || (typeof window < "u" && window.performance ? (Fo = !0, Mv = window.performance) : typeof globalThis < "u" && (!((e = globalThis.perf_hooks) === null || e === void 0) && e.performance) ? (Fo = !0, Mv = globalThis.perf_hooks.performance) : Fo = !1), Fo;
}
function QV() {
  return JV() ? Mv.now() : Date.now();
}
class eD {
  constructor(t, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = t, this.hook = n;
    const i = {};
    if (t.settings)
      for (const a in t.settings) {
        const o = t.settings[a];
        i[a] = o.defaultValue;
      }
    const r = `__vue-devtools-plugin-settings__${t.id}`;
    let s = Object.assign({}, i);
    try {
      const a = localStorage.getItem(r), o = JSON.parse(a);
      Object.assign(s, o);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return s;
      },
      setSettings(a) {
        try {
          localStorage.setItem(r, JSON.stringify(a));
        } catch {
        }
        s = a;
      },
      now() {
        return QV();
      }
    }, n && n.on(XV, (a, o) => {
      a === this.plugin.id && this.fallbacks.setSettings(o);
    }), this.proxiedOn = new Proxy({}, {
      get: (a, o) => this.target ? this.target.on[o] : (...l) => {
        this.onQueue.push({
          method: o,
          args: l
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (a, o) => this.target ? this.target[o] : o === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(o) ? (...l) => (this.targetQueue.push({
        method: o,
        args: l,
        resolve: () => {
        }
      }), this.fallbacks[o](...l)) : (...l) => new Promise((u) => {
        this.targetQueue.push({
          method: o,
          args: l,
          resolve: u
        });
      })
    });
  }
  async setRealTarget(t) {
    this.target = t;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function tD(e, t) {
  const n = e, i = uk(), r = YV(), s = ZV && n.enableEarlyProxy;
  if (r && (i.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !s))
    r.emit(KV, e, t);
  else {
    const a = s ? new eD(n, r) : null;
    (i.__VUE_DEVTOOLS_PLUGINS__ = i.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: t,
      proxy: a
    }), a && t(a.proxiedTarget);
  }
}
/**
  * vee-validate v4.12.8
  * (c) 2024 Abdelrahman Awad
  * @license MIT
  */
function cr(e) {
  return typeof e == "function";
}
function ck(e) {
  return e == null;
}
const Ga = (e) => e !== null && !!e && typeof e == "object" && !Array.isArray(e);
function Cp(e) {
  return Number(e) >= 0;
}
function nD(e) {
  return typeof e == "object" && e !== null;
}
function iD(e) {
  return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e);
}
function Aw(e) {
  if (!nD(e) || iD(e) !== "[object Object]")
    return !1;
  if (Object.getPrototypeOf(e) === null)
    return !0;
  let t = e;
  for (; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t;
}
function Yu(e, t) {
  return Object.keys(t).forEach((n) => {
    if (Aw(t[n]) && Aw(e[n])) {
      e[n] || (e[n] = {}), Yu(e[n], t[n]);
      return;
    }
    e[n] = t[n];
  }), e;
}
function pd(e) {
  const t = e.split(".");
  if (!t.length)
    return "";
  let n = String(t[0]);
  for (let i = 1; i < t.length; i++) {
    if (Cp(t[i])) {
      n += `[${t[i]}]`;
      continue;
    }
    n += `.${t[i]}`;
  }
  return n;
}
const rD = {};
function sD(e) {
  return rD[e];
}
function Iw(e, t, n) {
  typeof n.value == "object" && (n.value = zt(n.value)), !n.enumerable || n.get || n.set || !n.configurable || !n.writable || t === "__proto__" ? Object.defineProperty(e, t, n) : e[t] = n.value;
}
function zt(e) {
  if (typeof e != "object")
    return e;
  var t = 0, n, i, r, s = Object.prototype.toString.call(e);
  if (s === "[object Object]" ? r = Object.create(e.__proto__ || null) : s === "[object Array]" ? r = Array(e.length) : s === "[object Set]" ? (r = /* @__PURE__ */ new Set(), e.forEach(function(a) {
    r.add(zt(a));
  })) : s === "[object Map]" ? (r = /* @__PURE__ */ new Map(), e.forEach(function(a, o) {
    r.set(zt(o), zt(a));
  })) : s === "[object Date]" ? r = /* @__PURE__ */ new Date(+e) : s === "[object RegExp]" ? r = new RegExp(e.source, e.flags) : s === "[object DataView]" ? r = new e.constructor(zt(e.buffer)) : s === "[object ArrayBuffer]" ? r = e.slice(0) : s.slice(-6) === "Array]" && (r = new e.constructor(e)), r) {
    for (i = Object.getOwnPropertySymbols(e); t < i.length; t++)
      Iw(r, i[t], Object.getOwnPropertyDescriptor(e, i[t]));
    for (t = 0, i = Object.getOwnPropertyNames(e); t < i.length; t++)
      Object.hasOwnProperty.call(r, n = i[t]) && r[n] === e[n] || Iw(r, n, Object.getOwnPropertyDescriptor(e, n));
  }
  return r || e;
}
const aD = Symbol("vee-validate-form"), oD = typeof window < "u";
function lD(e) {
  return cr(e) && !!e.__locatorRef;
}
function Ys(e) {
  return !!e && cr(e.parse) && e.__type === "VVTypedSchema";
}
function dk(e) {
  return !!e && cr(e.validate);
}
function uD(e) {
  return e === "checkbox" || e === "radio";
}
function cD(e) {
  return Ga(e) || Array.isArray(e);
}
function dD(e) {
  return Array.isArray(e) ? e.length === 0 : Ga(e) && Object.keys(e).length === 0;
}
function Sh(e) {
  return /^\[.+\]$/i.test(e);
}
function fD(e) {
  return fk(e) && e.multiple;
}
function fk(e) {
  return e.tagName === "SELECT";
}
function hD(e) {
  return hk(e) && e.target && "submit" in e.target;
}
function hk(e) {
  return e ? !!(typeof Event < "u" && cr(Event) && e instanceof Event || e && e.srcElement) : !1;
}
function Du(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    var n, i, r;
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (i = n; i-- !== 0; )
        if (!Du(e[i], t[i]))
          return !1;
      return !0;
    }
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
        return !1;
      for (i of e.entries())
        if (!t.has(i[0]))
          return !1;
      for (i of e.entries())
        if (!Du(i[1], t.get(i[0])))
          return !1;
      return !0;
    }
    if (Ew(e) && Ew(t))
      return !(e.size !== t.size || e.name !== t.name || e.lastModified !== t.lastModified || e.type !== t.type);
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
        return !1;
      for (i of e.entries())
        if (!t.has(i[0]))
          return !1;
      return !0;
    }
    if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
      if (n = e.length, n != t.length)
        return !1;
      for (i = n; i-- !== 0; )
        if (e[i] !== t[i])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    for (r = Object.keys(e), n = r.length, i = n; i-- !== 0; ) {
      var s = r[i];
      if (!Du(e[s], t[s]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Ew(e) {
  return oD ? e instanceof File : !1;
}
function Tp(e) {
  return Sh(e) ? e.replace(/\[|\]/gi, "") : e;
}
function fs(e, t, n) {
  return e ? Sh(t) ? e[Tp(t)] : (t || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((r, s) => cD(r) && s in r ? r[s] : n, e) : n;
}
function os(e, t, n) {
  if (Sh(t)) {
    e[Tp(t)] = n;
    return;
  }
  const i = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let r = e;
  for (let s = 0; s < i.length; s++) {
    if (s === i.length - 1) {
      r[i[s]] = n;
      return;
    }
    (!(i[s] in r) || ck(r[i[s]])) && (r[i[s]] = Cp(i[s + 1]) ? [] : {}), r = r[i[s]];
  }
}
function qm(e, t) {
  if (Array.isArray(e) && Cp(t)) {
    e.splice(Number(t), 1);
    return;
  }
  Ga(e) && delete e[t];
}
function Ow(e, t) {
  if (Sh(t)) {
    delete e[Tp(t)];
    return;
  }
  const n = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let i = e;
  for (let s = 0; s < n.length; s++) {
    if (s === n.length - 1) {
      qm(i, n[s]);
      break;
    }
    if (!(n[s] in i) || ck(i[n[s]]))
      break;
    i = i[n[s]];
  }
  const r = n.map((s, a) => fs(e, n.slice(0, a).join(".")));
  for (let s = r.length - 1; s >= 0; s--)
    if (dD(r[s])) {
      if (s === 0) {
        qm(e, n[0]);
        continue;
      }
      qm(r[s - 1], n[s - 1]);
    }
}
function ki(e) {
  return Object.keys(e);
}
function mD(e, t) {
  let n, i;
  return function(...r) {
    const s = this;
    return n || (n = !0, setTimeout(() => n = !1, t), i = e.apply(s, r)), i;
  };
}
function Pw(e, t = 0) {
  let n = null, i = [];
  return function(...r) {
    return n && clearTimeout(n), n = setTimeout(() => {
      const s = e(...r);
      i.forEach((a) => a(s)), i = [];
    }, t), new Promise((s) => i.push(s));
  };
}
function vD(e, t) {
  let n;
  return async function(...r) {
    const s = e(...r);
    n = s;
    const a = await s;
    return s !== n ? a : (n = void 0, t(a, r));
  };
}
function Vw(e) {
  return Array.isArray(e) ? e : e ? [e] : [];
}
function yd(e, t) {
  const n = {};
  for (const i in e)
    t.includes(i) || (n[i] = e[i]);
  return n;
}
function gD(e) {
  let t = null, n = [];
  return function(...i) {
    const r = He(() => {
      if (t !== r)
        return;
      const s = e(...i);
      n.forEach((a) => a(s)), n = [], t = null;
    });
    return t = r, new Promise((s) => n.push(s));
  };
}
function Gm(e) {
  if (mk(e))
    return e._value;
}
function mk(e) {
  return "_value" in e;
}
function pD(e) {
  return e.type === "number" || e.type === "range" ? Number.isNaN(e.valueAsNumber) ? e.value : e.valueAsNumber : e.value;
}
function Dw(e) {
  if (!hk(e))
    return e;
  const t = e.target;
  if (uD(t.type) && mk(t))
    return Gm(t);
  if (t.type === "file" && t.files) {
    const n = Array.from(t.files);
    return t.multiple ? n : n[0];
  }
  if (fD(t))
    return Array.from(t.options).filter((n) => n.selected && !n.disabled).map(Gm);
  if (fk(t)) {
    const n = Array.from(t.options).find((i) => i.selected);
    return n ? Gm(n) : t.value;
  }
  return pD(t);
}
function yD(e) {
  const t = {};
  return Object.defineProperty(t, "_$$isNormalized", {
    value: !0,
    writable: !1,
    enumerable: !1,
    configurable: !1
  }), e ? Ga(e) && e._$$isNormalized ? e : Ga(e) ? Object.keys(e).reduce((n, i) => {
    const r = bD(e[i]);
    return e[i] !== !1 && (n[i] = Nw(r)), n;
  }, t) : typeof e != "string" ? t : e.split("|").reduce((n, i) => {
    const r = wD(i);
    return r.name && (n[r.name] = Nw(r.params)), n;
  }, t) : t;
}
function bD(e) {
  return e === !0 ? [] : Array.isArray(e) || Ga(e) ? e : [e];
}
function Nw(e) {
  const t = (n) => typeof n == "string" && n[0] === "@" ? _D(n.slice(1)) : n;
  return Array.isArray(e) ? e.map(t) : e instanceof RegExp ? [e] : Object.keys(e).reduce((n, i) => (n[i] = t(e[i]), n), {});
}
const wD = (e) => {
  let t = [];
  const n = e.split(":")[0];
  return e.includes(":") && (t = e.split(":").slice(1).join(":").split(",")), { name: n, params: t };
};
function _D(e) {
  const t = (n) => fs(n, e) || n[e];
  return t.__locatorRef = e, t;
}
const SD = {
  generateMessage: ({ field: e }) => `${e} is not valid.`,
  bails: !0,
  validateOnBlur: !0,
  validateOnChange: !0,
  validateOnInput: !1,
  validateOnModelUpdate: !0
};
let kD = Object.assign({}, SD);
const hu = () => kD;
async function CD(e, t, n = {}) {
  const i = n == null ? void 0 : n.bails, r = {
    name: (n == null ? void 0 : n.name) || "{field}",
    rules: t,
    label: n == null ? void 0 : n.label,
    bails: i ?? !0,
    formData: (n == null ? void 0 : n.values) || {}
  }, a = (await TD(r, e)).errors;
  return {
    errors: a,
    valid: !a.length
  };
}
async function TD(e, t) {
  if (Ys(e.rules) || dk(e.rules))
    return AD(t, e.rules);
  if (cr(e.rules) || Array.isArray(e.rules)) {
    const a = {
      field: e.label || e.name,
      name: e.name,
      label: e.label,
      form: e.formData,
      value: t
    }, o = Array.isArray(e.rules) ? e.rules : [e.rules], l = o.length, u = [];
    for (let c = 0; c < l; c++) {
      const d = o[c], f = await d(t, a);
      if (!(typeof f != "string" && !Array.isArray(f) && f)) {
        if (Array.isArray(f))
          u.push(...f);
        else {
          const m = typeof f == "string" ? f : gk(a);
          u.push(m);
        }
        if (e.bails)
          return {
            errors: u
          };
      }
    }
    return {
      errors: u
    };
  }
  const n = Object.assign(Object.assign({}, e), { rules: yD(e.rules) }), i = [], r = Object.keys(n.rules), s = r.length;
  for (let a = 0; a < s; a++) {
    const o = r[a], l = await ID(n, t, {
      name: o,
      params: n.rules[o]
    });
    if (l.error && (i.push(l.error), e.bails))
      return {
        errors: i
      };
  }
  return {
    errors: i
  };
}
function xD(e) {
  return !!e && e.name === "ValidationError";
}
function vk(e) {
  return {
    __type: "VVTypedSchema",
    async parse(n) {
      var i;
      try {
        return {
          output: await e.validate(n, { abortEarly: !1 }),
          errors: []
        };
      } catch (r) {
        if (!xD(r))
          throw r;
        if (!(!((i = r.inner) === null || i === void 0) && i.length) && r.errors.length)
          return { errors: [{ path: r.path, errors: r.errors }] };
        const s = r.inner.reduce((a, o) => {
          const l = o.path || "";
          return a[l] || (a[l] = { errors: [], path: l }), a[l].errors.push(...o.errors), a;
        }, {});
        return { errors: Object.values(s) };
      }
    }
  };
}
async function AD(e, t) {
  const i = await (Ys(t) ? t : vk(t)).parse(e), r = [];
  for (const s of i.errors)
    s.errors.length && r.push(...s.errors);
  return {
    errors: r
  };
}
async function ID(e, t, n) {
  const i = sD(n.name);
  if (!i)
    throw new Error(`No such validator '${n.name}' exists.`);
  const r = ED(n.params, e.formData), s = {
    field: e.label || e.name,
    name: e.name,
    label: e.label,
    value: t,
    form: e.formData,
    rule: Object.assign(Object.assign({}, n), { params: r })
  }, a = await i(t, r, s);
  return typeof a == "string" ? {
    error: a
  } : {
    error: a ? void 0 : gk(s)
  };
}
function gk(e) {
  const t = hu().generateMessage;
  return t ? t(e) : "Field is invalid";
}
function ED(e, t) {
  const n = (i) => lD(i) ? i(t) : i;
  return Array.isArray(e) ? e.map(n) : Object.keys(e).reduce((i, r) => (i[r] = n(e[r]), i), {});
}
async function OD(e, t) {
  const i = await (Ys(e) ? e : vk(e)).parse(zt(t)), r = {}, s = {};
  for (const a of i.errors) {
    const o = a.errors, l = (a.path || "").replace(/\["(\d+)"\]/g, (u, c) => `[${c}]`);
    r[l] = { valid: !o.length, errors: o }, o.length && (s[l] = o[0]);
  }
  return {
    valid: !i.errors.length,
    results: r,
    errors: s,
    values: i.value
  };
}
async function PD(e, t, n) {
  const r = ki(e).map(async (u) => {
    var c, d, f;
    const h = (c = n == null ? void 0 : n.names) === null || c === void 0 ? void 0 : c[u], m = await CD(fs(t, u), e[u], {
      name: (h == null ? void 0 : h.name) || u,
      label: h == null ? void 0 : h.label,
      values: t,
      bails: (f = (d = n == null ? void 0 : n.bailsMap) === null || d === void 0 ? void 0 : d[u]) !== null && f !== void 0 ? f : !0
    });
    return Object.assign(Object.assign({}, m), { path: u });
  });
  let s = !0;
  const a = await Promise.all(r), o = {}, l = {};
  for (const u of a)
    o[u.path] = {
      valid: u.valid,
      errors: u.errors
    }, u.valid || (s = !1, l[u.path] = u.errors[0]);
  return {
    valid: s,
    results: o,
    errors: l
  };
}
function VD(e) {
  process.env.NODE_ENV !== "production" && tD({
    id: "vee-validate-devtools-plugin",
    label: "VeeValidate Plugin",
    packageName: "vee-validate",
    homepage: "https://vee-validate.logaretm.com/v4",
    app: e,
    logo: "https://vee-validate.logaretm.com/v4/logo.png"
  }, ND);
}
const Nu = {}, pk = {};
let Ws;
const Rv = mD(() => {
  setTimeout(async () => {
    await He(), Ws == null || Ws.sendInspectorState(Ko), Ws == null || Ws.sendInspectorTree(Ko);
  }, 100);
}, 100);
function DD(e) {
  const t = Xg();
  if (!Ws) {
    const n = t == null ? void 0 : t.appContext.app;
    if (!n)
      return;
    VD(n);
  }
  Nu[e.formId] = Object.assign({}, e), Nu[e.formId]._vm = t, Q_(() => {
    delete Nu[e.formId], Rv();
  }), Rv();
}
const Ko = "vee-validate-inspector", di = {
  error: 12405579,
  success: 448379,
  unknown: 5522283,
  white: 16777215,
  black: 0,
  blue: 218007,
  purple: 12157168,
  orange: 16099682,
  gray: 12304330
};
let ln = null;
function ND(e) {
  Ws = e, e.addInspector({
    id: Ko,
    icon: "rule",
    label: "vee-validate",
    noSelectionText: "Select a vee-validate node to inspect",
    actions: [
      {
        icon: "done_outline",
        tooltip: "Validate selected item",
        action: async () => {
          if (!ln) {
            console.error("There is not a valid selected vee-validate node or component");
            return;
          }
          if (ln.type === "field") {
            await ln.field.validate();
            return;
          }
          if (ln.type === "form") {
            await ln.form.validate();
            return;
          }
          ln.type === "pathState" && await ln.form.validateField(ln.state.path);
        }
      },
      {
        icon: "delete_sweep",
        tooltip: "Clear validation state of the selected item",
        action: () => {
          if (!ln) {
            console.error("There is not a valid selected vee-validate node or component");
            return;
          }
          if (ln.type === "field") {
            ln.field.resetField();
            return;
          }
          ln.type === "form" && ln.form.resetForm(), ln.type === "pathState" && ln.form.resetField(ln.state.path);
        }
      }
    ]
  }), e.on.getInspectorTree((t) => {
    if (t.inspectorId !== Ko)
      return;
    const n = Object.values(Nu), i = Object.values(pk);
    t.rootNodes = [
      ...n.map(MD),
      ...i.map((r) => FD(r))
    ];
  }), e.on.getInspectorState((t, n) => {
    if (t.inspectorId !== Ko || n.currentTab !== `custom-inspector:${Ko}`)
      return;
    const { form: i, field: r, state: s, type: a } = BD(t.nodeId);
    if (i && a === "form") {
      t.state = LD(i), ln = { type: "form", form: i };
      return;
    }
    if (s && a === "pathState" && i) {
      t.state = Mw(s), ln = { type: "pathState", state: s, form: i };
      return;
    }
    if (r && a === "field") {
      t.state = Mw({
        errors: r.errors.value,
        dirty: r.meta.dirty,
        valid: r.meta.valid,
        touched: r.meta.touched,
        value: r.value.value,
        initialValue: r.meta.initialValue
      }), ln = { field: r, type: "field" };
      return;
    }
    ln = null;
  });
}
function MD(e) {
  const { textColor: t, bgColor: n } = bk(e.meta.value.valid), i = {};
  Object.values(e.getAllPathStates()).forEach((a) => {
    os(i, Ct(a.path), RD(a, e));
  });
  function r(a, o = []) {
    const l = [...o].pop();
    return "id" in a ? Object.assign(Object.assign({}, a), { label: l || a.label }) : Ga(a) ? {
      id: `${o.join(".")}`,
      label: l || "",
      children: Object.keys(a).map((u) => r(a[u], [...o, u]))
    } : Array.isArray(a) ? {
      id: `${o.join(".")}`,
      label: `${l}[]`,
      children: a.map((u, c) => r(u, [...o, String(c)]))
    } : { id: "", label: "", children: [] };
  }
  const { children: s } = r(i);
  return {
    id: xp(e),
    label: "Form",
    children: s,
    tags: [
      {
        label: "Form",
        textColor: t,
        backgroundColor: n
      },
      {
        label: `${e.getAllPathStates().length} fields`,
        textColor: di.white,
        backgroundColor: di.unknown
      }
    ]
  };
}
function RD(e, t) {
  return {
    id: xp(t, e),
    label: Ct(e.path),
    tags: yk(e.multiple, e.fieldsCount, e.type, e.valid, t)
  };
}
function FD(e, t) {
  return {
    id: xp(t, e),
    label: Ct(e.name),
    tags: yk(!1, 1, e.type, e.meta.valid, t)
  };
}
function yk(e, t, n, i, r) {
  const { textColor: s, bgColor: a } = bk(i);
  return [
    e ? void 0 : {
      label: "Field",
      textColor: s,
      backgroundColor: a
    },
    r ? void 0 : {
      label: "Standalone",
      textColor: di.black,
      backgroundColor: di.gray
    },
    n === "checkbox" ? {
      label: "Checkbox",
      textColor: di.white,
      backgroundColor: di.blue
    } : void 0,
    n === "radio" ? {
      label: "Radio",
      textColor: di.white,
      backgroundColor: di.purple
    } : void 0,
    e ? {
      label: "Multiple",
      textColor: di.black,
      backgroundColor: di.orange
    } : void 0
  ].filter(Boolean);
}
function xp(e, t) {
  const n = t ? "path" in t ? "pathState" : "field" : "form", i = t ? "path" in t ? t == null ? void 0 : t.path : Ct(t == null ? void 0 : t.name) : "", r = { f: e == null ? void 0 : e.formId, ff: i, type: n };
  return btoa(encodeURIComponent(JSON.stringify(r)));
}
function BD(e) {
  try {
    const t = JSON.parse(decodeURIComponent(atob(e))), n = Nu[t.f];
    if (!n && t.ff) {
      const r = pk[t.ff];
      return r ? {
        type: t.type,
        field: r
      } : {};
    }
    if (!n)
      return {};
    const i = n.getPathState(t.ff);
    return {
      type: t.type,
      form: n,
      state: i
    };
  } catch {
  }
  return {};
}
function Mw(e) {
  return {
    "Field state": [
      { key: "errors", value: e.errors },
      {
        key: "initialValue",
        value: e.initialValue
      },
      {
        key: "currentValue",
        value: e.value
      },
      {
        key: "touched",
        value: e.touched
      },
      {
        key: "dirty",
        value: e.dirty
      },
      {
        key: "valid",
        value: e.valid
      }
    ]
  };
}
function LD(e) {
  const { errorBag: t, meta: n, values: i, isSubmitting: r, isValidating: s, submitCount: a } = e;
  return {
    "Form state": [
      {
        key: "submitCount",
        value: a.value
      },
      {
        key: "isSubmitting",
        value: r.value
      },
      {
        key: "isValidating",
        value: s.value
      },
      {
        key: "touched",
        value: n.value.touched
      },
      {
        key: "dirty",
        value: n.value.dirty
      },
      {
        key: "valid",
        value: n.value.valid
      },
      {
        key: "initialValues",
        value: n.value.initialValues
      },
      {
        key: "currentValues",
        value: i
      },
      {
        key: "errors",
        value: ki(t.value).reduce((o, l) => {
          var u;
          const c = (u = t.value[l]) === null || u === void 0 ? void 0 : u[0];
          return c && (o[l] = c), o;
        }, {})
      }
    ]
  };
}
function bk(e) {
  return {
    bgColor: e ? di.success : di.error,
    textColor: e ? di.black : di.white
  };
}
let $D = 0;
const bd = ["bails", "fieldsCount", "id", "multiple", "type", "validate"];
function wk(e) {
  const t = (e == null ? void 0 : e.initialValues) || {}, n = Object.assign({}, Pn(t)), i = Ct(e == null ? void 0 : e.validationSchema);
  return i && Ys(i) && cr(i.cast) ? zt(i.cast(n) || {}) : zt(n);
}
function WD(e) {
  var t;
  const n = $D++;
  let i = 0;
  const r = X(!1), s = X(!1), a = X(0), o = [], l = ti(wk(e)), u = X([]), c = X({}), d = X({}), f = gD(() => {
    d.value = u.value.reduce((q, z) => (q[pd(Pn(z.path))] = z, q), {});
  });
  function h(q, z) {
    const de = $(q);
    if (!de) {
      typeof q == "string" && (c.value[pd(q)] = Vw(z));
      return;
    }
    if (typeof q == "string") {
      const P = pd(q);
      c.value[P] && delete c.value[P];
    }
    de.errors = Vw(z), de.valid = !de.errors.length;
  }
  function m(q) {
    ki(q).forEach((z) => {
      h(z, q[z]);
    });
  }
  e != null && e.initialErrors && m(e.initialErrors);
  const g = w(() => {
    const q = u.value.reduce((z, de) => (de.errors.length && (z[de.path] = de.errors), z), {});
    return Object.assign(Object.assign({}, c.value), q);
  }), p = w(() => ki(g.value).reduce((q, z) => {
    const de = g.value[z];
    return de != null && de.length && (q[z] = de[0]), q;
  }, {})), y = w(() => u.value.reduce((q, z) => (q[z.path] = { name: z.path || "", label: z.label || "" }, q), {})), k = w(() => u.value.reduce((q, z) => {
    var de;
    return q[z.path] = (de = z.bails) !== null && de !== void 0 ? de : !0, q;
  }, {})), T = Object.assign({}, (e == null ? void 0 : e.initialErrors) || {}), _ = (t = e == null ? void 0 : e.keepValuesOnUnmount) !== null && t !== void 0 ? t : !1, { initialValues: b, originalInitialValues: S, setInitialValues: C } = HD(u, l, e), x = jD(u, l, S, p), A = w(() => u.value.reduce((q, z) => {
    const de = fs(l, z.path);
    return os(q, z.path, de), q;
  }, {})), I = e == null ? void 0 : e.validationSchema;
  function E(q, z) {
    var de, P;
    const M = w(() => fs(b.value, Pn(q))), U = d.value[Pn(q)], Y = (z == null ? void 0 : z.type) === "checkbox" || (z == null ? void 0 : z.type) === "radio";
    if (U && Y) {
      U.multiple = !0;
      const qe = i++;
      return Array.isArray(U.id) ? U.id.push(qe) : U.id = [U.id, qe], U.fieldsCount++, U.__flags.pendingUnmount[qe] = !1, U;
    }
    const ce = w(() => fs(l, Pn(q))), Se = Pn(q), Ie = j.findIndex((qe) => qe === Se);
    Ie !== -1 && j.splice(Ie, 1);
    const Ne = w(() => {
      var qe, Et, Ot, ui;
      const es = Pn(I);
      if (Ys(es))
        return (Et = (qe = es.describe) === null || qe === void 0 ? void 0 : qe.call(es, Pn(q)).required) !== null && Et !== void 0 ? Et : !1;
      const va = Pn(z == null ? void 0 : z.schema);
      return Ys(va) && (ui = (Ot = va.describe) === null || Ot === void 0 ? void 0 : Ot.call(va).required) !== null && ui !== void 0 ? ui : !1;
    }), Le = i++, Ge = ti({
      id: Le,
      path: q,
      touched: !1,
      pending: !1,
      valid: !0,
      validated: !!(!((de = T[Se]) === null || de === void 0) && de.length),
      required: Ne,
      initialValue: M,
      errors: pe([]),
      bails: (P = z == null ? void 0 : z.bails) !== null && P !== void 0 ? P : !1,
      label: z == null ? void 0 : z.label,
      type: (z == null ? void 0 : z.type) || "default",
      value: ce,
      multiple: !1,
      __flags: {
        pendingUnmount: { [Le]: !1 },
        pendingReset: !1
      },
      fieldsCount: 1,
      validate: z == null ? void 0 : z.validate,
      dirty: w(() => !Du(Ct(ce), Ct(M)))
    });
    return u.value.push(Ge), d.value[Se] = Ge, f(), p.value[Se] && !T[Se] && He(() => {
      xe(Se, { mode: "silent" });
    }), ia(q) && fe(q, (qe) => {
      f();
      const Et = zt(ce.value);
      d.value[qe] = Ge, He(() => {
        os(l, qe, Et);
      });
    }), Ge;
  }
  const O = Pw(vt, 5), V = Pw(vt, 5), N = vD(async (q) => await (q === "silent" ? O() : V()), (q, [z]) => {
    const de = ki(K.errorBag.value), M = [
      .../* @__PURE__ */ new Set([...ki(q.results), ...u.value.map((U) => U.path), ...de])
    ].sort().reduce((U, Y) => {
      var ce;
      const Se = Y, Ie = $(Se) || Z(Se), Ne = ((ce = q.results[Se]) === null || ce === void 0 ? void 0 : ce.errors) || [], Le = Pn(Ie == null ? void 0 : Ie.path) || Se, Ge = zD({ errors: Ne, valid: !Ne.length }, U.results[Le]);
      return U.results[Le] = Ge, Ge.valid || (U.errors[Le] = Ge.errors[0]), Ie && c.value[Le] && delete c.value[Le], Ie ? (Ie.valid = Ge.valid, z === "silent" || z === "validated-only" && !Ie.validated || h(Ie, Ge.errors), U) : (h(Le, Ne), U);
    }, { valid: q.valid, results: {}, errors: {} });
    return q.values && (M.values = q.values), ki(M.results).forEach((U) => {
      var Y;
      const ce = $(U);
      ce && z !== "silent" && (z === "validated-only" && !ce.validated || h(ce, (Y = M.results[U]) === null || Y === void 0 ? void 0 : Y.errors));
    }), M;
  });
  function F(q) {
    u.value.forEach(q);
  }
  function $(q) {
    const z = typeof q == "string" ? pd(q) : q;
    return typeof z == "string" ? d.value[z] : z;
  }
  function Z(q) {
    return u.value.filter((de) => q.startsWith(de.path)).reduce((de, P) => de ? P.path.length > de.path.length ? P : de : P, void 0);
  }
  let j = [], H;
  function R(q) {
    return j.push(q), H || (H = He(() => {
      [...j].sort().reverse().forEach((de) => {
        Ow(l, de);
      }), j = [], H = null;
    })), H;
  }
  function L(q) {
    return function(de, P) {
      return function(U) {
        return U instanceof Event && (U.preventDefault(), U.stopPropagation()), F((Y) => Y.touched = !0), r.value = !0, a.value++, Fe().then((Y) => {
          const ce = zt(l);
          if (Y.valid && typeof de == "function") {
            const Se = zt(A.value);
            let Ie = q ? Se : ce;
            return Y.values && (Ie = Y.values), de(Ie, {
              evt: U,
              controlledValues: Se,
              setErrors: m,
              setFieldError: h,
              setTouched: te,
              setFieldTouched: Pe,
              setValues: Re,
              setFieldValue: ue,
              resetForm: Me,
              resetField: me
            });
          }
          !Y.valid && typeof P == "function" && P({
            values: ce,
            evt: U,
            errors: Y.errors,
            results: Y.results
          });
        }).then((Y) => (r.value = !1, Y), (Y) => {
          throw r.value = !1, Y;
        });
      };
    };
  }
  const oe = L(!1);
  oe.withControlled = L(!0);
  function we(q, z) {
    const de = u.value.findIndex((M) => M.path === q && (Array.isArray(M.id) ? M.id.includes(z) : M.id === z)), P = u.value[de];
    if (!(de === -1 || !P)) {
      if (He(() => {
        xe(q, { mode: "silent", warn: !1 });
      }), P.multiple && P.fieldsCount && P.fieldsCount--, Array.isArray(P.id)) {
        const M = P.id.indexOf(z);
        M >= 0 && P.id.splice(M, 1), delete P.__flags.pendingUnmount[z];
      }
      (!P.multiple || P.fieldsCount <= 0) && (u.value.splice(de, 1), ze(q), f(), delete d.value[q]);
    }
  }
  function ee(q) {
    ki(d.value).forEach((z) => {
      z.startsWith(q) && delete d.value[z];
    }), u.value = u.value.filter((z) => !z.path.startsWith(q)), He(() => {
      f();
    });
  }
  const K = {
    formId: n,
    values: l,
    controlledValues: A,
    errorBag: g,
    errors: p,
    schema: I,
    submitCount: a,
    meta: x,
    isSubmitting: r,
    isValidating: s,
    fieldArrays: o,
    keepValuesOnUnmount: _,
    validateSchema: Ct(I) ? N : void 0,
    validate: Fe,
    setFieldError: h,
    validateField: xe,
    setFieldValue: ue,
    setValues: Re,
    setErrors: m,
    setFieldTouched: Pe,
    setTouched: te,
    resetForm: Me,
    resetField: me,
    handleSubmit: oe,
    useFieldModel: Vr,
    defineInputBinds: ma,
    defineComponentBinds: li,
    defineField: On,
    stageInitialValue: Ke,
    unsetInitialValue: ze,
    setFieldInitialValue: ut,
    createPathState: E,
    getPathState: $,
    unsetPathValue: R,
    removePathState: we,
    initialValues: b,
    getAllPathStates: () => u.value,
    destroyPath: ee,
    isFieldTouched: le,
    isFieldDirty: be,
    isFieldValid: Oe
  };
  function ue(q, z, de = !0) {
    const P = zt(z), M = typeof q == "string" ? q : q.path;
    $(M) || E(M), os(l, M, P), de && xe(M);
  }
  function ve(q, z = !0) {
    ki(l).forEach((de) => {
      delete l[de];
    }), ki(q).forEach((de) => {
      ue(de, q[de], !1);
    }), z && Fe();
  }
  function Re(q, z = !0) {
    Yu(l, q), o.forEach((de) => de && de.reset()), z && Fe();
  }
  function he(q, z) {
    const de = $(Pn(q)) || E(q);
    return w({
      get() {
        return de.value;
      },
      set(P) {
        var M;
        const U = Pn(q);
        ue(U, P, (M = Pn(z)) !== null && M !== void 0 ? M : !1);
      }
    });
  }
  function Pe(q, z) {
    const de = $(q);
    de && (de.touched = z);
  }
  function le(q) {
    const z = $(q);
    return z ? z.touched : u.value.filter((de) => de.path.startsWith(q)).some((de) => de.touched);
  }
  function be(q) {
    const z = $(q);
    return z ? z.dirty : u.value.filter((de) => de.path.startsWith(q)).some((de) => de.dirty);
  }
  function Oe(q) {
    const z = $(q);
    return z ? z.valid : u.value.filter((de) => de.path.startsWith(q)).every((de) => de.valid);
  }
  function te(q) {
    if (typeof q == "boolean") {
      F((z) => {
        z.touched = q;
      });
      return;
    }
    ki(q).forEach((z) => {
      Pe(z, !!q[z]);
    });
  }
  function me(q, z) {
    var de;
    const P = z && "value" in z ? z.value : fs(b.value, q), M = $(q);
    M && (M.__flags.pendingReset = !0), ut(q, zt(P), !0), ue(q, P, !1), Pe(q, (de = z == null ? void 0 : z.touched) !== null && de !== void 0 ? de : !1), h(q, (z == null ? void 0 : z.errors) || []), He(() => {
      M && (M.__flags.pendingReset = !1);
    });
  }
  function Me(q, z) {
    let de = zt(q != null && q.values ? q.values : S.value);
    de = z != null && z.force ? de : Yu(S.value, de), de = Ys(I) && cr(I.cast) ? I.cast(de) : de, C(de), F((P) => {
      var M;
      P.__flags.pendingReset = !0, P.validated = !1, P.touched = ((M = q == null ? void 0 : q.touched) === null || M === void 0 ? void 0 : M[P.path]) || !1, ue(P.path, fs(de, P.path), !1), h(P.path, void 0);
    }), z != null && z.force ? ve(de, !1) : Re(de, !1), m((q == null ? void 0 : q.errors) || {}), a.value = (q == null ? void 0 : q.submitCount) || 0, He(() => {
      Fe({ mode: "silent" }), F((P) => {
        P.__flags.pendingReset = !1;
      });
    });
  }
  async function Fe(q) {
    const z = (q == null ? void 0 : q.mode) || "force";
    if (z === "force" && F((U) => U.validated = !0), K.validateSchema)
      return K.validateSchema(z);
    s.value = !0;
    const de = await Promise.all(u.value.map((U) => U.validate ? U.validate(q).then((Y) => ({
      key: U.path,
      valid: Y.valid,
      errors: Y.errors
    })) : Promise.resolve({
      key: U.path,
      valid: !0,
      errors: []
    })));
    s.value = !1;
    const P = {}, M = {};
    for (const U of de)
      P[U.key] = {
        valid: U.valid,
        errors: U.errors
      }, U.errors.length && (M[U.key] = U.errors[0]);
    return {
      valid: de.every((U) => U.valid),
      results: P,
      errors: M
    };
  }
  async function xe(q, z) {
    var de;
    const P = $(q);
    if (P && (z == null ? void 0 : z.mode) !== "silent" && (P.validated = !0), I) {
      const { results: U } = await N((z == null ? void 0 : z.mode) || "validated-only");
      return U[q] || { errors: [], valid: !0 };
    }
    return P != null && P.validate ? P.validate(z) : (!P && ((de = z == null ? void 0 : z.warn) !== null && de !== void 0 ? de : !0) && process.env.NODE_ENV !== "production" && xc(`field with path ${q} was not found`), Promise.resolve({ errors: [], valid: !0 }));
  }
  function ze(q) {
    Ow(b.value, q);
  }
  function Ke(q, z, de = !1) {
    ut(q, z), os(l, q, z), de && !(e != null && e.initialValues) && os(S.value, q, zt(z));
  }
  function ut(q, z, de = !1) {
    os(b.value, q, zt(z)), de && os(S.value, q, zt(z));
  }
  async function vt() {
    const q = Ct(I);
    if (!q)
      return { valid: !0, results: {}, errors: {} };
    s.value = !0;
    const z = dk(q) || Ys(q) ? await OD(q, l) : await PD(q, l, {
      names: y.value,
      bailsMap: k.value
    });
    return s.value = !1, z;
  }
  const En = oe((q, { evt: z }) => {
    hD(z) && z.target.submit();
  });
  jn(() => {
    if (e != null && e.initialErrors && m(e.initialErrors), e != null && e.initialTouched && te(e.initialTouched), e != null && e.validateOnMount) {
      Fe();
      return;
    }
    K.validateSchema && K.validateSchema("silent");
  }), ia(I) && fe(I, () => {
    var q;
    (q = K.validateSchema) === null || q === void 0 || q.call(K, "validated-only");
  }), Tt(aD, K), process.env.NODE_ENV !== "production" && (DD(K), fe(() => Object.assign(Object.assign({ errors: g.value }, x.value), { values: l, isSubmitting: r.value, isValidating: s.value, submitCount: a.value }), Rv, {
    deep: !0
  }));
  function On(q, z) {
    const de = cr(z) || z == null ? void 0 : z.label, P = $(Pn(q)) || E(q, { label: de }), M = () => cr(z) ? z(yd(P, bd)) : z || {};
    function U() {
      var Ne;
      P.touched = !0, ((Ne = M().validateOnBlur) !== null && Ne !== void 0 ? Ne : hu().validateOnBlur) && xe(P.path);
    }
    function Y() {
      var Ne;
      ((Ne = M().validateOnInput) !== null && Ne !== void 0 ? Ne : hu().validateOnInput) && He(() => {
        xe(P.path);
      });
    }
    function ce() {
      var Ne;
      ((Ne = M().validateOnChange) !== null && Ne !== void 0 ? Ne : hu().validateOnChange) && He(() => {
        xe(P.path);
      });
    }
    const Se = w(() => {
      const Ne = {
        onChange: ce,
        onInput: Y,
        onBlur: U
      };
      return cr(z) ? Object.assign(Object.assign({}, Ne), z(yd(P, bd)).props || {}) : z != null && z.props ? Object.assign(Object.assign({}, Ne), z.props(yd(P, bd))) : Ne;
    });
    return [he(q, () => {
      var Ne, Le, Ge;
      return (Ge = (Ne = M().validateOnModelUpdate) !== null && Ne !== void 0 ? Ne : (Le = hu()) === null || Le === void 0 ? void 0 : Le.validateOnModelUpdate) !== null && Ge !== void 0 ? Ge : !0;
    }), Se];
  }
  function Vr(q) {
    return Array.isArray(q) ? q.map((z) => he(z, !0)) : he(q);
  }
  function ma(q, z) {
    const [de, P] = On(q, z);
    function M() {
      P.value.onBlur();
    }
    function U(ce) {
      const Se = Dw(ce);
      ue(Pn(q), Se, !1), P.value.onInput();
    }
    function Y(ce) {
      const Se = Dw(ce);
      ue(Pn(q), Se, !1), P.value.onChange();
    }
    return w(() => Object.assign(Object.assign({}, P.value), {
      onBlur: M,
      onInput: U,
      onChange: Y,
      value: de.value
    }));
  }
  function li(q, z) {
    const [de, P] = On(q, z), M = $(Pn(q));
    function U(Y) {
      de.value = Y;
    }
    return w(() => {
      const Y = cr(z) ? z(yd(M, bd)) : z || {};
      return Object.assign({ [Y.model || "modelValue"]: de.value, [`onUpdate:${Y.model || "modelValue"}`]: U }, P.value);
    });
  }
  return Object.assign(Object.assign({}, K), { values: Ml(l), handleReset: () => Me(), submitForm: En });
}
function jD(e, t, n, i) {
  const r = {
    touched: "some",
    pending: "some",
    valid: "every"
  }, s = w(() => !Du(t, Ct(n)));
  function a() {
    const l = e.value;
    return ki(r).reduce((u, c) => {
      const d = r[c];
      return u[c] = l[d]((f) => f[c]), u;
    }, {});
  }
  const o = ti(a());
  return Wt(() => {
    const l = a();
    o.touched = l.touched, o.valid = l.valid, o.pending = l.pending;
  }), w(() => Object.assign(Object.assign({ initialValues: Ct(n) }, o), { valid: o.valid && !ki(i.value).length, dirty: s.value }));
}
function HD(e, t, n) {
  const i = wk(n), r = X(i), s = X(zt(i));
  function a(o, l = !1) {
    r.value = Yu(zt(r.value) || {}, zt(o)), s.value = Yu(zt(s.value) || {}, zt(o)), l && e.value.forEach((u) => {
      if (u.touched)
        return;
      const d = fs(r.value, u.path);
      os(t, u.path, zt(d));
    });
  }
  return {
    initialValues: r,
    originalInitialValues: s,
    setInitialValues: a
  };
}
function zD(e, t) {
  return t ? {
    valid: e.valid && t.valid,
    errors: [...e.errors, ...t.errors]
  } : e;
}
const Rw = (e) => ({
  props: {
    "error-messages": e.touched ? e.errors : [],
    "hide-details": !e.touched || e.errors.filter(
      (t) => typeof t == "string" && t.trim().length > 0
    ).length === 0 ? !1 : "auto"
  }
}), UD = ah({
  name: "VPFormLogin",
  components: {
    VPPasswordField: ik
  },
  props: {
    /**
     * The value of the username field. Accessible as a v-model using `v-model:username`.
     */
    username: {
      type: String,
      default: ""
    },
    /**
     * The value of the password field. Accessible as a v-model using `v-model:password`.
     */
    password: {
      type: String,
      default: ""
    },
    /**
     * The function to call when the form is submitted after validation.
     */
    onSubmit: {
      type: Function,
      required: !0
    },
    /**
     * The URL to which the form will be submitted. Will be passed to the function defined in the `onSubmit` prop.
     */
    action: {
      type: String,
      default: "#"
    },
    /**
     * The HTTP method to use when submitting the form. Will be passed to the function defined in the `onSubmit` prop.
     */
    method: {
      type: String,
      default: "post"
    },
    /**
     * Designates the border-radius applied to the component. This can be xs, sm, md, lg, xl or a numeric value.
     */
    border: {
      type: [String, Number, Boolean],
      default: !1
    },
    /**
     * The background color of the form. Can be the name of a theme color, a Vuetify Material Design color, or a CSS color value.
     */
    bgColor: {
      type: String,
      default: "transparent"
    },
    /**
     * Designates an elevation applied to the form between 0 and 24. You can find more information in the [Vuetify elevation documentation](https://vuetifyjs.com/en/styles/elevation/).
     */
    elevation: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Removes the form's elevation.
     */
    flat: {
      type: Boolean,
      default: !1
    },
    /**
     * Sets the height for the form.
     */
    height: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Apply a specific background image to the form.
     */
    backgroundImage: {
      type: String,
      default: void 0
    },
    /**
     * Sets the maximum height for the form.
     */
    maxHeight: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Sets the maximum width for the form.
     */
    maxWidth: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Sets the minimum height for the form.
     */
    minHeight: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Sets the minimum width for the form.
     */
    minWidth: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Sets the css positioning for the form.
     */
    position: {
      type: String,
      default: void 0
    },
    /**
     * Applies the [v-ripple](https://vuetifyjs.com/en/directives/ripple/) directive.
     */
    ripple: {
      type: [Boolean, Object],
      default: !1
    },
    /**
     * Designates the border-radius applied to the form. This can be 0, xs, sm, true, lg, xl, pill, circle, and shaped. Find more information on available border radius classes in the [Vuetify Border Radius documentation](https://vuetifyjs.com/en/styles/border-radius/).
     */
    rounded: {
      type: [Boolean, Number, String],
      default: void 0
    },
    /**
     * Specify a Vuetify theme for this form and all of its children.
     */
    theme: {
      type: String,
      default: void 0
    },
    /**
     * Removes any applied border-radius from the form.
     */
    tile: {
      type: Boolean,
      default: !1
    },
    /**
     * Applies a distinct style to the form.
     * Options are `text`, `flat`, `elevated`, `tonal`, `outlined`, and `plain`.
     */
    variant: {
      type: String,
      default: "elevated"
    },
    /**
     * Sets the width for the form.
     */
    width: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Title to be displayed on the form
     */
    title: {
      type: String,
      default: "Authentication"
    },
    /**
     * The density of the form fields.
     */
    density: {
      type: String,
      default: "default"
    },
    /**
     * The variant of the form fields.
     */
    fieldVariant: {
      type: String,
      default: "filled"
    },
    /**
     * Sets the color of the form fields when it not focused. Can be the name of a theme color, a Vuetify Material Design color, or a CSS color value.
     */
    fieldBaseColor: {
      type: String,
      default: void 0
    },
    /**
     * Set the background color of the form fields. Can be the name of a theme color, a Vuetify Material Design color, or a CSS color value.
     */
    fieldBackgroundColor: {
      type: String,
      default: void 0
    },
    /**
     * Removes elevation (shadow) added to element when using the `field-solo` or `field-solo-inverted` variants.
     */
    fieldFlat: {
      type: Boolean,
      default: !1
    },
    /**
     * Applies a border radius to the form fields
     */
    fieldRounded: {
      type: [Boolean, String, Number],
      default: void 0
    },
    /**
     * Prevents labels from moving when fields are focused on or dirty
     */
    fieldSingleLine: {
      type: Boolean,
      default: !1
    },
    /**
     * Specify a theme for the form fields and all children.
     */
    fieldTheme: {
      type: String,
      default: void 0
    },
    /**
     * Removes any applied border-radius from the form fields.
     */
    fieldTile: {
      type: Boolean,
      default: !1
    },
    /**
     * If the form fields should be clearable using a clear icon.
     */
    clearable: {
      type: Boolean,
      default: !0
    },
    /**
     * The validation function to use form the form's username field.
     */
    usernameValidator: {
      type: Function,
      required: !0
    },
    /**
     * The label to display for the username field.
     */
    usernameLabel: {
      type: String,
      default: "Username"
    },
    /**
     * The HTML5 input type to use for the username field.
     *
     * @values text, email
     */
    usernameType: {
      type: String,
      default: "text"
    },
    /**
     * The [HTML Autocomplete](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofilling-form-controls%3A-the-autocomplete-attribute) value to use for the username field.
     */
    usernameAutocomplete: {
      type: String,
      default: "username"
    },
    /**
     * Set the username field to autofocus on load.
     */
    usernameAutofocus: {
      type: Boolean,
      default: !1
    },
    /**
     * The icon to display for the username field.
     */
    usernameIcon: {
      type: String,
      default: void 0
    },
    /**
     * The position of the username icon.
     *
     * @values prepend, prepend-inner, append, append-inner
     */
    usernameIconPosition: {
      type: String,
      default: void 0
    },
    /**
     * Hint text to display when the username field is focused or `username-hint-persistent` is set.
     */
    usernameHint: {
      type: String,
      default: void 0
    },
    /**
     * Persist the hint text when the username field is not focused.
     */
    usernameHintPersistent: {
      type: Boolean,
      default: !1
    },
    /**
     * The validation function to use form the form's password field.
     */
    passwordValidator: {
      type: Function,
      required: !0
    },
    /**
     * The label to display for the password field.
     */
    passwordLabel: {
      type: String,
      default: "Password"
    },
    /**
     * The [HTML Autocomplete](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofilling-form-controls%3A-the-autocomplete-attribute) value to use for the password field.
     */
    passwordAutocomplete: {
      type: String,
      default: "current-password"
    },
    /**
     * The icon to display for the password field.
     */
    passwordIcon: {
      type: String,
      default: void 0
    },
    /**
     * The position of the password icon.
     *
     * @values prepend, prepend-inner, append
     */
    passwordIconPosition: {
      type: String,
      default: void 0
    },
    /**
     * Hint text to display when the password field is focused or `password-hint-persistent` is set.
     */
    passwordHint: {
      type: String,
      default: void 0
    },
    /**
     * Persist the hint text when the password field is not focused.
     */
    passwordHintPersistent: {
      type: Boolean,
      default: !1
    },
    /**
     * Icon to place after the content of the submission button
     */
    submitAppendIcon: {
      type: String,
      default: void 0
    },
    /**
     * Color of the submission button when not focused. Can be the name of a theme color, a Vuetify Material Design color, or a CSS color value.
     */
    submitBaseColor: {
      type: String,
      default: void 0
    },
    /**
     * Designates the border-radius applied to the submission button. This can be xs, sm, md, lg, xl or a numeric value.
     */
    submitBorder: {
      type: [String, Number, Boolean],
      default: !1
    },
    /**
     * The background color of the submission button. Can be the name of a theme color, a Vuetify Material Design color, or a CSS color value.
     */
    submitColor: {
      type: String,
      default: "primary"
    },
    /**
     * The density of the submission button.
     *
     * @values default, comfortable, compact
     */
    submitDensity: {
      type: String,
      default: "default"
    },
    /**
     * Designates an elevation applied to the submission button between 0 and 24. You can find more information in the [Vuetify elevation documentation](https://vuetifyjs.com/en/styles/elevation/).
     */
    submitElevation: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Removes the submission button's elevation.
     */
    submitFlat: {
      type: Boolean,
      default: !1
    },
    /**
     * Sets the height for the submission button.
     */
    submitHeight: {
      type: [String, Number],
      default: void 0
    },
    /**
     * Icon to place before the content of the submission button
     */
    submitPrependIcon: {
      type: String,
      default: void 0
    },
    /**
     * Applies the [v-ripple](https://vuetifyjs.com/en/directives/ripple/) directive to the submission button.
     */
    submitRipple: {
      type: [Boolean, Object],
      default: !1
    },
    /**
     * Designates the border-radius applied to the submission button. This can be 0, xs, sm, true, lg, xl, pill, circle, and shaped. Find more information on available border radius classes in the [Vuetify Border Radius documentation](https://vuetifyjs.com/en/styles/border-radius/).
     */
    submitRounded: {
      type: [Boolean, Number, String],
      default: void 0
    },
    /**
     * Set the "size" of the submission button. Can be a number, string or one of the following predefined sizes: `x-small`, `small`, `default`, `medium`, `large`, `x-large`.
     */
    submitSize: {
      type: [String, Number],
      default: "x-large"
    },
    /**
     * Change the submission button to the "slim" variant
     */
    submitSlim: {
      type: Boolean,
      default: !1
    },
    /**
     * Specify the text content of the submission button
     */
    submitText: {
      type: String,
      default: "Log In"
    },
    /**
     * Specify a Vuetify theme for the submission button.
     */
    submitTheme: {
      type: String,
      default: void 0
    },
    /**
     * Removes any applied border-radius from the submission button.
     */
    submitTile: {
      type: Boolean,
      default: !1
    },
    /**
     * Applies a distinct style to the submission button.
     */
    submitVariant: {
      type: String,
      default: "elevated"
    }
  },
  emits: [
    /**
     * Emitted when the form is submitted via the `onSubmit` function.
     *
     * @event submit
     * @property {any} result The result of the `onSubmit` function
     */
    "submit",
    /**
     * Emitted when the `onSubmit` function throws an error.
     *
     * @event submit:error
     * @property {Error} error The error that was thrown
     */
    "submit:error",
    /**
     * Emitted when the value of the `username` field is updated
     * 
     * @event update:username
     * @property {string|undefined} value The new value of the `username` field
     */
    "update:username",
    /**
     * Emitted when the value of the `password` field is updated
     * 
     * @event update:password
     * @property {string|undefined} value The new value of the `password` field
     */
    "update:password"
  ],
  setup(e, { emit: t }) {
    const n = up(e, "VPFormLogin"), i = w(() => n.action), r = w(() => n.method), s = w(() => n.border), a = w(() => n.bgColor), o = w(() => n.elevation), l = w(() => n.flat), u = w(() => n.height), c = w(() => n.backgroundImage), d = w(() => n.maxHeight), f = w(() => n.maxWidth), h = w(() => n.minHeight), m = w(() => n.minWidth), g = w(() => n.position), p = w(() => n.ripple), y = w(() => n.rounded), k = w(() => n.theme), T = w(() => n.tile), _ = w(() => n.variant), b = w(() => n.width), S = w(() => ({
      tag: "form",
      action: i.value,
      method: r.value,
      border: s.value,
      color: a.value,
      elevation: o.value,
      flat: l.value,
      height: u.value,
      image: c.value,
      maxHeight: d.value,
      maxWidth: f.value,
      minHeight: h.value,
      minWidth: m.value,
      position: g.value,
      ripple: p.value,
      rounded: y.value,
      theme: k.value,
      tile: T.value,
      variant: _.value,
      width: b.value
    })), C = w(() => n.title), x = w(() => ({
      title: C.value
    })), A = w(() => n.usernameValidator), I = w(() => n.passwordValidator), {
      handleSubmit: E,
      isSubmitting: O,
      isValidating: V,
      defineComponentBinds: N,
      errors: F,
      resetForm: $,
      resetField: Z,
      setFieldValue: j,
      setFieldTouched: H,
      setTouched: R,
      values: L
    } = WD({
      initialValues: {
        username: n.username,
        password: n.password
      },
      validationSchema: {
        username: (pt, ts) => A.value(pt, ts),
        password: (pt, ts) => I.value(pt, ts)
      }
    }), ne = w(() => n.username), oe = w(() => n.password);
    fe(() => ne.value, (pt) => {
      j("username", pt, !0);
    }), fe(() => oe.value, (pt) => {
      j("password", pt, !0);
    }), fe(() => L.username, (pt) => {
      t("update:username", pt);
    }), fe(() => L.password, (pt) => {
      t("update:password", pt);
    });
    const we = X(!1);
    let ee = new AbortController();
    const K = E(async (pt) => {
      if (!(we.value || !pt)) {
        ee && ee.abort(), ee = new AbortController(), ee.signal.addEventListener("abort", () => {
          we.value = !1;
        }), we.value = !0;
        try {
          const ts = await n.onSubmit(
            i.value,
            r.value,
            { ...pt },
            ee.signal,
            () => {
              ee.abort();
            }
          );
          t("submit", ts);
        } catch (ts) {
          t("submit:error", ts);
        }
        we.value = !1;
      }
    }), ue = (pt) => {
      pt.preventDefault(), K();
    }, ve = w(() => n.density), Re = w(() => n.fieldVariant), he = w(() => n.fieldBaseColor), Pe = w(() => n.fieldBackgroundColor), le = w(() => n.fieldFlat), be = w(() => n.fieldRounded), Oe = w(() => n.fieldSingleLine), te = w(() => n.fieldTheme), me = w(() => n.fieldTile), Me = w(() => n.clearable), Fe = w(() => n.usernameLabel), xe = w(() => n.usernameType), ze = w(() => n.usernameAutocomplete), Ke = w(() => n.usernameAutofocus), ut = w(() => n.usernameIcon), vt = w(() => n.usernameIconPosition), En = w(() => n.usernameHint), On = w(() => n.usernameHintPersistent), Vr = w(() => n.passwordLabel), ma = w(() => n.passwordAutocomplete), li = w(() => n.passwordIcon), q = w(() => n.passwordIconPosition), z = w(() => n.passwordHint), de = w(() => n.passwordHintPersistent), P = w(() => O.value), M = w(
      () => !P.value && Me.value
    ), U = w(() => {
      const pt = {};
      if (ut.value)
        switch (vt.value) {
          case "prepend":
            pt.prependIcon = ut.value;
            break;
          case "prepend-inner":
            pt.prependInnerIcon = ut.value;
            break;
          case "append":
            pt.appendIcon = ut.value;
            break;
          case "append-inner":
            pt.appendInnerIcon = ut.value;
            break;
        }
      return pt;
    }), Y = w(() => {
      const pt = {};
      if (li.value)
        switch (q.value) {
          case "prepend":
            pt.prependIcon = li.value;
            break;
          case "prepend-inner":
            pt.prependInnerIcon = li.value;
            break;
          case "append":
            pt.appendIcon = li.value;
            break;
        }
      return pt;
    }), ce = w(() => ({
      baseColor: he.value,
      bgColor: Pe.value,
      variant: Re.value,
      scrollIntoView: !0,
      density: ve.value,
      disabled: P.value,
      clearable: M.value,
      flat: le.value,
      rounded: be.value,
      fieldSingleLine: Oe.value,
      theme: te.value,
      tile: me.value
    })), Se = w(() => ({
      username: {
        ...N("username", Rw).value,
        ...ce.value,
        type: xe.value,
        label: Fe.value,
        autocomplete: ze.value,
        autofocus: Ke.value,
        ...U.value,
        hint: En.value,
        persistentHint: On.value
      },
      password: {
        ...N("password", Rw).value,
        ...ce.value,
        label: Vr.value,
        autocomplete: ma.value,
        ...Y.value,
        hint: z.value,
        persistentHint: de.value
      }
    })), Ie = w(
      () => O.value || we.value
    ), Ne = w(() => n.submitAppendIcon), Le = w(() => n.submitBaseColor), Ge = w(() => n.submitBorder), qe = w(() => n.submitColor), Et = w(() => n.submitDensity), Ot = w(() => n.submitElevation), ui = w(() => n.submitFlat), es = w(() => n.submitHeight), va = w(() => n.submitPrependIcon), Sm = w(() => n.submitRipple), km = w(() => n.submitRounded), nr = w(() => n.submitSize), Cm = w(() => n.submitSlim), Tm = w(() => n.submitText), xm = w(() => n.submitTheme), Am = w(() => n.submitTile), Im = w(() => n.submitVariant), Ps = w(() => ({
      appendIcon: Ne.value,
      baseColor: Le.value,
      border: Ge.value,
      color: qe.value,
      density: Et.value,
      elevation: Ot.value,
      flat: ui.value,
      height: es.value,
      prependIcon: va.value,
      ripple: Sm.value,
      rounded: km.value,
      size: nr.value,
      slim: Cm.value,
      text: Tm.value,
      theme: xm.value,
      tile: Am.value,
      variant: Im.value,
      disabled: V.value,
      loading: Ie.value,
      block: !0,
      type: "submit"
    }));
    return {
      formWrapperCardBindings: S,
      headerSlotBindings: x,
      form: Se,
      formIsProcessing: Ie,
      formIsValidating: V,
      resetFormFields: $,
      resetFormField: Z,
      formErrors: F,
      setFormFieldTouched: H,
      setFormTouched: R,
      submit: ue,
      submitButtonBindings: Ps
    };
  }
}), qD = /* @__PURE__ */ KE("input", {
  type: "submit",
  style: { display: "none" }
}, null, -1);
function GD(e, t, n, i, r, s) {
  const a = Nn("v-toolbar-title"), o = Nn("v-spacer"), l = Nn("v-toolbar-items"), u = Nn("v-toolbar"), c = Nn("v-divider"), d = Nn("v-text-field"), f = Nn("v-col"), h = Nn("v-row"), m = Nn("VPPasswordField"), g = Nn("v-btn"), p = Nn("v-container"), y = Nn("v-card");
  return af(), of(y, se(e.formWrapperCardBindings, {
    onSubmit: Cv(e.submit, ["stop"])
  }), {
    default: Rn(() => [
      qD,
      ns(e.$slots, "header", Rs(Fs(e.headerSlotBindings)), () => [
        v(u, {
          color: "transparent",
          density: "compact"
        }, {
          default: Rn(() => [
            v(a, null, {
              default: Rn(() => [
                wr(ep(e.title), 1)
              ]),
              _: 1
            }),
            v(o),
            v(l, null, {
              default: Rn(() => [
                ns(e.$slots, "header-actions", Rs(Fs(e.headerSlotBindings)))
              ]),
              _: 3
            })
          ]),
          _: 3
        }),
        v(c),
        ns(e.$slots, "before-fields"),
        v(p, null, {
          default: Rn(() => [
            v(h, null, {
              default: Rn(() => [
                v(f, { cols: "12" }, {
                  default: Rn(() => [
                    ns(e.$slots, "before-field-username", Rs(Fs(e.form.username))),
                    v(d, Rs(Fs(e.form.username)), null, 16),
                    ns(e.$slots, "after-field-username", Rs(Fs(e.form.username)))
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }),
            ns(e.$slots, "between-fields"),
            v(h, null, {
              default: Rn(() => [
                v(f, { cols: "12" }, {
                  default: Rn(() => [
                    v(m, Rs(Fs(e.form.password)), null, 16)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            ns(e.$slots, "before-submission"),
            v(h, null, {
              default: Rn(() => [
                v(f, { cols: "12" }, {
                  default: Rn(() => [
                    v(g, Rs(Fs(e.submitButtonBindings)), null, 16)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            ns(e.$slots, "after-submission")
          ]),
          _: 3
        })
      ])
    ]),
    _: 3
  }, 16, ["onSubmit"]);
}
const YD = /* @__PURE__ */ Sp(UD, [["render", GD]]), Fw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VPFormLogin: YD,
  VPPasswordField: ik,
  VPTextFieldCopyable: GV
}, Symbol.toStringTag, { value: "Module" }));
function ZD(e) {
  for (const t in Fw)
    e.component(t, Fw[t]);
}
const L7 = { install: ZD };
var _k = { exports: {} };
function Ap() {
}
Ap.prototype = {
  on: function(e, t, n) {
    var i = this.e || (this.e = {});
    return (i[e] || (i[e] = [])).push({
      fn: t,
      ctx: n
    }), this;
  },
  once: function(e, t, n) {
    var i = this;
    function r() {
      i.off(e, r), t.apply(n, arguments);
    }
    return r._ = t, this.on(e, r, n);
  },
  emit: function(e) {
    var t = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[e] || []).slice(), i = 0, r = n.length;
    for (i; i < r; i++)
      n[i].fn.apply(n[i].ctx, t);
    return this;
  },
  off: function(e, t) {
    var n = this.e || (this.e = {}), i = n[e], r = [];
    if (i && t)
      for (var s = 0, a = i.length; s < a; s++)
        i[s].fn !== t && i[s].fn._ !== t && r.push(i[s]);
    return r.length ? n[e] = r : delete n[e], this;
  }
};
_k.exports = Ap;
var Md = _k.exports.TinyEmitter = Ap, Ip = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, $e = (e, t, n) => (Ip(e, t, "read from private field"), n ? n.call(e) : t.get(e)), zn = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, Dr = (e, t, n, i) => (Ip(e, t, "write to private field"), i ? i.call(e, n) : t.set(e, n), n), Fi = (e, t, n) => (Ip(e, t, "access private method"), n), Wi, js, Wr, Aa, Xo, Zu, Ia, Jo, Bi, jo, Fv, Sk, Mu, mf, Rd, Bv, Fd, Lv, $v, kk, mu, Bd;
const kh = xs("Bus");
function Bw() {
  return Date.now().toString(36) + Math.random().toString(36).substring(2);
}
class Ch {
  /**
   * Create a new bus
   * @param namespace The namespace for the BroadcastChannel
   */
  constructor(t) {
    zn(this, Fv), zn(this, Mu), zn(this, Rd), zn(this, Fd), zn(this, $v), zn(this, mu), zn(this, Wi, void 0), zn(this, js, void 0), zn(this, Wr, void 0), zn(this, Aa, void 0), zn(this, Xo, void 0), zn(this, Zu, void 0), zn(this, Ia, void 0), zn(this, Jo, void 0), zn(this, Bi, void 0), zn(this, jo, void 0), Dr(this, Wi, Bw()), Dr(this, Wr, new Md()), Dr(this, Aa, new Md()), Dr(this, Xo, new Md()), Dr(this, Zu, /* @__PURE__ */ new Map()), Dr(this, Ia, X(!1)), Dr(this, Jo, X(void 0)), Dr(this, Bi, X({})), Dr(this, jo, X({})), typeof BroadcastChannel < "u" && (Dr(this, js, new BroadcastChannel(t || (window == null ? void 0 : window.location.origin) || "vueprint")), $e(this, js).onmessage = Fi(this, Fv, Sk).bind(this)), typeof window < "u" && (window.addEventListener("focus", Fi(this, Mu, mf).bind(this, !0)), window.addEventListener("blur", Fi(this, Mu, mf).bind(this, !1)), window.addEventListener("visibilitychange", Fi(this, Rd, Bv).bind(this)), Fi(this, Rd, Bv).call(this)), Fi(this, mu, Bd).call(this, "getActiveTabs", () => this.active.value), Fi(this, mu, Bd).call(this, "awaitCrossTab", async ({ event: n, args: i }) => {
      await Fi(this, Fd, Lv).call(this, n, i);
    }), kh(`Initialized Bus for tab ${$e(this, Wi)}`);
  }
  /**
   * The UUID of the tab
   */
  get uuid() {
    return $e(this, Wi);
  }
  /**
   * Whether the tab is active
   */
  get active() {
    return w(() => $e(this, Ia).value);
  }
  /**
   * Whether the tab has been inactive for too long and should have reduced functionality
   * to save user resources
   */
  get inactiveTooLong() {
    return w(() => $e(this, Ia).value === !0 || $e(this, Jo).value === void 0 ? !1 : Date.now() - $e(this, Jo).value > 6e4);
  }
  /**
   * Listen to an event
   * @param event The event to listen to
   * @param callback The callback to call when the event is emitted
   * @param options The options for listening to the event
   */
  on(t, n, i = {}) {
    if (i.local && $e(this, Wr).on(t, n), i.crossTab && $e(this, Aa).on(t, n), i.immediate) {
      let r = !1;
      const s = $e(this, Bi).value[t] ? Object.values($e(this, Bi).value[t]) : [];
      i.local && $e(this, Bi).value[t] && (r = !0, n(...s)), i.crossTab && $e(this, jo).value[t] && !r && (r = !0, n(...s));
    }
  }
  /**
   * Stop listening to an event
   * @param event The event to stop listening to
   * @param callback The callback to remove from the event
   * @param options The options for stopping listening to the event
   */
  off(t, n, i = {}) {
    i.local && $e(this, Wr).off(t, n), i.crossTab && $e(this, Aa).off(t, n);
  }
  /**
   * Listen to an event once
   * @param event The event to listen to
   * @param callback The callback to call when the event is emitted
   * @param options The options for listening to the event
   */
  once(t, n, i = {}) {
    if (i.local && $e(this, Wr).once(t, n), i.crossTab && $e(this, Aa).once(t, n), i.immediate) {
      let r = !1;
      const s = $e(this, Bi).value[t] ? Object.values($e(this, Bi).value[t]) : [];
      i.local && $e(this, Bi).value[t] && (r = !0, n(...s)), i.crossTab && $e(this, jo).value[t] && !r && (r = !0, n(...s));
    }
  }
  /**
   * Trigger an event
   * @param event The name of the event to emit
   * @param options The options for emitting the event
   * @param args The arguments to pass to the event
   */
  emit(t, n = {}, ...i) {
    var r;
    n.local && ($e(this, Wr).emit(t, ...i), $e(this, Bi).value[t] = i), n.crossTab && ((r = $e(this, js)) == null || r.postMessage(JSON.stringify({ event: t, args: i, from: $e(this, Wi) })), $e(this, jo).value[t] = i);
  }
  /**
   * Trigger an event and await for all listeners to process it
   * @param event The name of the event to await listener processing for
   * @param args The arguments to pass to the event
   * @returns A promise that resolves when all listeners have processed the event
   *
   * @remarks
   * This method is especially useful within service workers where you may need to use `event.waitUntil` to ensure that all listeners have processed the event before the service worker is terminated
   */
  await(t, n = {}, ...i) {
    const r = [];
    return n.local && r.push(Fi(this, Fd, Lv).call(this, t, i)), n.crossTab && r.push(Fi(this, $v, kk).call(this, t, i)), r.length ? Promise.all(r) : Promise.resolve();
  }
  /**
   * Make a request to all tabs and await their responses
   * @param method The method to call
   * @param payload The payload to send to the method being called
   * @param targets The uuids of the tabs to send the request to. Accepts "*" for all tabs
   * @param timeout The amount of time to wait for a response
   * @returns A map of responses from the tabs
   */
  async crossTabRequest(t, n, i = "*", r = 500) {
    if (!$e(this, js))
      throw new Error("BroadcastChannel is not available");
    const s = Bw(), a = JSON.stringify({
      event: "crossTabRequest",
      args: [s, t, n, i],
      from: $e(this, Wi)
    }), o = /* @__PURE__ */ new Map(), l = (c, d) => {
      o.set(d, c);
    }, u = new Promise((c) => {
      $e(this, Xo).on(s, l), setTimeout(c, r);
    });
    return $e(this, js).postMessage(a), await u, $e(this, Xo).off(s, l), o;
  }
  /**
   * Add a function which will handle requests for a method called by {@link BusService.crossTabRequest}
   * @param method The method which the handler will handle requests for
   * @param handler The function which will handle requests and return results
   */
  addRequestHandler(t, n) {
    if (["getActiveTabs", "awaitCrossTab"].includes(t))
      throw new Error(`Method "${t}" is protected and cannot be overridden`);
    Fi(this, mu, Bd).call(this, t, n);
  }
  /**
   * Get the active tabs
   * @param wait The time to wait before returning the active tabs
   * @returns The active tabs
   */
  async getActiveTabs(t = 500) {
    const n = /* @__PURE__ */ new Map();
    (await this.crossTabRequest("getActiveTabs", void 0, "*", t)).forEach((o, l) => {
      n.set(l, o);
    });
    const r = Array.from(n.entries());
    return r.push([$e(this, Wi), $e(this, Ia).value]), r.sort((o, l) => {
      const [u, c] = o, [d, f] = l;
      return c === f ? u.localeCompare(d, void 0, {
        numeric: !1,
        sensitivity: "base",
        ignorePunctuation: !0
      }) : c === !0 ? -1 : 1;
    }).map((o) => o[0]);
  }
  /**
   * Check if the tab is the main tab
   * @param wait The time to wait before returning the active tabs
   * @returns Whether the tab is the main tab
   */
  async isMain(t = 500) {
    const n = await this.getActiveTabs(t);
    return n.length > 0 ? n[0] === $e(this, Wi) : !1;
  }
}
Wi = /* @__PURE__ */ new WeakMap();
js = /* @__PURE__ */ new WeakMap();
Wr = /* @__PURE__ */ new WeakMap();
Aa = /* @__PURE__ */ new WeakMap();
Xo = /* @__PURE__ */ new WeakMap();
Zu = /* @__PURE__ */ new WeakMap();
Ia = /* @__PURE__ */ new WeakMap();
Jo = /* @__PURE__ */ new WeakMap();
Bi = /* @__PURE__ */ new WeakMap();
jo = /* @__PURE__ */ new WeakMap();
Fv = /* @__PURE__ */ new WeakSet();
Sk = function(e) {
  const t = e.data;
  let n, i = [], r;
  try {
    const s = JSON.parse(t);
    if (n = s.event, i = s.args, r = s.from, n === "crossTabRequest") {
      const [a, o, l, u] = i;
      if (u === "*" || u.includes($e(this, Wi))) {
        const c = $e(this, Zu).get(o);
        new Promise(async (f) => {
          let h;
          try {
            h = await (c == null ? void 0 : c(l));
          } catch (m) {
            kh(`Error handling crossTabRequest "${o}"`, m);
          }
          f(h);
        }).then((f) => {
          $e(this, js).postMessage(
            JSON.stringify({
              event: "crossTabResponse",
              args: [a, f],
              from: $e(this, Wi)
            })
          );
        });
      } else
        return;
    }
    if (n === "crossTabResponse") {
      const [a, o] = i;
      $e(this, Xo).emit(a, o, r);
      return;
    }
    $e(this, Aa).emit(n, ...i, r);
  } catch {
    return;
  }
};
Mu = /* @__PURE__ */ new WeakSet();
mf = function(e) {
  kh(`Tab is ${e ? "active" : "inactive"}`), $e(this, Ia).value = e, e ? ($e(this, Bi).value["tab:inactive"], this.emit("tab:active", { local: !0 })) : (delete $e(this, Bi).value["tab:active"], this.emit("tab:inactive", { local: !0 }), $e(this, Jo).value = Date.now()), this.emit("tab:uuid", { local: !1, crossTab: !0 }, $e(this, Wi), e);
};
Rd = /* @__PURE__ */ new WeakSet();
Bv = function() {
  typeof document > "u" || Fi(this, Mu, mf).call(this, document.visibilityState === "visible");
};
Fd = /* @__PURE__ */ new WeakSet();
Lv = function(e, t) {
  const n = [];
  return $e(this, Wr).e ? ($e(this, Wr).e[e] && $e(this, Wr).e[e].forEach(({ fn: i }) => {
    n.push(Promise.resolve(i.apply(null, t)));
  }), n.length ? Promise.all(n) : Promise.resolve()) : (["sw:fetch"].includes(e) || kh(`No local bus listeners for "${e}"`), Promise.resolve());
};
$v = /* @__PURE__ */ new WeakSet();
kk = function(e, t) {
  return new Promise((n) => {
    this.crossTabRequest("awaitCrossTab", { event: e, args: t }).then(() => {
      n(void 0);
    });
  });
};
mu = /* @__PURE__ */ new WeakSet();
Bd = function(e, t) {
  $e(this, Zu).set(e, t);
};
const KD = {
  install: (e, t) => {
    const n = new Ch(t == null ? void 0 : t.namespace);
    e.provide("bus", n), e.config.globalProperties.$bus = n;
  }
};
var Ep = { exports: {} }, al = typeof Reflect == "object" ? Reflect : null, Lw = al && typeof al.apply == "function" ? al.apply : function(t, n, i) {
  return Function.prototype.apply.call(t, n, i);
}, Ld;
al && typeof al.ownKeys == "function" ? Ld = al.ownKeys : Object.getOwnPropertySymbols ? Ld = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : Ld = function(t) {
  return Object.getOwnPropertyNames(t);
};
function XD(e) {
  console && console.warn && console.warn(e);
}
var Ck = Number.isNaN || function(t) {
  return t !== t;
};
function _t() {
  _t.init.call(this);
}
Ep.exports = _t;
Ep.exports.once = tN;
_t.EventEmitter = _t;
_t.prototype._events = void 0;
_t.prototype._eventsCount = 0;
_t.prototype._maxListeners = void 0;
var $w = 10;
function Th(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(_t, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return $w;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || Ck(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    $w = e;
  }
});
_t.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
_t.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || Ck(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function Tk(e) {
  return e._maxListeners === void 0 ? _t.defaultMaxListeners : e._maxListeners;
}
_t.prototype.getMaxListeners = function() {
  return Tk(this);
};
_t.prototype.emit = function(t) {
  for (var n = [], i = 1; i < arguments.length; i++)
    n.push(arguments[i]);
  var r = t === "error", s = this._events;
  if (s !== void 0)
    r = r && s.error === void 0;
  else if (!r)
    return !1;
  if (r) {
    var a;
    if (n.length > 0 && (a = n[0]), a instanceof Error)
      throw a;
    var o = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
    throw o.context = a, o;
  }
  var l = s[t];
  if (l === void 0)
    return !1;
  if (typeof l == "function")
    Lw(l, this, n);
  else
    for (var u = l.length, c = Ok(l, u), i = 0; i < u; ++i)
      Lw(c[i], this, n);
  return !0;
};
function xk(e, t, n, i) {
  var r, s, a;
  if (Th(n), s = e._events, s === void 0 ? (s = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (s.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    n.listener ? n.listener : n
  ), s = e._events), a = s[t]), a === void 0)
    a = s[t] = n, ++e._eventsCount;
  else if (typeof a == "function" ? a = s[t] = i ? [n, a] : [a, n] : i ? a.unshift(n) : a.push(n), r = Tk(e), r > 0 && a.length > r && !a.warned) {
    a.warned = !0;
    var o = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    o.name = "MaxListenersExceededWarning", o.emitter = e, o.type = t, o.count = a.length, XD(o);
  }
  return e;
}
_t.prototype.addListener = function(t, n) {
  return xk(this, t, n, !1);
};
_t.prototype.on = _t.prototype.addListener;
_t.prototype.prependListener = function(t, n) {
  return xk(this, t, n, !0);
};
function JD() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function Ak(e, t, n) {
  var i = { fired: !1, wrapFn: void 0, target: e, type: t, listener: n }, r = JD.bind(i);
  return r.listener = n, i.wrapFn = r, r;
}
_t.prototype.once = function(t, n) {
  return Th(n), this.on(t, Ak(this, t, n)), this;
};
_t.prototype.prependOnceListener = function(t, n) {
  return Th(n), this.prependListener(t, Ak(this, t, n)), this;
};
_t.prototype.removeListener = function(t, n) {
  var i, r, s, a, o;
  if (Th(n), r = this._events, r === void 0)
    return this;
  if (i = r[t], i === void 0)
    return this;
  if (i === n || i.listener === n)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete r[t], r.removeListener && this.emit("removeListener", t, i.listener || n));
  else if (typeof i != "function") {
    for (s = -1, a = i.length - 1; a >= 0; a--)
      if (i[a] === n || i[a].listener === n) {
        o = i[a].listener, s = a;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? i.shift() : QD(i, s), i.length === 1 && (r[t] = i[0]), r.removeListener !== void 0 && this.emit("removeListener", t, o || n);
  }
  return this;
};
_t.prototype.off = _t.prototype.removeListener;
_t.prototype.removeAllListeners = function(t) {
  var n, i, r;
  if (i = this._events, i === void 0)
    return this;
  if (i.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : i[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete i[t]), this;
  if (arguments.length === 0) {
    var s = Object.keys(i), a;
    for (r = 0; r < s.length; ++r)
      a = s[r], a !== "removeListener" && this.removeAllListeners(a);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (n = i[t], typeof n == "function")
    this.removeListener(t, n);
  else if (n !== void 0)
    for (r = n.length - 1; r >= 0; r--)
      this.removeListener(t, n[r]);
  return this;
};
function Ik(e, t, n) {
  var i = e._events;
  if (i === void 0)
    return [];
  var r = i[t];
  return r === void 0 ? [] : typeof r == "function" ? n ? [r.listener || r] : [r] : n ? eN(r) : Ok(r, r.length);
}
_t.prototype.listeners = function(t) {
  return Ik(this, t, !0);
};
_t.prototype.rawListeners = function(t) {
  return Ik(this, t, !1);
};
_t.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : Ek.call(e, t);
};
_t.prototype.listenerCount = Ek;
function Ek(e) {
  var t = this._events;
  if (t !== void 0) {
    var n = t[e];
    if (typeof n == "function")
      return 1;
    if (n !== void 0)
      return n.length;
  }
  return 0;
}
_t.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Ld(this._events) : [];
};
function Ok(e, t) {
  for (var n = new Array(t), i = 0; i < t; ++i)
    n[i] = e[i];
  return n;
}
function QD(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function eN(e) {
  for (var t = new Array(e.length), n = 0; n < t.length; ++n)
    t[n] = e[n].listener || e[n];
  return t;
}
function tN(e, t) {
  return new Promise(function(n, i) {
    function r(a) {
      e.removeListener(t, s), i(a);
    }
    function s() {
      typeof e.removeListener == "function" && e.removeListener("error", r), n([].slice.call(arguments));
    }
    Pk(e, t, s, { once: !0 }), t !== "error" && nN(e, r, { once: !0 });
  });
}
function nN(e, t, n) {
  typeof e.on == "function" && Pk(e, "error", t, n);
}
function Pk(e, t, n, i) {
  if (typeof e.on == "function")
    i.once ? e.once(t, n) : e.on(t, n);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function r(s) {
      i.once && e.removeEventListener(t, r), n(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var iN = Ep.exports;
class wo extends Error {
}
class rN extends wo {
  constructor(t) {
    super(`Invalid DateTime: ${t.toMessage()}`);
  }
}
class sN extends wo {
  constructor(t) {
    super(`Invalid Interval: ${t.toMessage()}`);
  }
}
class aN extends wo {
  constructor(t) {
    super(`Invalid Duration: ${t.toMessage()}`);
  }
}
class Qo extends wo {
}
class Vk extends wo {
  constructor(t) {
    super(`Invalid unit ${t}`);
  }
}
class hi extends wo {
}
class Vs extends wo {
  constructor() {
    super("Zone is an abstract class");
  }
}
const Ce = "numeric", Sr = "short", xi = "long", vf = {
  year: Ce,
  month: Ce,
  day: Ce
}, Dk = {
  year: Ce,
  month: Sr,
  day: Ce
}, oN = {
  year: Ce,
  month: Sr,
  day: Ce,
  weekday: Sr
}, Nk = {
  year: Ce,
  month: xi,
  day: Ce
}, Mk = {
  year: Ce,
  month: xi,
  day: Ce,
  weekday: xi
}, Rk = {
  hour: Ce,
  minute: Ce
}, Fk = {
  hour: Ce,
  minute: Ce,
  second: Ce
}, Bk = {
  hour: Ce,
  minute: Ce,
  second: Ce,
  timeZoneName: Sr
}, Lk = {
  hour: Ce,
  minute: Ce,
  second: Ce,
  timeZoneName: xi
}, $k = {
  hour: Ce,
  minute: Ce,
  hourCycle: "h23"
}, Wk = {
  hour: Ce,
  minute: Ce,
  second: Ce,
  hourCycle: "h23"
}, jk = {
  hour: Ce,
  minute: Ce,
  second: Ce,
  hourCycle: "h23",
  timeZoneName: Sr
}, Hk = {
  hour: Ce,
  minute: Ce,
  second: Ce,
  hourCycle: "h23",
  timeZoneName: xi
}, zk = {
  year: Ce,
  month: Ce,
  day: Ce,
  hour: Ce,
  minute: Ce
}, Uk = {
  year: Ce,
  month: Ce,
  day: Ce,
  hour: Ce,
  minute: Ce,
  second: Ce
}, qk = {
  year: Ce,
  month: Sr,
  day: Ce,
  hour: Ce,
  minute: Ce
}, Gk = {
  year: Ce,
  month: Sr,
  day: Ce,
  hour: Ce,
  minute: Ce,
  second: Ce
}, lN = {
  year: Ce,
  month: Sr,
  day: Ce,
  weekday: Sr,
  hour: Ce,
  minute: Ce
}, Yk = {
  year: Ce,
  month: xi,
  day: Ce,
  hour: Ce,
  minute: Ce,
  timeZoneName: Sr
}, Zk = {
  year: Ce,
  month: xi,
  day: Ce,
  hour: Ce,
  minute: Ce,
  second: Ce,
  timeZoneName: Sr
}, Kk = {
  year: Ce,
  month: xi,
  day: Ce,
  weekday: xi,
  hour: Ce,
  minute: Ce,
  timeZoneName: xi
}, Xk = {
  year: Ce,
  month: xi,
  day: Ce,
  weekday: xi,
  hour: Ce,
  minute: Ce,
  second: Ce,
  timeZoneName: xi
};
class Dc {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new Vs();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new Vs();
  }
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new Vs();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(t, n) {
    throw new Vs();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(t, n) {
    throw new Vs();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(t) {
    throw new Vs();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(t) {
    throw new Vs();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new Vs();
  }
}
let Ym = null;
class xh extends Dc {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    return Ym === null && (Ym = new xh()), Ym;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(t, { format: n, locale: i }) {
    return aC(t, n, i);
  }
  /** @override **/
  formatOffset(t, n) {
    return Ru(this.offset(t), n);
  }
  /** @override **/
  offset(t) {
    return -new Date(t).getTimezoneOffset();
  }
  /** @override **/
  equals(t) {
    return t.type === "system";
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
let $d = {};
function uN(e) {
  return $d[e] || ($d[e] = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: e,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  })), $d[e];
}
const cN = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function dN(e, t) {
  const n = e.format(t).replace(/\u200E/g, ""), i = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(n), [, r, s, a, o, l, u, c] = i;
  return [a, r, s, o, l, u, c];
}
function fN(e, t) {
  const n = e.formatToParts(t), i = [];
  for (let r = 0; r < n.length; r++) {
    const { type: s, value: a } = n[r], o = cN[s];
    s === "era" ? i[o] = a : Ue(o) || (i[o] = parseInt(a, 10));
  }
  return i;
}
let wd = {};
class ys extends Dc {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(t) {
    return wd[t] || (wd[t] = new ys(t)), wd[t];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    wd = {}, $d = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(t) {
    return this.isValidZone(t);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(t) {
    if (!t)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: t }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(t) {
    super(), this.zoneName = t, this.valid = ys.isValidZone(t);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(t, { format: n, locale: i }) {
    return aC(t, n, i, this.name);
  }
  /** @override **/
  formatOffset(t, n) {
    return Ru(this.offset(t), n);
  }
  /** @override **/
  offset(t) {
    const n = new Date(t);
    if (isNaN(n))
      return NaN;
    const i = uN(this.name);
    let [r, s, a, o, l, u, c] = i.formatToParts ? fN(i, n) : dN(i, n);
    o === "BC" && (r = -Math.abs(r) + 1);
    const f = Ih({
      year: r,
      month: s,
      day: a,
      hour: l === 24 ? 0 : l,
      minute: u,
      second: c,
      millisecond: 0
    });
    let h = +n;
    const m = h % 1e3;
    return h -= m >= 0 ? m : 1e3 + m, (f - h) / (60 * 1e3);
  }
  /** @override **/
  equals(t) {
    return t.type === "iana" && t.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
}
let Ww = {};
function hN(e, t = {}) {
  const n = JSON.stringify([e, t]);
  let i = Ww[n];
  return i || (i = new Intl.ListFormat(e, t), Ww[n] = i), i;
}
let Wv = {};
function jv(e, t = {}) {
  const n = JSON.stringify([e, t]);
  let i = Wv[n];
  return i || (i = new Intl.DateTimeFormat(e, t), Wv[n] = i), i;
}
let Hv = {};
function mN(e, t = {}) {
  const n = JSON.stringify([e, t]);
  let i = Hv[n];
  return i || (i = new Intl.NumberFormat(e, t), Hv[n] = i), i;
}
let zv = {};
function vN(e, t = {}) {
  const { base: n, ...i } = t, r = JSON.stringify([e, i]);
  let s = zv[r];
  return s || (s = new Intl.RelativeTimeFormat(e, t), zv[r] = s), s;
}
let vu = null;
function gN() {
  return vu || (vu = new Intl.DateTimeFormat().resolvedOptions().locale, vu);
}
let jw = {};
function pN(e) {
  let t = jw[e];
  if (!t) {
    const n = new Intl.Locale(e);
    t = "getWeekInfo" in n ? n.getWeekInfo() : n.weekInfo, jw[e] = t;
  }
  return t;
}
function yN(e) {
  const t = e.indexOf("-x-");
  t !== -1 && (e = e.substring(0, t));
  const n = e.indexOf("-u-");
  if (n === -1)
    return [e];
  {
    let i, r;
    try {
      i = jv(e).resolvedOptions(), r = e;
    } catch {
      const l = e.substring(0, n);
      i = jv(l).resolvedOptions(), r = l;
    }
    const { numberingSystem: s, calendar: a } = i;
    return [r, s, a];
  }
}
function bN(e, t, n) {
  return (n || t) && (e.includes("-u-") || (e += "-u"), n && (e += `-ca-${n}`), t && (e += `-nu-${t}`)), e;
}
function wN(e) {
  const t = [];
  for (let n = 1; n <= 12; n++) {
    const i = Be.utc(2009, n, 1);
    t.push(e(i));
  }
  return t;
}
function _N(e) {
  const t = [];
  for (let n = 1; n <= 7; n++) {
    const i = Be.utc(2016, 11, 13 + n);
    t.push(e(i));
  }
  return t;
}
function _d(e, t, n, i) {
  const r = e.listingMode();
  return r === "error" ? null : r === "en" ? n(t) : i(t);
}
function SN(e) {
  return e.numberingSystem && e.numberingSystem !== "latn" ? !1 : e.numberingSystem === "latn" || !e.locale || e.locale.startsWith("en") || new Intl.DateTimeFormat(e.intl).resolvedOptions().numberingSystem === "latn";
}
class kN {
  constructor(t, n, i) {
    this.padTo = i.padTo || 0, this.floor = i.floor || !1;
    const { padTo: r, floor: s, ...a } = i;
    if (!n || Object.keys(a).length > 0) {
      const o = { useGrouping: !1, ...i };
      i.padTo > 0 && (o.minimumIntegerDigits = i.padTo), this.inf = mN(t, o);
    }
  }
  format(t) {
    if (this.inf) {
      const n = this.floor ? Math.floor(t) : t;
      return this.inf.format(n);
    } else {
      const n = this.floor ? Math.floor(t) : Dp(t, 3);
      return cn(n, this.padTo);
    }
  }
}
class CN {
  constructor(t, n, i) {
    this.opts = i, this.originalZone = void 0;
    let r;
    if (this.opts.timeZone)
      this.dt = t;
    else if (t.zone.type === "fixed") {
      const a = -1 * (t.offset / 60), o = a >= 0 ? `Etc/GMT+${a}` : `Etc/GMT${a}`;
      t.offset !== 0 && ys.create(o).valid ? (r = o, this.dt = t) : (r = "UTC", this.dt = t.offset === 0 ? t : t.setZone("UTC").plus({ minutes: t.offset }), this.originalZone = t.zone);
    } else
      t.zone.type === "system" ? this.dt = t : t.zone.type === "iana" ? (this.dt = t, r = t.zone.name) : (r = "UTC", this.dt = t.setZone("UTC").plus({ minutes: t.offset }), this.originalZone = t.zone);
    const s = { ...this.opts };
    s.timeZone = s.timeZone || r, this.dtf = jv(n, s);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: t }) => t).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const t = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? t.map((n) => {
      if (n.type === "timeZoneName") {
        const i = this.originalZone.offsetName(this.dt.ts, {
          locale: this.dt.locale,
          format: this.opts.timeZoneName
        });
        return {
          ...n,
          value: i
        };
      } else
        return n;
    }) : t;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class TN {
  constructor(t, n, i) {
    this.opts = { style: "long", ...i }, !n && rC() && (this.rtf = vN(t, i));
  }
  format(t, n) {
    return this.rtf ? this.rtf.format(t, n) : UN(n, t, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(t, n) {
    return this.rtf ? this.rtf.formatToParts(t, n) : [];
  }
}
const xN = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
class bt {
  static fromOpts(t) {
    return bt.create(
      t.locale,
      t.numberingSystem,
      t.outputCalendar,
      t.weekSettings,
      t.defaultToEN
    );
  }
  static create(t, n, i, r, s = !1) {
    const a = t || nn.defaultLocale, o = a || (s ? "en-US" : gN()), l = n || nn.defaultNumberingSystem, u = i || nn.defaultOutputCalendar, c = Uv(r) || nn.defaultWeekSettings;
    return new bt(o, l, u, c, a);
  }
  static resetCache() {
    vu = null, Wv = {}, Hv = {}, zv = {};
  }
  static fromObject({ locale: t, numberingSystem: n, outputCalendar: i, weekSettings: r } = {}) {
    return bt.create(t, n, i, r);
  }
  constructor(t, n, i, r, s) {
    const [a, o, l] = yN(t);
    this.locale = a, this.numberingSystem = n || o || null, this.outputCalendar = i || l || null, this.weekSettings = r, this.intl = bN(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = s, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = SN(this)), this.fastNumbersCached;
  }
  listingMode() {
    const t = this.isEnglish(), n = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return t && n ? "en" : "intl";
  }
  clone(t) {
    return !t || Object.getOwnPropertyNames(t).length === 0 ? this : bt.create(
      t.locale || this.specifiedLocale,
      t.numberingSystem || this.numberingSystem,
      t.outputCalendar || this.outputCalendar,
      Uv(t.weekSettings) || this.weekSettings,
      t.defaultToEN || !1
    );
  }
  redefaultToEN(t = {}) {
    return this.clone({ ...t, defaultToEN: !0 });
  }
  redefaultToSystem(t = {}) {
    return this.clone({ ...t, defaultToEN: !1 });
  }
  months(t, n = !1) {
    return _d(this, t, uC, () => {
      const i = n ? { month: t, day: "numeric" } : { month: t }, r = n ? "format" : "standalone";
      return this.monthsCache[r][t] || (this.monthsCache[r][t] = wN((s) => this.extract(s, i, "month"))), this.monthsCache[r][t];
    });
  }
  weekdays(t, n = !1) {
    return _d(this, t, fC, () => {
      const i = n ? { weekday: t, year: "numeric", month: "long", day: "numeric" } : { weekday: t }, r = n ? "format" : "standalone";
      return this.weekdaysCache[r][t] || (this.weekdaysCache[r][t] = _N(
        (s) => this.extract(s, i, "weekday")
      )), this.weekdaysCache[r][t];
    });
  }
  meridiems() {
    return _d(
      this,
      void 0,
      () => hC,
      () => {
        if (!this.meridiemCache) {
          const t = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [Be.utc(2016, 11, 13, 9), Be.utc(2016, 11, 13, 19)].map(
            (n) => this.extract(n, t, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(t) {
    return _d(this, t, mC, () => {
      const n = { era: t };
      return this.eraCache[t] || (this.eraCache[t] = [Be.utc(-40, 1, 1), Be.utc(2017, 1, 1)].map(
        (i) => this.extract(i, n, "era")
      )), this.eraCache[t];
    });
  }
  extract(t, n, i) {
    const r = this.dtFormatter(t, n), s = r.formatToParts(), a = s.find((o) => o.type.toLowerCase() === i);
    return a ? a.value : null;
  }
  numberFormatter(t = {}) {
    return new kN(this.intl, t.forceSimple || this.fastNumbers, t);
  }
  dtFormatter(t, n = {}) {
    return new CN(t, this.intl, n);
  }
  relFormatter(t = {}) {
    return new TN(this.intl, this.isEnglish(), t);
  }
  listFormatter(t = {}) {
    return hN(this.intl, t);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    return this.weekSettings ? this.weekSettings : sC() ? pN(this.locale) : xN;
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(t) {
    return this.locale === t.locale && this.numberingSystem === t.numberingSystem && this.outputCalendar === t.outputCalendar;
  }
}
let Zm = null;
class ni extends Dc {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    return Zm === null && (Zm = new ni(0)), Zm;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(t) {
    return t === 0 ? ni.utcInstance : new ni(t);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(t) {
    if (t) {
      const n = t.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (n)
        return new ni(Eh(n[1], n[2]));
    }
    return null;
  }
  constructor(t) {
    super(), this.fixed = t;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${Ru(this.fixed, "narrow")}`;
  }
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${Ru(-this.fixed, "narrow")}`;
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(t, n) {
    return Ru(this.fixed, n);
  }
  /** @override **/
  get isUniversal() {
    return !0;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(t) {
    return t.type === "fixed" && t.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
class AN extends Dc {
  constructor(t) {
    super(), this.zoneName = t;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return !1;
  }
  /** @override **/
  get isValid() {
    return !1;
  }
}
function Us(e, t) {
  if (Ue(e) || e === null)
    return t;
  if (e instanceof Dc)
    return e;
  if (ON(e)) {
    const n = e.toLowerCase();
    return n === "default" ? t : n === "local" || n === "system" ? xh.instance : n === "utc" || n === "gmt" ? ni.utcInstance : ni.parseSpecifier(n) || ys.create(e);
  } else
    return ja(e) ? ni.instance(e) : typeof e == "object" && "offset" in e && typeof e.offset == "function" ? e : new AN(e);
}
let Hw = () => Date.now(), zw = "system", Uw = null, qw = null, Gw = null, Yw = 60, Zw, Kw = null;
class nn {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return Hw;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(t) {
    Hw = t;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(t) {
    zw = t;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return Us(zw, xh.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return Uw;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(t) {
    Uw = t;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return qw;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(t) {
    qw = t;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return Gw;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(t) {
    Gw = t;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return Kw;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(t) {
    Kw = Uv(t);
  }
  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return Yw;
  }
  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(t) {
    Yw = t % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return Zw;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    Zw = t;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    bt.resetCache(), ys.resetCache();
  }
}
class hr {
  constructor(t, n) {
    this.reason = t, this.explanation = n;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
const Jk = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Qk = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function zi(e, t) {
  return new hr(
    "unit out of range",
    `you specified ${t} (of type ${typeof t}) as a ${e}, which is invalid`
  );
}
function Op(e, t, n) {
  const i = new Date(Date.UTC(e, t - 1, n));
  e < 100 && e >= 0 && i.setUTCFullYear(i.getUTCFullYear() - 1900);
  const r = i.getUTCDay();
  return r === 0 ? 7 : r;
}
function eC(e, t, n) {
  return n + (Nc(e) ? Qk : Jk)[t - 1];
}
function tC(e, t) {
  const n = Nc(e) ? Qk : Jk, i = n.findIndex((s) => s < t), r = t - n[i];
  return { month: i + 1, day: r };
}
function Pp(e, t) {
  return (e - t + 7) % 7 + 1;
}
function gf(e, t = 4, n = 1) {
  const { year: i, month: r, day: s } = e, a = eC(i, r, s), o = Pp(Op(i, r, s), n);
  let l = Math.floor((a - o + 14 - t) / 7), u;
  return l < 1 ? (u = i - 1, l = Ku(u, t, n)) : l > Ku(i, t, n) ? (u = i + 1, l = 1) : u = i, { weekYear: u, weekNumber: l, weekday: o, ...Oh(e) };
}
function Xw(e, t = 4, n = 1) {
  const { weekYear: i, weekNumber: r, weekday: s } = e, a = Pp(Op(i, 1, t), n), o = ol(i);
  let l = r * 7 + s - a - 7 + t, u;
  l < 1 ? (u = i - 1, l += ol(u)) : l > o ? (u = i + 1, l -= ol(i)) : u = i;
  const { month: c, day: d } = tC(u, l);
  return { year: u, month: c, day: d, ...Oh(e) };
}
function Km(e) {
  const { year: t, month: n, day: i } = e, r = eC(t, n, i);
  return { year: t, ordinal: r, ...Oh(e) };
}
function Jw(e) {
  const { year: t, ordinal: n } = e, { month: i, day: r } = tC(t, n);
  return { year: t, month: i, day: r, ...Oh(e) };
}
function Qw(e, t) {
  if (!Ue(e.localWeekday) || !Ue(e.localWeekNumber) || !Ue(e.localWeekYear)) {
    if (!Ue(e.weekday) || !Ue(e.weekNumber) || !Ue(e.weekYear))
      throw new Qo(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    return Ue(e.localWeekday) || (e.weekday = e.localWeekday), Ue(e.localWeekNumber) || (e.weekNumber = e.localWeekNumber), Ue(e.localWeekYear) || (e.weekYear = e.localWeekYear), delete e.localWeekday, delete e.localWeekNumber, delete e.localWeekYear, {
      minDaysInFirstWeek: t.getMinDaysInFirstWeek(),
      startOfWeek: t.getStartOfWeek()
    };
  } else
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
}
function IN(e, t = 4, n = 1) {
  const i = Ah(e.weekYear), r = Ui(
    e.weekNumber,
    1,
    Ku(e.weekYear, t, n)
  ), s = Ui(e.weekday, 1, 7);
  return i ? r ? s ? !1 : zi("weekday", e.weekday) : zi("week", e.weekNumber) : zi("weekYear", e.weekYear);
}
function EN(e) {
  const t = Ah(e.year), n = Ui(e.ordinal, 1, ol(e.year));
  return t ? n ? !1 : zi("ordinal", e.ordinal) : zi("year", e.year);
}
function nC(e) {
  const t = Ah(e.year), n = Ui(e.month, 1, 12), i = Ui(e.day, 1, pf(e.year, e.month));
  return t ? n ? i ? !1 : zi("day", e.day) : zi("month", e.month) : zi("year", e.year);
}
function iC(e) {
  const { hour: t, minute: n, second: i, millisecond: r } = e, s = Ui(t, 0, 23) || t === 24 && n === 0 && i === 0 && r === 0, a = Ui(n, 0, 59), o = Ui(i, 0, 59), l = Ui(r, 0, 999);
  return s ? a ? o ? l ? !1 : zi("millisecond", r) : zi("second", i) : zi("minute", n) : zi("hour", t);
}
function Ue(e) {
  return typeof e > "u";
}
function ja(e) {
  return typeof e == "number";
}
function Ah(e) {
  return typeof e == "number" && e % 1 === 0;
}
function ON(e) {
  return typeof e == "string";
}
function PN(e) {
  return Object.prototype.toString.call(e) === "[object Date]";
}
function rC() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function sC() {
  try {
    return typeof Intl < "u" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch {
    return !1;
  }
}
function VN(e) {
  return Array.isArray(e) ? e : [e];
}
function e0(e, t, n) {
  if (e.length !== 0)
    return e.reduce((i, r) => {
      const s = [t(r), r];
      return i && n(i[0], s[0]) === i[0] ? i : s;
    }, null)[1];
}
function DN(e, t) {
  return t.reduce((n, i) => (n[i] = e[i], n), {});
}
function yl(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function Uv(e) {
  if (e == null)
    return null;
  if (typeof e != "object")
    throw new hi("Week settings must be an object");
  if (!Ui(e.firstDay, 1, 7) || !Ui(e.minimalDays, 1, 7) || !Array.isArray(e.weekend) || e.weekend.some((t) => !Ui(t, 1, 7)))
    throw new hi("Invalid week settings");
  return {
    firstDay: e.firstDay,
    minimalDays: e.minimalDays,
    weekend: Array.from(e.weekend)
  };
}
function Ui(e, t, n) {
  return Ah(e) && e >= t && e <= n;
}
function NN(e, t) {
  return e - t * Math.floor(e / t);
}
function cn(e, t = 2) {
  const n = e < 0;
  let i;
  return n ? i = "-" + ("" + -e).padStart(t, "0") : i = ("" + e).padStart(t, "0"), i;
}
function Hs(e) {
  if (!(Ue(e) || e === null || e === ""))
    return parseInt(e, 10);
}
function ba(e) {
  if (!(Ue(e) || e === null || e === ""))
    return parseFloat(e);
}
function Vp(e) {
  if (!(Ue(e) || e === null || e === "")) {
    const t = parseFloat("0." + e) * 1e3;
    return Math.floor(t);
  }
}
function Dp(e, t, n = !1) {
  const i = 10 ** t;
  return (n ? Math.trunc : Math.round)(e * i) / i;
}
function Nc(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function ol(e) {
  return Nc(e) ? 366 : 365;
}
function pf(e, t) {
  const n = NN(t - 1, 12) + 1, i = e + (t - n) / 12;
  return n === 2 ? Nc(i) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][n - 1];
}
function Ih(e) {
  let t = Date.UTC(
    e.year,
    e.month - 1,
    e.day,
    e.hour,
    e.minute,
    e.second,
    e.millisecond
  );
  return e.year < 100 && e.year >= 0 && (t = new Date(t), t.setUTCFullYear(e.year, e.month - 1, e.day)), +t;
}
function t0(e, t, n) {
  return -Pp(Op(e, 1, t), n) + t - 1;
}
function Ku(e, t = 4, n = 1) {
  const i = t0(e, t, n), r = t0(e + 1, t, n);
  return (ol(e) - i + r) / 7;
}
function qv(e) {
  return e > 99 ? e : e > nn.twoDigitCutoffYear ? 1900 + e : 2e3 + e;
}
function aC(e, t, n, i = null) {
  const r = new Date(e), s = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  i && (s.timeZone = i);
  const a = { timeZoneName: t, ...s }, o = new Intl.DateTimeFormat(n, a).formatToParts(r).find((l) => l.type.toLowerCase() === "timezonename");
  return o ? o.value : null;
}
function Eh(e, t) {
  let n = parseInt(e, 10);
  Number.isNaN(n) && (n = 0);
  const i = parseInt(t, 10) || 0, r = n < 0 || Object.is(n, -0) ? -i : i;
  return n * 60 + r;
}
function oC(e) {
  const t = Number(e);
  if (typeof e == "boolean" || e === "" || Number.isNaN(t))
    throw new hi(`Invalid unit value ${e}`);
  return t;
}
function yf(e, t) {
  const n = {};
  for (const i in e)
    if (yl(e, i)) {
      const r = e[i];
      if (r == null)
        continue;
      n[t(i)] = oC(r);
    }
  return n;
}
function Ru(e, t) {
  const n = Math.trunc(Math.abs(e / 60)), i = Math.trunc(Math.abs(e % 60)), r = e >= 0 ? "+" : "-";
  switch (t) {
    case "short":
      return `${r}${cn(n, 2)}:${cn(i, 2)}`;
    case "narrow":
      return `${r}${n}${i > 0 ? `:${i}` : ""}`;
    case "techie":
      return `${r}${cn(n, 2)}${cn(i, 2)}`;
    default:
      throw new RangeError(`Value format ${t} is out of range for property format`);
  }
}
function Oh(e) {
  return DN(e, ["hour", "minute", "second", "millisecond"]);
}
const MN = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], lC = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], RN = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function uC(e) {
  switch (e) {
    case "narrow":
      return [...RN];
    case "short":
      return [...lC];
    case "long":
      return [...MN];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const cC = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], dC = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], FN = ["M", "T", "W", "T", "F", "S", "S"];
function fC(e) {
  switch (e) {
    case "narrow":
      return [...FN];
    case "short":
      return [...dC];
    case "long":
      return [...cC];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const hC = ["AM", "PM"], BN = ["Before Christ", "Anno Domini"], LN = ["BC", "AD"], $N = ["B", "A"];
function mC(e) {
  switch (e) {
    case "narrow":
      return [...$N];
    case "short":
      return [...LN];
    case "long":
      return [...BN];
    default:
      return null;
  }
}
function WN(e) {
  return hC[e.hour < 12 ? 0 : 1];
}
function jN(e, t) {
  return fC(t)[e.weekday - 1];
}
function HN(e, t) {
  return uC(t)[e.month - 1];
}
function zN(e, t) {
  return mC(t)[e.year < 0 ? 0 : 1];
}
function UN(e, t, n = "always", i = !1) {
  const r = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, s = ["hours", "minutes", "seconds"].indexOf(e) === -1;
  if (n === "auto" && s) {
    const d = e === "days";
    switch (t) {
      case 1:
        return d ? "tomorrow" : `next ${r[e][0]}`;
      case -1:
        return d ? "yesterday" : `last ${r[e][0]}`;
      case 0:
        return d ? "today" : `this ${r[e][0]}`;
    }
  }
  const a = Object.is(t, -0) || t < 0, o = Math.abs(t), l = o === 1, u = r[e], c = i ? l ? u[1] : u[2] || u[1] : l ? r[e][0] : e;
  return a ? `${o} ${c} ago` : `in ${o} ${c}`;
}
function n0(e, t) {
  let n = "";
  for (const i of e)
    i.literal ? n += i.val : n += t(i.val);
  return n;
}
const qN = {
  D: vf,
  DD: Dk,
  DDD: Nk,
  DDDD: Mk,
  t: Rk,
  tt: Fk,
  ttt: Bk,
  tttt: Lk,
  T: $k,
  TT: Wk,
  TTT: jk,
  TTTT: Hk,
  f: zk,
  ff: qk,
  fff: Yk,
  ffff: Kk,
  F: Uk,
  FF: Gk,
  FFF: Zk,
  FFFF: Xk
};
class Un {
  static create(t, n = {}) {
    return new Un(t, n);
  }
  static parseFormat(t) {
    let n = null, i = "", r = !1;
    const s = [];
    for (let a = 0; a < t.length; a++) {
      const o = t.charAt(a);
      o === "'" ? (i.length > 0 && s.push({ literal: r || /^\s+$/.test(i), val: i }), n = null, i = "", r = !r) : r || o === n ? i += o : (i.length > 0 && s.push({ literal: /^\s+$/.test(i), val: i }), i = o, n = o);
    }
    return i.length > 0 && s.push({ literal: r || /^\s+$/.test(i), val: i }), s;
  }
  static macroTokenToFormatOpts(t) {
    return qN[t];
  }
  constructor(t, n) {
    this.opts = n, this.loc = t, this.systemLoc = null;
  }
  formatWithSystemDefault(t, n) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(t, { ...this.opts, ...n }).format();
  }
  dtFormatter(t, n = {}) {
    return this.loc.dtFormatter(t, { ...this.opts, ...n });
  }
  formatDateTime(t, n) {
    return this.dtFormatter(t, n).format();
  }
  formatDateTimeParts(t, n) {
    return this.dtFormatter(t, n).formatToParts();
  }
  formatInterval(t, n) {
    return this.dtFormatter(t.start, n).dtf.formatRange(t.start.toJSDate(), t.end.toJSDate());
  }
  resolvedOptions(t, n) {
    return this.dtFormatter(t, n).resolvedOptions();
  }
  num(t, n = 0) {
    if (this.opts.forceSimple)
      return cn(t, n);
    const i = { ...this.opts };
    return n > 0 && (i.padTo = n), this.loc.numberFormatter(i).format(t);
  }
  formatDateTimeFromString(t, n) {
    const i = this.loc.listingMode() === "en", r = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", s = (h, m) => this.loc.extract(t, h, m), a = (h) => t.isOffsetFixed && t.offset === 0 && h.allowZ ? "Z" : t.isValid ? t.zone.formatOffset(t.ts, h.format) : "", o = () => i ? WN(t) : s({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), l = (h, m) => i ? HN(t, h) : s(m ? { month: h } : { month: h, day: "numeric" }, "month"), u = (h, m) => i ? jN(t, h) : s(
      m ? { weekday: h } : { weekday: h, month: "long", day: "numeric" },
      "weekday"
    ), c = (h) => {
      const m = Un.macroTokenToFormatOpts(h);
      return m ? this.formatWithSystemDefault(t, m) : h;
    }, d = (h) => i ? zN(t, h) : s({ era: h }, "era"), f = (h) => {
      switch (h) {
        case "S":
          return this.num(t.millisecond);
        case "u":
        case "SSS":
          return this.num(t.millisecond, 3);
        case "s":
          return this.num(t.second);
        case "ss":
          return this.num(t.second, 2);
        case "uu":
          return this.num(Math.floor(t.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(t.millisecond / 100));
        case "m":
          return this.num(t.minute);
        case "mm":
          return this.num(t.minute, 2);
        case "h":
          return this.num(t.hour % 12 === 0 ? 12 : t.hour % 12);
        case "hh":
          return this.num(t.hour % 12 === 0 ? 12 : t.hour % 12, 2);
        case "H":
          return this.num(t.hour);
        case "HH":
          return this.num(t.hour, 2);
        case "Z":
          return a({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return a({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return a({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return t.zone.offsetName(t.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return t.zone.offsetName(t.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return t.zoneName;
        case "a":
          return o();
        case "d":
          return r ? s({ day: "numeric" }, "day") : this.num(t.day);
        case "dd":
          return r ? s({ day: "2-digit" }, "day") : this.num(t.day, 2);
        case "c":
          return this.num(t.weekday);
        case "ccc":
          return u("short", !0);
        case "cccc":
          return u("long", !0);
        case "ccccc":
          return u("narrow", !0);
        case "E":
          return this.num(t.weekday);
        case "EEE":
          return u("short", !1);
        case "EEEE":
          return u("long", !1);
        case "EEEEE":
          return u("narrow", !1);
        case "L":
          return r ? s({ month: "numeric", day: "numeric" }, "month") : this.num(t.month);
        case "LL":
          return r ? s({ month: "2-digit", day: "numeric" }, "month") : this.num(t.month, 2);
        case "LLL":
          return l("short", !0);
        case "LLLL":
          return l("long", !0);
        case "LLLLL":
          return l("narrow", !0);
        case "M":
          return r ? s({ month: "numeric" }, "month") : this.num(t.month);
        case "MM":
          return r ? s({ month: "2-digit" }, "month") : this.num(t.month, 2);
        case "MMM":
          return l("short", !1);
        case "MMMM":
          return l("long", !1);
        case "MMMMM":
          return l("narrow", !1);
        case "y":
          return r ? s({ year: "numeric" }, "year") : this.num(t.year);
        case "yy":
          return r ? s({ year: "2-digit" }, "year") : this.num(t.year.toString().slice(-2), 2);
        case "yyyy":
          return r ? s({ year: "numeric" }, "year") : this.num(t.year, 4);
        case "yyyyyy":
          return r ? s({ year: "numeric" }, "year") : this.num(t.year, 6);
        case "G":
          return d("short");
        case "GG":
          return d("long");
        case "GGGGG":
          return d("narrow");
        case "kk":
          return this.num(t.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(t.weekYear, 4);
        case "W":
          return this.num(t.weekNumber);
        case "WW":
          return this.num(t.weekNumber, 2);
        case "n":
          return this.num(t.localWeekNumber);
        case "nn":
          return this.num(t.localWeekNumber, 2);
        case "ii":
          return this.num(t.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(t.localWeekYear, 4);
        case "o":
          return this.num(t.ordinal);
        case "ooo":
          return this.num(t.ordinal, 3);
        case "q":
          return this.num(t.quarter);
        case "qq":
          return this.num(t.quarter, 2);
        case "X":
          return this.num(Math.floor(t.ts / 1e3));
        case "x":
          return this.num(t.ts);
        default:
          return c(h);
      }
    };
    return n0(Un.parseFormat(n), f);
  }
  formatDurationFromString(t, n) {
    const i = (l) => {
      switch (l[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, r = (l) => (u) => {
      const c = i(u);
      return c ? this.num(l.get(c), u.length) : u;
    }, s = Un.parseFormat(n), a = s.reduce(
      (l, { literal: u, val: c }) => u ? l : l.concat(c),
      []
    ), o = t.shiftTo(...a.map(i).filter((l) => l));
    return n0(s, r(o));
  }
}
const vC = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function $l(...e) {
  const t = e.reduce((n, i) => n + i.source, "");
  return RegExp(`^${t}$`);
}
function Wl(...e) {
  return (t) => e.reduce(
    ([n, i, r], s) => {
      const [a, o, l] = s(t, r);
      return [{ ...n, ...a }, o || i, l];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function jl(e, ...t) {
  if (e == null)
    return [null, null];
  for (const [n, i] of t) {
    const r = n.exec(e);
    if (r)
      return i(r);
  }
  return [null, null];
}
function gC(...e) {
  return (t, n) => {
    const i = {};
    let r;
    for (r = 0; r < e.length; r++)
      i[e[r]] = Hs(t[n + r]);
    return [i, null, n + r];
  };
}
const pC = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, GN = `(?:${pC.source}?(?:\\[(${vC.source})\\])?)?`, Np = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, yC = RegExp(`${Np.source}${GN}`), Mp = RegExp(`(?:T${yC.source})?`), YN = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, ZN = /(\d{4})-?W(\d\d)(?:-?(\d))?/, KN = /(\d{4})-?(\d{3})/, XN = gC("weekYear", "weekNumber", "weekDay"), JN = gC("year", "ordinal"), QN = /(\d{4})-(\d\d)-(\d\d)/, bC = RegExp(
  `${Np.source} ?(?:${pC.source}|(${vC.source}))?`
), eM = RegExp(`(?: ${bC.source})?`);
function ll(e, t, n) {
  const i = e[t];
  return Ue(i) ? n : Hs(i);
}
function tM(e, t) {
  return [{
    year: ll(e, t),
    month: ll(e, t + 1, 1),
    day: ll(e, t + 2, 1)
  }, null, t + 3];
}
function Hl(e, t) {
  return [{
    hours: ll(e, t, 0),
    minutes: ll(e, t + 1, 0),
    seconds: ll(e, t + 2, 0),
    milliseconds: Vp(e[t + 3])
  }, null, t + 4];
}
function Mc(e, t) {
  const n = !e[t] && !e[t + 1], i = Eh(e[t + 1], e[t + 2]), r = n ? null : ni.instance(i);
  return [{}, r, t + 3];
}
function Rc(e, t) {
  const n = e[t] ? ys.create(e[t]) : null;
  return [{}, n, t + 1];
}
const nM = RegExp(`^T?${Np.source}$`), iM = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function rM(e) {
  const [t, n, i, r, s, a, o, l, u] = e, c = t[0] === "-", d = l && l[0] === "-", f = (h, m = !1) => h !== void 0 && (m || h && c) ? -h : h;
  return [
    {
      years: f(ba(n)),
      months: f(ba(i)),
      weeks: f(ba(r)),
      days: f(ba(s)),
      hours: f(ba(a)),
      minutes: f(ba(o)),
      seconds: f(ba(l), l === "-0"),
      milliseconds: f(Vp(u), d)
    }
  ];
}
const sM = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function Rp(e, t, n, i, r, s, a) {
  const o = {
    year: t.length === 2 ? qv(Hs(t)) : Hs(t),
    month: lC.indexOf(n) + 1,
    day: Hs(i),
    hour: Hs(r),
    minute: Hs(s)
  };
  return a && (o.second = Hs(a)), e && (o.weekday = e.length > 3 ? cC.indexOf(e) + 1 : dC.indexOf(e) + 1), o;
}
const aM = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function oM(e) {
  const [
    ,
    t,
    n,
    i,
    r,
    s,
    a,
    o,
    l,
    u,
    c,
    d
  ] = e, f = Rp(t, r, i, n, s, a, o);
  let h;
  return l ? h = sM[l] : u ? h = 0 : h = Eh(c, d), [f, new ni(h)];
}
function lM(e) {
  return e.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const uM = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, cM = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, dM = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function i0(e) {
  const [, t, n, i, r, s, a, o] = e;
  return [Rp(t, r, i, n, s, a, o), ni.utcInstance];
}
function fM(e) {
  const [, t, n, i, r, s, a, o] = e;
  return [Rp(t, o, n, i, r, s, a), ni.utcInstance];
}
const hM = $l(YN, Mp), mM = $l(ZN, Mp), vM = $l(KN, Mp), gM = $l(yC), wC = Wl(
  tM,
  Hl,
  Mc,
  Rc
), pM = Wl(
  XN,
  Hl,
  Mc,
  Rc
), yM = Wl(
  JN,
  Hl,
  Mc,
  Rc
), bM = Wl(
  Hl,
  Mc,
  Rc
);
function wM(e) {
  return jl(
    e,
    [hM, wC],
    [mM, pM],
    [vM, yM],
    [gM, bM]
  );
}
function _M(e) {
  return jl(lM(e), [aM, oM]);
}
function SM(e) {
  return jl(
    e,
    [uM, i0],
    [cM, i0],
    [dM, fM]
  );
}
function kM(e) {
  return jl(e, [iM, rM]);
}
const CM = Wl(Hl);
function TM(e) {
  return jl(e, [nM, CM]);
}
const xM = $l(QN, eM), AM = $l(bC), IM = Wl(
  Hl,
  Mc,
  Rc
);
function EM(e) {
  return jl(
    e,
    [xM, wC],
    [AM, IM]
  );
}
const r0 = "Invalid Duration", _C = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, OM = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ..._C
}, Ri = 146097 / 400, Bo = 146097 / 4800, PM = {
  years: {
    quarters: 4,
    months: 12,
    weeks: Ri / 7,
    days: Ri,
    hours: Ri * 24,
    minutes: Ri * 24 * 60,
    seconds: Ri * 24 * 60 * 60,
    milliseconds: Ri * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: Ri / 28,
    days: Ri / 4,
    hours: Ri * 24 / 4,
    minutes: Ri * 24 * 60 / 4,
    seconds: Ri * 24 * 60 * 60 / 4,
    milliseconds: Ri * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: Bo / 7,
    days: Bo,
    hours: Bo * 24,
    minutes: Bo * 24 * 60,
    seconds: Bo * 24 * 60 * 60,
    milliseconds: Bo * 24 * 60 * 60 * 1e3
  },
  ..._C
}, Ma = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], VM = Ma.slice(0).reverse();
function Ds(e, t, n = !1) {
  const i = {
    values: n ? t.values : { ...e.values, ...t.values || {} },
    loc: e.loc.clone(t.loc),
    conversionAccuracy: t.conversionAccuracy || e.conversionAccuracy,
    matrix: t.matrix || e.matrix
  };
  return new ct(i);
}
function SC(e, t) {
  let n = t.milliseconds ?? 0;
  for (const i of VM.slice(1))
    t[i] && (n += t[i] * e[i].milliseconds);
  return n;
}
function s0(e, t) {
  const n = SC(e, t) < 0 ? -1 : 1;
  Ma.reduceRight((i, r) => {
    if (Ue(t[r]))
      return i;
    if (i) {
      const s = t[i] * n, a = e[r][i], o = Math.floor(s / a);
      t[r] += o * n, t[i] -= o * a * n;
    }
    return r;
  }, null), Ma.reduce((i, r) => {
    if (Ue(t[r]))
      return i;
    if (i) {
      const s = t[i] % 1;
      t[i] -= s, t[r] += s * e[i][r];
    }
    return r;
  }, null);
}
function DM(e) {
  const t = {};
  for (const [n, i] of Object.entries(e))
    i !== 0 && (t[n] = i);
  return t;
}
class ct {
  /**
   * @private
   */
  constructor(t) {
    const n = t.conversionAccuracy === "longterm" || !1;
    let i = n ? PM : OM;
    t.matrix && (i = t.matrix), this.values = t.values, this.loc = t.loc || bt.create(), this.conversionAccuracy = n ? "longterm" : "casual", this.invalid = t.invalid || null, this.matrix = i, this.isLuxonDuration = !0;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(t, n) {
    return ct.fromObject({ milliseconds: t }, n);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(t, n = {}) {
    if (t == null || typeof t != "object")
      throw new hi(
        `Duration.fromObject: argument expected to be an object, got ${t === null ? "null" : typeof t}`
      );
    return new ct({
      values: yf(t, ct.normalizeUnit),
      loc: bt.fromObject(n),
      conversionAccuracy: n.conversionAccuracy,
      matrix: n.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(t) {
    if (ja(t))
      return ct.fromMillis(t);
    if (ct.isDuration(t))
      return t;
    if (typeof t == "object")
      return ct.fromObject(t);
    throw new hi(
      `Unknown duration argument ${t} of type ${typeof t}`
    );
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(t, n) {
    const [i] = kM(t);
    return i ? ct.fromObject(i, n) : ct.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`);
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(t, n) {
    const [i] = TM(t);
    return i ? ct.fromObject(i, n) : ct.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`);
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(t, n = null) {
    if (!t)
      throw new hi("need to specify a reason the Duration is invalid");
    const i = t instanceof hr ? t : new hr(t, n);
    if (nn.throwOnInvalid)
      throw new aN(i);
    return new ct({ invalid: i });
  }
  /**
   * @private
   */
  static normalizeUnit(t) {
    const n = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[t && t.toLowerCase()];
    if (!n)
      throw new Vk(t);
    return n;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(t) {
    return t && t.isLuxonDuration || !1;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(t, n = {}) {
    const i = {
      ...n,
      floor: n.round !== !1 && n.floor !== !1
    };
    return this.isValid ? Un.create(this.loc, i).formatDurationFromString(this, t) : r0;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(t = {}) {
    if (!this.isValid)
      return r0;
    const n = Ma.map((i) => {
      const r = this.values[i];
      return Ue(r) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...t, unit: i.slice(0, -1) }).format(r);
    }).filter((i) => i);
    return this.loc.listFormatter({ type: "conjunction", style: t.listStyle || "narrow", ...t }).format(n);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let t = "P";
    return this.years !== 0 && (t += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (t += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (t += this.weeks + "W"), this.days !== 0 && (t += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (t += "T"), this.hours !== 0 && (t += this.hours + "H"), this.minutes !== 0 && (t += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (t += Dp(this.seconds + this.milliseconds / 1e3, 3) + "S"), t === "P" && (t += "T0S"), t;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(t = {}) {
    if (!this.isValid)
      return null;
    const n = this.toMillis();
    return n < 0 || n >= 864e5 ? null : (t = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...t,
      includeOffset: !1
    }, Be.fromMillis(n, { zone: "UTC" }).toISOTime(t));
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Duration { values: ${JSON.stringify(this.values)} }` : `Duration { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? SC(this.matrix, this.values) : NaN;
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(t) {
    if (!this.isValid)
      return this;
    const n = ct.fromDurationLike(t), i = {};
    for (const r of Ma)
      (yl(n.values, r) || yl(this.values, r)) && (i[r] = n.get(r) + this.get(r));
    return Ds(this, { values: i }, !0);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(t) {
    if (!this.isValid)
      return this;
    const n = ct.fromDurationLike(t);
    return this.plus(n.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(t) {
    if (!this.isValid)
      return this;
    const n = {};
    for (const i of Object.keys(this.values))
      n[i] = oC(t(this.values[i], i));
    return Ds(this, { values: n }, !0);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(t) {
    return this[ct.normalizeUnit(t)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(t) {
    if (!this.isValid)
      return this;
    const n = { ...this.values, ...yf(t, ct.normalizeUnit) };
    return Ds(this, { values: n });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale: t, numberingSystem: n, conversionAccuracy: i, matrix: r } = {}) {
    const a = { loc: this.loc.clone({ locale: t, numberingSystem: n }), matrix: r, conversionAccuracy: i };
    return Ds(this, a);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(t) {
    return this.isValid ? this.shiftTo(t).get(t) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const t = this.toObject();
    return s0(this.matrix, t), Ds(this, { values: t }, !0);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid)
      return this;
    const t = DM(this.normalize().shiftToAll().toObject());
    return Ds(this, { values: t }, !0);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...t) {
    if (!this.isValid)
      return this;
    if (t.length === 0)
      return this;
    t = t.map((a) => ct.normalizeUnit(a));
    const n = {}, i = {}, r = this.toObject();
    let s;
    for (const a of Ma)
      if (t.indexOf(a) >= 0) {
        s = a;
        let o = 0;
        for (const u in i)
          o += this.matrix[u][a] * i[u], i[u] = 0;
        ja(r[a]) && (o += r[a]);
        const l = Math.trunc(o);
        n[a] = l, i[a] = (o * 1e3 - l * 1e3) / 1e3;
      } else
        ja(r[a]) && (i[a] = r[a]);
    for (const a in i)
      i[a] !== 0 && (n[s] += a === s ? i[a] : i[a] / this.matrix[s][a]);
    return s0(this.matrix, n), Ds(this, { values: n }, !0);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    return this.isValid ? this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ) : this;
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const t = {};
    for (const n of Object.keys(this.values))
      t[n] = this.values[n] === 0 ? 0 : -this.values[n];
    return Ds(this, { values: t }, !0);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(t) {
    if (!this.isValid || !t.isValid || !this.loc.equals(t.loc))
      return !1;
    function n(i, r) {
      return i === void 0 || i === 0 ? r === void 0 || r === 0 : i === r;
    }
    for (const i of Ma)
      if (!n(this.values[i], t.values[i]))
        return !1;
    return !0;
  }
}
const Lo = "Invalid Interval";
function NM(e, t) {
  return !e || !e.isValid ? Yt.invalid("missing or invalid start") : !t || !t.isValid ? Yt.invalid("missing or invalid end") : t < e ? Yt.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${e.toISO()} and end=${t.toISO()}`
  ) : null;
}
class Yt {
  /**
   * @private
   */
  constructor(t) {
    this.s = t.start, this.e = t.end, this.invalid = t.invalid || null, this.isLuxonInterval = !0;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(t, n = null) {
    if (!t)
      throw new hi("need to specify a reason the Interval is invalid");
    const i = t instanceof hr ? t : new hr(t, n);
    if (nn.throwOnInvalid)
      throw new sN(i);
    return new Yt({ invalid: i });
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(t, n) {
    const i = lu(t), r = lu(n), s = NM(i, r);
    return s ?? new Yt({
      start: i,
      end: r
    });
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(t, n) {
    const i = ct.fromDurationLike(n), r = lu(t);
    return Yt.fromDateTimes(r, r.plus(i));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(t, n) {
    const i = ct.fromDurationLike(n), r = lu(t);
    return Yt.fromDateTimes(r.minus(i), r);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(t, n) {
    const [i, r] = (t || "").split("/", 2);
    if (i && r) {
      let s, a;
      try {
        s = Be.fromISO(i, n), a = s.isValid;
      } catch {
        a = !1;
      }
      let o, l;
      try {
        o = Be.fromISO(r, n), l = o.isValid;
      } catch {
        l = !1;
      }
      if (a && l)
        return Yt.fromDateTimes(s, o);
      if (a) {
        const u = ct.fromISO(r, n);
        if (u.isValid)
          return Yt.after(s, u);
      } else if (l) {
        const u = ct.fromISO(i, n);
        if (u.isValid)
          return Yt.before(o, u);
      }
    }
    return Yt.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(t) {
    return t && t.isLuxonInterval || !1;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(t = "milliseconds") {
    return this.isValid ? this.toDuration(t).get(t) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(t = "milliseconds", n) {
    if (!this.isValid)
      return NaN;
    const i = this.start.startOf(t, n);
    let r;
    return n != null && n.useLocaleWeeks ? r = this.end.reconfigure({ locale: i.locale }) : r = this.end, r = r.startOf(t, n), Math.floor(r.diff(i, t).get(t)) + (r.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(t) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, t) : !1;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(t) {
    return this.isValid ? this.s > t : !1;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(t) {
    return this.isValid ? this.e <= t : !1;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(t) {
    return this.isValid ? this.s <= t && this.e > t : !1;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start: t, end: n } = {}) {
    return this.isValid ? Yt.fromDateTimes(t || this.s, n || this.e) : this;
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...t) {
    if (!this.isValid)
      return [];
    const n = t.map(lu).filter((a) => this.contains(a)).sort((a, o) => a.toMillis() - o.toMillis()), i = [];
    let { s: r } = this, s = 0;
    for (; r < this.e; ) {
      const a = n[s] || this.e, o = +a > +this.e ? this.e : a;
      i.push(Yt.fromDateTimes(r, o)), r = o, s += 1;
    }
    return i;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(t) {
    const n = ct.fromDurationLike(t);
    if (!this.isValid || !n.isValid || n.as("milliseconds") === 0)
      return [];
    let { s: i } = this, r = 1, s;
    const a = [];
    for (; i < this.e; ) {
      const o = this.start.plus(n.mapUnits((l) => l * r));
      s = +o > +this.e ? this.e : o, a.push(Yt.fromDateTimes(i, s)), i = s, r += 1;
    }
    return a;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(t) {
    return this.isValid ? this.splitBy(this.length() / t).slice(0, t) : [];
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(t) {
    return this.e > t.s && this.s < t.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(t) {
    return this.isValid ? +this.e == +t.s : !1;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(t) {
    return this.isValid ? +t.e == +this.s : !1;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(t) {
    return this.isValid ? this.s <= t.s && this.e >= t.e : !1;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(t) {
    return !this.isValid || !t.isValid ? !1 : this.s.equals(t.s) && this.e.equals(t.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(t) {
    if (!this.isValid)
      return this;
    const n = this.s > t.s ? this.s : t.s, i = this.e < t.e ? this.e : t.e;
    return n >= i ? null : Yt.fromDateTimes(n, i);
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(t) {
    if (!this.isValid)
      return this;
    const n = this.s < t.s ? this.s : t.s, i = this.e > t.e ? this.e : t.e;
    return Yt.fromDateTimes(n, i);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(t) {
    const [n, i] = t.sort((r, s) => r.s - s.s).reduce(
      ([r, s], a) => s ? s.overlaps(a) || s.abutsStart(a) ? [r, s.union(a)] : [r.concat([s]), a] : [r, a],
      [[], null]
    );
    return i && n.push(i), n;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(t) {
    let n = null, i = 0;
    const r = [], s = t.map((l) => [
      { time: l.s, type: "s" },
      { time: l.e, type: "e" }
    ]), a = Array.prototype.concat(...s), o = a.sort((l, u) => l.time - u.time);
    for (const l of o)
      i += l.type === "s" ? 1 : -1, i === 1 ? n = l.time : (n && +n != +l.time && r.push(Yt.fromDateTimes(n, l.time)), n = null);
    return Yt.merge(r);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...t) {
    return Yt.xor([this].concat(t)).map((n) => this.intersection(n)).filter((n) => n && !n.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    return this.isValid ? `[${this.s.toISO()} – ${this.e.toISO()})` : Lo;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }` : `Interval { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString(t = vf, n = {}) {
    return this.isValid ? Un.create(this.s.loc.clone(n), t).formatInterval(this) : Lo;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(t) {
    return this.isValid ? `${this.s.toISO(t)}/${this.e.toISO(t)}` : Lo;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : Lo;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(t) {
    return this.isValid ? `${this.s.toISOTime(t)}/${this.e.toISOTime(t)}` : Lo;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(t, { separator: n = " – " } = {}) {
    return this.isValid ? `${this.s.toFormat(t)}${n}${this.e.toFormat(t)}` : Lo;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(t, n) {
    return this.isValid ? this.e.diff(this.s, t, n) : ct.invalid(this.invalidReason);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(t) {
    return Yt.fromDateTimes(t(this.s), t(this.e));
  }
}
class Sd {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(t = nn.defaultZone) {
    const n = Be.now().setZone(t).set({ month: 12 });
    return !t.isUniversal && n.offset !== n.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(t) {
    return ys.isValidZone(t);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(t) {
    return Us(t, nn.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale: t = null, locObj: n = null } = {}) {
    return (n || bt.create(t)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale: t = null, locObj: n = null } = {}) {
    return (n || bt.create(t)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale: t = null, locObj: n = null } = {}) {
    return (n || bt.create(t)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(t = "long", { locale: n = null, numberingSystem: i = null, locObj: r = null, outputCalendar: s = "gregory" } = {}) {
    return (r || bt.create(n, i, s)).months(t);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(t = "long", { locale: n = null, numberingSystem: i = null, locObj: r = null, outputCalendar: s = "gregory" } = {}) {
    return (r || bt.create(n, i, s)).months(t, !0);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(t = "long", { locale: n = null, numberingSystem: i = null, locObj: r = null } = {}) {
    return (r || bt.create(n, i, null)).weekdays(t);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(t = "long", { locale: n = null, numberingSystem: i = null, locObj: r = null } = {}) {
    return (r || bt.create(n, i, null)).weekdays(t, !0);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale: t = null } = {}) {
    return bt.create(t).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(t = "short", { locale: n = null } = {}) {
    return bt.create(n, null, "gregory").eras(t);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: rC(), localeWeek: sC() };
  }
}
function a0(e, t) {
  const n = (r) => r.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), i = n(t) - n(e);
  return Math.floor(ct.fromMillis(i).as("days"));
}
function MM(e, t, n) {
  const i = [
    ["years", (l, u) => u.year - l.year],
    ["quarters", (l, u) => u.quarter - l.quarter + (u.year - l.year) * 4],
    ["months", (l, u) => u.month - l.month + (u.year - l.year) * 12],
    [
      "weeks",
      (l, u) => {
        const c = a0(l, u);
        return (c - c % 7) / 7;
      }
    ],
    ["days", a0]
  ], r = {}, s = e;
  let a, o;
  for (const [l, u] of i)
    n.indexOf(l) >= 0 && (a = l, r[l] = u(e, t), o = s.plus(r), o > t ? (r[l]--, e = s.plus(r), e > t && (o = e, r[l]--, e = s.plus(r))) : e = o);
  return [e, r, o, a];
}
function RM(e, t, n, i) {
  let [r, s, a, o] = MM(e, t, n);
  const l = t - r, u = n.filter(
    (d) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(d) >= 0
  );
  u.length === 0 && (a < t && (a = r.plus({ [o]: 1 })), a !== r && (s[o] = (s[o] || 0) + l / (a - r)));
  const c = ct.fromObject(s, i);
  return u.length > 0 ? ct.fromMillis(l, i).shiftTo(...u).plus(c) : c;
}
const Fp = {
  arab: "[٠-٩]",
  arabext: "[۰-۹]",
  bali: "[᭐-᭙]",
  beng: "[০-৯]",
  deva: "[०-९]",
  fullwide: "[０-９]",
  gujr: "[૦-૯]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[០-៩]",
  knda: "[೦-೯]",
  laoo: "[໐-໙]",
  limb: "[᥆-᥏]",
  mlym: "[൦-൯]",
  mong: "[᠐-᠙]",
  mymr: "[၀-၉]",
  orya: "[୦-୯]",
  tamldec: "[௦-௯]",
  telu: "[౦-౯]",
  thai: "[๐-๙]",
  tibt: "[༠-༩]",
  latn: "\\d"
}, o0 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, FM = Fp.hanidec.replace(/[\[|\]]/g, "").split("");
function BM(e) {
  let t = parseInt(e, 10);
  if (isNaN(t)) {
    t = "";
    for (let n = 0; n < e.length; n++) {
      const i = e.charCodeAt(n);
      if (e[n].search(Fp.hanidec) !== -1)
        t += FM.indexOf(e[n]);
      else
        for (const r in o0) {
          const [s, a] = o0[r];
          i >= s && i <= a && (t += i - s);
        }
    }
    return parseInt(t, 10);
  } else
    return t;
}
function ir({ numberingSystem: e }, t = "") {
  return new RegExp(`${Fp[e || "latn"]}${t}`);
}
const LM = "missing Intl.DateTimeFormat.formatToParts support";
function ht(e, t = (n) => n) {
  return { regex: e, deser: ([n]) => t(BM(n)) };
}
const $M = String.fromCharCode(160), kC = `[ ${$M}]`, CC = new RegExp(kC, "g");
function WM(e) {
  return e.replace(/\./g, "\\.?").replace(CC, kC);
}
function l0(e) {
  return e.replace(/\./g, "").replace(CC, " ").toLowerCase();
}
function rr(e, t) {
  return e === null ? null : {
    regex: RegExp(e.map(WM).join("|")),
    deser: ([n]) => e.findIndex((i) => l0(n) === l0(i)) + t
  };
}
function u0(e, t) {
  return { regex: e, deser: ([, n, i]) => Eh(n, i), groups: t };
}
function kd(e) {
  return { regex: e, deser: ([t]) => t };
}
function jM(e) {
  return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function HM(e, t) {
  const n = ir(t), i = ir(t, "{2}"), r = ir(t, "{3}"), s = ir(t, "{4}"), a = ir(t, "{6}"), o = ir(t, "{1,2}"), l = ir(t, "{1,3}"), u = ir(t, "{1,6}"), c = ir(t, "{1,9}"), d = ir(t, "{2,4}"), f = ir(t, "{4,6}"), h = (p) => ({ regex: RegExp(jM(p.val)), deser: ([y]) => y, literal: !0 }), g = ((p) => {
    if (e.literal)
      return h(p);
    switch (p.val) {
      case "G":
        return rr(t.eras("short"), 0);
      case "GG":
        return rr(t.eras("long"), 0);
      case "y":
        return ht(u);
      case "yy":
        return ht(d, qv);
      case "yyyy":
        return ht(s);
      case "yyyyy":
        return ht(f);
      case "yyyyyy":
        return ht(a);
      case "M":
        return ht(o);
      case "MM":
        return ht(i);
      case "MMM":
        return rr(t.months("short", !0), 1);
      case "MMMM":
        return rr(t.months("long", !0), 1);
      case "L":
        return ht(o);
      case "LL":
        return ht(i);
      case "LLL":
        return rr(t.months("short", !1), 1);
      case "LLLL":
        return rr(t.months("long", !1), 1);
      case "d":
        return ht(o);
      case "dd":
        return ht(i);
      case "o":
        return ht(l);
      case "ooo":
        return ht(r);
      case "HH":
        return ht(i);
      case "H":
        return ht(o);
      case "hh":
        return ht(i);
      case "h":
        return ht(o);
      case "mm":
        return ht(i);
      case "m":
        return ht(o);
      case "q":
        return ht(o);
      case "qq":
        return ht(i);
      case "s":
        return ht(o);
      case "ss":
        return ht(i);
      case "S":
        return ht(l);
      case "SSS":
        return ht(r);
      case "u":
        return kd(c);
      case "uu":
        return kd(o);
      case "uuu":
        return ht(n);
      case "a":
        return rr(t.meridiems(), 0);
      case "kkkk":
        return ht(s);
      case "kk":
        return ht(d, qv);
      case "W":
        return ht(o);
      case "WW":
        return ht(i);
      case "E":
      case "c":
        return ht(n);
      case "EEE":
        return rr(t.weekdays("short", !1), 1);
      case "EEEE":
        return rr(t.weekdays("long", !1), 1);
      case "ccc":
        return rr(t.weekdays("short", !0), 1);
      case "cccc":
        return rr(t.weekdays("long", !0), 1);
      case "Z":
      case "ZZ":
        return u0(new RegExp(`([+-]${o.source})(?::(${i.source}))?`), 2);
      case "ZZZ":
        return u0(new RegExp(`([+-]${o.source})(${i.source})?`), 2);
      case "z":
        return kd(/[a-z_+-/]{1,256}?/i);
      case " ":
        return kd(/[^\S\n\r]/);
      default:
        return h(p);
    }
  })(e) || {
    invalidReason: LM
  };
  return g.token = e, g;
}
const zM = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function UM(e, t, n) {
  const { type: i, value: r } = e;
  if (i === "literal") {
    const l = /^\s+$/.test(r);
    return {
      literal: !l,
      val: l ? " " : r
    };
  }
  const s = t[i];
  let a = i;
  i === "hour" && (t.hour12 != null ? a = t.hour12 ? "hour12" : "hour24" : t.hourCycle != null ? t.hourCycle === "h11" || t.hourCycle === "h12" ? a = "hour12" : a = "hour24" : a = n.hour12 ? "hour12" : "hour24");
  let o = zM[a];
  if (typeof o == "object" && (o = o[s]), o)
    return {
      literal: !1,
      val: o
    };
}
function qM(e) {
  return [`^${e.map((n) => n.regex).reduce((n, i) => `${n}(${i.source})`, "")}$`, e];
}
function GM(e, t, n) {
  const i = e.match(t);
  if (i) {
    const r = {};
    let s = 1;
    for (const a in n)
      if (yl(n, a)) {
        const o = n[a], l = o.groups ? o.groups + 1 : 1;
        !o.literal && o.token && (r[o.token.val[0]] = o.deser(i.slice(s, s + l))), s += l;
      }
    return [i, r];
  } else
    return [i, {}];
}
function YM(e) {
  const t = (s) => {
    switch (s) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let n = null, i;
  return Ue(e.z) || (n = ys.create(e.z)), Ue(e.Z) || (n || (n = new ni(e.Z)), i = e.Z), Ue(e.q) || (e.M = (e.q - 1) * 3 + 1), Ue(e.h) || (e.h < 12 && e.a === 1 ? e.h += 12 : e.h === 12 && e.a === 0 && (e.h = 0)), e.G === 0 && e.y && (e.y = -e.y), Ue(e.u) || (e.S = Vp(e.u)), [Object.keys(e).reduce((s, a) => {
    const o = t(a);
    return o && (s[o] = e[a]), s;
  }, {}), n, i];
}
let Xm = null;
function ZM() {
  return Xm || (Xm = Be.fromMillis(1555555555555)), Xm;
}
function KM(e, t) {
  if (e.literal)
    return e;
  const n = Un.macroTokenToFormatOpts(e.val), i = AC(n, t);
  return i == null || i.includes(void 0) ? e : i;
}
function TC(e, t) {
  return Array.prototype.concat(...e.map((n) => KM(n, t)));
}
function xC(e, t, n) {
  const i = TC(Un.parseFormat(n), e), r = i.map((a) => HM(a, e)), s = r.find((a) => a.invalidReason);
  if (s)
    return { input: t, tokens: i, invalidReason: s.invalidReason };
  {
    const [a, o] = qM(r), l = RegExp(a, "i"), [u, c] = GM(t, l, o), [d, f, h] = c ? YM(c) : [null, null, void 0];
    if (yl(c, "a") && yl(c, "H"))
      throw new Qo(
        "Can't include meridiem when specifying 24-hour format"
      );
    return { input: t, tokens: i, regex: l, rawMatches: u, matches: c, result: d, zone: f, specificOffset: h };
  }
}
function XM(e, t, n) {
  const { result: i, zone: r, specificOffset: s, invalidReason: a } = xC(e, t, n);
  return [i, r, s, a];
}
function AC(e, t) {
  if (!e)
    return null;
  const i = Un.create(t, e).dtFormatter(ZM()), r = i.formatToParts(), s = i.resolvedOptions();
  return r.map((a) => UM(a, e, s));
}
const Jm = "Invalid DateTime", c0 = 864e13;
function Cd(e) {
  return new hr("unsupported zone", `the zone "${e.name}" is not supported`);
}
function Qm(e) {
  return e.weekData === null && (e.weekData = gf(e.c)), e.weekData;
}
function ev(e) {
  return e.localWeekData === null && (e.localWeekData = gf(
    e.c,
    e.loc.getMinDaysInFirstWeek(),
    e.loc.getStartOfWeek()
  )), e.localWeekData;
}
function wa(e, t) {
  const n = {
    ts: e.ts,
    zone: e.zone,
    c: e.c,
    o: e.o,
    loc: e.loc,
    invalid: e.invalid
  };
  return new Be({ ...n, ...t, old: n });
}
function IC(e, t, n) {
  let i = e - t * 60 * 1e3;
  const r = n.offset(i);
  if (t === r)
    return [i, t];
  i -= (r - t) * 60 * 1e3;
  const s = n.offset(i);
  return r === s ? [i, r] : [e - Math.min(r, s) * 60 * 1e3, Math.max(r, s)];
}
function Td(e, t) {
  e += t * 60 * 1e3;
  const n = new Date(e);
  return {
    year: n.getUTCFullYear(),
    month: n.getUTCMonth() + 1,
    day: n.getUTCDate(),
    hour: n.getUTCHours(),
    minute: n.getUTCMinutes(),
    second: n.getUTCSeconds(),
    millisecond: n.getUTCMilliseconds()
  };
}
function Wd(e, t, n) {
  return IC(Ih(e), t, n);
}
function d0(e, t) {
  const n = e.o, i = e.c.year + Math.trunc(t.years), r = e.c.month + Math.trunc(t.months) + Math.trunc(t.quarters) * 3, s = {
    ...e.c,
    year: i,
    month: r,
    day: Math.min(e.c.day, pf(i, r)) + Math.trunc(t.days) + Math.trunc(t.weeks) * 7
  }, a = ct.fromObject({
    years: t.years - Math.trunc(t.years),
    quarters: t.quarters - Math.trunc(t.quarters),
    months: t.months - Math.trunc(t.months),
    weeks: t.weeks - Math.trunc(t.weeks),
    days: t.days - Math.trunc(t.days),
    hours: t.hours,
    minutes: t.minutes,
    seconds: t.seconds,
    milliseconds: t.milliseconds
  }).as("milliseconds"), o = Ih(s);
  let [l, u] = IC(o, n, e.zone);
  return a !== 0 && (l += a, u = e.zone.offset(l)), { ts: l, o: u };
}
function ou(e, t, n, i, r, s) {
  const { setZone: a, zone: o } = n;
  if (e && Object.keys(e).length !== 0 || t) {
    const l = t || o, u = Be.fromObject(e, {
      ...n,
      zone: l,
      specificOffset: s
    });
    return a ? u : u.setZone(o);
  } else
    return Be.invalid(
      new hr("unparsable", `the input "${r}" can't be parsed as ${i}`)
    );
}
function xd(e, t, n = !0) {
  return e.isValid ? Un.create(bt.create("en-US"), {
    allowZ: n,
    forceSimple: !0
  }).formatDateTimeFromString(e, t) : null;
}
function tv(e, t) {
  const n = e.c.year > 9999 || e.c.year < 0;
  let i = "";
  return n && e.c.year >= 0 && (i += "+"), i += cn(e.c.year, n ? 6 : 4), t ? (i += "-", i += cn(e.c.month), i += "-", i += cn(e.c.day)) : (i += cn(e.c.month), i += cn(e.c.day)), i;
}
function f0(e, t, n, i, r, s) {
  let a = cn(e.c.hour);
  return t ? (a += ":", a += cn(e.c.minute), (e.c.millisecond !== 0 || e.c.second !== 0 || !n) && (a += ":")) : a += cn(e.c.minute), (e.c.millisecond !== 0 || e.c.second !== 0 || !n) && (a += cn(e.c.second), (e.c.millisecond !== 0 || !i) && (a += ".", a += cn(e.c.millisecond, 3))), r && (e.isOffsetFixed && e.offset === 0 && !s ? a += "Z" : e.o < 0 ? (a += "-", a += cn(Math.trunc(-e.o / 60)), a += ":", a += cn(Math.trunc(-e.o % 60))) : (a += "+", a += cn(Math.trunc(e.o / 60)), a += ":", a += cn(Math.trunc(e.o % 60)))), s && (a += "[" + e.zone.ianaName + "]"), a;
}
const EC = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, JM = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, QM = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, OC = ["year", "month", "day", "hour", "minute", "second", "millisecond"], eR = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], tR = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function nR(e) {
  const t = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[e.toLowerCase()];
  if (!t)
    throw new Vk(e);
  return t;
}
function h0(e) {
  switch (e.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return nR(e);
  }
}
function m0(e, t) {
  const n = Us(t.zone, nn.defaultZone), i = bt.fromObject(t), r = nn.now();
  let s, a;
  if (Ue(e.year))
    s = r;
  else {
    for (const u of OC)
      Ue(e[u]) && (e[u] = EC[u]);
    const o = nC(e) || iC(e);
    if (o)
      return Be.invalid(o);
    const l = n.offset(r);
    [s, a] = Wd(e, l, n);
  }
  return new Be({ ts: s, zone: n, loc: i, o: a });
}
function v0(e, t, n) {
  const i = Ue(n.round) ? !0 : n.round, r = (a, o) => (a = Dp(a, i || n.calendary ? 0 : 2, !0), t.loc.clone(n).relFormatter(n).format(a, o)), s = (a) => n.calendary ? t.hasSame(e, a) ? 0 : t.startOf(a).diff(e.startOf(a), a).get(a) : t.diff(e, a).get(a);
  if (n.unit)
    return r(s(n.unit), n.unit);
  for (const a of n.units) {
    const o = s(a);
    if (Math.abs(o) >= 1)
      return r(o, a);
  }
  return r(e > t ? -0 : 0, n.units[n.units.length - 1]);
}
function g0(e) {
  let t = {}, n;
  return e.length > 0 && typeof e[e.length - 1] == "object" ? (t = e[e.length - 1], n = Array.from(e).slice(0, e.length - 1)) : n = Array.from(e), [t, n];
}
class Be {
  /**
   * @access private
   */
  constructor(t) {
    const n = t.zone || nn.defaultZone;
    let i = t.invalid || (Number.isNaN(t.ts) ? new hr("invalid input") : null) || (n.isValid ? null : Cd(n));
    this.ts = Ue(t.ts) ? nn.now() : t.ts;
    let r = null, s = null;
    if (!i)
      if (t.old && t.old.ts === this.ts && t.old.zone.equals(n))
        [r, s] = [t.old.c, t.old.o];
      else {
        const o = n.offset(this.ts);
        r = Td(this.ts, o), i = Number.isNaN(r.year) ? new hr("invalid input") : null, r = i ? null : r, s = i ? null : o;
      }
    this._zone = n, this.loc = t.loc || bt.create(), this.invalid = i, this.weekData = null, this.localWeekData = null, this.c = r, this.o = s, this.isLuxonDateTime = !0;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new Be({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [t, n] = g0(arguments), [i, r, s, a, o, l, u] = n;
    return m0({ year: i, month: r, day: s, hour: a, minute: o, second: l, millisecond: u }, t);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [t, n] = g0(arguments), [i, r, s, a, o, l, u] = n;
    return t.zone = ni.utcInstance, m0({ year: i, month: r, day: s, hour: a, minute: o, second: l, millisecond: u }, t);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(t, n = {}) {
    const i = PN(t) ? t.valueOf() : NaN;
    if (Number.isNaN(i))
      return Be.invalid("invalid input");
    const r = Us(n.zone, nn.defaultZone);
    return r.isValid ? new Be({
      ts: i,
      zone: r,
      loc: bt.fromObject(n)
    }) : Be.invalid(Cd(r));
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(t, n = {}) {
    if (ja(t))
      return t < -c0 || t > c0 ? Be.invalid("Timestamp out of range") : new Be({
        ts: t,
        zone: Us(n.zone, nn.defaultZone),
        loc: bt.fromObject(n)
      });
    throw new hi(
      `fromMillis requires a numerical input, but received a ${typeof t} with value ${t}`
    );
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(t, n = {}) {
    if (ja(t))
      return new Be({
        ts: t * 1e3,
        zone: Us(n.zone, nn.defaultZone),
        loc: bt.fromObject(n)
      });
    throw new hi("fromSeconds requires a numerical input");
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(t, n = {}) {
    t = t || {};
    const i = Us(n.zone, nn.defaultZone);
    if (!i.isValid)
      return Be.invalid(Cd(i));
    const r = bt.fromObject(n), s = yf(t, h0), { minDaysInFirstWeek: a, startOfWeek: o } = Qw(s, r), l = nn.now(), u = Ue(n.specificOffset) ? i.offset(l) : n.specificOffset, c = !Ue(s.ordinal), d = !Ue(s.year), f = !Ue(s.month) || !Ue(s.day), h = d || f, m = s.weekYear || s.weekNumber;
    if ((h || c) && m)
      throw new Qo(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (f && c)
      throw new Qo("Can't mix ordinal dates with month/day");
    const g = m || s.weekday && !h;
    let p, y, k = Td(l, u);
    g ? (p = eR, y = JM, k = gf(k, a, o)) : c ? (p = tR, y = QM, k = Km(k)) : (p = OC, y = EC);
    let T = !1;
    for (const I of p) {
      const E = s[I];
      Ue(E) ? T ? s[I] = y[I] : s[I] = k[I] : T = !0;
    }
    const _ = g ? IN(s, a, o) : c ? EN(s) : nC(s), b = _ || iC(s);
    if (b)
      return Be.invalid(b);
    const S = g ? Xw(s, a, o) : c ? Jw(s) : s, [C, x] = Wd(S, u, i), A = new Be({
      ts: C,
      zone: i,
      o: x,
      loc: r
    });
    return s.weekday && h && t.weekday !== A.weekday ? Be.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${s.weekday} and a date of ${A.toISO()}`
    ) : A;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(t, n = {}) {
    const [i, r] = wM(t);
    return ou(i, r, n, "ISO 8601", t);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(t, n = {}) {
    const [i, r] = _M(t);
    return ou(i, r, n, "RFC 2822", t);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(t, n = {}) {
    const [i, r] = SM(t);
    return ou(i, r, n, "HTTP", n);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(t, n, i = {}) {
    if (Ue(t) || Ue(n))
      throw new hi("fromFormat requires an input string and a format");
    const { locale: r = null, numberingSystem: s = null } = i, a = bt.fromOpts({
      locale: r,
      numberingSystem: s,
      defaultToEN: !0
    }), [o, l, u, c] = XM(a, t, n);
    return c ? Be.invalid(c) : ou(o, l, i, `format ${n}`, t, u);
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(t, n, i = {}) {
    return Be.fromFormat(t, n, i);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(t, n = {}) {
    const [i, r] = EM(t);
    return ou(i, r, n, "SQL", t);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(t, n = null) {
    if (!t)
      throw new hi("need to specify a reason the DateTime is invalid");
    const i = t instanceof hr ? t : new hr(t, n);
    if (nn.throwOnInvalid)
      throw new rN(i);
    return new Be({ invalid: i });
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(t) {
    return t && t.isLuxonDateTime || !1;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(t, n = {}) {
    const i = AC(t, bt.fromObject(n));
    return i ? i.map((r) => r ? r.val : null).join("") : null;
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(t, n = {}) {
    return TC(Un.parseFormat(t), bt.fromObject(n)).map((r) => r.val).join("");
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(t) {
    return this[t];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? Qm(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? Qm(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? Qm(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? ev(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? ev(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? ev(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? Km(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Sd.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Sd.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Sd.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Sd.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed)
      return [this];
    const t = 864e5, n = 6e4, i = Ih(this.c), r = this.zone.offset(i - t), s = this.zone.offset(i + t), a = this.zone.offset(i - r * n), o = this.zone.offset(i - s * n);
    if (a === o)
      return [this];
    const l = i - a * n, u = i - o * n, c = Td(l, a), d = Td(u, o);
    return c.hour === d.hour && c.minute === d.minute && c.second === d.second && c.millisecond === d.millisecond ? [wa(this, { ts: l }), wa(this, { ts: u })] : [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return Nc(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return pf(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? ol(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? Ku(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? Ku(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(t = {}) {
    const { locale: n, numberingSystem: i, calendar: r } = Un.create(
      this.loc.clone(t),
      t
    ).resolvedOptions(this);
    return { locale: n, numberingSystem: i, outputCalendar: r };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(t = 0, n = {}) {
    return this.setZone(ni.instance(t), n);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(nn.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(t, { keepLocalTime: n = !1, keepCalendarTime: i = !1 } = {}) {
    if (t = Us(t, nn.defaultZone), t.equals(this.zone))
      return this;
    if (t.isValid) {
      let r = this.ts;
      if (n || i) {
        const s = t.offset(this.ts), a = this.toObject();
        [r] = Wd(a, s, t);
      }
      return wa(this, { ts: r, zone: t });
    } else
      return Be.invalid(Cd(t));
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale: t, numberingSystem: n, outputCalendar: i } = {}) {
    const r = this.loc.clone({ locale: t, numberingSystem: n, outputCalendar: i });
    return wa(this, { loc: r });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(t) {
    return this.reconfigure({ locale: t });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(t) {
    if (!this.isValid)
      return this;
    const n = yf(t, h0), { minDaysInFirstWeek: i, startOfWeek: r } = Qw(n, this.loc), s = !Ue(n.weekYear) || !Ue(n.weekNumber) || !Ue(n.weekday), a = !Ue(n.ordinal), o = !Ue(n.year), l = !Ue(n.month) || !Ue(n.day), u = o || l, c = n.weekYear || n.weekNumber;
    if ((u || a) && c)
      throw new Qo(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (l && a)
      throw new Qo("Can't mix ordinal dates with month/day");
    let d;
    s ? d = Xw(
      { ...gf(this.c, i, r), ...n },
      i,
      r
    ) : Ue(n.ordinal) ? (d = { ...this.toObject(), ...n }, Ue(n.day) && (d.day = Math.min(pf(d.year, d.month), d.day))) : d = Jw({ ...Km(this.c), ...n });
    const [f, h] = Wd(d, this.o, this.zone);
    return wa(this, { ts: f, o: h });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(t) {
    if (!this.isValid)
      return this;
    const n = ct.fromDurationLike(t);
    return wa(this, d0(this, n));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(t) {
    if (!this.isValid)
      return this;
    const n = ct.fromDurationLike(t).negate();
    return wa(this, d0(this, n));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(t, { useLocaleWeeks: n = !1 } = {}) {
    if (!this.isValid)
      return this;
    const i = {}, r = ct.normalizeUnit(t);
    switch (r) {
      case "years":
        i.month = 1;
      case "quarters":
      case "months":
        i.day = 1;
      case "weeks":
      case "days":
        i.hour = 0;
      case "hours":
        i.minute = 0;
      case "minutes":
        i.second = 0;
      case "seconds":
        i.millisecond = 0;
        break;
    }
    if (r === "weeks")
      if (n) {
        const s = this.loc.getStartOfWeek(), { weekday: a } = this;
        a < s && (i.weekNumber = this.weekNumber - 1), i.weekday = s;
      } else
        i.weekday = 1;
    if (r === "quarters") {
      const s = Math.ceil(this.month / 3);
      i.month = (s - 1) * 3 + 1;
    }
    return this.set(i);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(t, n) {
    return this.isValid ? this.plus({ [t]: 1 }).startOf(t, n).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(t, n = {}) {
    return this.isValid ? Un.create(this.loc.redefaultToEN(n)).formatDateTimeFromString(this, t) : Jm;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(t = vf, n = {}) {
    return this.isValid ? Un.create(this.loc.clone(n), t).formatDateTime(this) : Jm;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(t = {}) {
    return this.isValid ? Un.create(this.loc.clone(t), t).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format: t = "extended",
    suppressSeconds: n = !1,
    suppressMilliseconds: i = !1,
    includeOffset: r = !0,
    extendedZone: s = !1
  } = {}) {
    if (!this.isValid)
      return null;
    const a = t === "extended";
    let o = tv(this, a);
    return o += "T", o += f0(this, a, n, i, r, s), o;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format: t = "extended" } = {}) {
    return this.isValid ? tv(this, t === "extended") : null;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return xd(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds: t = !1,
    suppressSeconds: n = !1,
    includeOffset: i = !0,
    includePrefix: r = !1,
    extendedZone: s = !1,
    format: a = "extended"
  } = {}) {
    return this.isValid ? (r ? "T" : "") + f0(
      this,
      a === "extended",
      n,
      t,
      i,
      s
    ) : null;
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return xd(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return xd(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    return this.isValid ? tv(this, !0) : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset: t = !0, includeZone: n = !1, includeOffsetSpace: i = !0 } = {}) {
    let r = "HH:mm:ss.SSS";
    return (n || t) && (i && (r += " "), n ? r += "z" : t && (r += "ZZ")), xd(this, r, !0);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(t = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(t)}` : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : Jm;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }` : `DateTime { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(t = {}) {
    if (!this.isValid)
      return {};
    const n = { ...this.c };
    return t.includeConfig && (n.outputCalendar = this.outputCalendar, n.numberingSystem = this.loc.numberingSystem, n.locale = this.loc.locale), n;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(t, n = "milliseconds", i = {}) {
    if (!this.isValid || !t.isValid)
      return ct.invalid("created by diffing an invalid DateTime");
    const r = { locale: this.locale, numberingSystem: this.numberingSystem, ...i }, s = VN(n).map(ct.normalizeUnit), a = t.valueOf() > this.valueOf(), o = a ? this : t, l = a ? t : this, u = RM(o, l, s, r);
    return a ? u.negate() : u;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(t = "milliseconds", n = {}) {
    return this.diff(Be.now(), t, n);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(t) {
    return this.isValid ? Yt.fromDateTimes(this, t) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(t, n, i) {
    if (!this.isValid)
      return !1;
    const r = t.valueOf(), s = this.setZone(t.zone, { keepLocalTime: !0 });
    return s.startOf(n, i) <= r && r <= s.endOf(n, i);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(t) {
    return this.isValid && t.isValid && this.valueOf() === t.valueOf() && this.zone.equals(t.zone) && this.loc.equals(t.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(t = {}) {
    if (!this.isValid)
      return null;
    const n = t.base || Be.fromObject({}, { zone: this.zone }), i = t.padding ? this < n ? -t.padding : t.padding : 0;
    let r = ["years", "months", "days", "hours", "minutes", "seconds"], s = t.unit;
    return Array.isArray(t.unit) && (r = t.unit, s = void 0), v0(n, this.plus(i), {
      ...t,
      numeric: "always",
      units: r,
      unit: s
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(t = {}) {
    return this.isValid ? v0(t.base || Be.fromObject({}, { zone: this.zone }), this, {
      ...t,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...t) {
    if (!t.every(Be.isDateTime))
      throw new hi("min requires all arguments be DateTimes");
    return e0(t, (n) => n.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...t) {
    if (!t.every(Be.isDateTime))
      throw new hi("max requires all arguments be DateTimes");
    return e0(t, (n) => n.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(t, n, i = {}) {
    const { locale: r = null, numberingSystem: s = null } = i, a = bt.fromOpts({
      locale: r,
      numberingSystem: s,
      defaultToEN: !0
    });
    return xC(a, t, n);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(t, n, i = {}) {
    return Be.fromFormatExplain(t, n, i);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return vf;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return Dk;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return oN;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return Nk;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return Mk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return Rk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return Fk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return Bk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return Lk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return $k;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return Wk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return jk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return Hk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return zk;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return Uk;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return qk;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return Gk;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return lN;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return Yk;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return Zk;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return Kk;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return Xk;
  }
}
function lu(e) {
  if (Be.isDateTime(e))
    return e;
  if (e && e.valueOf && ja(e.valueOf()))
    return Be.fromJSDate(e);
  if (e && typeof e == "object")
    return Be.fromObject(e);
  throw new hi(
    `Unknown datetime argument: ${e}, of type ${typeof e}`
  );
}
var Bp = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, Qt = (e, t, n) => (Bp(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Ra = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, bf = (e, t, n, i) => (Bp(e, t, "write to private field"), i ? i.call(e, n) : t.set(e, n), n), is = (e, t, n) => (Bp(e, t, "access private method"), n), or, Fu, el, wf, Gv, ls, Bs, Ph, Lp, us, Ls;
const Fc = class Yv {
  /**
   * Creates a new instance of the MiliCron class.
   * @constructor
   * @param {boolean} [autostart=false] - Whether to automatically start the cron daemon upon instantiation.
   * @returns {MiliCron} - A new instance of the MiliCron class.
   */
  constructor(t) {
    Ra(this, wf), Ra(this, or, void 0), Ra(this, Fu, void 0), Ra(this, el, !1), bf(this, or, new iN.EventEmitter({ captureRejections: !0 })), Qt(this, or).setMaxListeners(1 / 0), t === !0 && this.start();
  }
  /**
   * Starts the cron daemon if it is not already running.
   * @function
   * @returns {void}
   */
  start() {
    Qt(this, el) || is(this, wf, Gv).call(this);
  }
  /**
   * Stops the cron daemon if it is running.
   * @function
   * @returns {void}
   */
  stop() {
    Qt(this, Fu) && clearTimeout(Qt(this, Fu)), bf(this, el, !1);
  }
  /**
   * Stops the cron daemon if it is running and then starts it again.
   * @function
   * @returns {void}
   */
  restart() {
    this.stop(), this.start();
  }
  /**
   * Returns a boolean indicating whether the cron daemon is currently running.
   * @readonly
   * @returns {boolean} - A boolean indicating whether the cron daemon is currently running.
   */
  get running() {
    return Qt(this, el);
  }
  $on(t, n) {
    Qt(this, or).on(t, n);
  }
  $once(t, n) {
    Qt(this, or).once(t, n);
  }
  $off(t, n) {
    Qt(this, or).off(t, n);
  }
  /**
   * Removes all listeners for the specified event or all events if no event is specified.
   * @param {string} [event] - The name of the event to remove all listeners from.
   * @returns {void}
   * @see {@link events!EventEmitter.removeAllListeners | EventEmitter.removeAllListeners}
   */
  $clear(t) {
    t ? Qt(this, or).removeAllListeners(t) : Qt(this, or).removeAllListeners();
  }
  /**
   * Determines whether the given crontab expression matches the given date and time.
   * @param {string} crontab - The crontab expression to check.
   * @param {DateTime} now - The date and time to check against the crontab expression.
   * @returns {boolean} - A boolean indicating whether the crontab expression matches the given date and time.
   */
  crontabMatchesDateTime(t, n) {
    return Yv.crontabMatchesDateTime(t, n);
  }
  /**
   * Parses the given cron expression and returns either a `DateTime` object representing the next time the cron expression will match, or a `CronTabObject` containing the parsed cron expression.
   * @param {string} cronExpression - The cron expression to parse.
   * @param {DateTime} [now] - The current date and time to use as a reference when calculating the next match time. If not provided, the current date and time will be used.
   * @throws {Error} - Throws an error if the cron expression is so invalid that it cannot be recognized, or if the `now` parameter is not a valid `DateTime` object.
   * @returns {DateTime | CronTabObject} - A `DateTime` object representing the next time the cron expression will match, or a `CronTabObject` containing the parsed cron expression.
   */
  getParsedCronExpression(t, n) {
    return Yv.getParsedCronExpression(t, n);
  }
  /**
   * Check if the crontab expression matches the current time
   * @param crontab A crontab expression, crontab alias or unix timestamp
   * @param now A DateTime object representing the current time
   * @returns If the crontab expression matches the current time
   */
  static crontabMatchesDateTime(t, n) {
    if (!n.isValid)
      return !1;
    try {
      const i = this.getParsedCronExpression(t, n);
      return i instanceof Be ? i >= n.minus({ milliseconds: 9 }) && i <= n.plus({ milliseconds: 9 }) : [
        i.millisecondly.has(n.millisecond),
        i.secondly.has(n.second),
        i.minutely.has(n.minute),
        i.hourly.has(n.hour),
        i.dayOfMonthly.has(n.day),
        i.monthly.has(n.month),
        i.dayOfWeekly.has(n.weekday)
      ].every((r) => r === !0);
    } catch {
      return !1;
    }
  }
  /**
   * Parses the given cron expression and returns either a `DateTime` object representing the next time the cron expression will match, or a `CronTabObject` containing the parsed cron expression.
   * @param {string} cronExpression - The cron expression to parse.
   * @param {DateTime} [now] - The current date and time to use as a reference when calculating the next match time. If not provided, the current date and time will be used.
   * @throws {Error} - Throws an error if the cron expression is so invalid that it cannot be recognized, or if the `now` parameter is not a valid `DateTime` object.
   * @returns {DateTime | CronTabObject} - A `DateTime` object representing the next time the cron expression will match, or a `CronTabObject` containing the parsed cron expression.
   */
  static getParsedCronExpression(t, n) {
    if (!n)
      n = Be.now().toUTC();
    else if (!n.isValid)
      throw new Error("Invalid DateTime object");
    if (t.startsWith("@")) {
      const f = Qt(this, Ph, Lp).expressions[t];
      if (f)
        return this.getParsedCronExpression(f);
    }
    const i = t.replace(/\s+/g, " ").split(" ").map((f) => f.trim());
    if (i.length === 1)
      return Be.fromSeconds(parseInt(i[0]));
    if (i.length > 7)
      throw new Error("Invalid crontab expression");
    for (; i.length < 7; )
      i.unshift("0");
    const [r, s, a, o, l, u, c] = i;
    return {
      millisecondly: is(this, us, Ls).call(this, "millisecond", r, Qt(this, ls, Bs).millisecondly, n),
      secondly: is(this, us, Ls).call(this, "second", s, Qt(this, ls, Bs).secondly, n),
      minutely: is(this, us, Ls).call(this, "minute", a, Qt(this, ls, Bs).minutely, n),
      hourly: is(this, us, Ls).call(this, "hour", o, Qt(this, ls, Bs).hourly, n),
      dayOfMonthly: is(this, us, Ls).call(this, "dayOfMonth", l, Qt(this, ls, Bs).dayOfMonthly, n),
      monthly: is(this, us, Ls).call(this, "month", u, Qt(this, ls, Bs).monthly, n),
      dayOfWeekly: is(this, us, Ls).call(this, "dayOfWeek", c, Qt(this, ls, Bs).dayOfWeekly, n)
    };
  }
};
or = /* @__PURE__ */ new WeakMap();
Fu = /* @__PURE__ */ new WeakMap();
el = /* @__PURE__ */ new WeakMap();
wf = /* @__PURE__ */ new WeakSet();
Gv = function() {
  bf(this, el, !0);
  const e = Be.now().toUTC();
  Qt(this, or).eventNames().filter((n) => n !== "error").forEach((n) => {
    Fc.crontabMatchesDateTime(n.toString(), e) && Qt(this, or).emit(n);
  }), bf(this, Fu, setTimeout(is(this, wf, Gv).bind(this), 10));
};
ls = /* @__PURE__ */ new WeakSet();
Bs = function() {
  const e = {
    millisecondly: {
      min: 0,
      max: 999,
      chars: [],
      validChars: /^[,*\d/-]+$/
    },
    secondly: {
      min: 0,
      max: 59,
      chars: [],
      validChars: /^[,*\d/-]+$/
    },
    minutely: {
      min: 0,
      max: 59,
      chars: [],
      validChars: /^[,*\d/-]+$/
    },
    hourly: {
      min: 0,
      max: 23,
      chars: [],
      validChars: /^[,*\d/-]+$/
    },
    dayOfMonthly: {
      min: 1,
      max: 31,
      chars: ["L"],
      validChars: /^[?,*\dL/-]+$/
    },
    monthly: {
      min: 1,
      max: 12,
      chars: [],
      validChars: /^[,*\d/-]+$/
    },
    dayOfWeekly: {
      min: 0,
      max: 7,
      chars: ["L"],
      validChars: /^[?,*\dL#/-]+$/
    }
  };
  return Object.freeze(e), e;
};
Ph = /* @__PURE__ */ new WeakSet();
Lp = function() {
  const e = {
    expressions: {
      "@yearly": "0 0 0 0 1 1 *",
      "@monthly": "0 0 0 0 1 * *",
      "@weekly": "0 0 0 0 * * 0",
      "@daily": "0 0 0 0 * * *",
      "@hourly": "0 0 0 * * * *"
    },
    month: {
      JAN: 1,
      FEB: 2,
      MAR: 3,
      APR: 4,
      MAY: 5,
      JUN: 6,
      JUL: 7,
      AUG: 8,
      SEP: 9,
      OCT: 10,
      NOV: 11,
      DEC: 12
    },
    daysOfWeek: {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    }
  };
  return Object.freeze(e), e;
};
us = /* @__PURE__ */ new WeakSet();
Ls = function(e, t, n, i) {
  const r = /* @__PURE__ */ new Set(), s = Qt(this, Ph, Lp)[e];
  switch (e) {
    case "month":
    case "dayOfWeek":
      t = t.replace(/[a-z]{3}/gi, (o) => (o = o.toUpperCase(), s && typeof s[o] < "u" ? s[o].toString() : "X"));
      break;
  }
  return t === "X" || !n.validChars.test(t) || (t.includes("*") ? t = t.replace(/\*/g, n.min + "-" + n.max) : t.includes("?") && (t = t.replace(/\?/g, n.min + "-" + n.max)), t.split(",").forEach((o) => {
    if (o.includes("-"))
      if (o.includes("/")) {
        if (o.split("/").length !== 2)
          return;
        const [l, u] = o.split("/"), [c, d] = l.split("-"), f = parseInt(c), h = parseInt(d), m = parseInt(u);
        if (m <= 0 || f > h)
          return;
        for (let g = f; g <= h; g += m)
          r.add(g);
      } else {
        const [l, u] = o.split("-"), c = parseInt(l), d = parseInt(u);
        if (c > d)
          return;
        for (let f = c; f <= d; f++)
          r.add(f);
      }
    else if (o.includes("/")) {
      if (o.split("/").length !== 2)
        return;
      const [l, u] = o.split("/"), c = parseInt(l), d = parseInt(u);
      if (d <= 0 || c > n.max)
        return;
      for (let f = c; f <= n.max; f += d)
        r.add(f);
    } else if (o.includes("#")) {
      const [l, u] = o.split("#"), c = parseInt(l), d = parseInt(u);
      if (c > n.max)
        return;
      const h = Be.fromObject({
        year: i.year,
        month: i.month,
        day: 1
      }).weekday, g = Be.fromObject({
        year: i.year,
        month: i.month,
        day: 1 + (c - h)
      }).plus({
        weeks: d - 1
      });
      if (g.month !== i.month)
        return;
      r.add(g.day);
    } else if (o.includes("L")) {
      if (o.split("/").length !== 2)
        return;
      const [l, u] = o.split("/"), c = parseInt(l), d = parseInt(u);
      if (d <= 0 || c > n.max)
        return;
      for (let f = c; f <= n.max; f += d)
        r.add(f);
    } else {
      const l = parseInt(o);
      l >= n.min && l <= n.max && r.add(l);
    }
  }), e === "millisecond" && [...r].forEach((l) => {
    const u = l - 9 < n.min ? n.min : l - 9, c = l + 9 > n.max ? n.max : l + 9;
    for (let d = u; d <= c; d++)
      r.add(d);
  }), e === "dayOfWeek" && (r.has(7) && r.add(0), r.has(0) && r.add(7))), r;
};
Ra(Fc, ls);
Ra(Fc, Ph);
Ra(Fc, us);
let $p = Fc;
const iR = {
  install: (e) => {
    const t = new $p();
    e.provide("cron", t), e.config.globalProperties.$cron = t;
  }
};
var tl = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Wp(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var _f = { exports: {} };
_f.exports;
(function(e, t) {
  var n = 200, i = "__lodash_hash_undefined__", r = 800, s = 16, a = 9007199254740991, o = "[object Arguments]", l = "[object Array]", u = "[object AsyncFunction]", c = "[object Boolean]", d = "[object Date]", f = "[object Error]", h = "[object Function]", m = "[object GeneratorFunction]", g = "[object Map]", p = "[object Number]", y = "[object Null]", k = "[object Object]", T = "[object Proxy]", _ = "[object RegExp]", b = "[object Set]", S = "[object String]", C = "[object Undefined]", x = "[object WeakMap]", A = "[object ArrayBuffer]", I = "[object DataView]", E = "[object Float32Array]", O = "[object Float64Array]", V = "[object Int8Array]", N = "[object Int16Array]", F = "[object Int32Array]", $ = "[object Uint8Array]", Z = "[object Uint8ClampedArray]", j = "[object Uint16Array]", H = "[object Uint32Array]", R = /[\\^$.*+?()[\]{}|]/g, L = /^\[object .+?Constructor\]$/, ne = /^(?:0|[1-9]\d*)$/, oe = {};
  oe[E] = oe[O] = oe[V] = oe[N] = oe[F] = oe[$] = oe[Z] = oe[j] = oe[H] = !0, oe[o] = oe[l] = oe[A] = oe[c] = oe[I] = oe[d] = oe[f] = oe[h] = oe[g] = oe[p] = oe[k] = oe[_] = oe[b] = oe[S] = oe[x] = !1;
  var we = typeof tl == "object" && tl && tl.Object === Object && tl, ee = typeof self == "object" && self && self.Object === Object && self, K = we || ee || Function("return this")(), ue = t && !t.nodeType && t, ve = ue && !0 && e && !e.nodeType && e, Re = ve && ve.exports === ue, he = Re && we.process, Pe = function() {
    try {
      var D = ve && ve.require && ve.require("util").types;
      return D || he && he.binding && he.binding("util");
    } catch {
    }
  }(), le = Pe && Pe.isTypedArray;
  function be(D, W, Q) {
    switch (Q.length) {
      case 0:
        return D.call(W);
      case 1:
        return D.call(W, Q[0]);
      case 2:
        return D.call(W, Q[0], Q[1]);
      case 3:
        return D.call(W, Q[0], Q[1], Q[2]);
    }
    return D.apply(W, Q);
  }
  function Oe(D, W) {
    for (var Q = -1, Ve = Array(D); ++Q < D; )
      Ve[Q] = W(Q);
    return Ve;
  }
  function te(D) {
    return function(W) {
      return D(W);
    };
  }
  function me(D, W) {
    return D == null ? void 0 : D[W];
  }
  function Me(D, W) {
    return function(Q) {
      return D(W(Q));
    };
  }
  var Fe = Array.prototype, xe = Function.prototype, ze = Object.prototype, Ke = K["__core-js_shared__"], ut = xe.toString, vt = ze.hasOwnProperty, En = function() {
    var D = /[^.]+$/.exec(Ke && Ke.keys && Ke.keys.IE_PROTO || "");
    return D ? "Symbol(src)_1." + D : "";
  }(), On = ze.toString, Vr = ut.call(Object), ma = RegExp(
    "^" + ut.call(vt).replace(R, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), li = Re ? K.Buffer : void 0, q = K.Symbol, z = K.Uint8Array, de = li ? li.allocUnsafe : void 0, P = Me(Object.getPrototypeOf, Object), M = Object.create, U = ze.propertyIsEnumerable, Y = Fe.splice, ce = q ? q.toStringTag : void 0, Se = function() {
    try {
      var D = Pm(Object, "defineProperty");
      return D({}, "", {}), D;
    } catch {
    }
  }(), Ie = li ? li.isBuffer : void 0, Ne = Math.max, Le = Date.now, Ge = Pm(K, "Map"), qe = Pm(Object, "create"), Et = function() {
    function D() {
    }
    return function(W) {
      if (!ga(W))
        return {};
      if (M)
        return M(W);
      D.prototype = W;
      var Q = new D();
      return D.prototype = void 0, Q;
    };
  }();
  function Ot(D) {
    var W = -1, Q = D == null ? 0 : D.length;
    for (this.clear(); ++W < Q; ) {
      var Ve = D[W];
      this.set(Ve[0], Ve[1]);
    }
  }
  function ui() {
    this.__data__ = qe ? qe(null) : {}, this.size = 0;
  }
  function es(D) {
    var W = this.has(D) && delete this.__data__[D];
    return this.size -= W ? 1 : 0, W;
  }
  function va(D) {
    var W = this.__data__;
    if (qe) {
      var Q = W[D];
      return Q === i ? void 0 : Q;
    }
    return vt.call(W, D) ? W[D] : void 0;
  }
  function Sm(D) {
    var W = this.__data__;
    return qe ? W[D] !== void 0 : vt.call(W, D);
  }
  function km(D, W) {
    var Q = this.__data__;
    return this.size += this.has(D) ? 0 : 1, Q[D] = qe && W === void 0 ? i : W, this;
  }
  Ot.prototype.clear = ui, Ot.prototype.delete = es, Ot.prototype.get = va, Ot.prototype.has = Sm, Ot.prototype.set = km;
  function nr(D) {
    var W = -1, Q = D == null ? 0 : D.length;
    for (this.clear(); ++W < Q; ) {
      var Ve = D[W];
      this.set(Ve[0], Ve[1]);
    }
  }
  function Cm() {
    this.__data__ = [], this.size = 0;
  }
  function Tm(D) {
    var W = this.__data__, Q = ld(W, D);
    if (Q < 0)
      return !1;
    var Ve = W.length - 1;
    return Q == Ve ? W.pop() : Y.call(W, Q, 1), --this.size, !0;
  }
  function xm(D) {
    var W = this.__data__, Q = ld(W, D);
    return Q < 0 ? void 0 : W[Q][1];
  }
  function Am(D) {
    return ld(this.__data__, D) > -1;
  }
  function Im(D, W) {
    var Q = this.__data__, Ve = ld(Q, D);
    return Ve < 0 ? (++this.size, Q.push([D, W])) : Q[Ve][1] = W, this;
  }
  nr.prototype.clear = Cm, nr.prototype.delete = Tm, nr.prototype.get = xm, nr.prototype.has = Am, nr.prototype.set = Im;
  function Ps(D) {
    var W = -1, Q = D == null ? 0 : D.length;
    for (this.clear(); ++W < Q; ) {
      var Ve = D[W];
      this.set(Ve[0], Ve[1]);
    }
  }
  function pt() {
    this.size = 0, this.__data__ = {
      hash: new Ot(),
      map: new (Ge || nr)(),
      string: new Ot()
    };
  }
  function ts(D) {
    var W = cd(this, D).delete(D);
    return this.size -= W ? 1 : 0, W;
  }
  function XI(D) {
    return cd(this, D).get(D);
  }
  function JI(D) {
    return cd(this, D).has(D);
  }
  function QI(D, W) {
    var Q = cd(this, D), Ve = Q.size;
    return Q.set(D, W), this.size += Q.size == Ve ? 0 : 1, this;
  }
  Ps.prototype.clear = pt, Ps.prototype.delete = ts, Ps.prototype.get = XI, Ps.prototype.has = JI, Ps.prototype.set = QI;
  function Do(D) {
    var W = this.__data__ = new nr(D);
    this.size = W.size;
  }
  function eE() {
    this.__data__ = new nr(), this.size = 0;
  }
  function tE(D) {
    var W = this.__data__, Q = W.delete(D);
    return this.size = W.size, Q;
  }
  function nE(D) {
    return this.__data__.get(D);
  }
  function iE(D) {
    return this.__data__.has(D);
  }
  function rE(D, W) {
    var Q = this.__data__;
    if (Q instanceof nr) {
      var Ve = Q.__data__;
      if (!Ge || Ve.length < n - 1)
        return Ve.push([D, W]), this.size = ++Q.size, this;
      Q = this.__data__ = new Ps(Ve);
    }
    return Q.set(D, W), this.size = Q.size, this;
  }
  Do.prototype.clear = eE, Do.prototype.delete = tE, Do.prototype.get = nE, Do.prototype.has = iE, Do.prototype.set = rE;
  function sE(D, W) {
    var Q = Nm(D), Ve = !Q && Dm(D), rt = !Q && !Ve && Pb(D), kt = !Q && !Ve && !rt && Db(D), Ft = Q || Ve || rt || kt, it = Ft ? Oe(D.length, String) : [], Bt = it.length;
    for (var Mi in D)
      (W || vt.call(D, Mi)) && !(Ft && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Mi == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      rt && (Mi == "offset" || Mi == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      kt && (Mi == "buffer" || Mi == "byteLength" || Mi == "byteOffset") || // Skip index properties.
      Eb(Mi, Bt))) && it.push(Mi);
    return it;
  }
  function Em(D, W, Q) {
    (Q !== void 0 && !dd(D[W], Q) || Q === void 0 && !(W in D)) && Om(D, W, Q);
  }
  function aE(D, W, Q) {
    var Ve = D[W];
    (!(vt.call(D, W) && dd(Ve, Q)) || Q === void 0 && !(W in D)) && Om(D, W, Q);
  }
  function ld(D, W) {
    for (var Q = D.length; Q--; )
      if (dd(D[Q][0], W))
        return Q;
    return -1;
  }
  function Om(D, W, Q) {
    W == "__proto__" && Se ? Se(D, W, {
      configurable: !0,
      enumerable: !0,
      value: Q,
      writable: !0
    }) : D[W] = Q;
  }
  var oE = wE();
  function ud(D) {
    return D == null ? D === void 0 ? C : y : ce && ce in Object(D) ? _E(D) : AE(D);
  }
  function Ab(D) {
    return su(D) && ud(D) == o;
  }
  function lE(D) {
    if (!ga(D) || TE(D))
      return !1;
    var W = Rm(D) ? ma : L;
    return W.test(PE(D));
  }
  function uE(D) {
    return su(D) && Vb(D.length) && !!oe[ud(D)];
  }
  function cE(D) {
    if (!ga(D))
      return xE(D);
    var W = Ob(D), Q = [];
    for (var Ve in D)
      Ve == "constructor" && (W || !vt.call(D, Ve)) || Q.push(Ve);
    return Q;
  }
  function Ib(D, W, Q, Ve, rt) {
    D !== W && oE(W, function(kt, Ft) {
      if (rt || (rt = new Do()), ga(kt))
        dE(D, W, Ft, Q, Ib, Ve, rt);
      else {
        var it = Ve ? Ve(Vm(D, Ft), kt, Ft + "", D, W, rt) : void 0;
        it === void 0 && (it = kt), Em(D, Ft, it);
      }
    }, Nb);
  }
  function dE(D, W, Q, Ve, rt, kt, Ft) {
    var it = Vm(D, Q), Bt = Vm(W, Q), Mi = Ft.get(Bt);
    if (Mi) {
      Em(D, Q, Mi);
      return;
    }
    var _i = kt ? kt(it, Bt, Q + "", D, W, Ft) : void 0, au = _i === void 0;
    if (au) {
      var Fm = Nm(Bt), Bm = !Fm && Pb(Bt), Rb = !Fm && !Bm && Db(Bt);
      _i = Bt, Fm || Bm || Rb ? Nm(it) ? _i = it : VE(it) ? _i = pE(it) : Bm ? (au = !1, _i = mE(Bt, !0)) : Rb ? (au = !1, _i = gE(Bt, !0)) : _i = [] : DE(Bt) || Dm(Bt) ? (_i = it, Dm(it) ? _i = NE(it) : (!ga(it) || Rm(it)) && (_i = SE(Bt))) : au = !1;
    }
    au && (Ft.set(Bt, _i), rt(_i, Bt, Ve, kt, Ft), Ft.delete(Bt)), Em(D, Q, _i);
  }
  function fE(D, W) {
    return EE(IE(D, W, Mb), D + "");
  }
  var hE = Se ? function(D, W) {
    return Se(D, "toString", {
      configurable: !0,
      enumerable: !1,
      value: RE(W),
      writable: !0
    });
  } : Mb;
  function mE(D, W) {
    if (W)
      return D.slice();
    var Q = D.length, Ve = de ? de(Q) : new D.constructor(Q);
    return D.copy(Ve), Ve;
  }
  function vE(D) {
    var W = new D.constructor(D.byteLength);
    return new z(W).set(new z(D)), W;
  }
  function gE(D, W) {
    var Q = W ? vE(D.buffer) : D.buffer;
    return new D.constructor(Q, D.byteOffset, D.length);
  }
  function pE(D, W) {
    var Q = -1, Ve = D.length;
    for (W || (W = Array(Ve)); ++Q < Ve; )
      W[Q] = D[Q];
    return W;
  }
  function yE(D, W, Q, Ve) {
    var rt = !Q;
    Q || (Q = {});
    for (var kt = -1, Ft = W.length; ++kt < Ft; ) {
      var it = W[kt], Bt = Ve ? Ve(Q[it], D[it], it, Q, D) : void 0;
      Bt === void 0 && (Bt = D[it]), rt ? Om(Q, it, Bt) : aE(Q, it, Bt);
    }
    return Q;
  }
  function bE(D) {
    return fE(function(W, Q) {
      var Ve = -1, rt = Q.length, kt = rt > 1 ? Q[rt - 1] : void 0, Ft = rt > 2 ? Q[2] : void 0;
      for (kt = D.length > 3 && typeof kt == "function" ? (rt--, kt) : void 0, Ft && kE(Q[0], Q[1], Ft) && (kt = rt < 3 ? void 0 : kt, rt = 1), W = Object(W); ++Ve < rt; ) {
        var it = Q[Ve];
        it && D(W, it, Ve, kt);
      }
      return W;
    });
  }
  function wE(D) {
    return function(W, Q, Ve) {
      for (var rt = -1, kt = Object(W), Ft = Ve(W), it = Ft.length; it--; ) {
        var Bt = Ft[D ? it : ++rt];
        if (Q(kt[Bt], Bt, kt) === !1)
          break;
      }
      return W;
    };
  }
  function cd(D, W) {
    var Q = D.__data__;
    return CE(W) ? Q[typeof W == "string" ? "string" : "hash"] : Q.map;
  }
  function Pm(D, W) {
    var Q = me(D, W);
    return lE(Q) ? Q : void 0;
  }
  function _E(D) {
    var W = vt.call(D, ce), Q = D[ce];
    try {
      D[ce] = void 0;
      var Ve = !0;
    } catch {
    }
    var rt = On.call(D);
    return Ve && (W ? D[ce] = Q : delete D[ce]), rt;
  }
  function SE(D) {
    return typeof D.constructor == "function" && !Ob(D) ? Et(P(D)) : {};
  }
  function Eb(D, W) {
    var Q = typeof D;
    return W = W ?? a, !!W && (Q == "number" || Q != "symbol" && ne.test(D)) && D > -1 && D % 1 == 0 && D < W;
  }
  function kE(D, W, Q) {
    if (!ga(Q))
      return !1;
    var Ve = typeof W;
    return (Ve == "number" ? Mm(Q) && Eb(W, Q.length) : Ve == "string" && W in Q) ? dd(Q[W], D) : !1;
  }
  function CE(D) {
    var W = typeof D;
    return W == "string" || W == "number" || W == "symbol" || W == "boolean" ? D !== "__proto__" : D === null;
  }
  function TE(D) {
    return !!En && En in D;
  }
  function Ob(D) {
    var W = D && D.constructor, Q = typeof W == "function" && W.prototype || ze;
    return D === Q;
  }
  function xE(D) {
    var W = [];
    if (D != null)
      for (var Q in Object(D))
        W.push(Q);
    return W;
  }
  function AE(D) {
    return On.call(D);
  }
  function IE(D, W, Q) {
    return W = Ne(W === void 0 ? D.length - 1 : W, 0), function() {
      for (var Ve = arguments, rt = -1, kt = Ne(Ve.length - W, 0), Ft = Array(kt); ++rt < kt; )
        Ft[rt] = Ve[W + rt];
      rt = -1;
      for (var it = Array(W + 1); ++rt < W; )
        it[rt] = Ve[rt];
      return it[W] = Q(Ft), be(D, this, it);
    };
  }
  function Vm(D, W) {
    if (!(W === "constructor" && typeof D[W] == "function") && W != "__proto__")
      return D[W];
  }
  var EE = OE(hE);
  function OE(D) {
    var W = 0, Q = 0;
    return function() {
      var Ve = Le(), rt = s - (Ve - Q);
      if (Q = Ve, rt > 0) {
        if (++W >= r)
          return arguments[0];
      } else
        W = 0;
      return D.apply(void 0, arguments);
    };
  }
  function PE(D) {
    if (D != null) {
      try {
        return ut.call(D);
      } catch {
      }
      try {
        return D + "";
      } catch {
      }
    }
    return "";
  }
  function dd(D, W) {
    return D === W || D !== D && W !== W;
  }
  var Dm = Ab(function() {
    return arguments;
  }()) ? Ab : function(D) {
    return su(D) && vt.call(D, "callee") && !U.call(D, "callee");
  }, Nm = Array.isArray;
  function Mm(D) {
    return D != null && Vb(D.length) && !Rm(D);
  }
  function VE(D) {
    return su(D) && Mm(D);
  }
  var Pb = Ie || FE;
  function Rm(D) {
    if (!ga(D))
      return !1;
    var W = ud(D);
    return W == h || W == m || W == u || W == T;
  }
  function Vb(D) {
    return typeof D == "number" && D > -1 && D % 1 == 0 && D <= a;
  }
  function ga(D) {
    var W = typeof D;
    return D != null && (W == "object" || W == "function");
  }
  function su(D) {
    return D != null && typeof D == "object";
  }
  function DE(D) {
    if (!su(D) || ud(D) != k)
      return !1;
    var W = P(D);
    if (W === null)
      return !0;
    var Q = vt.call(W, "constructor") && W.constructor;
    return typeof Q == "function" && Q instanceof Q && ut.call(Q) == Vr;
  }
  var Db = le ? te(le) : uE;
  function NE(D) {
    return yE(D, Nb(D));
  }
  function Nb(D) {
    return Mm(D) ? sE(D, !0) : cE(D);
  }
  var ME = bE(function(D, W, Q) {
    Ib(D, W, Q);
  });
  function RE(D) {
    return function() {
      return D;
    };
  }
  function Mb(D) {
    return D;
  }
  function FE() {
    return !1;
  }
  e.exports = ME;
})(_f, _f.exports);
var rR = _f.exports;
const Vh = /* @__PURE__ */ Wp(rR);
function _o(e, t) {
  var n, i;
  if (typeof t == "function")
    i = t(e), i !== void 0 && (e = i);
  else if (Array.isArray(t))
    for (n = 0; n < t.length; n++)
      i = t[n](e), i !== void 0 && (e = i);
  return e;
}
function sR(e, t) {
  return e[0] === "-" && Array.isArray(t) && /^-\d+$/.test(e) ? t.length + parseInt(e, 10) : e;
}
function aR(e) {
  return /^\d+$/.test(e);
}
function jd(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function gu(e) {
  return Object(e) === e;
}
function Hd(e) {
  return Object.keys(e).length === 0;
}
var oR = ["__proto__", "prototype", "constructor"], lR = function(e) {
  return oR.indexOf(e) === -1;
};
function Dh(e, t) {
  e.indexOf("[") >= 0 && (e = e.replace(/\[/g, t).replace(/]/g, ""));
  var n = e.split(t), i = n.filter(lR);
  if (i.length !== n.length)
    throw Error("Refusing to update blacklisted property " + e);
  return n;
}
var p0 = Object.prototype.hasOwnProperty;
function ot(e, t, n, i) {
  if (!(this instanceof ot))
    return new ot(e, t, n, i);
  typeof t > "u" && (t = !1), typeof n > "u" && (n = !0), typeof i > "u" && (i = !0), this.separator = e || ".", this.override = t, this.useArray = n, this.useBrackets = i, this.keepArray = !1, this.cleanup = [];
}
var bl = new ot(".", !1, !0, !0);
function Ar(e) {
  return function() {
    return bl[e].apply(bl, arguments);
  };
}
ot.prototype._fill = function(e, t, n, i) {
  var r = e.shift();
  if (e.length > 0) {
    if (t[r] = t[r] || (this.useArray && aR(e[0]) ? [] : {}), !gu(t[r]))
      if (this.override)
        t[r] = {};
      else {
        if (!(gu(n) && Hd(n)))
          throw new Error(
            "Trying to redefine `" + r + "` which is a " + typeof t[r]
          );
        return;
      }
    this._fill(e, t[r], n, i);
  } else {
    if (!this.override && gu(t[r]) && !Hd(t[r])) {
      if (!(gu(n) && Hd(n)))
        throw new Error("Trying to redefine non-empty obj['" + r + "']");
      return;
    }
    t[r] = _o(n, i);
  }
};
ot.prototype.object = function(e, t) {
  var n = this;
  return Object.keys(e).forEach(function(i) {
    var r = t === void 0 ? null : t[i], s = Dh(i, n.separator).join(n.separator);
    s.indexOf(n.separator) !== -1 ? (n._fill(s.split(n.separator), e, e[i], r), delete e[i]) : e[i] = _o(e[i], r);
  }), e;
};
ot.prototype.str = function(e, t, n, i) {
  var r = Dh(e, this.separator).join(this.separator);
  return e.indexOf(this.separator) !== -1 ? this._fill(r.split(this.separator), n, t, i) : n[e] = _o(t, i), n;
};
ot.prototype.pick = function(e, t, n, i) {
  var r, s, a, o, l;
  for (s = Dh(e, this.separator), r = 0; r < s.length; r++)
    if (o = sR(s[r], t), t && typeof t == "object" && o in t) {
      if (r === s.length - 1)
        return n ? (a = t[o], i && Array.isArray(t) ? t.splice(o, 1) : delete t[o], Array.isArray(t) && (l = s.slice(0, -1).join("."), this.cleanup.indexOf(l) === -1 && this.cleanup.push(l)), a) : t[o];
      t = t[o];
    } else
      return;
  return n && Array.isArray(t) && (t = t.filter(function(u) {
    return u !== void 0;
  })), t;
};
ot.prototype.delete = function(e, t) {
  return this.remove(e, t, !0);
};
ot.prototype.remove = function(e, t, n) {
  var i;
  if (this.cleanup = [], Array.isArray(e)) {
    for (i = 0; i < e.length; i++)
      this.pick(e[i], t, !0, n);
    return n || this._cleanup(t), t;
  } else
    return this.pick(e, t, !0, n);
};
ot.prototype._cleanup = function(e) {
  var t, n, i, r;
  if (this.cleanup.length) {
    for (n = 0; n < this.cleanup.length; n++)
      i = this.cleanup[n].split("."), r = i.splice(0, -1).join("."), t = r ? this.pick(r, e) : e, t = t[i[0]].filter(function(s) {
        return s !== void 0;
      }), this.set(this.cleanup[n], t, e);
    this.cleanup = [];
  }
};
ot.prototype.del = ot.prototype.remove;
ot.prototype.move = function(e, t, n, i, r) {
  return typeof i == "function" || Array.isArray(i) ? this.set(t, _o(this.pick(e, n, !0), i), n, r) : (r = i, this.set(t, this.pick(e, n, !0), n, r)), n;
};
ot.prototype.transfer = function(e, t, n, i, r, s) {
  return typeof r == "function" || Array.isArray(r) ? this.set(
    t,
    _o(this.pick(e, n, !0), r),
    i,
    s
  ) : (s = r, this.set(t, this.pick(e, n, !0), i, s)), i;
};
ot.prototype.copy = function(e, t, n, i, r, s) {
  return typeof r == "function" || Array.isArray(r) ? this.set(
    t,
    _o(
      // clone what is picked
      JSON.parse(JSON.stringify(this.pick(e, n, !1))),
      r
    ),
    i,
    s
  ) : (s = r, this.set(t, this.pick(e, n, !1), i, s)), i;
};
ot.prototype.set = function(e, t, n, i) {
  var r, s, a, o;
  if (typeof t > "u")
    return n;
  for (a = Dh(e, this.separator), r = 0; r < a.length; r++) {
    if (o = a[r], r === a.length - 1)
      if (i && jd(t) && jd(n[o]))
        for (s in t)
          p0.call(t, s) && (n[o][s] = t[s]);
      else if (i && Array.isArray(n[o]) && Array.isArray(t))
        for (var l = 0; l < t.length; l++)
          n[a[r]].push(t[l]);
      else
        n[o] = t;
    else
      // force the value to be an object
      (!p0.call(n, o) || !jd(n[o]) && !Array.isArray(n[o])) && (/^\d+$/.test(a[r + 1]) ? n[o] = [] : n[o] = {});
    n = n[o];
  }
  return n;
};
ot.prototype.transform = function(e, t, n) {
  return t = t || {}, n = n || {}, Object.keys(e).forEach(
    (function(i) {
      this.set(e[i], this.pick(i, t), n);
    }).bind(this)
  ), n;
};
ot.prototype.dot = function(e, t, n) {
  t = t || {}, n = n || [];
  var i = Array.isArray(e);
  return Object.keys(e).forEach(
    (function(r) {
      var s = i && this.useBrackets ? "[" + r + "]" : r;
      if (gu(e[r]) && (jd(e[r]) && !Hd(e[r]) || Array.isArray(e[r]) && !this.keepArray && e[r].length !== 0))
        if (i && this.useBrackets) {
          var a = n[n.length - 1] || "";
          return this.dot(
            e[r],
            t,
            n.slice(0, -1).concat(a + s)
          );
        } else
          return this.dot(e[r], t, n.concat(s));
      else
        i && this.useBrackets ? t[n.join(this.separator).concat("[" + r + "]")] = e[r] : t[n.concat(s).join(this.separator)] = e[r];
    }).bind(this)
  ), t;
};
ot.pick = Ar("pick");
ot.move = Ar("move");
ot.transfer = Ar("transfer");
ot.transform = Ar("transform");
ot.copy = Ar("copy");
ot.object = Ar("object");
ot.str = Ar("str");
ot.set = Ar("set");
ot.delete = Ar("delete");
ot.del = ot.remove = Ar("remove");
ot.dot = Ar("dot");
["override", "overwrite"].forEach(function(e) {
  Object.defineProperty(ot, e, {
    get: function() {
      return bl.override;
    },
    set: function(t) {
      bl.override = !!t;
    }
  });
});
["useArray", "keepArray", "useBrackets"].forEach(function(e) {
  Object.defineProperty(ot, e, {
    get: function() {
      return bl[e];
    },
    set: function(t) {
      bl[e] = t;
    }
  });
});
ot._process = _o;
var uR = ot;
const nv = /* @__PURE__ */ Wp(uR);
var jp = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, Ae = (e, t, n) => (jp(e, t, "read from private field"), n ? n.call(e) : t.get(e)), sr = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, Si = (e, t, n, i) => (jp(e, t, "write to private field"), i ? i.call(e, n) : t.set(e, n), n), Nr = (e, t, n) => (jp(e, t, "access private method"), n), Qn, Jn, Zt, Dn, Ho, zd, Mr, ar, pu, yu, Ud, rs, $s;
const ci = xs("LocalStorage");
class Nh {
  /**
   * Create a new LocalStorage instance.
   * @param namespace The namespace to use for the local storage.
   */
  constructor(t) {
    sr(this, yu), sr(this, rs), sr(this, Qn, void 0), sr(this, Jn, void 0), sr(this, Zt, void 0), sr(this, Dn, void 0), sr(this, Ho, void 0), sr(this, zd, !1), sr(this, Mr, void 0), sr(this, ar, void 0), sr(this, pu, void 0), Si(this, Qn, t), Si(this, ar, !(typeof window < "u")), Si(this, Jn, new Md()), Si(this, Dn, X({})), typeof window < "u" ? (Si(this, pu, new BroadcastChannel(`ls:${t}`)), Ae(this, pu).onmessage = () => {
      ci("Updating due to change in another tab."), this.refresh();
    }, this.on("change", () => {
      var n;
      ci("Notifying other tabs about change."), (n = Ae(this, pu)) == null || n.postMessage("change");
    }), Si(this, Ho, new Promise((n) => {
      import("./secure-ls-82d35ea1.mjs").then(function(i) {
        return i.s;
      }).then(({ default: i }) => {
        Si(this, Zt, new i({
          encodingType: "aes",
          isCompression: !0,
          encryptionSecret: t
        })), Nr(this, yu, Ud).call(this), Ae(this, Jn).on("tab:active", Nr(this, yu, Ud).bind(this), { local: !0 }), Si(this, Mr, fe(
          () => Ae(this, Dn).value,
          () => {
            Ae(this, Jn).emit("change"), Nr(this, rs, $s).call(this);
          },
          {
            deep: !0
          }
        )), ci(`Loaded Encrypted Local Storage Values for ${t}.`), Si(this, zd, !0), Ae(this, Jn).emit("loaded"), n();
      });
    }))) : Si(this, Ho, Promise.resolve()), Ae(this, Ho).then(() => {
      ci(`Loaded Encrypted Local Storage for ${t}.`);
    }), this.on("loaded", () => {
      if (window) {
        window._vueprint_loaded || (window._vueprint_loaded = {}), window._vueprint_loaded.localstorage = !0;
        const n = new CustomEvent("localstorage:loaded", { detail: {} });
        window.dispatchEvent(n);
      }
    }), Si(this, Mr, () => {
    });
  }
  /**
   * Whether or not the local storage has been loaded.
   */
  get loaded() {
    return Ae(this, zd);
  }
  /**
   * A promise which resolves when the local storage has been loaded.
   */
  get promise() {
    return Ae(this, Ho);
  }
  /**
   * The current content of the local storage.
   */
  get value() {
    return Ae(this, Dn).value;
  }
  /**
   * Refresh the information in the service from the browser's local storage.
   */
  refresh() {
    Ae(this, Mr) && Ae(this, Mr).call(this), Nr(this, yu, Ud).call(this), Si(this, Mr, fe(
      () => Ae(this, Dn).value,
      () => {
        Ae(this, Jn).emit("change"), Nr(this, rs, $s).call(this);
      },
      {
        deep: !0
      }
    ));
  }
  /**
   * Get the encryption secret used by the local storage.
   */
  getEncryptionSecret() {
    var t;
    return !Ae(this, Zt) && !Ae(this, ar) && ci(
      `Trying to fetch encryption secret from localStorage ${Ae(this, Qn)} before it is loaded.`
    ), ((t = Ae(this, Zt)) == null ? void 0 : t.getEncryptionSecret()) || "";
  }
  /**
   * Get the value of a key in the local storage.
   * @param key The key to fetch from the local storage.
   * @returns The value of the key in the local storage, if it exists
   */
  get(t) {
    return !Ae(this, Zt) && !Ae(this, ar) && ci(`Trying to fetch ${t} from localStorage ${Ae(this, Qn)} before it is loaded.`), nv.pick(t, Ae(this, Dn).value);
  }
  /**
   * Get the value of a key in the local storage.
   * @param key The key to fetch from the local storage.
   * @returns The value of the key in the local storage, if it exists
   */
  getDataFromLocalStorage(t) {
    var n;
    return !Ae(this, Zt) && !Ae(this, ar) && ci(`Trying to fetch ${t} from localStorage ${Ae(this, Qn)} before it is loaded.`), ((n = Ae(this, Zt)) == null ? void 0 : n.getDataFromLocalStorage(t)) || null;
  }
  /**
   * Get all of the keys in the local storage.
   * @returns An array of all of the keys in the local storage.
   */
  getAllKeys() {
    return !Ae(this, Zt) && !Ae(this, ar) && ci(`Trying to fetch keys from localStorage ${Ae(this, Qn)} before it is loaded.`), Object.keys(Ae(this, Dn).value);
  }
  /**
   * Set the value of a key in the local storage.
   * @param key The key to set in the local storage.
   * @param data The value to set for the key in the local storage.
   */
  set(t, n) {
    !Ae(this, Zt) && !Ae(this, ar) && ci(`Trying to set ${t} in localStorage ${Ae(this, Qn)} before it is loaded.`), Ae(this, Mr) && Ae(this, Mr).call(this), nv.set(t, n, Ae(this, Dn).value), Nr(this, rs, $s).call(this), Si(this, Mr, fe(
      () => Ae(this, Dn).value,
      () => {
        Ae(this, Jn).emit("change"), Nr(this, rs, $s).call(this);
      },
      {
        deep: !0
      }
    )), Ae(this, Jn).emit("change");
  }
  /**
   * Merge data into the local storage.
   * @param data The data to merge into the local storage.
   */
  merge(t) {
    const n = { ...Ae(this, Dn).value }, i = { ...t }, r = Vh({}, n, i);
    Ae(this, Dn).value = r, Nr(this, rs, $s).call(this);
  }
  /**
   * Set the value of a key in the local storage.
   * @param key The key to set in the local storage.
   * @param data The value to set for the key in the local storage.
   */
  setDataToLocalStorage(t, n) {
    var i;
    return Ae(this, Zt) && Ae(this, Jn).emit("setDataToLocalStorage", t, n), (i = Ae(this, Zt)) == null ? void 0 : i.setDataToLocalStorage(t, n);
  }
  /**
   * Remove a key from the local storage.
   * @param key The key to remove from the local storage.
   */
  remove(t) {
    !Ae(this, Zt) && !Ae(this, ar) && ci(`Trying to remove ${t} from localStorage ${Ae(this, Qn)} before it is loaded.`), nv.delete(t, Ae(this, Dn).value), Nr(this, rs, $s).call(this);
  }
  /**
   * Remove all keys from the local storage.
   */
  removeAll() {
    !Ae(this, Zt) && !Ae(this, ar) && ci(`Trying to remove all keys from localStorage ${Ae(this, Qn)} before it is loaded.`), Ae(this, Dn).value = {}, Nr(this, rs, $s).call(this);
  }
  /**
   * Clear the local storage.
   */
  clear() {
    var t;
    return this.removeAll(), Ae(this, Zt) ? Ae(this, Jn).emit("clear") : ci(`Trying to clear localStorage ${Ae(this, Qn)} before it is loaded.`), (t = Ae(this, Zt)) == null ? void 0 : t.clear();
  }
  /**
   * Reset all keys in the local storage.
   */
  resetAllKeys() {
    var t;
    return Ae(this, Zt) && Ae(this, Jn).emit("resetAllKeys"), ((t = Ae(this, Zt)) == null ? void 0 : t.resetAllKeys()) || [];
  }
  /**
   * Add a listener for an event on the local bus.
   * @param event The event name.
   * @param callback The callback function.
   */
  on(t, n) {
    Ae(this, Jn).on(t, n);
  }
  /**
   * Remove a listener for an event on the local bus.
   * @param event The event name.
   * @param callback The callback function.
   */
  off(t, n) {
    Ae(this, Jn).off(t, n);
  }
  /**
   * Add a listener for an event on the local bus one time
   * @param event The event name.
   * @param callback The callback function.
   */
  once(t, n) {
    Ae(this, Jn).once(t, n);
  }
}
Qn = /* @__PURE__ */ new WeakMap();
Jn = /* @__PURE__ */ new WeakMap();
Zt = /* @__PURE__ */ new WeakMap();
Dn = /* @__PURE__ */ new WeakMap();
Ho = /* @__PURE__ */ new WeakMap();
zd = /* @__PURE__ */ new WeakMap();
Mr = /* @__PURE__ */ new WeakMap();
ar = /* @__PURE__ */ new WeakMap();
pu = /* @__PURE__ */ new WeakMap();
yu = /* @__PURE__ */ new WeakSet();
Ud = function() {
  if (Ae(this, Zt)) {
    let e;
    try {
      e = JSON.parse(Ae(this, Zt).get(Ae(this, Qn)) || "{}");
    } catch (n) {
      ci(`Error parsing localStorage ${Ae(this, Qn)}.`, n), e = {};
    }
    const t = Vh({}, Ae(this, Dn).value, e);
    Ae(this, Dn).value = t;
  } else
    Ae(this, ar) || ci(`Trying to refresh localStorage ${Ae(this, Qn)} before it is loaded.`);
};
rs = /* @__PURE__ */ new WeakSet();
$s = function() {
  Ae(this, Zt) && Ae(this, Zt).set(Ae(this, Qn), JSON.stringify({ ...Ae(this, Dn).value }));
};
const cR = {
  install: (e, t) => {
    const n = new Nh((t == null ? void 0 : t.namespace) || "app");
    e.provide("ls", n), e.config.globalProperties.$ls = n;
  }
}, dR = (e, t, n) => {
  const i = new Set(Object.values(t).flatMap((a) => Object.keys(a.colors))), r = Vh({}, n, {
    theme: {
      defaultTheme: e,
      variations: {
        colors: Array.from(i),
        lighten: 5,
        darken: 5
      },
      themes: t
    }
  });
  return KS(r);
}, fR = {
  install: (e, t) => {
    const n = (t == null ? void 0 : t.defaultTheme) || "main", i = (t == null ? void 0 : t.themes) || {
      main: {
        dark: !1,
        colors: {
          background: "#e3e3e3",
          surface: "#eef0f0",
          primary: "#34495E",
          secondary: "#41B883",
          accent: "#676464",
          highlight: "#34495E",
          notify: "#E53935",
          success: "#06972E",
          info: "#3F51B5",
          warning: "#FFA000",
          error: "#E43333",
          question: "#554C7D",
          cancel: "#666666"
        }
      }
    }, r = (t == null ? void 0 : t.options) || {}, s = dR(n, i, r);
    e.use(s);
  }
};
function PC(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: hR } = Object.prototype, { getPrototypeOf: Hp } = Object, Mh = ((e) => (t) => {
  const n = hR.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Ir = (e) => (e = e.toLowerCase(), (t) => Mh(t) === e), Rh = (e) => (t) => typeof t === e, { isArray: zl } = Array, Xu = Rh("undefined");
function mR(e) {
  return e !== null && !Xu(e) && e.constructor !== null && !Xu(e.constructor) && Yi(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const VC = Ir("ArrayBuffer");
function vR(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && VC(e.buffer), t;
}
const gR = Rh("string"), Yi = Rh("function"), DC = Rh("number"), Fh = (e) => e !== null && typeof e == "object", pR = (e) => e === !0 || e === !1, qd = (e) => {
  if (Mh(e) !== "object")
    return !1;
  const t = Hp(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, yR = Ir("Date"), bR = Ir("File"), wR = Ir("Blob"), _R = Ir("FileList"), SR = (e) => Fh(e) && Yi(e.pipe), kR = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Yi(e.append) && ((t = Mh(e)) === "formdata" || // detect form-data instance
  t === "object" && Yi(e.toString) && e.toString() === "[object FormData]"));
}, CR = Ir("URLSearchParams"), [TR, xR, AR, IR] = ["ReadableStream", "Request", "Response", "Headers"].map(Ir), ER = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Bc(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let i, r;
  if (typeof e != "object" && (e = [e]), zl(e))
    for (i = 0, r = e.length; i < r; i++)
      t.call(null, e[i], i, e);
  else {
    const s = n ? Object.getOwnPropertyNames(e) : Object.keys(e), a = s.length;
    let o;
    for (i = 0; i < a; i++)
      o = s[i], t.call(null, e[o], o, e);
  }
}
function NC(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let i = n.length, r;
  for (; i-- > 0; )
    if (r = n[i], t === r.toLowerCase())
      return r;
  return null;
}
const MC = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), RC = (e) => !Xu(e) && e !== MC;
function Zv() {
  const { caseless: e } = RC(this) && this || {}, t = {}, n = (i, r) => {
    const s = e && NC(t, r) || r;
    qd(t[s]) && qd(i) ? t[s] = Zv(t[s], i) : qd(i) ? t[s] = Zv({}, i) : zl(i) ? t[s] = i.slice() : t[s] = i;
  };
  for (let i = 0, r = arguments.length; i < r; i++)
    arguments[i] && Bc(arguments[i], n);
  return t;
}
const OR = (e, t, n, { allOwnKeys: i } = {}) => (Bc(t, (r, s) => {
  n && Yi(r) ? e[s] = PC(r, n) : e[s] = r;
}, { allOwnKeys: i }), e), PR = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), VR = (e, t, n, i) => {
  e.prototype = Object.create(t.prototype, i), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, DR = (e, t, n, i) => {
  let r, s, a;
  const o = {};
  if (t = t || {}, e == null)
    return t;
  do {
    for (r = Object.getOwnPropertyNames(e), s = r.length; s-- > 0; )
      a = r[s], (!i || i(a, e, t)) && !o[a] && (t[a] = e[a], o[a] = !0);
    e = n !== !1 && Hp(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, NR = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const i = e.indexOf(t, n);
  return i !== -1 && i === n;
}, MR = (e) => {
  if (!e)
    return null;
  if (zl(e))
    return e;
  let t = e.length;
  if (!DC(t))
    return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, RR = ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && Hp(Uint8Array)), FR = (e, t) => {
  const i = (e && e[Symbol.iterator]).call(e);
  let r;
  for (; (r = i.next()) && !r.done; ) {
    const s = r.value;
    t.call(e, s[0], s[1]);
  }
}, BR = (e, t) => {
  let n;
  const i = [];
  for (; (n = e.exec(t)) !== null; )
    i.push(n);
  return i;
}, LR = Ir("HTMLFormElement"), $R = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, i, r) {
    return i.toUpperCase() + r;
  }
), y0 = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), WR = Ir("RegExp"), FC = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), i = {};
  Bc(n, (r, s) => {
    let a;
    (a = t(r, s, e)) !== !1 && (i[s] = a || r);
  }), Object.defineProperties(e, i);
}, jR = (e) => {
  FC(e, (t, n) => {
    if (Yi(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const i = e[n];
    if (Yi(i)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, HR = (e, t) => {
  const n = {}, i = (r) => {
    r.forEach((s) => {
      n[s] = !0;
    });
  };
  return zl(e) ? i(e) : i(String(e).split(t)), n;
}, zR = () => {
}, UR = (e, t) => e != null && Number.isFinite(e = +e) ? e : t, iv = "abcdefghijklmnopqrstuvwxyz", b0 = "0123456789", BC = {
  DIGIT: b0,
  ALPHA: iv,
  ALPHA_DIGIT: iv + iv.toUpperCase() + b0
}, qR = (e = 16, t = BC.ALPHA_DIGIT) => {
  let n = "";
  const { length: i } = t;
  for (; e--; )
    n += t[Math.random() * i | 0];
  return n;
};
function GR(e) {
  return !!(e && Yi(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const YR = (e) => {
  const t = new Array(10), n = (i, r) => {
    if (Fh(i)) {
      if (t.indexOf(i) >= 0)
        return;
      if (!("toJSON" in i)) {
        t[r] = i;
        const s = zl(i) ? [] : {};
        return Bc(i, (a, o) => {
          const l = n(a, r + 1);
          !Xu(l) && (s[o] = l);
        }), t[r] = void 0, s;
      }
    }
    return i;
  };
  return n(e, 0);
}, ZR = Ir("AsyncFunction"), KR = (e) => e && (Fh(e) || Yi(e)) && Yi(e.then) && Yi(e.catch), ae = {
  isArray: zl,
  isArrayBuffer: VC,
  isBuffer: mR,
  isFormData: kR,
  isArrayBufferView: vR,
  isString: gR,
  isNumber: DC,
  isBoolean: pR,
  isObject: Fh,
  isPlainObject: qd,
  isReadableStream: TR,
  isRequest: xR,
  isResponse: AR,
  isHeaders: IR,
  isUndefined: Xu,
  isDate: yR,
  isFile: bR,
  isBlob: wR,
  isRegExp: WR,
  isFunction: Yi,
  isStream: SR,
  isURLSearchParams: CR,
  isTypedArray: RR,
  isFileList: _R,
  forEach: Bc,
  merge: Zv,
  extend: OR,
  trim: ER,
  stripBOM: PR,
  inherits: VR,
  toFlatObject: DR,
  kindOf: Mh,
  kindOfTest: Ir,
  endsWith: NR,
  toArray: MR,
  forEachEntry: FR,
  matchAll: BR,
  isHTMLForm: LR,
  hasOwnProperty: y0,
  hasOwnProp: y0,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: FC,
  freezeMethods: jR,
  toObjectSet: HR,
  toCamelCase: $R,
  noop: zR,
  toFiniteNumber: UR,
  findKey: NC,
  global: MC,
  isContextDefined: RC,
  ALPHABET: BC,
  generateString: qR,
  isSpecCompliantForm: GR,
  toJSONObject: YR,
  isAsyncFn: ZR,
  isThenable: KR
};
function Ye(e, t, n, i, r) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), i && (this.request = i), r && (this.response = r);
}
ae.inherits(Ye, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: ae.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const LC = Ye.prototype, $C = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  $C[e] = { value: e };
});
Object.defineProperties(Ye, $C);
Object.defineProperty(LC, "isAxiosError", { value: !0 });
Ye.from = (e, t, n, i, r, s) => {
  const a = Object.create(LC);
  return ae.toFlatObject(e, a, function(l) {
    return l !== Error.prototype;
  }, (o) => o !== "isAxiosError"), Ye.call(a, e.message, t, n, i, r), a.cause = e, a.name = e.name, s && Object.assign(a, s), a;
};
const XR = null;
function Kv(e) {
  return ae.isPlainObject(e) || ae.isArray(e);
}
function WC(e) {
  return ae.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function w0(e, t, n) {
  return e ? e.concat(t).map(function(r, s) {
    return r = WC(r), !n && s ? "[" + r + "]" : r;
  }).join(n ? "." : "") : t;
}
function JR(e) {
  return ae.isArray(e) && !e.some(Kv);
}
const QR = ae.toFlatObject(ae, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Bh(e, t, n) {
  if (!ae.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = ae.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(g, p) {
    return !ae.isUndefined(p[g]);
  });
  const i = n.metaTokens, r = n.visitor || c, s = n.dots, a = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && ae.isSpecCompliantForm(t);
  if (!ae.isFunction(r))
    throw new TypeError("visitor must be a function");
  function u(m) {
    if (m === null)
      return "";
    if (ae.isDate(m))
      return m.toISOString();
    if (!l && ae.isBlob(m))
      throw new Ye("Blob is not supported. Use a Buffer instead.");
    return ae.isArrayBuffer(m) || ae.isTypedArray(m) ? l && typeof Blob == "function" ? new Blob([m]) : Buffer.from(m) : m;
  }
  function c(m, g, p) {
    let y = m;
    if (m && !p && typeof m == "object") {
      if (ae.endsWith(g, "{}"))
        g = i ? g : g.slice(0, -2), m = JSON.stringify(m);
      else if (ae.isArray(m) && JR(m) || (ae.isFileList(m) || ae.endsWith(g, "[]")) && (y = ae.toArray(m)))
        return g = WC(g), y.forEach(function(T, _) {
          !(ae.isUndefined(T) || T === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            a === !0 ? w0([g], _, s) : a === null ? g : g + "[]",
            u(T)
          );
        }), !1;
    }
    return Kv(m) ? !0 : (t.append(w0(p, g, s), u(m)), !1);
  }
  const d = [], f = Object.assign(QR, {
    defaultVisitor: c,
    convertValue: u,
    isVisitable: Kv
  });
  function h(m, g) {
    if (!ae.isUndefined(m)) {
      if (d.indexOf(m) !== -1)
        throw Error("Circular reference detected in " + g.join("."));
      d.push(m), ae.forEach(m, function(y, k) {
        (!(ae.isUndefined(y) || y === null) && r.call(
          t,
          y,
          ae.isString(k) ? k.trim() : k,
          g,
          f
        )) === !0 && h(y, g ? g.concat(k) : [k]);
      }), d.pop();
    }
  }
  if (!ae.isObject(e))
    throw new TypeError("data must be an object");
  return h(e), t;
}
function _0(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(i) {
    return t[i];
  });
}
function zp(e, t) {
  this._pairs = [], e && Bh(e, this, t);
}
const jC = zp.prototype;
jC.append = function(t, n) {
  this._pairs.push([t, n]);
};
jC.toString = function(t) {
  const n = t ? function(i) {
    return t.call(this, i, _0);
  } : _0;
  return this._pairs.map(function(r) {
    return n(r[0]) + "=" + n(r[1]);
  }, "").join("&");
};
function eF(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function HC(e, t, n) {
  if (!t)
    return e;
  const i = n && n.encode || eF, r = n && n.serialize;
  let s;
  if (r ? s = r(t, n) : s = ae.isURLSearchParams(t) ? t.toString() : new zp(t, n).toString(i), s) {
    const a = e.indexOf("#");
    a !== -1 && (e = e.slice(0, a)), e += (e.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return e;
}
class tF {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, i) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: i ? i.synchronous : !1,
      runWhen: i ? i.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    ae.forEach(this.handlers, function(i) {
      i !== null && t(i);
    });
  }
}
const S0 = tF, zC = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, nF = typeof URLSearchParams < "u" ? URLSearchParams : zp, iF = typeof FormData < "u" ? FormData : null, rF = typeof Blob < "u" ? Blob : null, sF = {
  isBrowser: !0,
  classes: {
    URLSearchParams: nF,
    FormData: iF,
    Blob: rF
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Up = typeof window < "u" && typeof document < "u", aF = ((e) => Up && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator < "u" && navigator.product), oF = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), lF = Up && window.location.href || "http://localhost", uF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Up,
  hasStandardBrowserEnv: aF,
  hasStandardBrowserWebWorkerEnv: oF,
  origin: lF
}, Symbol.toStringTag, { value: "Module" })), pr = {
  ...uF,
  ...sF
};
function cF(e, t) {
  return Bh(e, new pr.classes.URLSearchParams(), Object.assign({
    visitor: function(n, i, r, s) {
      return pr.isNode && ae.isBuffer(n) ? (this.append(i, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function dF(e) {
  return ae.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function fF(e) {
  const t = {}, n = Object.keys(e);
  let i;
  const r = n.length;
  let s;
  for (i = 0; i < r; i++)
    s = n[i], t[s] = e[s];
  return t;
}
function UC(e) {
  function t(n, i, r, s) {
    let a = n[s++];
    if (a === "__proto__")
      return !0;
    const o = Number.isFinite(+a), l = s >= n.length;
    return a = !a && ae.isArray(r) ? r.length : a, l ? (ae.hasOwnProp(r, a) ? r[a] = [r[a], i] : r[a] = i, !o) : ((!r[a] || !ae.isObject(r[a])) && (r[a] = []), t(n, i, r[a], s) && ae.isArray(r[a]) && (r[a] = fF(r[a])), !o);
  }
  if (ae.isFormData(e) && ae.isFunction(e.entries)) {
    const n = {};
    return ae.forEachEntry(e, (i, r) => {
      t(dF(i), r, n, 0);
    }), n;
  }
  return null;
}
function hF(e, t, n) {
  if (ae.isString(e))
    try {
      return (t || JSON.parse)(e), ae.trim(e);
    } catch (i) {
      if (i.name !== "SyntaxError")
        throw i;
    }
  return (n || JSON.stringify)(e);
}
const qp = {
  transitional: zC,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, n) {
    const i = n.getContentType() || "", r = i.indexOf("application/json") > -1, s = ae.isObject(t);
    if (s && ae.isHTMLForm(t) && (t = new FormData(t)), ae.isFormData(t))
      return r ? JSON.stringify(UC(t)) : t;
    if (ae.isArrayBuffer(t) || ae.isBuffer(t) || ae.isStream(t) || ae.isFile(t) || ae.isBlob(t) || ae.isReadableStream(t))
      return t;
    if (ae.isArrayBufferView(t))
      return t.buffer;
    if (ae.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let o;
    if (s) {
      if (i.indexOf("application/x-www-form-urlencoded") > -1)
        return cF(t, this.formSerializer).toString();
      if ((o = ae.isFileList(t)) || i.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return Bh(
          o ? { "files[]": t } : t,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return s || r ? (n.setContentType("application/json", !1), hF(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || qp.transitional, i = n && n.forcedJSONParsing, r = this.responseType === "json";
    if (ae.isResponse(t) || ae.isReadableStream(t))
      return t;
    if (t && ae.isString(t) && (i && !this.responseType || r)) {
      const a = !(n && n.silentJSONParsing) && r;
      try {
        return JSON.parse(t);
      } catch (o) {
        if (a)
          throw o.name === "SyntaxError" ? Ye.from(o, Ye.ERR_BAD_RESPONSE, this, null, this.response) : o;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: pr.classes.FormData,
    Blob: pr.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
ae.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  qp.headers[e] = {};
});
const Gp = qp, mF = ae.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), vF = (e) => {
  const t = {};
  let n, i, r;
  return e && e.split(`
`).forEach(function(a) {
    r = a.indexOf(":"), n = a.substring(0, r).trim().toLowerCase(), i = a.substring(r + 1).trim(), !(!n || t[n] && mF[n]) && (n === "set-cookie" ? t[n] ? t[n].push(i) : t[n] = [i] : t[n] = t[n] ? t[n] + ", " + i : i);
  }), t;
}, k0 = Symbol("internals");
function uu(e) {
  return e && String(e).trim().toLowerCase();
}
function Gd(e) {
  return e === !1 || e == null ? e : ae.isArray(e) ? e.map(Gd) : String(e);
}
function gF(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let i;
  for (; i = n.exec(e); )
    t[i[1]] = i[2];
  return t;
}
const pF = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function rv(e, t, n, i, r) {
  if (ae.isFunction(i))
    return i.call(this, t, n);
  if (r && (t = n), !!ae.isString(t)) {
    if (ae.isString(i))
      return t.indexOf(i) !== -1;
    if (ae.isRegExp(i))
      return i.test(t);
  }
}
function yF(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, i) => n.toUpperCase() + i);
}
function bF(e, t) {
  const n = ae.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((i) => {
    Object.defineProperty(e, i + n, {
      value: function(r, s, a) {
        return this[i].call(this, t, r, s, a);
      },
      configurable: !0
    });
  });
}
class Lh {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, i) {
    const r = this;
    function s(o, l, u) {
      const c = uu(l);
      if (!c)
        throw new Error("header name must be a non-empty string");
      const d = ae.findKey(r, c);
      (!d || r[d] === void 0 || u === !0 || u === void 0 && r[d] !== !1) && (r[d || l] = Gd(o));
    }
    const a = (o, l) => ae.forEach(o, (u, c) => s(u, c, l));
    if (ae.isPlainObject(t) || t instanceof this.constructor)
      a(t, n);
    else if (ae.isString(t) && (t = t.trim()) && !pF(t))
      a(vF(t), n);
    else if (ae.isHeaders(t))
      for (const [o, l] of t.entries())
        s(l, o, i);
    else
      t != null && s(n, t, i);
    return this;
  }
  get(t, n) {
    if (t = uu(t), t) {
      const i = ae.findKey(this, t);
      if (i) {
        const r = this[i];
        if (!n)
          return r;
        if (n === !0)
          return gF(r);
        if (ae.isFunction(n))
          return n.call(this, r, i);
        if (ae.isRegExp(n))
          return n.exec(r);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = uu(t), t) {
      const i = ae.findKey(this, t);
      return !!(i && this[i] !== void 0 && (!n || rv(this, this[i], i, n)));
    }
    return !1;
  }
  delete(t, n) {
    const i = this;
    let r = !1;
    function s(a) {
      if (a = uu(a), a) {
        const o = ae.findKey(i, a);
        o && (!n || rv(i, i[o], o, n)) && (delete i[o], r = !0);
      }
    }
    return ae.isArray(t) ? t.forEach(s) : s(t), r;
  }
  clear(t) {
    const n = Object.keys(this);
    let i = n.length, r = !1;
    for (; i--; ) {
      const s = n[i];
      (!t || rv(this, this[s], s, t, !0)) && (delete this[s], r = !0);
    }
    return r;
  }
  normalize(t) {
    const n = this, i = {};
    return ae.forEach(this, (r, s) => {
      const a = ae.findKey(i, s);
      if (a) {
        n[a] = Gd(r), delete n[s];
        return;
      }
      const o = t ? yF(s) : String(s).trim();
      o !== s && delete n[s], n[o] = Gd(r), i[o] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return ae.forEach(this, (i, r) => {
      i != null && i !== !1 && (n[r] = t && ae.isArray(i) ? i.join(", ") : i);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const i = new this(t);
    return n.forEach((r) => i.set(r)), i;
  }
  static accessor(t) {
    const i = (this[k0] = this[k0] = {
      accessors: {}
    }).accessors, r = this.prototype;
    function s(a) {
      const o = uu(a);
      i[o] || (bF(r, a), i[o] = !0);
    }
    return ae.isArray(t) ? t.forEach(s) : s(t), this;
  }
}
Lh.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
ae.reduceDescriptors(Lh.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(i) {
      this[n] = i;
    }
  };
});
ae.freezeMethods(Lh);
const yr = Lh;
function sv(e, t) {
  const n = this || Gp, i = t || n, r = yr.from(i.headers);
  let s = i.data;
  return ae.forEach(e, function(o) {
    s = o.call(n, s, r.normalize(), t ? t.status : void 0);
  }), r.normalize(), s;
}
function qC(e) {
  return !!(e && e.__CANCEL__);
}
function Ul(e, t, n) {
  Ye.call(this, e ?? "canceled", Ye.ERR_CANCELED, t, n), this.name = "CanceledError";
}
ae.inherits(Ul, Ye, {
  __CANCEL__: !0
});
function GC(e, t, n) {
  const i = n.config.validateStatus;
  !n.status || !i || i(n.status) ? e(n) : t(new Ye(
    "Request failed with status code " + n.status,
    [Ye.ERR_BAD_REQUEST, Ye.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function wF(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function _F(e, t) {
  e = e || 10;
  const n = new Array(e), i = new Array(e);
  let r = 0, s = 0, a;
  return t = t !== void 0 ? t : 1e3, function(l) {
    const u = Date.now(), c = i[s];
    a || (a = u), n[r] = l, i[r] = u;
    let d = s, f = 0;
    for (; d !== r; )
      f += n[d++], d = d % e;
    if (r = (r + 1) % e, r === s && (s = (s + 1) % e), u - a < t)
      return;
    const h = c && u - c;
    return h ? Math.round(f * 1e3 / h) : void 0;
  };
}
function SF(e, t) {
  let n = 0;
  const i = 1e3 / t;
  let r = null;
  return function() {
    const a = this === !0, o = Date.now();
    if (a || o - n > i)
      return r && (clearTimeout(r), r = null), n = o, e.apply(null, arguments);
    r || (r = setTimeout(() => (r = null, n = Date.now(), e.apply(null, arguments)), i - (o - n)));
  };
}
const Sf = (e, t, n = 3) => {
  let i = 0;
  const r = _F(50, 250);
  return SF((s) => {
    const a = s.loaded, o = s.lengthComputable ? s.total : void 0, l = a - i, u = r(l), c = a <= o;
    i = a;
    const d = {
      loaded: a,
      total: o,
      progress: o ? a / o : void 0,
      bytes: l,
      rate: u || void 0,
      estimated: u && o && c ? (o - a) / u : void 0,
      event: s,
      lengthComputable: o != null
    };
    d[t ? "download" : "upload"] = !0, e(d);
  }, n);
}, kF = pr.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a");
    let i;
    function r(s) {
      let a = s;
      return t && (n.setAttribute("href", a), a = n.href), n.setAttribute("href", a), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return i = r(window.location.href), function(a) {
      const o = ae.isString(a) ? r(a) : a;
      return o.protocol === i.protocol && o.host === i.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function() {
    return function() {
      return !0;
    };
  }()
), CF = pr.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, i, r, s) {
      const a = [e + "=" + encodeURIComponent(t)];
      ae.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()), ae.isString(i) && a.push("path=" + i), ae.isString(r) && a.push("domain=" + r), s === !0 && a.push("secure"), document.cookie = a.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function TF(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function xF(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function YC(e, t) {
  return e && !TF(t) ? xF(e, t) : t;
}
const C0 = (e) => e instanceof yr ? { ...e } : e;
function Ya(e, t) {
  t = t || {};
  const n = {};
  function i(u, c, d) {
    return ae.isPlainObject(u) && ae.isPlainObject(c) ? ae.merge.call({ caseless: d }, u, c) : ae.isPlainObject(c) ? ae.merge({}, c) : ae.isArray(c) ? c.slice() : c;
  }
  function r(u, c, d) {
    if (ae.isUndefined(c)) {
      if (!ae.isUndefined(u))
        return i(void 0, u, d);
    } else
      return i(u, c, d);
  }
  function s(u, c) {
    if (!ae.isUndefined(c))
      return i(void 0, c);
  }
  function a(u, c) {
    if (ae.isUndefined(c)) {
      if (!ae.isUndefined(u))
        return i(void 0, u);
    } else
      return i(void 0, c);
  }
  function o(u, c, d) {
    if (d in t)
      return i(u, c);
    if (d in e)
      return i(void 0, u);
  }
  const l = {
    url: s,
    method: s,
    data: s,
    baseURL: a,
    transformRequest: a,
    transformResponse: a,
    paramsSerializer: a,
    timeout: a,
    timeoutMessage: a,
    withCredentials: a,
    withXSRFToken: a,
    adapter: a,
    responseType: a,
    xsrfCookieName: a,
    xsrfHeaderName: a,
    onUploadProgress: a,
    onDownloadProgress: a,
    decompress: a,
    maxContentLength: a,
    maxBodyLength: a,
    beforeRedirect: a,
    transport: a,
    httpAgent: a,
    httpsAgent: a,
    cancelToken: a,
    socketPath: a,
    responseEncoding: a,
    validateStatus: o,
    headers: (u, c) => r(C0(u), C0(c), !0)
  };
  return ae.forEach(Object.keys(Object.assign({}, e, t)), function(c) {
    const d = l[c] || r, f = d(e[c], t[c], c);
    ae.isUndefined(f) && d !== o || (n[c] = f);
  }), n;
}
const ZC = (e) => {
  const t = Ya({}, e);
  let { data: n, withXSRFToken: i, xsrfHeaderName: r, xsrfCookieName: s, headers: a, auth: o } = t;
  t.headers = a = yr.from(a), t.url = HC(YC(t.baseURL, t.url), e.params, e.paramsSerializer), o && a.set(
    "Authorization",
    "Basic " + btoa((o.username || "") + ":" + (o.password ? unescape(encodeURIComponent(o.password)) : ""))
  );
  let l;
  if (ae.isFormData(n)) {
    if (pr.hasStandardBrowserEnv || pr.hasStandardBrowserWebWorkerEnv)
      a.setContentType(void 0);
    else if ((l = a.getContentType()) !== !1) {
      const [u, ...c] = l ? l.split(";").map((d) => d.trim()).filter(Boolean) : [];
      a.setContentType([u || "multipart/form-data", ...c].join("; "));
    }
  }
  if (pr.hasStandardBrowserEnv && (i && ae.isFunction(i) && (i = i(t)), i || i !== !1 && kF(t.url))) {
    const u = r && s && CF.read(s);
    u && a.set(r, u);
  }
  return t;
}, AF = typeof XMLHttpRequest < "u", IF = AF && function(e) {
  return new Promise(function(n, i) {
    const r = ZC(e);
    let s = r.data;
    const a = yr.from(r.headers).normalize();
    let { responseType: o } = r, l;
    function u() {
      r.cancelToken && r.cancelToken.unsubscribe(l), r.signal && r.signal.removeEventListener("abort", l);
    }
    let c = new XMLHttpRequest();
    c.open(r.method.toUpperCase(), r.url, !0), c.timeout = r.timeout;
    function d() {
      if (!c)
        return;
      const h = yr.from(
        "getAllResponseHeaders" in c && c.getAllResponseHeaders()
      ), g = {
        data: !o || o === "text" || o === "json" ? c.responseText : c.response,
        status: c.status,
        statusText: c.statusText,
        headers: h,
        config: e,
        request: c
      };
      GC(function(y) {
        n(y), u();
      }, function(y) {
        i(y), u();
      }, g), c = null;
    }
    "onloadend" in c ? c.onloadend = d : c.onreadystatechange = function() {
      !c || c.readyState !== 4 || c.status === 0 && !(c.responseURL && c.responseURL.indexOf("file:") === 0) || setTimeout(d);
    }, c.onabort = function() {
      c && (i(new Ye("Request aborted", Ye.ECONNABORTED, r, c)), c = null);
    }, c.onerror = function() {
      i(new Ye("Network Error", Ye.ERR_NETWORK, r, c)), c = null;
    }, c.ontimeout = function() {
      let m = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded";
      const g = r.transitional || zC;
      r.timeoutErrorMessage && (m = r.timeoutErrorMessage), i(new Ye(
        m,
        g.clarifyTimeoutError ? Ye.ETIMEDOUT : Ye.ECONNABORTED,
        r,
        c
      )), c = null;
    }, s === void 0 && a.setContentType(null), "setRequestHeader" in c && ae.forEach(a.toJSON(), function(m, g) {
      c.setRequestHeader(g, m);
    }), ae.isUndefined(r.withCredentials) || (c.withCredentials = !!r.withCredentials), o && o !== "json" && (c.responseType = r.responseType), typeof r.onDownloadProgress == "function" && c.addEventListener("progress", Sf(r.onDownloadProgress, !0)), typeof r.onUploadProgress == "function" && c.upload && c.upload.addEventListener("progress", Sf(r.onUploadProgress)), (r.cancelToken || r.signal) && (l = (h) => {
      c && (i(!h || h.type ? new Ul(null, e, c) : h), c.abort(), c = null);
    }, r.cancelToken && r.cancelToken.subscribe(l), r.signal && (r.signal.aborted ? l() : r.signal.addEventListener("abort", l)));
    const f = wF(r.url);
    if (f && pr.protocols.indexOf(f) === -1) {
      i(new Ye("Unsupported protocol " + f + ":", Ye.ERR_BAD_REQUEST, e));
      return;
    }
    c.send(s || null);
  });
}, EF = (e, t) => {
  let n = new AbortController(), i;
  const r = function(l) {
    if (!i) {
      i = !0, a();
      const u = l instanceof Error ? l : this.reason;
      n.abort(u instanceof Ye ? u : new Ul(u instanceof Error ? u.message : u));
    }
  };
  let s = t && setTimeout(() => {
    r(new Ye(`timeout ${t} of ms exceeded`, Ye.ETIMEDOUT));
  }, t);
  const a = () => {
    e && (s && clearTimeout(s), s = null, e.forEach((l) => {
      l && (l.removeEventListener ? l.removeEventListener("abort", r) : l.unsubscribe(r));
    }), e = null);
  };
  e.forEach((l) => l && l.addEventListener && l.addEventListener("abort", r));
  const { signal: o } = n;
  return o.unsubscribe = a, [o, () => {
    s && clearTimeout(s), s = null;
  }];
}, OF = EF, PF = function* (e, t) {
  let n = e.byteLength;
  if (!t || n < t) {
    yield e;
    return;
  }
  let i = 0, r;
  for (; i < n; )
    r = i + t, yield e.slice(i, r), i = r;
}, VF = async function* (e, t, n) {
  for await (const i of e)
    yield* PF(ArrayBuffer.isView(i) ? i : await n(String(i)), t);
}, T0 = (e, t, n, i, r) => {
  const s = VF(e, t, r);
  let a = 0;
  return new ReadableStream({
    type: "bytes",
    async pull(o) {
      const { done: l, value: u } = await s.next();
      if (l) {
        o.close(), i();
        return;
      }
      let c = u.byteLength;
      n && n(a += c), o.enqueue(new Uint8Array(u));
    },
    cancel(o) {
      return i(o), s.return();
    }
  }, {
    highWaterMark: 2
  });
}, x0 = (e, t) => {
  const n = e != null;
  return (i) => setTimeout(() => t({
    lengthComputable: n,
    total: e,
    loaded: i
  }));
}, $h = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", KC = $h && typeof ReadableStream == "function", Xv = $h && (typeof TextEncoder == "function" ? ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), DF = KC && (() => {
  let e = !1;
  const t = new Request(pr.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
})(), A0 = 64 * 1024, Jv = KC && !!(() => {
  try {
    return ae.isReadableStream(new Response("").body);
  } catch {
  }
})(), kf = {
  stream: Jv && ((e) => e.body)
};
$h && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !kf[t] && (kf[t] = ae.isFunction(e[t]) ? (n) => n[t]() : (n, i) => {
      throw new Ye(`Response type '${t}' is not supported`, Ye.ERR_NOT_SUPPORT, i);
    });
  });
})(new Response());
const NF = async (e) => {
  if (e == null)
    return 0;
  if (ae.isBlob(e))
    return e.size;
  if (ae.isSpecCompliantForm(e))
    return (await new Request(e).arrayBuffer()).byteLength;
  if (ae.isArrayBufferView(e))
    return e.byteLength;
  if (ae.isURLSearchParams(e) && (e = e + ""), ae.isString(e))
    return (await Xv(e)).byteLength;
}, MF = async (e, t) => {
  const n = ae.toFiniteNumber(e.getContentLength());
  return n ?? NF(t);
}, RF = $h && (async (e) => {
  let {
    url: t,
    method: n,
    data: i,
    signal: r,
    cancelToken: s,
    timeout: a,
    onDownloadProgress: o,
    onUploadProgress: l,
    responseType: u,
    headers: c,
    withCredentials: d = "same-origin",
    fetchOptions: f
  } = ZC(e);
  u = u ? (u + "").toLowerCase() : "text";
  let [h, m] = r || s || a ? OF([r, s], a) : [], g, p;
  const y = () => {
    !g && setTimeout(() => {
      h && h.unsubscribe();
    }), g = !0;
  };
  let k;
  try {
    if (l && DF && n !== "get" && n !== "head" && (k = await MF(c, i)) !== 0) {
      let S = new Request(t, {
        method: "POST",
        body: i,
        duplex: "half"
      }), C;
      ae.isFormData(i) && (C = S.headers.get("content-type")) && c.setContentType(C), S.body && (i = T0(S.body, A0, x0(
        k,
        Sf(l)
      ), null, Xv));
    }
    ae.isString(d) || (d = d ? "cors" : "omit"), p = new Request(t, {
      ...f,
      signal: h,
      method: n.toUpperCase(),
      headers: c.normalize().toJSON(),
      body: i,
      duplex: "half",
      withCredentials: d
    });
    let T = await fetch(p);
    const _ = Jv && (u === "stream" || u === "response");
    if (Jv && (o || _)) {
      const S = {};
      ["status", "statusText", "headers"].forEach((x) => {
        S[x] = T[x];
      });
      const C = ae.toFiniteNumber(T.headers.get("content-length"));
      T = new Response(
        T0(T.body, A0, o && x0(
          C,
          Sf(o, !0)
        ), _ && y, Xv),
        S
      );
    }
    u = u || "text";
    let b = await kf[ae.findKey(kf, u) || "text"](T, e);
    return !_ && y(), m && m(), await new Promise((S, C) => {
      GC(S, C, {
        data: b,
        headers: yr.from(T.headers),
        status: T.status,
        statusText: T.statusText,
        config: e,
        request: p
      });
    });
  } catch (T) {
    throw y(), T && T.name === "TypeError" && /fetch/i.test(T.message) ? Object.assign(
      new Ye("Network Error", Ye.ERR_NETWORK, e, p),
      {
        cause: T.cause || T
      }
    ) : Ye.from(T, T && T.code, e, p);
  }
}), Qv = {
  http: XR,
  xhr: IF,
  fetch: RF
};
ae.forEach(Qv, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const I0 = (e) => `- ${e}`, FF = (e) => ae.isFunction(e) || e === null || e === !1, XC = {
  getAdapter: (e) => {
    e = ae.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, i;
    const r = {};
    for (let s = 0; s < t; s++) {
      n = e[s];
      let a;
      if (i = n, !FF(n) && (i = Qv[(a = String(n)).toLowerCase()], i === void 0))
        throw new Ye(`Unknown adapter '${a}'`);
      if (i)
        break;
      r[a || "#" + s] = i;
    }
    if (!i) {
      const s = Object.entries(r).map(
        ([o, l]) => `adapter ${o} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let a = t ? s.length > 1 ? `since :
` + s.map(I0).join(`
`) : " " + I0(s[0]) : "as no adapter specified";
      throw new Ye(
        "There is no suitable adapter to dispatch the request " + a,
        "ERR_NOT_SUPPORT"
      );
    }
    return i;
  },
  adapters: Qv
};
function av(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Ul(null, e);
}
function E0(e) {
  return av(e), e.headers = yr.from(e.headers), e.data = sv.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), XC.getAdapter(e.adapter || Gp.adapter)(e).then(function(i) {
    return av(e), i.data = sv.call(
      e,
      e.transformResponse,
      i
    ), i.headers = yr.from(i.headers), i;
  }, function(i) {
    return qC(i) || (av(e), i && i.response && (i.response.data = sv.call(
      e,
      e.transformResponse,
      i.response
    ), i.response.headers = yr.from(i.response.headers))), Promise.reject(i);
  });
}
const JC = "1.7.2", Yp = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Yp[e] = function(i) {
    return typeof i === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const O0 = {};
Yp.transitional = function(t, n, i) {
  function r(s, a) {
    return "[Axios v" + JC + "] Transitional option '" + s + "'" + a + (i ? ". " + i : "");
  }
  return (s, a, o) => {
    if (t === !1)
      throw new Ye(
        r(a, " has been removed" + (n ? " in " + n : "")),
        Ye.ERR_DEPRECATED
      );
    return n && !O0[a] && (O0[a] = !0, console.warn(
      r(
        a,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(s, a, o) : !0;
  };
};
function BF(e, t, n) {
  if (typeof e != "object")
    throw new Ye("options must be an object", Ye.ERR_BAD_OPTION_VALUE);
  const i = Object.keys(e);
  let r = i.length;
  for (; r-- > 0; ) {
    const s = i[r], a = t[s];
    if (a) {
      const o = e[s], l = o === void 0 || a(o, s, e);
      if (l !== !0)
        throw new Ye("option " + s + " must be " + l, Ye.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new Ye("Unknown option " + s, Ye.ERR_BAD_OPTION);
  }
}
const eg = {
  assertOptions: BF,
  validators: Yp
}, Ns = eg.validators;
class Cf {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new S0(),
      response: new S0()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (i) {
      if (i instanceof Error) {
        let r;
        Error.captureStackTrace ? Error.captureStackTrace(r = {}) : r = new Error();
        const s = r.stack ? r.stack.replace(/^.+\n/, "") : "";
        try {
          i.stack ? s && !String(i.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (i.stack += `
` + s) : i.stack = s;
        } catch {
        }
      }
      throw i;
    }
  }
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Ya(this.defaults, n);
    const { transitional: i, paramsSerializer: r, headers: s } = n;
    i !== void 0 && eg.assertOptions(i, {
      silentJSONParsing: Ns.transitional(Ns.boolean),
      forcedJSONParsing: Ns.transitional(Ns.boolean),
      clarifyTimeoutError: Ns.transitional(Ns.boolean)
    }, !1), r != null && (ae.isFunction(r) ? n.paramsSerializer = {
      serialize: r
    } : eg.assertOptions(r, {
      encode: Ns.function,
      serialize: Ns.function
    }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let a = s && ae.merge(
      s.common,
      s[n.method]
    );
    s && ae.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (m) => {
        delete s[m];
      }
    ), n.headers = yr.concat(a, s);
    const o = [];
    let l = !0;
    this.interceptors.request.forEach(function(g) {
      typeof g.runWhen == "function" && g.runWhen(n) === !1 || (l = l && g.synchronous, o.unshift(g.fulfilled, g.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function(g) {
      u.push(g.fulfilled, g.rejected);
    });
    let c, d = 0, f;
    if (!l) {
      const m = [E0.bind(this), void 0];
      for (m.unshift.apply(m, o), m.push.apply(m, u), f = m.length, c = Promise.resolve(n); d < f; )
        c = c.then(m[d++], m[d++]);
      return c;
    }
    f = o.length;
    let h = n;
    for (d = 0; d < f; ) {
      const m = o[d++], g = o[d++];
      try {
        h = m(h);
      } catch (p) {
        g.call(this, p);
        break;
      }
    }
    try {
      c = E0.call(this, h);
    } catch (m) {
      return Promise.reject(m);
    }
    for (d = 0, f = u.length; d < f; )
      c = c.then(u[d++], u[d++]);
    return c;
  }
  getUri(t) {
    t = Ya(this.defaults, t);
    const n = YC(t.baseURL, t.url);
    return HC(n, t.params, t.paramsSerializer);
  }
}
ae.forEach(["delete", "get", "head", "options"], function(t) {
  Cf.prototype[t] = function(n, i) {
    return this.request(Ya(i || {}, {
      method: t,
      url: n,
      data: (i || {}).data
    }));
  };
});
ae.forEach(["post", "put", "patch"], function(t) {
  function n(i) {
    return function(s, a, o) {
      return this.request(Ya(o || {}, {
        method: t,
        headers: i ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: a
      }));
    };
  }
  Cf.prototype[t] = n(), Cf.prototype[t + "Form"] = n(!0);
});
const Yd = Cf;
class Zp {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(s) {
      n = s;
    });
    const i = this;
    this.promise.then((r) => {
      if (!i._listeners)
        return;
      let s = i._listeners.length;
      for (; s-- > 0; )
        i._listeners[s](r);
      i._listeners = null;
    }), this.promise.then = (r) => {
      let s;
      const a = new Promise((o) => {
        i.subscribe(o), s = o;
      }).then(r);
      return a.cancel = function() {
        i.unsubscribe(s);
      }, a;
    }, t(function(s, a, o) {
      i.reason || (i.reason = new Ul(s, a, o), n(i.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new Zp(function(r) {
        t = r;
      }),
      cancel: t
    };
  }
}
const LF = Zp;
function $F(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function WF(e) {
  return ae.isObject(e) && e.isAxiosError === !0;
}
const tg = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(tg).forEach(([e, t]) => {
  tg[t] = e;
});
const jF = tg;
function QC(e) {
  const t = new Yd(e), n = PC(Yd.prototype.request, t);
  return ae.extend(n, Yd.prototype, t, { allOwnKeys: !0 }), ae.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(r) {
    return QC(Ya(e, r));
  }, n;
}
const hn = QC(Gp);
hn.Axios = Yd;
hn.CanceledError = Ul;
hn.CancelToken = LF;
hn.isCancel = qC;
hn.VERSION = JC;
hn.toFormData = Bh;
hn.AxiosError = Ye;
hn.Cancel = hn.CanceledError;
hn.all = function(t) {
  return Promise.all(t);
};
hn.spread = $F;
hn.isAxiosError = WF;
hn.mergeConfig = Ya;
hn.AxiosHeaders = yr;
hn.formToJSON = (e) => UC(ae.isHTMLForm(e) ? new FormData(e) : e);
hn.getAdapter = XC.getAdapter;
hn.HttpStatusCode = jF;
hn.default = hn;
const HF = hn, zF = (e, t, n) => {
  if (!(t instanceof Nh))
    throw new Error("Invalid or missing LocalStorageService instance");
  if (!(n instanceof Ch))
    throw new Error("Invalid or missing Bus instance");
  const i = HF.create({
    baseURL: e,
    headers: {
      "Content-Type": "application/json"
    },
    validateStatus: () => !0
  });
  return i.interceptors.request.use(
    (r) => {
      if (t && t.loaded) {
        const s = t.get("bearer");
        s && (r.headers.Authorization = `Bearer ${s}`);
      }
      return r;
    },
    (r) => Promise.reject(r)
  ), i.interceptors.response.use(
    (r) => (r.status === 401 && n && n.emit("api:unauthorized", {
      local: !0,
      crossTab: !0
    }), r),
    (r) => (r.response && r.response.status === 401 && n && n.emit("api:unauthorized", {
      local: !0,
      crossTab: !0
    }), Promise.reject(r))
  ), i;
}, UF = (e) => typeof e == "function" && typeof e.defaults == "object" && typeof e.request == "function" && typeof e.get == "function" && typeof e.delete == "function" && typeof e.head == "function" && typeof e.options == "function" && typeof e.post == "function" && typeof e.put == "function" && typeof e.patch == "function", qF = {
  install: (e, t) => {
    const n = t != null && t.baseURL || window ? window.location.origin : "http://localhost:3000", i = zF(
      n,
      e.config.globalProperties.$ls,
      e.config.globalProperties.$bus
    );
    e.provide("api", i), e.config.globalProperties.$api = i;
  }
};
var Kp = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, ye = (e, t, n) => (Kp(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Gt = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, Sn = (e, t, n, i) => (Kp(e, t, "write to private field"), i ? i.call(e, n) : t.set(e, n), n), vn = (e, t, n) => (Kp(e, t, "access private method"), n), Vn, Ju, Fn, Sa, Fr, Lr, lr, Br, Ci, bu, wu, _u, Su, ku, Zd, Fa, Tf, Cu, Rr, ss, Qu, xf, qs, Ba, Kd, ng;
const Li = xs("Identity");
class eT {
  /**
   * Create a new Identity instance
   * @param bus A BusService instance
   * @param ls A LocalStorageService instance
   * @param cron A MiliCron instance
   * @param api An Axios instance
   * @param tokenRefresh A token refresh callback
   * @param tokenRefreshBuffer The amount of time in milliseconds before the token expires before a token is considered refreshable (default: 5 minutes)
   */
  constructor(t, n, i, r, s, a = 60 * 5) {
    if (Gt(this, Rr), Gt(this, Qu), Gt(this, qs), Gt(this, Kd), Gt(this, Vn, void 0), Gt(this, Ju, void 0), Gt(this, Fn, void 0), Gt(this, Sa, void 0), Gt(this, Fr, void 0), Gt(this, Lr, void 0), Gt(this, lr, void 0), Gt(this, Br, void 0), Gt(this, Ci, X(void 0)), Gt(this, bu, void 0), Gt(this, wu, void 0), Gt(this, _u, void 0), Gt(this, Su, void 0), Gt(this, ku, void 0), Gt(this, Zd, void 0), Gt(this, Fa, void 0), Gt(this, Tf, void 0), Gt(this, Cu, void 0), !(t instanceof Ch))
      throw Li({ bus: t }), new Error("Invalid or missing BusService instance");
    if (!(n instanceof Nh))
      throw Li({ ls: n }), new Error("Invalid or missing LocalStorageService instance");
    if (!(i instanceof $p))
      throw Li({ cron: i }), new Error("Invalid or missing MiliCron instance");
    if (!UF(r))
      throw Li({ api: r }), new Error("Invalid or missing Axios instance");
    Sn(this, Fr, X(!1)), Sn(this, Vn, t), Sn(this, Ju, r), Sn(this, Fn, n), Sn(this, Tf, s), Sn(this, Cu, a), Sn(this, Sa, i), Sn(this, Lr, X(void 0)), Sn(this, lr, X(void 0)), Sn(this, Br, X(void 0)), Sn(this, Ci, X(void 0)), Sn(this, wu, w(() => ye(this, Ci).value !== void 0 && ye(this, Ci).value > 0 && ye(this, Ci).value <= ye(this, Cu))), Sn(this, Su, w(() => ye(this, Fr).value === !0 && ye(this, Lr).value !== void 0 && ye(this, Ci).value !== void 0 && ye(this, Ci).value > 0)), Sn(this, ku, w(() => ye(this, Su).value && ye(this, Br).value !== void 0 && ye(this, Br).value !== null && Object.keys(ye(this, Br).value).length > 0)), Sn(this, Zd, w(() => {
      if (ye(this, ku).value)
        return {
          ...ye(this, Br).value
        };
    })), Sn(this, Fa, X(void 0));
  }
  /**
   * Whether or not the Identity service has booted
   */
  get booted() {
    return ye(this, Fr);
  }
  /**
   * Whether or not the visitor is authenticated
   */
  get authenticated() {
    return ye(this, Su);
  }
  /**
   * Whether or not the visitor is identified
   */
  get identified() {
    return ye(this, ku);
  }
  /**
   * The user's identity
   */
  get user() {
    return ye(this, Zd);
  }
  /**
   * Whether or not the token is refreshable
   */
  get refreshable() {
    return ye(this, wu);
  }
  /**
   * The time until the authentication expires
   */
  get ttl() {
    return ye(this, Ci);
  }
  /**
   * Save the bearer token, expiration, and user identity to the LocalStorageService and update the authentication & identification state
   * @param bearer The bearer token
   * @param expiration The expiration time of the token
   * @param identity The user's identity
   * @returns void
   */
  login(t, n, i) {
    if (!ye(this, Fr)) {
      Li("Login not processed because not booted");
      return;
    }
    ye(this, Fn).set("bearer", t), ye(this, Lr).value = t, ye(this, Fn).set("expiration", n), ye(this, lr).value = n, ye(this, Fn).set("user.identity", i), ye(this, Br).value = i, vn(this, qs, Ba).call(this), ye(this, Vn).emit(
      "identity:login",
      {
        local: !0,
        crossTab: !0
      },
      t,
      n,
      i
    );
  }
  /**
   * Remove the bearer token, expiration, and user identity from the LocalStorageService and update the authentication & identification state
   * @returns void
   */
  logout() {
    ye(this, Fn).remove("bearer"), ye(this, Lr).value = void 0, ye(this, Fn).remove("expiration"), ye(this, lr).value = void 0, ye(this, Fn).remove("user.identity"), ye(this, Br).value = void 0, ye(this, Vn).emit("identity:logout", {
      local: !0,
      crossTab: !0
    });
  }
  /**
   * Boot the Identity service
   */
  boot() {
    ye(this, Vn).on("api:unauthorized", this.logout.bind(this), { local: !0, crossTab: !0 }), ye(this, Vn).on("identity:login", vn(this, Rr, ss).bind(this), {
      local: !0,
      crossTab: !0,
      immediate: !0
    }), ye(this, Vn).on("identity:logout", vn(this, Rr, ss).bind(this), {
      local: !0,
      crossTab: !0,
      immediate: !0
    }), ye(this, Vn).on("tab:active", vn(this, Rr, ss).bind(this), {
      local: !0
    }), ye(this, Vn).on("authentication:refreshable", vn(this, Kd, ng).bind(this), {
      local: !0,
      crossTab: !0,
      immediate: !0
    }), ye(this, Sa).$on("*/250 * * * * *", vn(this, Rr, ss).bind(this)), ye(this, Sa).$on("* * * * *", vn(this, qs, Ba).bind(this)), Sn(this, bu, fe(
      () => ye(this, Ci).value,
      (t, n) => {
        t !== n && (t === void 0 && n !== void 0 && ye(this, Lr).value !== void 0 ? (Li("Authentication Expired. Logging Out."), this.logout()) : t !== void 0 && t <= 0 && (Li("Authentication Expired. Logging Out."), this.logout()));
      },
      {
        immediate: !0
      }
    )), Sn(this, _u, fe(
      () => ye(this, wu).value,
      (t) => {
        t && (Li("Token is refreshable"), ye(this, Vn).emit("authentication:refreshable", {
          local: !0,
          crossTab: !0
        }));
      }
    )), vn(this, Qu, xf).call(this, !0);
  }
  /**
   * Shutdown the Identity service
   */
  shutdown() {
    ye(this, Vn).off("api:unauthorized", this.logout.bind(this), { local: !0, crossTab: !0 }), ye(this, Vn).off("identity:login", vn(this, Rr, ss).bind(this), {
      local: !0,
      crossTab: !0
    }), ye(this, Vn).off("tab:active", vn(this, Rr, ss).bind(this), {
      local: !0
    }), ye(this, Vn).off("identity:logout", vn(this, Rr, ss).bind(this), {
      local: !0,
      crossTab: !0
    }), ye(this, Sa).$off("*/250 * * * * *", vn(this, Rr, ss).bind(this)), ye(this, Sa).$off("* * * * *", vn(this, qs, Ba).bind(this)), ye(this, bu) && ye(this, bu).call(this), ye(this, _u) && ye(this, _u).call(this), ye(this, Fr).value = !1, Li("Shutdown");
  }
  /**
   * Force a refresh of the token
   * @private
   * @remarks This method is not intended to be used by the consumer of the Identity service, but is for development and testing purposes
   */
  async forceRefreshToken() {
    ye(this, Fr).value && await vn(this, Kd, ng).call(this);
  }
  /**
   * Make the token refreshable
   * @private
   * @remarks This method is not intended to be used by the consumer of the Identity service, but is for development and testing purposes
   */
  $makeRefreshable() {
    if (ye(this, Fr).value && typeof ye(this, Lr).value == "string" && typeof ye(this, lr).value == "string") {
      const t = Be.now().plus({ seconds: ye(this, Cu) }).toISO();
      ye(this, Fn).set("expiration", t), ye(this, lr).value = t, vn(this, qs, Ba).call(this);
    }
  }
}
Vn = /* @__PURE__ */ new WeakMap();
Ju = /* @__PURE__ */ new WeakMap();
Fn = /* @__PURE__ */ new WeakMap();
Sa = /* @__PURE__ */ new WeakMap();
Fr = /* @__PURE__ */ new WeakMap();
Lr = /* @__PURE__ */ new WeakMap();
lr = /* @__PURE__ */ new WeakMap();
Br = /* @__PURE__ */ new WeakMap();
Ci = /* @__PURE__ */ new WeakMap();
bu = /* @__PURE__ */ new WeakMap();
wu = /* @__PURE__ */ new WeakMap();
_u = /* @__PURE__ */ new WeakMap();
Su = /* @__PURE__ */ new WeakMap();
ku = /* @__PURE__ */ new WeakMap();
Zd = /* @__PURE__ */ new WeakMap();
Fa = /* @__PURE__ */ new WeakMap();
Tf = /* @__PURE__ */ new WeakMap();
Cu = /* @__PURE__ */ new WeakMap();
Rr = /* @__PURE__ */ new WeakSet();
ss = function() {
  vn(this, Qu, xf).call(this);
};
Qu = /* @__PURE__ */ new WeakSet();
xf = function(e = !1) {
  if (!ye(this, Fn).loaded) {
    ye(this, Fn).promise.then(() => {
      vn(this, Qu, xf).call(this, e);
    });
    return;
  }
  ye(this, Lr).value = ye(this, Fn).get("bearer"), ye(this, lr).value = ye(this, Fn).get("expiration"), ye(this, Br).value = ye(this, Fn).get("user.identity"), e && (vn(this, qs, Ba).call(this), ye(this, Fr).value = !0, Li("Booted"));
};
qs = /* @__PURE__ */ new WeakSet();
Ba = function() {
  if (ye(this, lr).value) {
    const e = Be.fromISO(ye(this, lr).value);
    if (!e.isValid) {
      ye(this, Ci).value = void 0;
      return;
    }
    const t = Be.now(), n = e.diff(t, "seconds");
    ye(this, Ci).value = n.seconds;
  } else {
    ye(this, Ci).value = void 0;
    return;
  }
};
Kd = /* @__PURE__ */ new WeakSet();
ng = async function() {
  if (ye(this, Vn) && ye(this, Ju))
    if (await ye(this, Vn).isMain(500)) {
      ye(this, Fa).value && ye(this, Fa).value.abort(), ye(this, Fa).value = new AbortController();
      try {
        const { bearer: t, expiration: n } = await ye(this, Tf).call(this, ye(this, Ju), ye(this, Fa).value.signal);
        ye(this, Fn).set("bearer", t), ye(this, Lr).value = t, ye(this, Fn).set("expiration", n), ye(this, lr).value = n, vn(this, qs, Ba).call(this);
      } catch {
        Li("Failed to refresh token");
      }
    } else
      Li("Not main tab. Allowing main tab to refresh token.");
};
const GF = {
  install: (e, t) => {
    const n = (t == null ? void 0 : t.tokenRefreshBuffer) || 300, i = (t == null ? void 0 : t.tokenRefresh) || (() => ({
      bearer: "",
      expiration: Be.now().plus({ minutes: n * 3 }).toISO()
    })), r = new eT(
      e.config.globalProperties.$bus,
      e.config.globalProperties.$ls,
      e.config.globalProperties.$cron,
      e.config.globalProperties.$api,
      i,
      n
    );
    e.provide("identity", r), e.config.globalProperties.$identity = r;
  }
}, $7 = {
  install: (e, t) => {
    e.use(KD, t == null ? void 0 : t.bus), e.use(iR), e.use(cR, t == null ? void 0 : t.ls), e.use(fR, t == null ? void 0 : t.vuetify), e.use(qF, t == null ? void 0 : t.api), e.use(GF, t == null ? void 0 : t.identity);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tT = function(e) {
  const t = [];
  let n = 0;
  for (let i = 0; i < e.length; i++) {
    let r = e.charCodeAt(i);
    r < 128 ? t[n++] = r : r < 2048 ? (t[n++] = r >> 6 | 192, t[n++] = r & 63 | 128) : (r & 64512) === 55296 && i + 1 < e.length && (e.charCodeAt(i + 1) & 64512) === 56320 ? (r = 65536 + ((r & 1023) << 10) + (e.charCodeAt(++i) & 1023), t[n++] = r >> 18 | 240, t[n++] = r >> 12 & 63 | 128, t[n++] = r >> 6 & 63 | 128, t[n++] = r & 63 | 128) : (t[n++] = r >> 12 | 224, t[n++] = r >> 6 & 63 | 128, t[n++] = r & 63 | 128);
  }
  return t;
}, YF = function(e) {
  const t = [];
  let n = 0, i = 0;
  for (; n < e.length; ) {
    const r = e[n++];
    if (r < 128)
      t[i++] = String.fromCharCode(r);
    else if (r > 191 && r < 224) {
      const s = e[n++];
      t[i++] = String.fromCharCode((r & 31) << 6 | s & 63);
    } else if (r > 239 && r < 365) {
      const s = e[n++], a = e[n++], o = e[n++], l = ((r & 7) << 18 | (s & 63) << 12 | (a & 63) << 6 | o & 63) - 65536;
      t[i++] = String.fromCharCode(55296 + (l >> 10)), t[i++] = String.fromCharCode(56320 + (l & 1023));
    } else {
      const s = e[n++], a = e[n++];
      t[i++] = String.fromCharCode((r & 15) << 12 | (s & 63) << 6 | a & 63);
    }
  }
  return t.join("");
}, nT = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob == "function",
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray(e, t) {
    if (!Array.isArray(e))
      throw Error("encodeByteArray takes an array as a parameter");
    this.init_();
    const n = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, i = [];
    for (let r = 0; r < e.length; r += 3) {
      const s = e[r], a = r + 1 < e.length, o = a ? e[r + 1] : 0, l = r + 2 < e.length, u = l ? e[r + 2] : 0, c = s >> 2, d = (s & 3) << 4 | o >> 4;
      let f = (o & 15) << 2 | u >> 6, h = u & 63;
      l || (h = 64, a || (f = 64)), i.push(n[c], n[d], n[f], n[h]);
    }
    return i.join("");
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString(e, t) {
    return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(tT(e), t);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString(e, t) {
    return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : YF(this.decodeStringToByteArray(e, t));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray(e, t) {
    this.init_();
    const n = t ? this.charToByteMapWebSafe_ : this.charToByteMap_, i = [];
    for (let r = 0; r < e.length; ) {
      const s = n[e.charAt(r++)], o = r < e.length ? n[e.charAt(r)] : 0;
      ++r;
      const u = r < e.length ? n[e.charAt(r)] : 64;
      ++r;
      const d = r < e.length ? n[e.charAt(r)] : 64;
      if (++r, s == null || o == null || u == null || d == null)
        throw new ZF();
      const f = s << 2 | o >> 4;
      if (i.push(f), u !== 64) {
        const h = o << 4 & 240 | u >> 2;
        if (i.push(h), d !== 64) {
          const m = u << 6 & 192 | d;
          i.push(m);
        }
      }
    }
    return i;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
      for (let e = 0; e < this.ENCODED_VALS.length; e++)
        this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e), this.charToByteMap_[this.byteToCharMap_[e]] = e, this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e, e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e);
    }
  }
};
class ZF extends Error {
  constructor() {
    super(...arguments), this.name = "DecodeBase64StringError";
  }
}
const KF = function(e) {
  const t = tT(e);
  return nT.encodeByteArray(t, !0);
}, iT = function(e) {
  return KF(e).replace(/\./g, "");
}, XF = function(e) {
  try {
    return nT.decodeString(e, !0);
  } catch (t) {
    console.error("base64Decode failed: ", t);
  }
  return null;
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function JF() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const QF = () => JF().__FIREBASE_DEFAULTS__, eB = () => {
  if (typeof process > "u" || typeof process.env > "u")
    return;
  const e = process.env.__FIREBASE_DEFAULTS__;
  if (e)
    return JSON.parse(e);
}, tB = () => {
  if (typeof document > "u")
    return;
  let e;
  try {
    e = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch {
    return;
  }
  const t = e && XF(e[1]);
  return t && JSON.parse(t);
}, nB = () => {
  try {
    return QF() || eB() || tB();
  } catch (e) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);
    return;
  }
}, rT = () => {
  var e;
  return (e = nB()) === null || e === void 0 ? void 0 : e.config;
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class iB {
  constructor() {
    this.reject = () => {
    }, this.resolve = () => {
    }, this.promise = new Promise((t, n) => {
      this.resolve = t, this.reject = n;
    });
  }
  /**
   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(t) {
    return (n, i) => {
      n ? this.reject(n) : this.resolve(i), typeof t == "function" && (this.promise.catch(() => {
      }), t.length === 1 ? t(n) : t(n, i));
    };
  }
}
function sT() {
  try {
    return typeof indexedDB == "object";
  } catch {
    return !1;
  }
}
function aT() {
  return new Promise((e, t) => {
    try {
      let n = !0;
      const i = "validate-browser-context-for-indexeddb-analytics-module", r = self.indexedDB.open(i);
      r.onsuccess = () => {
        r.result.close(), n || self.indexedDB.deleteDatabase(i), e(!0);
      }, r.onupgradeneeded = () => {
        n = !1;
      }, r.onerror = () => {
        var s;
        t(((s = r.error) === null || s === void 0 ? void 0 : s.message) || "");
      };
    } catch (n) {
      t(n);
    }
  });
}
function rB() {
  return !(typeof navigator > "u" || !navigator.cookieEnabled);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const sB = "FirebaseError";
class ql extends Error {
  constructor(t, n, i) {
    super(n), this.code = t, this.customData = i, this.name = sB, Object.setPrototypeOf(this, ql.prototype), Error.captureStackTrace && Error.captureStackTrace(this, Wh.prototype.create);
  }
}
class Wh {
  constructor(t, n, i) {
    this.service = t, this.serviceName = n, this.errors = i;
  }
  create(t, ...n) {
    const i = n[0] || {}, r = `${this.service}/${t}`, s = this.errors[t], a = s ? aB(s, i) : "Error", o = `${this.serviceName}: ${a} (${r}).`;
    return new ql(r, o, i);
  }
}
function aB(e, t) {
  return e.replace(oB, (n, i) => {
    const r = t[i];
    return r != null ? String(r) : `<${i}?>`;
  });
}
const oB = /\{\$([^}]+)}/g;
function ig(e, t) {
  if (e === t)
    return !0;
  const n = Object.keys(e), i = Object.keys(t);
  for (const r of n) {
    if (!i.includes(r))
      return !1;
    const s = e[r], a = t[r];
    if (P0(s) && P0(a)) {
      if (!ig(s, a))
        return !1;
    } else if (s !== a)
      return !1;
  }
  for (const r of i)
    if (!n.includes(r))
      return !1;
  return !0;
}
function P0(e) {
  return e !== null && typeof e == "object";
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Xp(e) {
  return e && e._delegate ? e._delegate : e;
}
class ra {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(t, n, i) {
    this.name = t, this.instanceFactory = n, this.type = i, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
  }
  setInstantiationMode(t) {
    return this.instantiationMode = t, this;
  }
  setMultipleInstances(t) {
    return this.multipleInstances = t, this;
  }
  setServiceProps(t) {
    return this.serviceProps = t, this;
  }
  setInstanceCreatedCallback(t) {
    return this.onInstanceCreated = t, this;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ka = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class lB {
  constructor(t, n) {
    this.name = t, this.container = n, this.component = null, this.instances = /* @__PURE__ */ new Map(), this.instancesDeferred = /* @__PURE__ */ new Map(), this.instancesOptions = /* @__PURE__ */ new Map(), this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  /**
   * @param identifier A provider can provide mulitple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(t) {
    const n = this.normalizeInstanceIdentifier(t);
    if (!this.instancesDeferred.has(n)) {
      const i = new iB();
      if (this.instancesDeferred.set(n, i), this.isInitialized(n) || this.shouldAutoInitialize())
        try {
          const r = this.getOrInitializeService({
            instanceIdentifier: n
          });
          r && i.resolve(r);
        } catch {
        }
    }
    return this.instancesDeferred.get(n).promise;
  }
  getImmediate(t) {
    var n;
    const i = this.normalizeInstanceIdentifier(t == null ? void 0 : t.identifier), r = (n = t == null ? void 0 : t.optional) !== null && n !== void 0 ? n : !1;
    if (this.isInitialized(i) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({
          instanceIdentifier: i
        });
      } catch (s) {
        if (r)
          return null;
        throw s;
      }
    else {
      if (r)
        return null;
      throw Error(`Service ${this.name} is not available`);
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(t) {
    if (t.name !== this.name)
      throw Error(`Mismatching Component ${t.name} for Provider ${this.name}.`);
    if (this.component)
      throw Error(`Component for ${this.name} has already been provided`);
    if (this.component = t, !!this.shouldAutoInitialize()) {
      if (cB(t))
        try {
          this.getOrInitializeService({ instanceIdentifier: ka });
        } catch {
        }
      for (const [n, i] of this.instancesDeferred.entries()) {
        const r = this.normalizeInstanceIdentifier(n);
        try {
          const s = this.getOrInitializeService({
            instanceIdentifier: r
          });
          i.resolve(s);
        } catch {
        }
      }
    }
  }
  clearInstance(t = ka) {
    this.instancesDeferred.delete(t), this.instancesOptions.delete(t), this.instances.delete(t);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const t = Array.from(this.instances.values());
    await Promise.all([
      ...t.filter((n) => "INTERNAL" in n).map((n) => n.INTERNAL.delete()),
      ...t.filter((n) => "_delete" in n).map((n) => n._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(t = ka) {
    return this.instances.has(t);
  }
  getOptions(t = ka) {
    return this.instancesOptions.get(t) || {};
  }
  initialize(t = {}) {
    const { options: n = {} } = t, i = this.normalizeInstanceIdentifier(t.instanceIdentifier);
    if (this.isInitialized(i))
      throw Error(`${this.name}(${i}) has already been initialized`);
    if (!this.isComponentSet())
      throw Error(`Component ${this.name} has not been registered yet`);
    const r = this.getOrInitializeService({
      instanceIdentifier: i,
      options: n
    });
    for (const [s, a] of this.instancesDeferred.entries()) {
      const o = this.normalizeInstanceIdentifier(s);
      i === o && a.resolve(r);
    }
    return r;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(t, n) {
    var i;
    const r = this.normalizeInstanceIdentifier(n), s = (i = this.onInitCallbacks.get(r)) !== null && i !== void 0 ? i : /* @__PURE__ */ new Set();
    s.add(t), this.onInitCallbacks.set(r, s);
    const a = this.instances.get(r);
    return a && t(a, r), () => {
      s.delete(t);
    };
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(t, n) {
    const i = this.onInitCallbacks.get(n);
    if (i)
      for (const r of i)
        try {
          r(t, n);
        } catch {
        }
  }
  getOrInitializeService({ instanceIdentifier: t, options: n = {} }) {
    let i = this.instances.get(t);
    if (!i && this.component && (i = this.component.instanceFactory(this.container, {
      instanceIdentifier: uB(t),
      options: n
    }), this.instances.set(t, i), this.instancesOptions.set(t, n), this.invokeOnInitCallbacks(i, t), this.component.onInstanceCreated))
      try {
        this.component.onInstanceCreated(this.container, t, i);
      } catch {
      }
    return i || null;
  }
  normalizeInstanceIdentifier(t = ka) {
    return this.component ? this.component.multipleInstances ? t : ka : t;
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}
function uB(e) {
  return e === ka ? void 0 : e;
}
function cB(e) {
  return e.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dB {
  constructor(t) {
    this.name = t, this.providers = /* @__PURE__ */ new Map();
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(t) {
    const n = this.getProvider(t.name);
    if (n.isComponentSet())
      throw new Error(`Component ${t.name} has already been registered with ${this.name}`);
    n.setComponent(t);
  }
  addOrOverwriteComponent(t) {
    this.getProvider(t.name).isComponentSet() && this.providers.delete(t.name), this.addComponent(t);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(t) {
    if (this.providers.has(t))
      return this.providers.get(t);
    const n = new lB(t, this);
    return this.providers.set(t, n), n;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Dt;
(function(e) {
  e[e.DEBUG = 0] = "DEBUG", e[e.VERBOSE = 1] = "VERBOSE", e[e.INFO = 2] = "INFO", e[e.WARN = 3] = "WARN", e[e.ERROR = 4] = "ERROR", e[e.SILENT = 5] = "SILENT";
})(Dt || (Dt = {}));
const fB = {
  debug: Dt.DEBUG,
  verbose: Dt.VERBOSE,
  info: Dt.INFO,
  warn: Dt.WARN,
  error: Dt.ERROR,
  silent: Dt.SILENT
}, hB = Dt.INFO, mB = {
  [Dt.DEBUG]: "log",
  [Dt.VERBOSE]: "log",
  [Dt.INFO]: "info",
  [Dt.WARN]: "warn",
  [Dt.ERROR]: "error"
}, vB = (e, t, ...n) => {
  if (t < e.logLevel)
    return;
  const i = (/* @__PURE__ */ new Date()).toISOString(), r = mB[t];
  if (r)
    console[r](`[${i}]  ${e.name}:`, ...n);
  else
    throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`);
};
class gB {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(t) {
    this.name = t, this._logLevel = hB, this._logHandler = vB, this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(t) {
    if (!(t in Dt))
      throw new TypeError(`Invalid value "${t}" assigned to \`logLevel\``);
    this._logLevel = t;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(t) {
    this._logLevel = typeof t == "string" ? fB[t] : t;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(t) {
    if (typeof t != "function")
      throw new TypeError("Value assigned to `logHandler` must be a function");
    this._logHandler = t;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(t) {
    this._userLogHandler = t;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...t) {
    this._userLogHandler && this._userLogHandler(this, Dt.DEBUG, ...t), this._logHandler(this, Dt.DEBUG, ...t);
  }
  log(...t) {
    this._userLogHandler && this._userLogHandler(this, Dt.VERBOSE, ...t), this._logHandler(this, Dt.VERBOSE, ...t);
  }
  info(...t) {
    this._userLogHandler && this._userLogHandler(this, Dt.INFO, ...t), this._logHandler(this, Dt.INFO, ...t);
  }
  warn(...t) {
    this._userLogHandler && this._userLogHandler(this, Dt.WARN, ...t), this._logHandler(this, Dt.WARN, ...t);
  }
  error(...t) {
    this._userLogHandler && this._userLogHandler(this, Dt.ERROR, ...t), this._logHandler(this, Dt.ERROR, ...t);
  }
}
const pB = (e, t) => t.some((n) => e instanceof n);
let V0, D0;
function yB() {
  return V0 || (V0 = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function bB() {
  return D0 || (D0 = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const oT = /* @__PURE__ */ new WeakMap(), rg = /* @__PURE__ */ new WeakMap(), lT = /* @__PURE__ */ new WeakMap(), ov = /* @__PURE__ */ new WeakMap(), Jp = /* @__PURE__ */ new WeakMap();
function wB(e) {
  const t = new Promise((n, i) => {
    const r = () => {
      e.removeEventListener("success", s), e.removeEventListener("error", a);
    }, s = () => {
      n(ms(e.result)), r();
    }, a = () => {
      i(e.error), r();
    };
    e.addEventListener("success", s), e.addEventListener("error", a);
  });
  return t.then((n) => {
    n instanceof IDBCursor && oT.set(n, e);
  }).catch(() => {
  }), Jp.set(t, e), t;
}
function _B(e) {
  if (rg.has(e))
    return;
  const t = new Promise((n, i) => {
    const r = () => {
      e.removeEventListener("complete", s), e.removeEventListener("error", a), e.removeEventListener("abort", a);
    }, s = () => {
      n(), r();
    }, a = () => {
      i(e.error || new DOMException("AbortError", "AbortError")), r();
    };
    e.addEventListener("complete", s), e.addEventListener("error", a), e.addEventListener("abort", a);
  });
  rg.set(e, t);
}
let sg = {
  get(e, t, n) {
    if (e instanceof IDBTransaction) {
      if (t === "done")
        return rg.get(e);
      if (t === "objectStoreNames")
        return e.objectStoreNames || lT.get(e);
      if (t === "store")
        return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
    }
    return ms(e[t]);
  },
  set(e, t, n) {
    return e[t] = n, !0;
  },
  has(e, t) {
    return e instanceof IDBTransaction && (t === "done" || t === "store") ? !0 : t in e;
  }
};
function SB(e) {
  sg = e(sg);
}
function kB(e) {
  return e === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(t, ...n) {
    const i = e.call(lv(this), t, ...n);
    return lT.set(i, t.sort ? t.sort() : [t]), ms(i);
  } : bB().includes(e) ? function(...t) {
    return e.apply(lv(this), t), ms(oT.get(this));
  } : function(...t) {
    return ms(e.apply(lv(this), t));
  };
}
function CB(e) {
  return typeof e == "function" ? kB(e) : (e instanceof IDBTransaction && _B(e), pB(e, yB()) ? new Proxy(e, sg) : e);
}
function ms(e) {
  if (e instanceof IDBRequest)
    return wB(e);
  if (ov.has(e))
    return ov.get(e);
  const t = CB(e);
  return t !== e && (ov.set(e, t), Jp.set(t, e)), t;
}
const lv = (e) => Jp.get(e);
function jh(e, t, { blocked: n, upgrade: i, blocking: r, terminated: s } = {}) {
  const a = indexedDB.open(e, t), o = ms(a);
  return i && a.addEventListener("upgradeneeded", (l) => {
    i(ms(a.result), l.oldVersion, l.newVersion, ms(a.transaction), l);
  }), n && a.addEventListener("blocked", (l) => n(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    l.oldVersion,
    l.newVersion,
    l
  )), o.then((l) => {
    s && l.addEventListener("close", () => s()), r && l.addEventListener("versionchange", (u) => r(u.oldVersion, u.newVersion, u));
  }).catch(() => {
  }), o;
}
function uv(e, { blocked: t } = {}) {
  const n = indexedDB.deleteDatabase(e);
  return t && n.addEventListener("blocked", (i) => t(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    i.oldVersion,
    i
  )), ms(n).then(() => {
  });
}
const TB = ["get", "getKey", "getAll", "getAllKeys", "count"], xB = ["put", "add", "delete", "clear"], cv = /* @__PURE__ */ new Map();
function N0(e, t) {
  if (!(e instanceof IDBDatabase && !(t in e) && typeof t == "string"))
    return;
  if (cv.get(t))
    return cv.get(t);
  const n = t.replace(/FromIndex$/, ""), i = t !== n, r = xB.includes(n);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(n in (i ? IDBIndex : IDBObjectStore).prototype) || !(r || TB.includes(n))
  )
    return;
  const s = async function(a, ...o) {
    const l = this.transaction(a, r ? "readwrite" : "readonly");
    let u = l.store;
    return i && (u = u.index(o.shift())), (await Promise.all([
      u[n](...o),
      r && l.done
    ]))[0];
  };
  return cv.set(t, s), s;
}
SB((e) => ({
  ...e,
  get: (t, n, i) => N0(t, n) || e.get(t, n, i),
  has: (t, n) => !!N0(t, n) || e.has(t, n)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AB {
  constructor(t) {
    this.container = t;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    return this.container.getProviders().map((n) => {
      if (IB(n)) {
        const i = n.getImmediate();
        return `${i.library}/${i.version}`;
      } else
        return null;
    }).filter((n) => n).join(" ");
  }
}
function IB(e) {
  const t = e.getComponent();
  return (t == null ? void 0 : t.type) === "VERSION";
}
const ag = "@firebase/app", M0 = "0.10.4";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Za = new gB("@firebase/app"), EB = "@firebase/app-compat", OB = "@firebase/analytics-compat", PB = "@firebase/analytics", VB = "@firebase/app-check-compat", DB = "@firebase/app-check", NB = "@firebase/auth", MB = "@firebase/auth-compat", RB = "@firebase/database", FB = "@firebase/database-compat", BB = "@firebase/functions", LB = "@firebase/functions-compat", $B = "@firebase/installations", WB = "@firebase/installations-compat", jB = "@firebase/messaging", HB = "@firebase/messaging-compat", zB = "@firebase/performance", UB = "@firebase/performance-compat", qB = "@firebase/remote-config", GB = "@firebase/remote-config-compat", YB = "@firebase/storage", ZB = "@firebase/storage-compat", KB = "@firebase/firestore", XB = "@firebase/vertexai-preview", JB = "@firebase/firestore-compat", QB = "firebase";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const og = "[DEFAULT]", eL = {
  [ag]: "fire-core",
  [EB]: "fire-core-compat",
  [PB]: "fire-analytics",
  [OB]: "fire-analytics-compat",
  [DB]: "fire-app-check",
  [VB]: "fire-app-check-compat",
  [NB]: "fire-auth",
  [MB]: "fire-auth-compat",
  [RB]: "fire-rtdb",
  [FB]: "fire-rtdb-compat",
  [BB]: "fire-fn",
  [LB]: "fire-fn-compat",
  [$B]: "fire-iid",
  [WB]: "fire-iid-compat",
  [jB]: "fire-fcm",
  [HB]: "fire-fcm-compat",
  [zB]: "fire-perf",
  [UB]: "fire-perf-compat",
  [qB]: "fire-rc",
  [GB]: "fire-rc-compat",
  [YB]: "fire-gcs",
  [ZB]: "fire-gcs-compat",
  [KB]: "fire-fst",
  [JB]: "fire-fst-compat",
  [XB]: "fire-vertex",
  "fire-js": "fire-js",
  [QB]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Af = /* @__PURE__ */ new Map(), tL = /* @__PURE__ */ new Map(), lg = /* @__PURE__ */ new Map();
function R0(e, t) {
  try {
    e.container.addComponent(t);
  } catch (n) {
    Za.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`, n);
  }
}
function Ka(e) {
  const t = e.name;
  if (lg.has(t))
    return Za.debug(`There were multiple attempts to register component ${t}.`), !1;
  lg.set(t, e);
  for (const n of Af.values())
    R0(n, e);
  for (const n of tL.values())
    R0(n, e);
  return !0;
}
function Qp(e, t) {
  const n = e.container.getProvider("heartbeat").getImmediate({ optional: !0 });
  return n && n.triggerHeartbeat(), e.container.getProvider(t);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const nL = {
  "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
  "bad-app-name": "Illegal App name: '{$appName}'",
  "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
  "app-deleted": "Firebase App named '{$appName}' already deleted",
  "server-app-deleted": "Firebase Server App has been deleted",
  "no-options": "Need to provide options, when not being deployed to hosting via source.",
  "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  "invalid-log-argument": "First argument to `onLog` must be null or a function.",
  "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
  "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
  "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments."
}, Qs = new Wh("app", "Firebase", nL);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class iL {
  constructor(t, n, i) {
    this._isDeleted = !1, this._options = Object.assign({}, t), this._config = Object.assign({}, n), this._name = n.name, this._automaticDataCollectionEnabled = n.automaticDataCollectionEnabled, this._container = i, this.container.addComponent(new ra(
      "app",
      () => this,
      "PUBLIC"
      /* ComponentType.PUBLIC */
    ));
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(t) {
    this.checkDestroyed(), this._automaticDataCollectionEnabled = t;
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(t) {
    this._isDeleted = t;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted)
      throw Qs.create("app-deleted", { appName: this._name });
  }
}
function uT(e, t = {}) {
  let n = e;
  typeof t != "object" && (t = { name: t });
  const i = Object.assign({ name: og, automaticDataCollectionEnabled: !1 }, t), r = i.name;
  if (typeof r != "string" || !r)
    throw Qs.create("bad-app-name", {
      appName: String(r)
    });
  if (n || (n = rT()), !n)
    throw Qs.create(
      "no-options"
      /* AppError.NO_OPTIONS */
    );
  const s = Af.get(r);
  if (s) {
    if (ig(n, s.options) && ig(i, s.config))
      return s;
    throw Qs.create("duplicate-app", { appName: r });
  }
  const a = new dB(r);
  for (const l of lg.values())
    a.addComponent(l);
  const o = new iL(n, i, a);
  return Af.set(r, o), o;
}
function rL(e = og) {
  const t = Af.get(e);
  if (!t && e === og && rT())
    return uT();
  if (!t)
    throw Qs.create("no-app", { appName: e });
  return t;
}
function ea(e, t, n) {
  var i;
  let r = (i = eL[e]) !== null && i !== void 0 ? i : e;
  n && (r += `-${n}`);
  const s = r.match(/\s|\//), a = t.match(/\s|\//);
  if (s || a) {
    const o = [
      `Unable to register library "${r}" with version "${t}":`
    ];
    s && o.push(`library name "${r}" contains illegal characters (whitespace or "/")`), s && a && o.push("and"), a && o.push(`version name "${t}" contains illegal characters (whitespace or "/")`), Za.warn(o.join(" "));
    return;
  }
  Ka(new ra(
    `${r}-version`,
    () => ({ library: r, version: t }),
    "VERSION"
    /* ComponentType.VERSION */
  ));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const sL = "firebase-heartbeat-database", aL = 1, ec = "firebase-heartbeat-store";
let dv = null;
function cT() {
  return dv || (dv = jh(sL, aL, {
    upgrade: (e, t) => {
      switch (t) {
        case 0:
          try {
            e.createObjectStore(ec);
          } catch (n) {
            console.warn(n);
          }
      }
    }
  }).catch((e) => {
    throw Qs.create("idb-open", {
      originalErrorMessage: e.message
    });
  })), dv;
}
async function oL(e) {
  try {
    const n = (await cT()).transaction(ec), i = await n.objectStore(ec).get(dT(e));
    return await n.done, i;
  } catch (t) {
    if (t instanceof ql)
      Za.warn(t.message);
    else {
      const n = Qs.create("idb-get", {
        originalErrorMessage: t == null ? void 0 : t.message
      });
      Za.warn(n.message);
    }
  }
}
async function F0(e, t) {
  try {
    const i = (await cT()).transaction(ec, "readwrite");
    await i.objectStore(ec).put(t, dT(e)), await i.done;
  } catch (n) {
    if (n instanceof ql)
      Za.warn(n.message);
    else {
      const i = Qs.create("idb-set", {
        originalErrorMessage: n == null ? void 0 : n.message
      });
      Za.warn(i.message);
    }
  }
}
function dT(e) {
  return `${e.name}!${e.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const lL = 1024, uL = 30 * 24 * 60 * 60 * 1e3;
class cL {
  constructor(t) {
    this.container = t, this._heartbeatsCache = null;
    const n = this.container.getProvider("app").getImmediate();
    this._storage = new fL(n), this._heartbeatsCachePromise = this._storage.read().then((i) => (this._heartbeatsCache = i, i));
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    var t, n;
    const r = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), s = B0();
    if (!(((t = this._heartbeatsCache) === null || t === void 0 ? void 0 : t.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise, ((n = this._heartbeatsCache) === null || n === void 0 ? void 0 : n.heartbeats) == null)) && !(this._heartbeatsCache.lastSentHeartbeatDate === s || this._heartbeatsCache.heartbeats.some((a) => a.date === s)))
      return this._heartbeatsCache.heartbeats.push({ date: s, agent: r }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((a) => {
        const o = new Date(a.date).valueOf();
        return Date.now() - o <= uL;
      }), this._storage.overwrite(this._heartbeatsCache);
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    var t;
    if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, ((t = this._heartbeatsCache) === null || t === void 0 ? void 0 : t.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0)
      return "";
    const n = B0(), { heartbeatsToSend: i, unsentEntries: r } = dL(this._heartbeatsCache.heartbeats), s = iT(JSON.stringify({ version: 2, heartbeats: i }));
    return this._heartbeatsCache.lastSentHeartbeatDate = n, r.length > 0 ? (this._heartbeatsCache.heartbeats = r, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), s;
  }
}
function B0() {
  return (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);
}
function dL(e, t = lL) {
  const n = [];
  let i = e.slice();
  for (const r of e) {
    const s = n.find((a) => a.agent === r.agent);
    if (s) {
      if (s.dates.push(r.date), L0(n) > t) {
        s.dates.pop();
        break;
      }
    } else if (n.push({
      agent: r.agent,
      dates: [r.date]
    }), L0(n) > t) {
      n.pop();
      break;
    }
    i = i.slice(1);
  }
  return {
    heartbeatsToSend: n,
    unsentEntries: i
  };
}
class fL {
  constructor(t) {
    this.app = t, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    return sT() ? aT().then(() => !0).catch(() => !1) : !1;
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    if (await this._canUseIndexedDBPromise) {
      const n = await oL(this.app);
      return n != null && n.heartbeats ? n : { heartbeats: [] };
    } else
      return { heartbeats: [] };
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(t) {
    var n;
    if (await this._canUseIndexedDBPromise) {
      const r = await this.read();
      return F0(this.app, {
        lastSentHeartbeatDate: (n = t.lastSentHeartbeatDate) !== null && n !== void 0 ? n : r.lastSentHeartbeatDate,
        heartbeats: t.heartbeats
      });
    } else
      return;
  }
  // add heartbeats
  async add(t) {
    var n;
    if (await this._canUseIndexedDBPromise) {
      const r = await this.read();
      return F0(this.app, {
        lastSentHeartbeatDate: (n = t.lastSentHeartbeatDate) !== null && n !== void 0 ? n : r.lastSentHeartbeatDate,
        heartbeats: [
          ...r.heartbeats,
          ...t.heartbeats
        ]
      });
    } else
      return;
  }
}
function L0(e) {
  return iT(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: e })
  ).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function hL(e) {
  Ka(new ra(
    "platform-logger",
    (t) => new AB(t),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), Ka(new ra(
    "heartbeat",
    (t) => new cL(t),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), ea(ag, M0, e), ea(ag, M0, "esm2017"), ea("fire-js", "");
}
hL("");
var mL = "firebase", vL = "10.12.1";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
ea(mL, vL, "app");
const fT = "@firebase/installations", ey = "0.6.7";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const hT = 1e4, mT = `w:${ey}`, vT = "FIS_v2", gL = "https://firebaseinstallations.googleapis.com/v1", pL = 60 * 60 * 1e3, yL = "installations", bL = "Installations";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const wL = {
  "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
  "not-registered": "Firebase Installation is not registered.",
  "installation-not-found": "Firebase Installation not found.",
  "request-failed": '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
  "app-offline": "Could not process request. Application offline.",
  "delete-pending-registration": "Can't delete installation while there is a pending registration request."
}, Xa = new Wh(yL, bL, wL);
function gT(e) {
  return e instanceof ql && e.code.includes(
    "request-failed"
    /* ErrorCode.REQUEST_FAILED */
  );
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function pT({ projectId: e }) {
  return `${gL}/projects/${e}/installations`;
}
function yT(e) {
  return {
    token: e.token,
    requestStatus: 2,
    expiresIn: SL(e.expiresIn),
    creationTime: Date.now()
  };
}
async function bT(e, t) {
  const i = (await t.json()).error;
  return Xa.create("request-failed", {
    requestName: e,
    serverCode: i.code,
    serverMessage: i.message,
    serverStatus: i.status
  });
}
function wT({ apiKey: e }) {
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": e
  });
}
function _L(e, { refreshToken: t }) {
  const n = wT(e);
  return n.append("Authorization", kL(t)), n;
}
async function _T(e) {
  const t = await e();
  return t.status >= 500 && t.status < 600 ? e() : t;
}
function SL(e) {
  return Number(e.replace("s", "000"));
}
function kL(e) {
  return `${vT} ${e}`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function CL({ appConfig: e, heartbeatServiceProvider: t }, { fid: n }) {
  const i = pT(e), r = wT(e), s = t.getImmediate({
    optional: !0
  });
  if (s) {
    const u = await s.getHeartbeatsHeader();
    u && r.append("x-firebase-client", u);
  }
  const a = {
    fid: n,
    authVersion: vT,
    appId: e.appId,
    sdkVersion: mT
  }, o = {
    method: "POST",
    headers: r,
    body: JSON.stringify(a)
  }, l = await _T(() => fetch(i, o));
  if (l.ok) {
    const u = await l.json();
    return {
      fid: u.fid || n,
      registrationStatus: 2,
      refreshToken: u.refreshToken,
      authToken: yT(u.authToken)
    };
  } else
    throw await bT("Create Installation", l);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ST(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function TL(e) {
  return btoa(String.fromCharCode(...e)).replace(/\+/g, "-").replace(/\//g, "_");
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const xL = /^[cdef][\w-]{21}$/, ug = "";
function AL() {
  try {
    const e = new Uint8Array(17);
    (self.crypto || self.msCrypto).getRandomValues(e), e[0] = 112 + e[0] % 16;
    const n = IL(e);
    return xL.test(n) ? n : ug;
  } catch {
    return ug;
  }
}
function IL(e) {
  return TL(e).substr(0, 22);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Hh(e) {
  return `${e.appName}!${e.appId}`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const kT = /* @__PURE__ */ new Map();
function CT(e, t) {
  const n = Hh(e);
  TT(n, t), EL(n, t);
}
function TT(e, t) {
  const n = kT.get(e);
  if (n)
    for (const i of n)
      i(t);
}
function EL(e, t) {
  const n = OL();
  n && n.postMessage({ key: e, fid: t }), PL();
}
let La = null;
function OL() {
  return !La && "BroadcastChannel" in self && (La = new BroadcastChannel("[Firebase] FID Change"), La.onmessage = (e) => {
    TT(e.data.key, e.data.fid);
  }), La;
}
function PL() {
  kT.size === 0 && La && (La.close(), La = null);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const VL = "firebase-installations-database", DL = 1, Ja = "firebase-installations-store";
let fv = null;
function ty() {
  return fv || (fv = jh(VL, DL, {
    upgrade: (e, t) => {
      switch (t) {
        case 0:
          e.createObjectStore(Ja);
      }
    }
  })), fv;
}
async function If(e, t) {
  const n = Hh(e), r = (await ty()).transaction(Ja, "readwrite"), s = r.objectStore(Ja), a = await s.get(n);
  return await s.put(t, n), await r.done, (!a || a.fid !== t.fid) && CT(e, t.fid), t;
}
async function xT(e) {
  const t = Hh(e), i = (await ty()).transaction(Ja, "readwrite");
  await i.objectStore(Ja).delete(t), await i.done;
}
async function zh(e, t) {
  const n = Hh(e), r = (await ty()).transaction(Ja, "readwrite"), s = r.objectStore(Ja), a = await s.get(n), o = t(a);
  return o === void 0 ? await s.delete(n) : await s.put(o, n), await r.done, o && (!a || a.fid !== o.fid) && CT(e, o.fid), o;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function ny(e) {
  let t;
  const n = await zh(e.appConfig, (i) => {
    const r = NL(i), s = ML(e, r);
    return t = s.registrationPromise, s.installationEntry;
  });
  return n.fid === ug ? { installationEntry: await t } : {
    installationEntry: n,
    registrationPromise: t
  };
}
function NL(e) {
  const t = e || {
    fid: AL(),
    registrationStatus: 0
    /* RequestStatus.NOT_STARTED */
  };
  return AT(t);
}
function ML(e, t) {
  if (t.registrationStatus === 0) {
    if (!navigator.onLine) {
      const r = Promise.reject(Xa.create(
        "app-offline"
        /* ErrorCode.APP_OFFLINE */
      ));
      return {
        installationEntry: t,
        registrationPromise: r
      };
    }
    const n = {
      fid: t.fid,
      registrationStatus: 1,
      registrationTime: Date.now()
    }, i = RL(e, n);
    return { installationEntry: n, registrationPromise: i };
  } else
    return t.registrationStatus === 1 ? {
      installationEntry: t,
      registrationPromise: FL(e)
    } : { installationEntry: t };
}
async function RL(e, t) {
  try {
    const n = await CL(e, t);
    return If(e.appConfig, n);
  } catch (n) {
    throw gT(n) && n.customData.serverCode === 409 ? await xT(e.appConfig) : await If(e.appConfig, {
      fid: t.fid,
      registrationStatus: 0
      /* RequestStatus.NOT_STARTED */
    }), n;
  }
}
async function FL(e) {
  let t = await $0(e.appConfig);
  for (; t.registrationStatus === 1; )
    await ST(100), t = await $0(e.appConfig);
  if (t.registrationStatus === 0) {
    const { installationEntry: n, registrationPromise: i } = await ny(e);
    return i || n;
  }
  return t;
}
function $0(e) {
  return zh(e, (t) => {
    if (!t)
      throw Xa.create(
        "installation-not-found"
        /* ErrorCode.INSTALLATION_NOT_FOUND */
      );
    return AT(t);
  });
}
function AT(e) {
  return BL(e) ? {
    fid: e.fid,
    registrationStatus: 0
    /* RequestStatus.NOT_STARTED */
  } : e;
}
function BL(e) {
  return e.registrationStatus === 1 && e.registrationTime + hT < Date.now();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function LL({ appConfig: e, heartbeatServiceProvider: t }, n) {
  const i = $L(e, n), r = _L(e, n), s = t.getImmediate({
    optional: !0
  });
  if (s) {
    const u = await s.getHeartbeatsHeader();
    u && r.append("x-firebase-client", u);
  }
  const a = {
    installation: {
      sdkVersion: mT,
      appId: e.appId
    }
  }, o = {
    method: "POST",
    headers: r,
    body: JSON.stringify(a)
  }, l = await _T(() => fetch(i, o));
  if (l.ok) {
    const u = await l.json();
    return yT(u);
  } else
    throw await bT("Generate Auth Token", l);
}
function $L(e, { fid: t }) {
  return `${pT(e)}/${t}/authTokens:generate`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function iy(e, t = !1) {
  let n;
  const i = await zh(e.appConfig, (s) => {
    if (!IT(s))
      throw Xa.create(
        "not-registered"
        /* ErrorCode.NOT_REGISTERED */
      );
    const a = s.authToken;
    if (!t && HL(a))
      return s;
    if (a.requestStatus === 1)
      return n = WL(e, t), s;
    {
      if (!navigator.onLine)
        throw Xa.create(
          "app-offline"
          /* ErrorCode.APP_OFFLINE */
        );
      const o = UL(s);
      return n = jL(e, o), o;
    }
  });
  return n ? await n : i.authToken;
}
async function WL(e, t) {
  let n = await W0(e.appConfig);
  for (; n.authToken.requestStatus === 1; )
    await ST(100), n = await W0(e.appConfig);
  const i = n.authToken;
  return i.requestStatus === 0 ? iy(e, t) : i;
}
function W0(e) {
  return zh(e, (t) => {
    if (!IT(t))
      throw Xa.create(
        "not-registered"
        /* ErrorCode.NOT_REGISTERED */
      );
    const n = t.authToken;
    return qL(n) ? Object.assign(Object.assign({}, t), { authToken: {
      requestStatus: 0
      /* RequestStatus.NOT_STARTED */
    } }) : t;
  });
}
async function jL(e, t) {
  try {
    const n = await LL(e, t), i = Object.assign(Object.assign({}, t), { authToken: n });
    return await If(e.appConfig, i), n;
  } catch (n) {
    if (gT(n) && (n.customData.serverCode === 401 || n.customData.serverCode === 404))
      await xT(e.appConfig);
    else {
      const i = Object.assign(Object.assign({}, t), { authToken: {
        requestStatus: 0
        /* RequestStatus.NOT_STARTED */
      } });
      await If(e.appConfig, i);
    }
    throw n;
  }
}
function IT(e) {
  return e !== void 0 && e.registrationStatus === 2;
}
function HL(e) {
  return e.requestStatus === 2 && !zL(e);
}
function zL(e) {
  const t = Date.now();
  return t < e.creationTime || e.creationTime + e.expiresIn < t + pL;
}
function UL(e) {
  const t = {
    requestStatus: 1,
    requestTime: Date.now()
  };
  return Object.assign(Object.assign({}, e), { authToken: t });
}
function qL(e) {
  return e.requestStatus === 1 && e.requestTime + hT < Date.now();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function GL(e) {
  const t = e, { installationEntry: n, registrationPromise: i } = await ny(t);
  return i ? i.catch(console.error) : iy(t).catch(console.error), n.fid;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function YL(e, t = !1) {
  const n = e;
  return await ZL(n), (await iy(n, t)).token;
}
async function ZL(e) {
  const { registrationPromise: t } = await ny(e);
  t && await t;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function KL(e) {
  if (!e || !e.options)
    throw hv("App Configuration");
  if (!e.name)
    throw hv("App Name");
  const t = [
    "projectId",
    "apiKey",
    "appId"
  ];
  for (const n of t)
    if (!e.options[n])
      throw hv(n);
  return {
    appName: e.name,
    projectId: e.options.projectId,
    apiKey: e.options.apiKey,
    appId: e.options.appId
  };
}
function hv(e) {
  return Xa.create("missing-app-config-values", {
    valueName: e
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ET = "installations", XL = "installations-internal", JL = (e) => {
  const t = e.getProvider("app").getImmediate(), n = KL(t), i = Qp(t, "heartbeat");
  return {
    app: t,
    appConfig: n,
    heartbeatServiceProvider: i,
    _delete: () => Promise.resolve()
  };
}, QL = (e) => {
  const t = e.getProvider("app").getImmediate(), n = Qp(t, ET).getImmediate();
  return {
    getId: () => GL(n),
    getToken: (r) => YL(n, r)
  };
};
function e2() {
  Ka(new ra(
    ET,
    JL,
    "PUBLIC"
    /* ComponentType.PUBLIC */
  )), Ka(new ra(
    XL,
    QL,
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ));
}
e2();
ea(fT, ey);
ea(fT, ey, "esm2017");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const t2 = "/firebase-messaging-sw.js", n2 = "/firebase-cloud-messaging-push-scope", OT = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4", i2 = "https://fcmregistrations.googleapis.com/v1", PT = "google.c.a.c_id", r2 = "google.c.a.c_l", s2 = "google.c.a.ts", a2 = "google.c.a.e";
var j0;
(function(e) {
  e[e.DATA_MESSAGE = 1] = "DATA_MESSAGE", e[e.DISPLAY_NOTIFICATION = 3] = "DISPLAY_NOTIFICATION";
})(j0 || (j0 = {}));
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
var tc;
(function(e) {
  e.PUSH_RECEIVED = "push-received", e.NOTIFICATION_CLICKED = "notification-clicked";
})(tc || (tc = {}));
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function cs(e) {
  const t = new Uint8Array(e);
  return btoa(String.fromCharCode(...t)).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function o2(e) {
  const t = "=".repeat((4 - e.length % 4) % 4), n = (e + t).replace(/\-/g, "+").replace(/_/g, "/"), i = atob(n), r = new Uint8Array(i.length);
  for (let s = 0; s < i.length; ++s)
    r[s] = i.charCodeAt(s);
  return r;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mv = "fcm_token_details_db", l2 = 5, H0 = "fcm_token_object_Store";
async function u2(e) {
  if ("databases" in indexedDB && !(await indexedDB.databases()).map((s) => s.name).includes(mv))
    return null;
  let t = null;
  return (await jh(mv, l2, {
    upgrade: async (i, r, s, a) => {
      var o;
      if (r < 2 || !i.objectStoreNames.contains(H0))
        return;
      const l = a.objectStore(H0), u = await l.index("fcmSenderId").get(e);
      if (await l.clear(), !!u) {
        if (r === 2) {
          const c = u;
          if (!c.auth || !c.p256dh || !c.endpoint)
            return;
          t = {
            token: c.fcmToken,
            createTime: (o = c.createTime) !== null && o !== void 0 ? o : Date.now(),
            subscriptionOptions: {
              auth: c.auth,
              p256dh: c.p256dh,
              endpoint: c.endpoint,
              swScope: c.swScope,
              vapidKey: typeof c.vapidKey == "string" ? c.vapidKey : cs(c.vapidKey)
            }
          };
        } else if (r === 3) {
          const c = u;
          t = {
            token: c.fcmToken,
            createTime: c.createTime,
            subscriptionOptions: {
              auth: cs(c.auth),
              p256dh: cs(c.p256dh),
              endpoint: c.endpoint,
              swScope: c.swScope,
              vapidKey: cs(c.vapidKey)
            }
          };
        } else if (r === 4) {
          const c = u;
          t = {
            token: c.fcmToken,
            createTime: c.createTime,
            subscriptionOptions: {
              auth: cs(c.auth),
              p256dh: cs(c.p256dh),
              endpoint: c.endpoint,
              swScope: c.swScope,
              vapidKey: cs(c.vapidKey)
            }
          };
        }
      }
    }
  })).close(), await uv(mv), await uv("fcm_vapid_details_db"), await uv("undefined"), c2(t) ? t : null;
}
function c2(e) {
  if (!e || !e.subscriptionOptions)
    return !1;
  const { subscriptionOptions: t } = e;
  return typeof e.createTime == "number" && e.createTime > 0 && typeof e.token == "string" && e.token.length > 0 && typeof t.auth == "string" && t.auth.length > 0 && typeof t.p256dh == "string" && t.p256dh.length > 0 && typeof t.endpoint == "string" && t.endpoint.length > 0 && typeof t.swScope == "string" && t.swScope.length > 0 && typeof t.vapidKey == "string" && t.vapidKey.length > 0;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const d2 = "firebase-messaging-database", f2 = 1, nc = "firebase-messaging-store";
let vv = null;
function VT() {
  return vv || (vv = jh(d2, f2, {
    upgrade: (e, t) => {
      switch (t) {
        case 0:
          e.createObjectStore(nc);
      }
    }
  })), vv;
}
async function h2(e) {
  const t = DT(e), i = await (await VT()).transaction(nc).objectStore(nc).get(t);
  if (i)
    return i;
  {
    const r = await u2(e.appConfig.senderId);
    if (r)
      return await ry(e, r), r;
  }
}
async function ry(e, t) {
  const n = DT(e), r = (await VT()).transaction(nc, "readwrite");
  return await r.objectStore(nc).put(t, n), await r.done, t;
}
function DT({ appConfig: e }) {
  return e.appId;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const m2 = {
  "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
  "only-available-in-window": "This method is available in a Window context.",
  "only-available-in-sw": "This method is available in a service worker context.",
  "permission-default": "The notification permission was not granted and dismissed instead.",
  "permission-blocked": "The notification permission was not granted and blocked instead.",
  "unsupported-browser": "This browser doesn't support the API's required to use the Firebase SDK.",
  "indexed-db-unsupported": "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)",
  "failed-service-worker-registration": "We are unable to register the default service worker. {$browserErrorMessage}",
  "token-subscribe-failed": "A problem occurred while subscribing the user to FCM: {$errorInfo}",
  "token-subscribe-no-token": "FCM returned no token when subscribing the user to push.",
  "token-unsubscribe-failed": "A problem occurred while unsubscribing the user from FCM: {$errorInfo}",
  "token-update-failed": "A problem occurred while updating the user from FCM: {$errorInfo}",
  "token-update-no-token": "FCM returned no token when updating the user to push.",
  "use-sw-after-get-token": "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.",
  "invalid-sw-registration": "The input to useServiceWorker() must be a ServiceWorkerRegistration.",
  "invalid-bg-handler": "The input to setBackgroundMessageHandler() must be a function.",
  "invalid-vapid-key": "The public VAPID key must be a string.",
  "use-vapid-key-after-get-token": "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used."
}, Yn = new Wh("messaging", "Messaging", m2);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function v2(e, t) {
  const n = await ay(e), i = NT(t), r = {
    method: "POST",
    headers: n,
    body: JSON.stringify(i)
  };
  let s;
  try {
    s = await (await fetch(sy(e.appConfig), r)).json();
  } catch (a) {
    throw Yn.create("token-subscribe-failed", {
      errorInfo: a == null ? void 0 : a.toString()
    });
  }
  if (s.error) {
    const a = s.error.message;
    throw Yn.create("token-subscribe-failed", {
      errorInfo: a
    });
  }
  if (!s.token)
    throw Yn.create(
      "token-subscribe-no-token"
      /* ErrorCode.TOKEN_SUBSCRIBE_NO_TOKEN */
    );
  return s.token;
}
async function g2(e, t) {
  const n = await ay(e), i = NT(t.subscriptionOptions), r = {
    method: "PATCH",
    headers: n,
    body: JSON.stringify(i)
  };
  let s;
  try {
    s = await (await fetch(`${sy(e.appConfig)}/${t.token}`, r)).json();
  } catch (a) {
    throw Yn.create("token-update-failed", {
      errorInfo: a == null ? void 0 : a.toString()
    });
  }
  if (s.error) {
    const a = s.error.message;
    throw Yn.create("token-update-failed", {
      errorInfo: a
    });
  }
  if (!s.token)
    throw Yn.create(
      "token-update-no-token"
      /* ErrorCode.TOKEN_UPDATE_NO_TOKEN */
    );
  return s.token;
}
async function p2(e, t) {
  const i = {
    method: "DELETE",
    headers: await ay(e)
  };
  try {
    const s = await (await fetch(`${sy(e.appConfig)}/${t}`, i)).json();
    if (s.error) {
      const a = s.error.message;
      throw Yn.create("token-unsubscribe-failed", {
        errorInfo: a
      });
    }
  } catch (r) {
    throw Yn.create("token-unsubscribe-failed", {
      errorInfo: r == null ? void 0 : r.toString()
    });
  }
}
function sy({ projectId: e }) {
  return `${i2}/projects/${e}/registrations`;
}
async function ay({ appConfig: e, installations: t }) {
  const n = await t.getToken();
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": e.apiKey,
    "x-goog-firebase-installations-auth": `FIS ${n}`
  });
}
function NT({ p256dh: e, auth: t, endpoint: n, vapidKey: i }) {
  const r = {
    web: {
      endpoint: n,
      auth: t,
      p256dh: e
    }
  };
  return i !== OT && (r.web.applicationPubKey = i), r;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const y2 = 7 * 24 * 60 * 60 * 1e3;
async function b2(e) {
  const t = await _2(e.swRegistration, e.vapidKey), n = {
    vapidKey: e.vapidKey,
    swScope: e.swRegistration.scope,
    endpoint: t.endpoint,
    auth: cs(t.getKey("auth")),
    p256dh: cs(t.getKey("p256dh"))
  }, i = await h2(e.firebaseDependencies);
  if (i) {
    if (S2(i.subscriptionOptions, n))
      return Date.now() >= i.createTime + y2 ? w2(e, {
        token: i.token,
        createTime: Date.now(),
        subscriptionOptions: n
      }) : i.token;
    try {
      await p2(e.firebaseDependencies, i.token);
    } catch (r) {
      console.warn(r);
    }
    return z0(e.firebaseDependencies, n);
  } else
    return z0(e.firebaseDependencies, n);
}
async function w2(e, t) {
  try {
    const n = await g2(e.firebaseDependencies, t), i = Object.assign(Object.assign({}, t), { token: n, createTime: Date.now() });
    return await ry(e.firebaseDependencies, i), n;
  } catch (n) {
    throw n;
  }
}
async function z0(e, t) {
  const i = {
    token: await v2(e, t),
    createTime: Date.now(),
    subscriptionOptions: t
  };
  return await ry(e, i), i.token;
}
async function _2(e, t) {
  const n = await e.pushManager.getSubscription();
  return n || e.pushManager.subscribe({
    userVisibleOnly: !0,
    // Chrome <= 75 doesn't support base64-encoded VAPID key. For backward compatibility, VAPID key
    // submitted to pushManager#subscribe must be of type Uint8Array.
    applicationServerKey: o2(t)
  });
}
function S2(e, t) {
  const n = t.vapidKey === e.vapidKey, i = t.endpoint === e.endpoint, r = t.auth === e.auth, s = t.p256dh === e.p256dh;
  return n && i && r && s;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function U0(e) {
  const t = {
    from: e.from,
    // eslint-disable-next-line camelcase
    collapseKey: e.collapse_key,
    // eslint-disable-next-line camelcase
    messageId: e.fcmMessageId
  };
  return k2(t, e), C2(t, e), T2(t, e), t;
}
function k2(e, t) {
  if (!t.notification)
    return;
  e.notification = {};
  const n = t.notification.title;
  n && (e.notification.title = n);
  const i = t.notification.body;
  i && (e.notification.body = i);
  const r = t.notification.image;
  r && (e.notification.image = r);
  const s = t.notification.icon;
  s && (e.notification.icon = s);
}
function C2(e, t) {
  t.data && (e.data = t.data);
}
function T2(e, t) {
  var n, i, r, s, a;
  if (!t.fcmOptions && !(!((n = t.notification) === null || n === void 0) && n.click_action))
    return;
  e.fcmOptions = {};
  const o = (r = (i = t.fcmOptions) === null || i === void 0 ? void 0 : i.link) !== null && r !== void 0 ? r : (s = t.notification) === null || s === void 0 ? void 0 : s.click_action;
  o && (e.fcmOptions.link = o);
  const l = (a = t.fcmOptions) === null || a === void 0 ? void 0 : a.analytics_label;
  l && (e.fcmOptions.analyticsLabel = l);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function x2(e) {
  return typeof e == "object" && !!e && PT in e;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
MT("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o");
MT("AzSCbw63g1R0nCw85jG8", "Iaya3yLKwmgvh7cF0q4");
function MT(e, t) {
  const n = [];
  for (let i = 0; i < e.length; i++)
    n.push(e.charAt(i)), i < t.length && n.push(t.charAt(i));
  return n.join("");
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function A2(e) {
  if (!e || !e.options)
    throw gv("App Configuration Object");
  if (!e.name)
    throw gv("App Name");
  const t = [
    "projectId",
    "apiKey",
    "appId",
    "messagingSenderId"
  ], { options: n } = e;
  for (const i of t)
    if (!n[i])
      throw gv(i);
  return {
    appName: e.name,
    projectId: n.projectId,
    apiKey: n.apiKey,
    appId: n.appId,
    senderId: n.messagingSenderId
  };
}
function gv(e) {
  return Yn.create("missing-app-config-values", {
    valueName: e
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class I2 {
  constructor(t, n, i) {
    this.deliveryMetricsExportedToBigQueryEnabled = !1, this.onBackgroundMessageHandler = null, this.onMessageHandler = null, this.logEvents = [], this.isLogServiceStarted = !1;
    const r = A2(t);
    this.firebaseDependencies = {
      app: t,
      appConfig: r,
      installations: n,
      analyticsProvider: i
    };
  }
  _delete() {
    return Promise.resolve();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function E2(e) {
  try {
    e.swRegistration = await navigator.serviceWorker.register(t2, {
      scope: n2
    }), e.swRegistration.update().catch(() => {
    });
  } catch (t) {
    throw Yn.create("failed-service-worker-registration", {
      browserErrorMessage: t == null ? void 0 : t.message
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function O2(e, t) {
  if (!t && !e.swRegistration && await E2(e), !(!t && e.swRegistration)) {
    if (!(t instanceof ServiceWorkerRegistration))
      throw Yn.create(
        "invalid-sw-registration"
        /* ErrorCode.INVALID_SW_REGISTRATION */
      );
    e.swRegistration = t;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function P2(e, t) {
  t ? e.vapidKey = t : e.vapidKey || (e.vapidKey = OT);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function RT(e, t) {
  if (!navigator)
    throw Yn.create(
      "only-available-in-window"
      /* ErrorCode.AVAILABLE_IN_WINDOW */
    );
  if (Notification.permission === "default" && await Notification.requestPermission(), Notification.permission !== "granted")
    throw Yn.create(
      "permission-blocked"
      /* ErrorCode.PERMISSION_BLOCKED */
    );
  return await P2(e, t == null ? void 0 : t.vapidKey), await O2(e, t == null ? void 0 : t.serviceWorkerRegistration), b2(e);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function V2(e, t, n) {
  const i = D2(t);
  (await e.firebaseDependencies.analyticsProvider.get()).logEvent(i, {
    /* eslint-disable camelcase */
    message_id: n[PT],
    message_name: n[r2],
    message_time: n[s2],
    message_device_time: Math.floor(Date.now() / 1e3)
    /* eslint-enable camelcase */
  });
}
function D2(e) {
  switch (e) {
    case tc.NOTIFICATION_CLICKED:
      return "notification_open";
    case tc.PUSH_RECEIVED:
      return "notification_foreground";
    default:
      throw new Error();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function N2(e, t) {
  const n = t.data;
  if (!n.isFirebaseMessaging)
    return;
  e.onMessageHandler && n.messageType === tc.PUSH_RECEIVED && (typeof e.onMessageHandler == "function" ? e.onMessageHandler(U0(n)) : e.onMessageHandler.next(U0(n)));
  const i = n.data;
  x2(i) && i[a2] === "1" && await V2(e, n.messageType, i);
}
const q0 = "@firebase/messaging", G0 = "0.12.9";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const M2 = (e) => {
  const t = new I2(e.getProvider("app").getImmediate(), e.getProvider("installations-internal").getImmediate(), e.getProvider("analytics-internal"));
  return navigator.serviceWorker.addEventListener("message", (n) => N2(t, n)), t;
}, R2 = (e) => {
  const t = e.getProvider("messaging").getImmediate();
  return {
    getToken: (i) => RT(t, i)
  };
};
function F2() {
  Ka(new ra(
    "messaging",
    M2,
    "PUBLIC"
    /* ComponentType.PUBLIC */
  )), Ka(new ra(
    "messaging-internal",
    R2,
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), ea(q0, G0), ea(q0, G0, "esm2017");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function B2() {
  try {
    await aT();
  } catch {
    return !1;
  }
  return typeof window < "u" && sT() && rB() && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function L2(e, t) {
  if (!navigator)
    throw Yn.create(
      "only-available-in-window"
      /* ErrorCode.AVAILABLE_IN_WINDOW */
    );
  return e.onMessageHandler = t, () => {
    e.onMessageHandler = null;
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function $2(e = rL()) {
  return B2().then((t) => {
    if (!t)
      throw Yn.create(
        "unsupported-browser"
        /* ErrorCode.UNSUPPORTED_BROWSER */
      );
  }, (t) => {
    throw Yn.create(
      "indexed-db-unsupported"
      /* ErrorCode.INDEXED_DB_UNSUPPORTED */
    );
  }), Qp(Xp(e), "messaging").getImmediate();
}
async function W2(e, t) {
  return e = Xp(e), RT(e, t);
}
function j2(e, t) {
  return e = Xp(e), L2(e, t);
}
F2();
var FT = { exports: {} };
/**
 * @license
 *
 * Push v1.0.9
 * =========
 * A compact, cross-browser solution for the JavaScript Notifications API
 *
 * Credits
 * -------
 * Tsvetan Tsvetkov (ttsvetko)
 * Alex Gibson (alexgibson)
 *
 * License
 * -------
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-2017 Tyler Nickerson
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
(function(e, t) {
  (function(n, i) {
    e.exports = i();
  })(tl, function() {
    var n = { errors: { incompatible: "".concat("PushError:", " Push.js is incompatible with browser."), invalid_plugin: "".concat("PushError:", " plugin class missing from plugin manifest (invalid plugin). Please check the documentation."), invalid_title: "".concat("PushError:", " title of notification must be a string"), permission_denied: "".concat("PushError:", " permission request declined"), sw_notification_error: "".concat("PushError:", " could not show a ServiceWorker notification due to the following reason: "), sw_registration_error: "".concat("PushError:", " could not register the ServiceWorker due to the following reason: "), unknown_interface: "".concat("PushError:", " unable to create notification: unknown interface") } };
    function i(T) {
      return (i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(_) {
        return typeof _;
      } : function(_) {
        return _ && typeof Symbol == "function" && _.constructor === Symbol && _ !== Symbol.prototype ? "symbol" : typeof _;
      })(T);
    }
    function r(T, _) {
      if (!(T instanceof _))
        throw new TypeError("Cannot call a class as a function");
    }
    function s(T, _) {
      for (var b = 0; b < _.length; b++) {
        var S = _[b];
        S.enumerable = S.enumerable || !1, S.configurable = !0, "value" in S && (S.writable = !0), Object.defineProperty(T, S.key, S);
      }
    }
    function a(T, _, b) {
      return _ && s(T.prototype, _), b && s(T, b), T;
    }
    function o(T, _) {
      if (typeof _ != "function" && _ !== null)
        throw new TypeError("Super expression must either be null or a function");
      T.prototype = Object.create(_ && _.prototype, { constructor: { value: T, writable: !0, configurable: !0 } }), _ && u(T, _);
    }
    function l(T) {
      return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(_) {
        return _.__proto__ || Object.getPrototypeOf(_);
      })(T);
    }
    function u(T, _) {
      return (u = Object.setPrototypeOf || function(b, S) {
        return b.__proto__ = S, b;
      })(T, _);
    }
    function c(T, _) {
      return !_ || typeof _ != "object" && typeof _ != "function" ? function(b) {
        if (b === void 0)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return b;
      }(T) : _;
    }
    var d = function() {
      function T(_) {
        r(this, T), this._win = _, this.GRANTED = "granted", this.DEFAULT = "default", this.DENIED = "denied", this._permissions = [this.GRANTED, this.DEFAULT, this.DENIED];
      }
      return a(T, [{ key: "request", value: function(_, b) {
        return arguments.length > 0 ? this._requestWithCallback.apply(this, arguments) : this._requestAsPromise();
      } }, { key: "_requestWithCallback", value: function(_, b) {
        var S, C = this, x = this.get(), A = !1, I = function() {
          var E = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : C._win.Notification.permission;
          A || (A = !0, E === void 0 && C._win.webkitNotifications && (E = C._win.webkitNotifications.checkPermission()), E === C.GRANTED || E === 0 ? _ && _() : b && b());
        };
        x !== this.DEFAULT ? I(x) : this._win.webkitNotifications && this._win.webkitNotifications.checkPermission ? this._win.webkitNotifications.requestPermission(I) : this._win.Notification && this._win.Notification.requestPermission ? (S = this._win.Notification.requestPermission(I)) && S.then && S.then(I).catch(function() {
          b && b();
        }) : _ && _();
      } }, { key: "_requestAsPromise", value: function() {
        var _ = this, b = this.get(), S = b !== this.DEFAULT, C = this._win.Notification && this._win.Notification.requestPermission, x = this._win.webkitNotifications && this._win.webkitNotifications.checkPermission;
        return new Promise(function(A, I) {
          var E, O = !1, V = function(N) {
            O || (O = !0, function(F) {
              return F === _.GRANTED || F === 0;
            }(N) ? A() : I());
          };
          S ? V(b) : x ? _._win.webkitNotifications.requestPermission(function(N) {
            V(N);
          }) : C ? (E = _._win.Notification.requestPermission(V)) && E.then && E.then(V).catch(I) : A();
        });
      } }, { key: "has", value: function() {
        return this.get() === this.GRANTED;
      } }, { key: "get", value: function() {
        return this._win.Notification && this._win.Notification.permission ? this._win.Notification.permission : this._win.webkitNotifications && this._win.webkitNotifications.checkPermission ? this._permissions[this._win.webkitNotifications.checkPermission()] : navigator.mozNotification ? this.GRANTED : this._win.external && this._win.external.msIsSiteMode ? this._win.external.msIsSiteMode() ? this.GRANTED : this.DEFAULT : this.GRANTED;
      } }]), T;
    }(), f = function() {
      function T() {
        r(this, T);
      }
      return a(T, null, [{ key: "isUndefined", value: function(_) {
        return _ === void 0;
      } }, { key: "isNull", value: function(_) {
        return obj === null;
      } }, { key: "isString", value: function(_) {
        return typeof _ == "string";
      } }, { key: "isFunction", value: function(_) {
        return _ && {}.toString.call(_) === "[object Function]";
      } }, { key: "isObject", value: function(_) {
        return i(_) === "object";
      } }, { key: "objectMerge", value: function(_, b) {
        for (var S in b)
          _.hasOwnProperty(S) && this.isObject(_[S]) && this.isObject(b[S]) ? this.objectMerge(_[S], b[S]) : _[S] = b[S];
      } }]), T;
    }(), h = function T(_) {
      r(this, T), this._win = _;
    }, m = function(T) {
      function _() {
        return r(this, _), c(this, l(_).apply(this, arguments));
      }
      return o(_, h), a(_, [{ key: "isSupported", value: function() {
        return this._win.Notification !== void 0;
      } }, { key: "create", value: function(b, S) {
        return new this._win.Notification(b, { icon: f.isString(S.icon) || f.isUndefined(S.icon) || f.isNull(S.icon) ? S.icon : S.icon.x32, body: S.body, tag: S.tag, requireInteraction: S.requireInteraction });
      } }, { key: "close", value: function(b) {
        b.close();
      } }]), _;
    }(), g = function(T) {
      function _() {
        return r(this, _), c(this, l(_).apply(this, arguments));
      }
      return o(_, h), a(_, [{ key: "isSupported", value: function() {
        return this._win.navigator !== void 0 && this._win.navigator.serviceWorker !== void 0;
      } }, { key: "getFunctionBody", value: function(b) {
        var S = b.toString().match(/function[^{]+{([\s\S]*)}$/);
        return S != null && S.length > 1 ? S[1] : null;
      } }, { key: "create", value: function(b, S, C, x, A) {
        var I = this;
        this._win.navigator.serviceWorker.register(x), this._win.navigator.serviceWorker.ready.then(function(E) {
          var O = { id: b, link: C.link, origin: document.location.href, onClick: f.isFunction(C.onClick) ? I.getFunctionBody(C.onClick) : "", onClose: f.isFunction(C.onClose) ? I.getFunctionBody(C.onClose) : "" };
          C.data !== void 0 && C.data !== null && (O = Object.assign(O, C.data)), E.showNotification(S, { icon: C.icon, body: C.body, vibrate: C.vibrate, tag: C.tag, data: O, requireInteraction: C.requireInteraction, silent: C.silent }).then(function() {
            E.getNotifications().then(function(V) {
              E.active.postMessage(""), A(V);
            });
          }).catch(function(V) {
            throw new Error(n.errors.sw_notification_error + V.message);
          });
        }).catch(function(E) {
          throw new Error(n.errors.sw_registration_error + E.message);
        });
      } }, { key: "close", value: function() {
      } }]), _;
    }(), p = function(T) {
      function _() {
        return r(this, _), c(this, l(_).apply(this, arguments));
      }
      return o(_, h), a(_, [{ key: "isSupported", value: function() {
        return this._win.navigator.mozNotification !== void 0;
      } }, { key: "create", value: function(b, S) {
        var C = this._win.navigator.mozNotification.createNotification(b, S.body, S.icon);
        return C.show(), C;
      } }]), _;
    }(), y = function(T) {
      function _() {
        return r(this, _), c(this, l(_).apply(this, arguments));
      }
      return o(_, h), a(_, [{ key: "isSupported", value: function() {
        return this._win.external !== void 0 && this._win.external.msIsSiteMode !== void 0;
      } }, { key: "create", value: function(b, S) {
        return this._win.external.msSiteModeClearIconOverlay(), this._win.external.msSiteModeSetIconOverlay(f.isString(S.icon) || f.isUndefined(S.icon) ? S.icon : S.icon.x16, b), this._win.external.msSiteModeActivate(), null;
      } }, { key: "close", value: function() {
        this._win.external.msSiteModeClearIconOverlay();
      } }]), _;
    }(), k = function(T) {
      function _() {
        return r(this, _), c(this, l(_).apply(this, arguments));
      }
      return o(_, h), a(_, [{ key: "isSupported", value: function() {
        return this._win.webkitNotifications !== void 0;
      } }, { key: "create", value: function(b, S) {
        var C = this._win.webkitNotifications.createNotification(S.icon, b, S.body);
        return C.show(), C;
      } }, { key: "close", value: function(b) {
        b.cancel();
      } }]), _;
    }();
    return new (function() {
      function T(_) {
        r(this, T), this._currentId = 0, this._notifications = {}, this._win = _, this.Permission = new d(_), this._agents = { desktop: new m(_), chrome: new g(_), firefox: new p(_), ms: new y(_), webkit: new k(_) }, this._configuration = { serviceWorker: "/serviceWorker.min.js", fallback: function(b) {
        } };
      }
      return a(T, [{ key: "_closeNotification", value: function(_) {
        var b = !0, S = this._notifications[_];
        if (S !== void 0) {
          if (b = this._removeNotification(_), this._agents.desktop.isSupported())
            this._agents.desktop.close(S);
          else if (this._agents.webkit.isSupported())
            this._agents.webkit.close(S);
          else {
            if (!this._agents.ms.isSupported())
              throw b = !1, new Error(n.errors.unknown_interface);
            this._agents.ms.close();
          }
          return b;
        }
        return !1;
      } }, { key: "_addNotification", value: function(_) {
        var b = this._currentId;
        return this._notifications[b] = _, this._currentId++, b;
      } }, { key: "_removeNotification", value: function(_) {
        var b = !1;
        return this._notifications.hasOwnProperty(_) && (delete this._notifications[_], b = !0), b;
      } }, { key: "_prepareNotification", value: function(_, b) {
        var S, C = this;
        return S = { get: function() {
          return C._notifications[_];
        }, close: function() {
          C._closeNotification(_);
        } }, b.timeout && setTimeout(function() {
          S.close();
        }, b.timeout), S;
      } }, { key: "_serviceWorkerCallback", value: function(_, b, S) {
        var C = this, x = this._addNotification(_[_.length - 1]);
        navigator && navigator.serviceWorker && (navigator.serviceWorker.addEventListener("message", function(A) {
          var I = JSON.parse(A.data);
          I.action === "close" && Number.isInteger(I.id) && C._removeNotification(I.id);
        }), S(this._prepareNotification(x, b))), S(null);
      } }, { key: "_createCallback", value: function(_, b, S) {
        var C, x = this, A = null;
        if (b = b || {}, C = function(N) {
          x._removeNotification(N), f.isFunction(b.onClose) && b.onClose.call(x, A);
        }, this._agents.desktop.isSupported())
          try {
            A = this._agents.desktop.create(_, b);
          } catch {
            var I = this._currentId, E = this.config().serviceWorker;
            this._agents.chrome.isSupported() && this._agents.chrome.create(I, _, b, E, function(F) {
              return x._serviceWorkerCallback(F, b, S);
            });
          }
        else
          this._agents.webkit.isSupported() ? A = this._agents.webkit.create(_, b) : this._agents.firefox.isSupported() ? this._agents.firefox.create(_, b) : this._agents.ms.isSupported() ? A = this._agents.ms.create(_, b) : (b.title = _, this.config().fallback(b));
        if (A !== null) {
          var O = this._addNotification(A), V = this._prepareNotification(O, b);
          f.isFunction(b.onShow) && A.addEventListener("show", b.onShow), f.isFunction(b.onError) && A.addEventListener("error", b.onError), f.isFunction(b.onClick) && A.addEventListener("click", b.onClick), A.addEventListener("close", function() {
            C(O);
          }), A.addEventListener("cancel", function() {
            C(O);
          }), S(V);
        }
        S(null);
      } }, { key: "create", value: function(_, b) {
        var S, C = this;
        if (!f.isString(_))
          throw new Error(n.errors.invalid_title);
        return S = this.Permission.has() ? function(x, A) {
          try {
            C._createCallback(_, b, x);
          } catch (I) {
            A(I);
          }
        } : function(x, A) {
          C.Permission.request().then(function() {
            C._createCallback(_, b, x);
          }).catch(function() {
            A(n.errors.permission_denied);
          });
        }, new Promise(S);
      } }, { key: "count", value: function() {
        var _, b = 0;
        for (_ in this._notifications)
          this._notifications.hasOwnProperty(_) && b++;
        return b;
      } }, { key: "close", value: function(_) {
        var b;
        for (b in this._notifications)
          if (this._notifications.hasOwnProperty(b) && this._notifications[b].tag === _)
            return this._closeNotification(b);
      } }, { key: "clear", value: function() {
        var _, b = !0;
        for (_ in this._notifications)
          this._notifications.hasOwnProperty(_) && (b = b && this._closeNotification(_));
        return b;
      } }, { key: "supported", value: function() {
        var _ = !1;
        for (var b in this._agents)
          this._agents.hasOwnProperty(b) && (_ = _ || this._agents[b].isSupported());
        return _;
      } }, { key: "config", value: function(_) {
        return (_ !== void 0 || _ !== null && f.isObject(_)) && f.objectMerge(this._configuration, _), this._configuration;
      } }, { key: "extend", value: function(_) {
        var b, S = {}.hasOwnProperty;
        if (!S.call(_, "plugin"))
          throw new Error(n.errors.invalid_plugin);
        for (var C in S.call(_, "config") && f.isObject(_.config) && _.config !== null && this.config(_.config), b = new _.plugin(this.config()))
          S.call(b, C) && f.isFunction(b[C]) && (this[C] = b[C]);
      } }]), T;
    }())(typeof window < "u" ? window : tl);
  });
})(FT);
var H2 = FT.exports;
const Ca = /* @__PURE__ */ Wp(H2);
var oy = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, ge = (e, t, n) => (oy(e, t, "read from private field"), n ? n.call(e) : t.get(e)), mt = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, Pt = (e, t, n, i) => (oy(e, t, "write to private field"), i ? i.call(e, n) : t.set(e, n), n), Mn = (e, t, n) => (oy(e, t, "access private method"), n), Ta, kn, qi, Tu, Bu, zo, Ea, $i, dr, Oa, Pa, Xd, Jd, Ef, Of, Uo, qo, Zs, xu, Au, Iu, Eu, Ou, hs, Pu, wl, ic, rc, Pf, Go, Vu, Qd, cg, ef, dg, tf, fg;
const un = xs("Push"), Cn = xs("Firebase", "#1B3A57", "#FFCA28"), as = xs("Service Worker");
class z2 {
  /**
   * Create a new PushService instance.
   * @param bus The BusService instance to use for communication
   * @param ls The LocalStorageService instance to use for storing and retrieving preferences and tokens
   * @param cron The MiliCron instance to use for scheduling updates
   * @param identity The IdentityService instance to use for determining if the user is authenticated
   * @param firebaseOptions The options to use for initializing Firebase
   * @param onAuthenticatedForFirebase The callback to use for storing the Firebase Messaging Token in an external service when the user is authenticated
   * @param onUnauthenticatedForFirebase The callback to use for removing the Firebase Messaging Token from an external service when the user is unauthenticated
   * @param serviceWorkerPath The path to the service worker to use for handling push notifications
   * @param serviceWorkerMode The mode to use for the service worker
   */
  constructor(t, n, i, r, s, a, o, l, u) {
    if (mt(this, wl), mt(this, rc), mt(this, Go), mt(this, Qd), mt(this, ef), mt(this, tf), mt(this, Ta, void 0), mt(this, kn, void 0), mt(this, qi, void 0), mt(this, Tu, void 0), mt(this, Bu, void 0), mt(this, zo, void 0), mt(this, Ea, void 0), mt(this, $i, void 0), mt(this, dr, void 0), mt(this, Oa, void 0), mt(this, Pa, void 0), mt(this, Xd, void 0), mt(this, Jd, void 0), mt(this, Ef, void 0), mt(this, Of, void 0), mt(this, Uo, void 0), mt(this, qo, void 0), mt(this, Zs, void 0), mt(this, xu, void 0), mt(this, Au, void 0), mt(this, Iu, void 0), mt(this, Eu, void 0), mt(this, Ou, void 0), mt(this, hs, void 0), mt(this, Pu, void 0), !(t instanceof Ch))
      throw new Error("Invalid or missing BusService instance");
    if (!(n instanceof Nh))
      throw new Error("Invalid or missing LocalStorageService instance");
    if (!(i instanceof $p))
      throw new Error("Invalid or missing MiliCron instance");
    if (!(r instanceof eT))
      throw new Error("Invalid or missing IdentityService instance");
    Pt(this, Ta, X(!1)), Pt(this, Zs, X(void 0)), Pt(this, kn, t), Pt(this, qi, n), Pt(this, Tu, i), Pt(this, Bu, r), Pt(this, $i, X(void 0)), Pt(this, dr, X(void 0)), Pt(this, Oa, X(void 0)), Pt(this, Pa, X(void 0)), Pt(this, Ef, a), Pt(this, Of, o), Pt(this, Uo, l), Pt(this, qo, u), Pt(this, Xd, w(() => {
      if (ge(this, Pa).value === !0 || ge(this, Pa).value === void 0)
        return !1;
      switch (ge(this, Oa).value) {
        case Ca.Permission.DEFAULT:
          return !0;
        default:
          return !1;
      }
    })), Pt(this, Jd, w(() => {
      switch (ge(this, Oa).value) {
        case Ca.Permission.DENIED:
          return !1;
        case Ca.Permission.GRANTED:
          return !0;
        case Ca.Permission.DEFAULT:
          return null;
        default:
          return !1;
      }
    }));
    try {
      Pt(this, zo, uT(s));
    } catch (c) {
      Cn("Failed to Initialize Firebase Application", c.message);
    }
    if (ge(this, zo))
      try {
        Pt(this, Ea, $2(ge(this, zo)));
      } catch (c) {
        Cn("Failed to Initialize Firebase Messaging", c.message);
      }
    ge(this, zo) && ge(this, Ea) ? Cn("Firebase Application & Messaging Initialized") : Cn("Firebase Application & Messaging Skipped");
  }
  /**
   * Whether or not the service has been booted.
   */
  get booted() {
    return ge(this, Ta);
  }
  /**
   * Whether or not the UI should show a prompt for the user to allow push notifications.
   */
  get canRequestPermission() {
    return ge(this, Xd);
  }
  /**
   * Whether or not permissions have been granted for push notifications.
   */
  get canPush() {
    return ge(this, Jd);
  }
  /**
   * The current state of the service worker.
   */
  get serviceWorkerState() {
    return w(() => ge(this, Zs).value);
  }
  /**
   * If there is an update pending for the service worker.
   */
  get appUpdatePending() {
    return w(() => ge(this, Zs).value === "waiting");
  }
  /**
   * Request permission to show push notifications.
   */
  requestPushPermission() {
    Ca.Permission.request(
      () => {
        un("Push Permission Granted"), ge(this, kn).emit("push:updated", { local: !0, crossTab: !0 }), ge(this, kn).emit("push:permission:granted", { local: !0, crossTab: !0 });
      },
      () => {
        un("Push Permission Denied"), ge(this, kn).emit("push:updated", { local: !0, crossTab: !0 }), ge(this, kn).emit("push:permission:denied", { local: !0, crossTab: !0 });
      }
    );
  }
  /**
   * Stop asking the user for permission to show push notifications.
   * @returns void
   */
  doNotRequestPushPermission() {
    this.canPush.value || (ge(this, qi).set("push.donotaskforpermission", !0), ge(this, kn).emit("push:updated", { local: !0, crossTab: !0 }));
  }
  /**
   * Create a web push notification (otherwise known as a desktop notification).
   * @param options The options for the web push notification
   */
  createWebPushNotification(t) {
    if (!this.canPush.value)
      return;
    const n = {
      body: t.body,
      icon: t.icon,
      link: t.link,
      requireInteraction: t.requireInteraction,
      timeout: t.timeout,
      vibrate: t.vibrate,
      silent: t.silent,
      onClick: function(i) {
        un("Web Push Notification Clicked", i), t.onClick && t.onClick(i), t.closeOnClick && (window.focus(), this.close());
      },
      onClose: function(i) {
        un("Web Push Notification Closed", i), t.onClose && t.onClose(i);
      },
      onError: function(i) {
        un("Web Push Notification Error", i), t.onError && t.onError(i);
      },
      onShow: function(i) {
        un("Web Push Notification Shown", i), t.onShow && t.onShow(i);
      }
    };
    try {
      Ca.create(t.title, n);
    } catch (i) {
      un("Web Push Notification Error", i);
    }
  }
  /**
   * Reset the preference to ask the user for permission to show push notifications.
   * @private
   * @returns void
   * @remarks This is a function that should only be used for development and testing purposes.
   */
  $resetDoNotRequestPushPermissionPreference() {
    ge(this, qi).remove("push.donotaskforpermission"), ge(this, kn).emit("push:updated", { local: !0, crossTab: !0 });
  }
  /**
   * Boot the service.
   */
  boot() {
    if (ge(this, Ta).value)
      return;
    un("Booting");
    const t = () => {
      ge(this, Ta).value = !0, un("Booted");
    };
    if (Pt(this, xu, fe(
      () => ge(this, $i).value,
      (n, i) => {
        i !== n && (un("Service Worker Registration Changed", { was: i, is: n }), n ? Mn(this, Qd, cg).call(this) : ge(this, dr).value || Cn("Skipped generating Firebase Messaging Token", {
          canPush: this.canPush.value,
          serviceWorkerRegistration: typeof ge(this, $i).value < "u"
        }));
      },
      {
        immediate: !0,
        deep: !0
      }
    )), Pt(this, Au, fe(
      () => ge(this, dr).value,
      (n, i) => {
        i !== n && (Cn("Notifying of Firebase Messaging Token Update", { token: n }), ge(this, kn).emit("firebase:token:updated", { local: !0, crossTab: !0 }, n), Mn(this, ef, dg).call(this));
      },
      {
        immediate: !0,
        deep: !0
      }
    )), Pt(this, Iu, fe(
      () => ge(this, Oa).value,
      (n, i) => {
        i !== n && (un("Push Permission Changed", { was: i, is: n }), this.canPush.value && ge(this, $i).value ? Mn(this, Qd, cg).call(this) : ge(this, dr).value || Cn("Skipped generating Firebase Messaging Token", {
          canPush: this.canPush.value,
          serviceWorkerRegistration: typeof ge(this, $i).value < "u"
        }));
      },
      {
        immediate: !0,
        deep: !0
      }
    )), Pt(this, Eu, fe(
      () => ge(this, Pa).value,
      (n, i) => {
        i !== n && un("Do Not Ask For Permission Preference Changed", { was: i, is: n });
      },
      {
        immediate: !0,
        deep: !0
      }
    )), Pt(this, Ou, fe(
      () => ge(this, Bu).authenticated.value,
      (n, i) => {
        i !== n && Mn(this, ef, dg).call(this);
      },
      {
        immediate: !0,
        deep: !0
      }
    )), ge(this, Tu).$on("*/250 * * * * *", Mn(this, Go, Vu).bind(this)), ge(this, kn).on("push:updated", Mn(this, Go, Vu).bind(this), { local: !0, crossTab: !0 }), ge(this, kn).on("sw:install", Mn(this, tf, fg).bind(this), {
      local: !0,
      crossTab: !0
    }), Mn(this, rc, Pf).call(this, !0), typeof window < "u" && "serviceWorker" in navigator) {
      if (typeof ge(this, $i).value > "u") {
        if (!ge(this, Uo) || !ge(this, qo))
          return un("Service Worker Path or Mode not set, skipping registration"), t();
        un("Attempting to register Service Worker", {
          path: ge(this, Uo),
          mode: ge(this, qo)
        }), navigator.serviceWorker.register(ge(this, Uo), { type: ge(this, qo) }).then((n) => {
          as("Service Worker Registered", n), ge(this, $i).value = n;
        }).catch((n) => {
          as("Service Worker Registration Failed", n);
        });
      }
      navigator.serviceWorker.addEventListener("message", (n) => {
        if (as("Got new message from service worker", n.data), n.data.messageType === "push-received" && n.data.data && n.data.data.event) {
          as("Got push notification from service worker", n.data.data);
          const { event: i, detail: r } = n.data.data, s = `background:${i}`;
          ge(this, kn).emit(s, { local: !0 }, r);
        }
        if (n.data.messageType === "sw-received" && n.data.data && n.data.data.event) {
          as("Got event from service worker", n.data.data);
          const { event: i, detail: r } = n.data.data, s = `background:${i}`;
          ge(this, kn).emit(s, { local: !0 }, r);
        }
        n.data.notification && ge(this, kn).emit("push:notification", { local: !0 }, n.data.notification);
      }), navigator.serviceWorker.addEventListener("messageerror", (n) => {
        as("Got new message error from service worker", n.data);
      }), navigator.serviceWorker.ready.then((n) => {
        as("Service Worker Ready", n), ge(this, $i).value = n, Mn(this, wl, ic).call(this, n);
      }), navigator.serviceWorker.addEventListener("controllerchange", (n) => {
        as("Service Worker saw Controller Change", n);
      });
    }
    return ge(this, Ea) && Pt(this, Pu, j2(ge(this, Ea), (n) => {
      if (Cn("Got Firebase Messaging Payload", n), n.data && n.data.event) {
        const { event: i, detail: r } = n.data, s = `background:${i}`;
        ge(this, kn).emit(s, { local: !0 }, r);
      }
    })), t();
  }
  /**
   * Shut down the service.
   */
  shutdown() {
    ge(this, Ta).value && (un("Shutting Down"), ge(this, kn).off("push:updated", Mn(this, Go, Vu).bind(this), { local: !0, crossTab: !0 }), ge(this, kn).off("sw:install", Mn(this, tf, fg).bind(this), {
      local: !0,
      crossTab: !0
    }), ge(this, Tu).$off("*/250 * * * * *", Mn(this, Go, Vu).bind(this)), ge(this, xu) && ge(this, xu).call(this), ge(this, Au) && ge(this, Au).call(this), ge(this, Iu) && ge(this, Iu).call(this), ge(this, Eu) && ge(this, Eu).call(this), ge(this, Ou) && ge(this, Ou).call(this), ge(this, hs) && ge(this, hs).abort(), ge(this, Pu) && ge(this, Pu).call(this), un("Shut Down"));
  }
  async update() {
    if (!(typeof window < "u" && "serviceWorker" in navigator)) {
      un("Not in a context with a Service Worker");
      return;
    }
    if (!this.appUpdatePending.value) {
      un("No Service Worker Update Pending");
      return;
    }
    const t = await navigator.serviceWorker.ready;
    if (!t.waiting) {
      un("No Waiting Service Worker");
      return;
    }
    const n = new Promise((i) => {
      navigator.serviceWorker.addEventListener("controllerchange", i, { once: !0 });
    });
    t.waiting.postMessage({ type: "SKIP_WAITING" }), await n, window && window.location ? window.location.reload() : un("Finished waiting for Service Worker to update");
  }
}
Ta = /* @__PURE__ */ new WeakMap();
kn = /* @__PURE__ */ new WeakMap();
qi = /* @__PURE__ */ new WeakMap();
Tu = /* @__PURE__ */ new WeakMap();
Bu = /* @__PURE__ */ new WeakMap();
zo = /* @__PURE__ */ new WeakMap();
Ea = /* @__PURE__ */ new WeakMap();
$i = /* @__PURE__ */ new WeakMap();
dr = /* @__PURE__ */ new WeakMap();
Oa = /* @__PURE__ */ new WeakMap();
Pa = /* @__PURE__ */ new WeakMap();
Xd = /* @__PURE__ */ new WeakMap();
Jd = /* @__PURE__ */ new WeakMap();
Ef = /* @__PURE__ */ new WeakMap();
Of = /* @__PURE__ */ new WeakMap();
Uo = /* @__PURE__ */ new WeakMap();
qo = /* @__PURE__ */ new WeakMap();
Zs = /* @__PURE__ */ new WeakMap();
xu = /* @__PURE__ */ new WeakMap();
Au = /* @__PURE__ */ new WeakMap();
Iu = /* @__PURE__ */ new WeakMap();
Eu = /* @__PURE__ */ new WeakMap();
Ou = /* @__PURE__ */ new WeakMap();
hs = /* @__PURE__ */ new WeakMap();
Pu = /* @__PURE__ */ new WeakMap();
wl = /* @__PURE__ */ new WeakSet();
ic = function(e) {
  if (e) {
    switch (!0) {
      case e.installing !== null:
        ge(this, Zs).value = "installing";
        break;
      case e.waiting !== null:
        ge(this, Zs).value = "waiting";
        break;
      case e.active !== null:
        ge(this, Zs).value = "activated";
        break;
    }
    return;
  }
  typeof window < "u" && "serviceWorker" in navigator && navigator.serviceWorker.ready.then((t) => {
    Mn(this, wl, ic).call(this, t);
  });
};
rc = /* @__PURE__ */ new WeakSet();
Pf = function(e = !1) {
  if (!ge(this, qi).loaded) {
    e && ge(this, qi).promise.then(() => {
      Mn(this, rc, Pf).call(this, e);
    });
    return;
  }
  const t = ge(this, qi).get("push.donotaskforpermission") || !1;
  ge(this, Pa).value = t, ge(this, Oa).value = Ca.Permission.get(), Mn(this, wl, ic).call(this);
};
Go = /* @__PURE__ */ new WeakSet();
Vu = function() {
  Mn(this, rc, Pf).call(this);
};
Qd = /* @__PURE__ */ new WeakSet();
cg = function() {
  !ge(this, $i).value || !this.canPush.value || ge(this, dr).value || W2(ge(this, Ea), {
    serviceWorkerRegistration: ge(this, $i).value
  }).then((e) => {
    e ? (Cn("Firebase Messaging Token", e), ge(this, dr).value = e, ge(this, qi).loaded ? ge(this, qi).set("push.serviceworker.registration.token", e) : ge(this, qi).promise.then(() => {
      ge(this, qi).set("push.serviceworker.registration.token", e);
    })) : Cn("No Firebase Messaging Token");
  }).catch((e) => {
    Cn("Error retreiving Firebase Messaging Token", e);
  });
};
ef = /* @__PURE__ */ new WeakSet();
dg = function() {
  if (ge(this, dr).value) {
    const e = ge(this, Bu).authenticated.value;
    ge(this, hs) && ge(this, hs).abort(), Pt(this, hs, new AbortController());
    try {
      e ? (async () => {
        Cn("Registering Firebase Messaging Token");
        try {
          await ge(this, Ef).call(this, ge(this, dr).value, ge(this, hs).signal), Cn("Registered Firebase Messaging Token");
        } catch (t) {
          (t instanceof Error && t.name !== "CancelError" || !(t instanceof Error)) && Cn("Failed to register Firebase Messaging Token", t);
        }
      })() : (async () => {
        Cn("Unregistering Firebase Messaging Token");
        try {
          await ge(this, Of).call(this, ge(this, dr).value, ge(this, hs).signal), Cn("Unregistered Firebase Messaging Token");
        } catch (t) {
          (t instanceof Error && t.name !== "CancelError" || !(t instanceof Error)) && Cn("Failed to unregister Firebase Messaging Token", t);
        }
      })();
    } catch (t) {
      t instanceof Error && t.name !== "CancelError" && Cn("API Firebase Operation threw and Error", t);
    }
  }
};
tf = /* @__PURE__ */ new WeakSet();
fg = function(e) {
  as("Service Worker Installed might be waiting", e), Mn(this, wl, ic).call(this);
};
const U2 = {
  install: (e, t) => {
    const n = (t == null ? void 0 : t.firebaseOptions) || {}, i = (t == null ? void 0 : t.onAuthenticatedForFirebase) || (() => {
    }), r = (t == null ? void 0 : t.onUnauthenticatedForFirebase) || (() => {
    }), s = t == null ? void 0 : t.serviceWorkerPath, a = t == null ? void 0 : t.serviceWorkerMode, o = new z2(
      e.config.globalProperties.$bus,
      e.config.globalProperties.$ls,
      e.config.globalProperties.$cron,
      e.config.globalProperties.$identity,
      n,
      i,
      r,
      s,
      a
    );
    e.provide("push", o), e.config.globalProperties.$push = o;
  }
}, q2 = 100, Je = {}, G2 = () => {
  Je.previousActiveElement instanceof HTMLElement ? (Je.previousActiveElement.focus(), Je.previousActiveElement = null) : document.body && document.body.focus();
}, Y2 = (e) => new Promise((t) => {
  if (!e)
    return t();
  const n = window.scrollX, i = window.scrollY;
  Je.restoreFocusTimeout = setTimeout(() => {
    G2(), t();
  }, q2), window.scrollTo(n, i);
}), BT = "swal2-", Z2 = [
  "container",
  "shown",
  "height-auto",
  "iosfix",
  "popup",
  "modal",
  "no-backdrop",
  "no-transition",
  "toast",
  "toast-shown",
  "show",
  "hide",
  "close",
  "title",
  "html-container",
  "actions",
  "confirm",
  "deny",
  "cancel",
  "default-outline",
  "footer",
  "icon",
  "icon-content",
  "image",
  "input",
  "file",
  "range",
  "select",
  "radio",
  "checkbox",
  "label",
  "textarea",
  "inputerror",
  "input-label",
  "validation-message",
  "progress-steps",
  "active-progress-step",
  "progress-step",
  "progress-step-line",
  "loader",
  "loading",
  "styled",
  "top",
  "top-start",
  "top-end",
  "top-left",
  "top-right",
  "center",
  "center-start",
  "center-end",
  "center-left",
  "center-right",
  "bottom",
  "bottom-start",
  "bottom-end",
  "bottom-left",
  "bottom-right",
  "grow-row",
  "grow-column",
  "grow-fullscreen",
  "rtl",
  "timer-progress-bar",
  "timer-progress-bar-container",
  "scrollbar-measure",
  "icon-success",
  "icon-warning",
  "icon-info",
  "icon-question",
  "icon-error"
], re = Z2.reduce(
  (e, t) => (e[t] = BT + t, e),
  /** @type {SwalClasses} */
  {}
), K2 = ["success", "warning", "info", "question", "error"], Vf = K2.reduce(
  (e, t) => (e[t] = BT + t, e),
  /** @type {SwalIcons} */
  {}
), LT = "SweetAlert2:", ly = (e) => e.charAt(0).toUpperCase() + e.slice(1), bi = (e) => {
  console.warn(`${LT} ${typeof e == "object" ? e.join(" ") : e}`);
}, So = (e) => {
  console.error(`${LT} ${e}`);
}, Y0 = [], X2 = (e) => {
  Y0.includes(e) || (Y0.push(e), bi(e));
}, J2 = (e, t) => {
  X2(
    `"${e}" is deprecated and will be removed in the next major release. Please use "${t}" instead.`
  );
}, Uh = (e) => typeof e == "function" ? e() : e, uy = (e) => e && typeof e.toPromise == "function", Lc = (e) => uy(e) ? e.toPromise() : Promise.resolve(e), cy = (e) => e && Promise.resolve(e) === e, wi = () => document.body.querySelector(`.${re.container}`), $c = (e) => {
  const t = wi();
  return t ? t.querySelector(e) : null;
}, Vi = (e) => $c(`.${e}`), yt = () => Vi(re.popup), Wc = () => Vi(re.icon), Q2 = () => Vi(re["icon-content"]), $T = () => Vi(re.title), dy = () => Vi(re["html-container"]), WT = () => Vi(re.image), fy = () => Vi(re["progress-steps"]), qh = () => Vi(re["validation-message"]), Hr = () => (
  /** @type {HTMLButtonElement} */
  $c(`.${re.actions} .${re.confirm}`)
), Gl = () => (
  /** @type {HTMLButtonElement} */
  $c(`.${re.actions} .${re.cancel}`)
), ko = () => (
  /** @type {HTMLButtonElement} */
  $c(`.${re.actions} .${re.deny}`)
), e$ = () => Vi(re["input-label"]), Yl = () => $c(`.${re.loader}`), jc = () => Vi(re.actions), jT = () => Vi(re.footer), Gh = () => Vi(re["timer-progress-bar"]), hy = () => Vi(re.close), t$ = `
  a[href],
  area[href],
  input:not([disabled]),
  select:not([disabled]),
  textarea:not([disabled]),
  button:not([disabled]),
  iframe,
  object,
  embed,
  [tabindex="0"],
  [contenteditable],
  audio[controls],
  video[controls],
  summary
`, my = () => {
  const e = yt();
  if (!e)
    return [];
  const t = e.querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])'), n = Array.from(t).sort((s, a) => {
    const o = parseInt(s.getAttribute("tabindex") || "0"), l = parseInt(a.getAttribute("tabindex") || "0");
    return o > l ? 1 : o < l ? -1 : 0;
  }), i = e.querySelectorAll(t$), r = Array.from(i).filter(
    (s) => s.getAttribute("tabindex") !== "-1"
  );
  return [...new Set(n.concat(r))].filter(
    (s) => Ai(s)
  );
}, vy = () => vs(document.body, re.shown) && !vs(document.body, re["toast-shown"]) && !vs(document.body, re["no-backdrop"]), Yh = () => {
  const e = yt();
  return e ? vs(e, re.toast) : !1;
}, n$ = () => {
  const e = yt();
  return e ? e.hasAttribute("data-loading") : !1;
}, Di = (e, t) => {
  if (e.textContent = "", t) {
    const i = new DOMParser().parseFromString(t, "text/html"), r = i.querySelector("head");
    r && Array.from(r.childNodes).forEach((a) => {
      e.appendChild(a);
    });
    const s = i.querySelector("body");
    s && Array.from(s.childNodes).forEach((a) => {
      a instanceof HTMLVideoElement || a instanceof HTMLAudioElement ? e.appendChild(a.cloneNode(!0)) : e.appendChild(a);
    });
  }
}, vs = (e, t) => {
  if (!t)
    return !1;
  const n = t.split(/\s+/);
  for (let i = 0; i < n.length; i++)
    if (!e.classList.contains(n[i]))
      return !1;
  return !0;
}, i$ = (e, t) => {
  Array.from(e.classList).forEach((n) => {
    !Object.values(re).includes(n) && !Object.values(Vf).includes(n) && !Object.values(t.showClass || {}).includes(n) && e.classList.remove(n);
  });
}, Xi = (e, t, n) => {
  if (i$(e, t), t.customClass && t.customClass[n]) {
    if (typeof t.customClass[n] != "string" && !t.customClass[n].forEach) {
      bi(
        `Invalid type of customClass.${n}! Expected string or iterable object, got "${typeof t.customClass[n]}"`
      );
      return;
    }
    dt(e, t.customClass[n]);
  }
}, Zh = (e, t) => {
  if (!t)
    return null;
  switch (t) {
    case "select":
    case "textarea":
    case "file":
      return e.querySelector(`.${re.popup} > .${re[t]}`);
    case "checkbox":
      return e.querySelector(`.${re.popup} > .${re.checkbox} input`);
    case "radio":
      return e.querySelector(`.${re.popup} > .${re.radio} input:checked`) || e.querySelector(`.${re.popup} > .${re.radio} input:first-child`);
    case "range":
      return e.querySelector(`.${re.popup} > .${re.range} input`);
    default:
      return e.querySelector(`.${re.popup} > .${re.input}`);
  }
}, HT = (e) => {
  if (e.focus(), e.type !== "file") {
    const t = e.value;
    e.value = "", e.value = t;
  }
}, zT = (e, t, n) => {
  !e || !t || (typeof t == "string" && (t = t.split(/\s+/).filter(Boolean)), t.forEach((i) => {
    Array.isArray(e) ? e.forEach((r) => {
      n ? r.classList.add(i) : r.classList.remove(i);
    }) : n ? e.classList.add(i) : e.classList.remove(i);
  }));
}, dt = (e, t) => {
  zT(e, t, !0);
}, zr = (e, t) => {
  zT(e, t, !1);
}, Ks = (e, t) => {
  const n = Array.from(e.children);
  for (let i = 0; i < n.length; i++) {
    const r = n[i];
    if (r instanceof HTMLElement && vs(r, t))
      return r;
  }
}, Ha = (e, t, n) => {
  n === `${parseInt(n)}` && (n = parseInt(n)), n || parseInt(n) === 0 ? e.style.setProperty(t, typeof n == "number" ? `${n}px` : n) : e.style.removeProperty(t);
}, xn = (e, t = "flex") => {
  e && (e.style.display = t);
}, Zn = (e) => {
  e && (e.style.display = "none");
}, gy = (e, t = "block") => {
  e && new MutationObserver(() => {
    Hc(e, e.innerHTML, t);
  }).observe(e, { childList: !0, subtree: !0 });
}, Z0 = (e, t, n, i) => {
  const r = e.querySelector(t);
  r && r.style.setProperty(n, i);
}, Hc = (e, t, n = "flex") => {
  t ? xn(e, n) : Zn(e);
}, Ai = (e) => !!(e && (e.offsetWidth || e.offsetHeight || e.getClientRects().length)), r$ = () => !Ai(Hr()) && !Ai(ko()) && !Ai(Gl()), K0 = (e) => e.scrollHeight > e.clientHeight, UT = (e) => {
  const t = window.getComputedStyle(e), n = parseFloat(t.getPropertyValue("animation-duration") || "0"), i = parseFloat(t.getPropertyValue("transition-duration") || "0");
  return n > 0 || i > 0;
}, py = (e, t = !1) => {
  const n = Gh();
  n && Ai(n) && (t && (n.style.transition = "none", n.style.width = "100%"), setTimeout(() => {
    n.style.transition = `width ${e / 1e3}s linear`, n.style.width = "0%";
  }, 10));
}, s$ = () => {
  const e = Gh();
  if (!e)
    return;
  const t = parseInt(window.getComputedStyle(e).width);
  e.style.removeProperty("transition"), e.style.width = "100%";
  const n = parseInt(window.getComputedStyle(e).width), i = t / n * 100;
  e.style.width = `${i}%`;
}, qT = () => typeof window > "u" || typeof document > "u", a$ = `
 <div aria-labelledby="${re.title}" aria-describedby="${re["html-container"]}" class="${re.popup}" tabindex="-1">
   <button type="button" class="${re.close}"></button>
   <ul class="${re["progress-steps"]}"></ul>
   <div class="${re.icon}"></div>
   <img class="${re.image}" />
   <h2 class="${re.title}" id="${re.title}"></h2>
   <div class="${re["html-container"]}" id="${re["html-container"]}"></div>
   <input class="${re.input}" id="${re.input}" />
   <input type="file" class="${re.file}" />
   <div class="${re.range}">
     <input type="range" />
     <output></output>
   </div>
   <select class="${re.select}" id="${re.select}"></select>
   <div class="${re.radio}"></div>
   <label class="${re.checkbox}">
     <input type="checkbox" id="${re.checkbox}" />
     <span class="${re.label}"></span>
   </label>
   <textarea class="${re.textarea}" id="${re.textarea}"></textarea>
   <div class="${re["validation-message"]}" id="${re["validation-message"]}"></div>
   <div class="${re.actions}">
     <div class="${re.loader}"></div>
     <button type="button" class="${re.confirm}"></button>
     <button type="button" class="${re.deny}"></button>
     <button type="button" class="${re.cancel}"></button>
   </div>
   <div class="${re.footer}"></div>
   <div class="${re["timer-progress-bar-container"]}">
     <div class="${re["timer-progress-bar"]}"></div>
   </div>
 </div>
`.replace(/(^|\n)\s*/g, ""), o$ = () => {
  const e = wi();
  return e ? (e.remove(), zr(
    [document.documentElement, document.body],
    [re["no-backdrop"], re["toast-shown"], re["has-column"]]
  ), !0) : !1;
}, _a = () => {
  Je.currentInstance.resetValidationMessage();
}, l$ = () => {
  const e = yt(), t = Ks(e, re.input), n = Ks(e, re.file), i = e.querySelector(`.${re.range} input`), r = e.querySelector(`.${re.range} output`), s = Ks(e, re.select), a = e.querySelector(`.${re.checkbox} input`), o = Ks(e, re.textarea);
  t.oninput = _a, n.onchange = _a, s.onchange = _a, a.onchange = _a, o.oninput = _a, i.oninput = () => {
    _a(), r.value = i.value;
  }, i.onchange = () => {
    _a(), r.value = i.value;
  };
}, u$ = (e) => typeof e == "string" ? document.querySelector(e) : e, c$ = (e) => {
  const t = yt();
  t.setAttribute("role", e.toast ? "alert" : "dialog"), t.setAttribute("aria-live", e.toast ? "polite" : "assertive"), e.toast || t.setAttribute("aria-modal", "true");
}, d$ = (e) => {
  window.getComputedStyle(e).direction === "rtl" && dt(wi(), re.rtl);
}, f$ = (e) => {
  const t = o$();
  if (qT()) {
    So("SweetAlert2 requires document to initialize");
    return;
  }
  const n = document.createElement("div");
  n.className = re.container, t && dt(n, re["no-transition"]), Di(n, a$);
  const i = u$(e.target);
  i.appendChild(n), c$(e), d$(i), l$();
}, yy = (e, t) => {
  e instanceof HTMLElement ? t.appendChild(e) : typeof e == "object" ? h$(e, t) : e && Di(t, e);
}, h$ = (e, t) => {
  e.jquery ? m$(t, e) : Di(t, e.toString());
}, m$ = (e, t) => {
  if (e.textContent = "", 0 in t)
    for (let n = 0; n in t; n++)
      e.appendChild(t[n].cloneNode(!0));
  else
    e.appendChild(t.cloneNode(!0));
}, Qa = (() => {
  if (qT())
    return !1;
  const e = document.createElement("div");
  return typeof e.style.webkitAnimation < "u" ? "webkitAnimationEnd" : typeof e.style.animation < "u" ? "animationend" : !1;
})(), v$ = (e, t) => {
  const n = jc(), i = Yl();
  !n || !i || (!t.showConfirmButton && !t.showDenyButton && !t.showCancelButton ? Zn(n) : xn(n), Xi(n, t, "actions"), g$(n, i, t), Di(i, t.loaderHtml || ""), Xi(i, t, "loader"));
};
function g$(e, t, n) {
  const i = Hr(), r = ko(), s = Gl();
  !i || !r || !s || (pv(i, "confirm", n), pv(r, "deny", n), pv(s, "cancel", n), p$(i, r, s, n), n.reverseButtons && (n.toast ? (e.insertBefore(s, i), e.insertBefore(r, i)) : (e.insertBefore(s, t), e.insertBefore(r, t), e.insertBefore(i, t))));
}
function p$(e, t, n, i) {
  if (!i.buttonsStyling) {
    zr([e, t, n], re.styled);
    return;
  }
  dt([e, t, n], re.styled), i.confirmButtonColor && (e.style.backgroundColor = i.confirmButtonColor, dt(e, re["default-outline"])), i.denyButtonColor && (t.style.backgroundColor = i.denyButtonColor, dt(t, re["default-outline"])), i.cancelButtonColor && (n.style.backgroundColor = i.cancelButtonColor, dt(n, re["default-outline"]));
}
function pv(e, t, n) {
  const i = (
    /** @type {'Confirm' | 'Deny' | 'Cancel'} */
    ly(t)
  );
  Hc(e, n[`show${i}Button`], "inline-block"), Di(e, n[`${t}ButtonText`] || ""), e.setAttribute("aria-label", n[`${t}ButtonAriaLabel`] || ""), e.className = re[t], Xi(e, n, `${t}Button`);
}
const y$ = (e, t) => {
  const n = hy();
  n && (Di(n, t.closeButtonHtml || ""), Xi(n, t, "closeButton"), Hc(n, t.showCloseButton), n.setAttribute("aria-label", t.closeButtonAriaLabel || ""));
}, b$ = (e, t) => {
  const n = wi();
  n && (w$(n, t.backdrop), _$(n, t.position), S$(n, t.grow), Xi(n, t, "container"));
};
function w$(e, t) {
  typeof t == "string" ? e.style.background = t : t || dt([document.documentElement, document.body], re["no-backdrop"]);
}
function _$(e, t) {
  t && (t in re ? dt(e, re[t]) : (bi('The "position" parameter is not valid, defaulting to "center"'), dt(e, re.center)));
}
function S$(e, t) {
  t && dt(e, re[`grow-${t}`]);
}
const xt = {
  innerParams: /* @__PURE__ */ new WeakMap(),
  domCache: /* @__PURE__ */ new WeakMap()
}, k$ = ["input", "file", "range", "select", "radio", "checkbox", "textarea"], C$ = (e, t) => {
  const n = yt();
  if (!n)
    return;
  const i = xt.innerParams.get(e), r = !i || t.input !== i.input;
  k$.forEach((s) => {
    const a = Ks(n, re[s]);
    a && (A$(s, t.inputAttributes), a.className = re[s], r && Zn(a));
  }), t.input && (r && T$(t), I$(t));
}, T$ = (e) => {
  if (!e.input)
    return;
  if (!tn[e.input]) {
    So(`Unexpected type of input! Expected ${Object.keys(tn).join(" | ")}, got "${e.input}"`);
    return;
  }
  const t = GT(e.input), n = tn[e.input](t, e);
  xn(t), e.inputAutoFocus && setTimeout(() => {
    HT(n);
  });
}, x$ = (e) => {
  for (let t = 0; t < e.attributes.length; t++) {
    const n = e.attributes[t].name;
    ["id", "type", "value", "style"].includes(n) || e.removeAttribute(n);
  }
}, A$ = (e, t) => {
  const n = Zh(yt(), e);
  if (n) {
    x$(n);
    for (const i in t)
      n.setAttribute(i, t[i]);
  }
}, I$ = (e) => {
  const t = GT(e.input);
  typeof e.customClass == "object" && dt(t, e.customClass.input);
}, by = (e, t) => {
  (!e.placeholder || t.inputPlaceholder) && (e.placeholder = t.inputPlaceholder);
}, zc = (e, t, n) => {
  if (n.inputLabel) {
    const i = document.createElement("label"), r = re["input-label"];
    i.setAttribute("for", e.id), i.className = r, typeof n.customClass == "object" && dt(i, n.customClass.inputLabel), i.innerText = n.inputLabel, t.insertAdjacentElement("beforebegin", i);
  }
}, GT = (e) => Ks(yt(), re[e] || re.input), Df = (e, t) => {
  ["string", "number"].includes(typeof t) ? e.value = `${t}` : cy(t) || bi(`Unexpected type of inputValue! Expected "string", "number" or "Promise", got "${typeof t}"`);
}, tn = {};
tn.text = tn.email = tn.password = tn.number = tn.tel = tn.url = tn.search = tn.date = tn["datetime-local"] = tn.time = tn.week = tn.month = (e, t) => (Df(e, t.inputValue), zc(e, e, t), by(e, t), e.type = t.input, e);
tn.file = (e, t) => (zc(e, e, t), by(e, t), e);
tn.range = (e, t) => {
  const n = e.querySelector("input"), i = e.querySelector("output");
  return Df(n, t.inputValue), n.type = t.input, Df(i, t.inputValue), zc(n, e, t), e;
};
tn.select = (e, t) => {
  if (e.textContent = "", t.inputPlaceholder) {
    const n = document.createElement("option");
    Di(n, t.inputPlaceholder), n.value = "", n.disabled = !0, n.selected = !0, e.appendChild(n);
  }
  return zc(e, e, t), e;
};
tn.radio = (e) => (e.textContent = "", e);
tn.checkbox = (e, t) => {
  const n = Zh(yt(), "checkbox");
  n.value = "1", n.checked = !!t.inputValue;
  const i = e.querySelector("span");
  return Di(i, t.inputPlaceholder), n;
};
tn.textarea = (e, t) => {
  Df(e, t.inputValue), by(e, t), zc(e, e, t);
  const n = (i) => parseInt(window.getComputedStyle(i).marginLeft) + parseInt(window.getComputedStyle(i).marginRight);
  return setTimeout(() => {
    if ("MutationObserver" in window) {
      const i = parseInt(window.getComputedStyle(yt()).width), r = () => {
        if (!document.body.contains(e))
          return;
        const s = e.offsetWidth + n(e);
        s > i ? yt().style.width = `${s}px` : Ha(yt(), "width", t.width);
      };
      new MutationObserver(r).observe(e, {
        attributes: !0,
        attributeFilter: ["style"]
      });
    }
  }), e;
};
const E$ = (e, t) => {
  const n = dy();
  n && (gy(n), Xi(n, t, "htmlContainer"), t.html ? (yy(t.html, n), xn(n, "block")) : t.text ? (n.textContent = t.text, xn(n, "block")) : Zn(n), C$(e, t));
}, O$ = (e, t) => {
  const n = jT();
  n && (gy(n), Hc(n, t.footer, "block"), t.footer && yy(t.footer, n), Xi(n, t, "footer"));
}, P$ = (e, t) => {
  const n = xt.innerParams.get(e), i = Wc();
  if (i) {
    if (n && t.icon === n.icon) {
      J0(i, t), X0(i, t);
      return;
    }
    if (!t.icon && !t.iconHtml) {
      Zn(i);
      return;
    }
    if (t.icon && Object.keys(Vf).indexOf(t.icon) === -1) {
      So(`Unknown icon! Expected "success", "error", "warning", "info" or "question", got "${t.icon}"`), Zn(i);
      return;
    }
    xn(i), J0(i, t), X0(i, t), dt(i, t.showClass && t.showClass.icon);
  }
}, X0 = (e, t) => {
  for (const [n, i] of Object.entries(Vf))
    t.icon !== n && zr(e, i);
  dt(e, t.icon && Vf[t.icon]), M$(e, t), V$(), Xi(e, t, "icon");
}, V$ = () => {
  const e = yt();
  if (!e)
    return;
  const t = window.getComputedStyle(e).getPropertyValue("background-color"), n = e.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
  for (let i = 0; i < n.length; i++)
    n[i].style.backgroundColor = t;
}, D$ = `
  <div class="swal2-success-circular-line-left"></div>
  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>
  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>
  <div class="swal2-success-circular-line-right"></div>
`, N$ = `
  <span class="swal2-x-mark">
    <span class="swal2-x-mark-line-left"></span>
    <span class="swal2-x-mark-line-right"></span>
  </span>
`, J0 = (e, t) => {
  if (!t.icon && !t.iconHtml)
    return;
  let n = e.innerHTML, i = "";
  t.iconHtml ? i = Q0(t.iconHtml) : t.icon === "success" ? (i = D$, n = n.replace(/ style=".*?"/g, "")) : t.icon === "error" ? i = N$ : t.icon && (i = Q0({
    question: "?",
    warning: "!",
    info: "i"
  }[t.icon])), n.trim() !== i.trim() && Di(e, i);
}, M$ = (e, t) => {
  if (t.iconColor) {
    e.style.color = t.iconColor, e.style.borderColor = t.iconColor;
    for (const n of [
      ".swal2-success-line-tip",
      ".swal2-success-line-long",
      ".swal2-x-mark-line-left",
      ".swal2-x-mark-line-right"
    ])
      Z0(e, n, "background-color", t.iconColor);
    Z0(e, ".swal2-success-ring", "border-color", t.iconColor);
  }
}, Q0 = (e) => `<div class="${re["icon-content"]}">${e}</div>`, R$ = (e, t) => {
  const n = WT();
  if (n) {
    if (!t.imageUrl) {
      Zn(n);
      return;
    }
    xn(n, ""), n.setAttribute("src", t.imageUrl), n.setAttribute("alt", t.imageAlt || ""), Ha(n, "width", t.imageWidth), Ha(n, "height", t.imageHeight), n.className = re.image, Xi(n, t, "image");
  }
}, F$ = (e, t) => {
  const n = wi(), i = yt();
  if (!(!n || !i)) {
    if (t.toast) {
      Ha(n, "width", t.width), i.style.width = "100%";
      const r = Yl();
      r && i.insertBefore(r, Wc());
    } else
      Ha(i, "width", t.width);
    Ha(i, "padding", t.padding), t.color && (i.style.color = t.color), t.background && (i.style.background = t.background), Zn(qh()), B$(i, t);
  }
}, B$ = (e, t) => {
  const n = t.showClass || {};
  e.className = `${re.popup} ${Ai(e) ? n.popup : ""}`, t.toast ? (dt([document.documentElement, document.body], re["toast-shown"]), dt(e, re.toast)) : dt(e, re.modal), Xi(e, t, "popup"), typeof t.customClass == "string" && dt(e, t.customClass), t.icon && dt(e, re[`icon-${t.icon}`]);
}, L$ = (e, t) => {
  const n = fy();
  if (!n)
    return;
  const { progressSteps: i, currentProgressStep: r } = t;
  if (!i || i.length === 0 || r === void 0) {
    Zn(n);
    return;
  }
  xn(n), n.textContent = "", r >= i.length && bi(
    "Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)"
  ), i.forEach((s, a) => {
    const o = $$(s);
    if (n.appendChild(o), a === r && dt(o, re["active-progress-step"]), a !== i.length - 1) {
      const l = W$(t);
      n.appendChild(l);
    }
  });
}, $$ = (e) => {
  const t = document.createElement("li");
  return dt(t, re["progress-step"]), Di(t, e), t;
}, W$ = (e) => {
  const t = document.createElement("li");
  return dt(t, re["progress-step-line"]), e.progressStepsDistance && Ha(t, "width", e.progressStepsDistance), t;
}, j$ = (e, t) => {
  const n = $T();
  n && (gy(n), Hc(n, t.title || t.titleText, "block"), t.title && yy(t.title, n), t.titleText && (n.innerText = t.titleText), Xi(n, t, "title"));
}, YT = (e, t) => {
  F$(e, t), b$(e, t), L$(e, t), P$(e, t), R$(e, t), j$(e, t), y$(e, t), E$(e, t), v$(e, t), O$(e, t);
  const n = yt();
  typeof t.didRender == "function" && n && t.didRender(n);
}, H$ = () => Ai(yt()), ZT = () => {
  var e;
  return (e = Hr()) == null ? void 0 : e.click();
}, z$ = () => {
  var e;
  return (e = ko()) == null ? void 0 : e.click();
}, U$ = () => {
  var e;
  return (e = Gl()) == null ? void 0 : e.click();
}, Zl = Object.freeze({
  cancel: "cancel",
  backdrop: "backdrop",
  close: "close",
  esc: "esc",
  timer: "timer"
}), KT = (e) => {
  e.keydownTarget && e.keydownHandlerAdded && (e.keydownTarget.removeEventListener("keydown", e.keydownHandler, {
    capture: e.keydownListenerCapture
  }), e.keydownHandlerAdded = !1);
}, q$ = (e, t, n) => {
  KT(e), t.toast || (e.keydownHandler = (i) => Y$(t, i, n), e.keydownTarget = t.keydownListenerCapture ? window : yt(), e.keydownListenerCapture = t.keydownListenerCapture, e.keydownTarget.addEventListener("keydown", e.keydownHandler, {
    capture: e.keydownListenerCapture
  }), e.keydownHandlerAdded = !0);
}, hg = (e, t) => {
  var i;
  const n = my();
  if (n.length) {
    e = e + t, e === n.length ? e = 0 : e === -1 && (e = n.length - 1), n[e].focus();
    return;
  }
  (i = yt()) == null || i.focus();
}, XT = ["ArrowRight", "ArrowDown"], G$ = ["ArrowLeft", "ArrowUp"], Y$ = (e, t, n) => {
  e && (t.isComposing || t.keyCode === 229 || (e.stopKeydownPropagation && t.stopPropagation(), t.key === "Enter" ? Z$(t, e) : t.key === "Tab" ? K$(t) : [...XT, ...G$].includes(t.key) ? X$(t.key) : t.key === "Escape" && J$(t, e, n)));
}, Z$ = (e, t) => {
  if (!Uh(t.allowEnterKey))
    return;
  const n = Zh(yt(), t.input);
  if (e.target && n && e.target instanceof HTMLElement && e.target.outerHTML === n.outerHTML) {
    if (["textarea", "file"].includes(t.input))
      return;
    ZT(), e.preventDefault();
  }
}, K$ = (e) => {
  const t = e.target, n = my();
  let i = -1;
  for (let r = 0; r < n.length; r++)
    if (t === n[r]) {
      i = r;
      break;
    }
  e.shiftKey ? hg(i, -1) : hg(i, 1), e.stopPropagation(), e.preventDefault();
}, X$ = (e) => {
  const t = jc(), n = Hr(), i = ko(), r = Gl();
  if (!t || !n || !i || !r)
    return;
  const s = [n, i, r];
  if (document.activeElement instanceof HTMLElement && !s.includes(document.activeElement))
    return;
  const a = XT.includes(e) ? "nextElementSibling" : "previousElementSibling";
  let o = document.activeElement;
  if (o) {
    for (let l = 0; l < t.children.length; l++) {
      if (o = o[a], !o)
        return;
      if (o instanceof HTMLButtonElement && Ai(o))
        break;
    }
    o instanceof HTMLButtonElement && o.focus();
  }
}, J$ = (e, t, n) => {
  Uh(t.allowEscapeKey) && (e.preventDefault(), n(Zl.esc));
}, _l = {
  swalPromiseResolve: /* @__PURE__ */ new WeakMap(),
  swalPromiseReject: /* @__PURE__ */ new WeakMap()
}, Q$ = () => {
  const e = wi();
  Array.from(document.body.children).forEach((n) => {
    n.contains(e) || (n.hasAttribute("aria-hidden") && n.setAttribute("data-previous-aria-hidden", n.getAttribute("aria-hidden") || ""), n.setAttribute("aria-hidden", "true"));
  });
}, JT = () => {
  Array.from(document.body.children).forEach((t) => {
    t.hasAttribute("data-previous-aria-hidden") ? (t.setAttribute("aria-hidden", t.getAttribute("data-previous-aria-hidden") || ""), t.removeAttribute("data-previous-aria-hidden")) : t.removeAttribute("aria-hidden");
  });
}, QT = typeof window < "u" && !!window.GestureEvent, eW = () => {
  if (QT && !vs(document.body, re.iosfix)) {
    const e = document.body.scrollTop;
    document.body.style.top = `${e * -1}px`, dt(document.body, re.iosfix), tW();
  }
}, tW = () => {
  const e = wi();
  if (!e)
    return;
  let t;
  e.ontouchstart = (n) => {
    t = nW(n);
  }, e.ontouchmove = (n) => {
    t && (n.preventDefault(), n.stopPropagation());
  };
}, nW = (e) => {
  const t = e.target, n = wi(), i = dy();
  return !n || !i || iW(e) || rW(e) ? !1 : t === n || !K0(n) && t instanceof HTMLElement && t.tagName !== "INPUT" && // #1603
  t.tagName !== "TEXTAREA" && // #2266
  !(K0(i) && // #1944
  i.contains(t));
}, iW = (e) => e.touches && e.touches.length && e.touches[0].touchType === "stylus", rW = (e) => e.touches && e.touches.length > 1, sW = () => {
  if (vs(document.body, re.iosfix)) {
    const e = parseInt(document.body.style.top, 10);
    zr(document.body, re.iosfix), document.body.style.top = "", document.body.scrollTop = e * -1;
  }
}, aW = () => {
  const e = document.createElement("div");
  e.className = re["scrollbar-measure"], document.body.appendChild(e);
  const t = e.getBoundingClientRect().width - e.clientWidth;
  return document.body.removeChild(e), t;
};
let ul = null;
const oW = (e) => {
  ul === null && (document.body.scrollHeight > window.innerHeight || e === "scroll") && (ul = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right")), document.body.style.paddingRight = `${ul + aW()}px`);
}, lW = () => {
  ul !== null && (document.body.style.paddingRight = `${ul}px`, ul = null);
};
function e1(e, t, n, i) {
  Yh() ? e_(e, i) : (Y2(n).then(() => e_(e, i)), KT(Je)), QT ? (t.setAttribute("style", "display:none !important"), t.removeAttribute("class"), t.innerHTML = "") : t.remove(), vy() && (lW(), sW(), JT()), uW();
}
function uW() {
  zr(
    [document.documentElement, document.body],
    [re.shown, re["height-auto"], re["no-backdrop"], re["toast-shown"]]
  );
}
function Xs(e) {
  e = dW(e);
  const t = _l.swalPromiseResolve.get(this), n = cW(this);
  this.isAwaitingPromise ? e.isDismissed || (Uc(this), t(e)) : n && t(e);
}
const cW = (e) => {
  const t = yt();
  if (!t)
    return !1;
  const n = xt.innerParams.get(e);
  if (!n || vs(t, n.hideClass.popup))
    return !1;
  zr(t, n.showClass.popup), dt(t, n.hideClass.popup);
  const i = wi();
  return zr(i, n.showClass.backdrop), dt(i, n.hideClass.backdrop), fW(e, t, n), !0;
};
function t1(e) {
  const t = _l.swalPromiseReject.get(this);
  Uc(this), t && t(e);
}
const Uc = (e) => {
  e.isAwaitingPromise && (delete e.isAwaitingPromise, xt.innerParams.get(e) || e._destroy());
}, dW = (e) => typeof e > "u" ? {
  isConfirmed: !1,
  isDenied: !1,
  isDismissed: !0
} : Object.assign(
  {
    isConfirmed: !1,
    isDenied: !1,
    isDismissed: !1
  },
  e
), fW = (e, t, n) => {
  const i = wi(), r = Qa && UT(t);
  typeof n.willClose == "function" && n.willClose(t), r ? hW(e, t, i, n.returnFocus, n.didClose) : e1(e, i, n.returnFocus, n.didClose);
}, hW = (e, t, n, i, r) => {
  Qa && (Je.swalCloseEventFinishedCallback = e1.bind(
    null,
    e,
    n,
    i,
    r
  ), t.addEventListener(Qa, function(s) {
    s.target === t && (Je.swalCloseEventFinishedCallback(), delete Je.swalCloseEventFinishedCallback);
  }));
}, e_ = (e, t) => {
  setTimeout(() => {
    typeof t == "function" && t.bind(e.params)(), e._destroy && e._destroy();
  });
}, Sl = (e) => {
  let t = yt();
  if (t || new to(), t = yt(), !t)
    return;
  const n = Yl();
  Yh() ? Zn(Wc()) : mW(t, e), xn(n), t.setAttribute("data-loading", "true"), t.setAttribute("aria-busy", "true"), t.focus();
}, mW = (e, t) => {
  const n = jc(), i = Yl();
  !n || !i || (!t && Ai(Hr()) && (t = Hr()), xn(n), t && (Zn(t), i.setAttribute("data-button-to-replace", t.className), n.insertBefore(i, t)), dt([e, n], re.loading));
}, vW = (e, t) => {
  t.input === "select" || t.input === "radio" ? wW(e, t) : ["text", "email", "number", "tel", "textarea"].some((n) => n === t.input) && (uy(t.inputValue) || cy(t.inputValue)) && (Sl(Hr()), _W(e, t));
}, gW = (e, t) => {
  const n = e.getInput();
  if (!n)
    return null;
  switch (t.input) {
    case "checkbox":
      return pW(n);
    case "radio":
      return yW(n);
    case "file":
      return bW(n);
    default:
      return t.inputAutoTrim ? n.value.trim() : n.value;
  }
}, pW = (e) => e.checked ? 1 : 0, yW = (e) => e.checked ? e.value : null, bW = (e) => e.files && e.files.length ? e.getAttribute("multiple") !== null ? e.files : e.files[0] : null, wW = (e, t) => {
  const n = yt();
  if (!n)
    return;
  const i = (r) => {
    t.input === "select" ? SW(n, Nf(r), t) : t.input === "radio" && kW(n, Nf(r), t);
  };
  uy(t.inputOptions) || cy(t.inputOptions) ? (Sl(Hr()), Lc(t.inputOptions).then((r) => {
    e.hideLoading(), i(r);
  })) : typeof t.inputOptions == "object" ? i(t.inputOptions) : So(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof t.inputOptions}`);
}, _W = (e, t) => {
  const n = e.getInput();
  n && (Zn(n), Lc(t.inputValue).then((i) => {
    n.value = t.input === "number" ? `${parseFloat(i) || 0}` : `${i}`, xn(n), n.focus(), e.hideLoading();
  }).catch((i) => {
    So(`Error in inputValue promise: ${i}`), n.value = "", xn(n), n.focus(), e.hideLoading();
  }));
};
function SW(e, t, n) {
  const i = Ks(e, re.select);
  if (!i)
    return;
  const r = (s, a, o) => {
    const l = document.createElement("option");
    l.value = o, Di(l, a), l.selected = n1(o, n.inputValue), s.appendChild(l);
  };
  t.forEach((s) => {
    const a = s[0], o = s[1];
    if (Array.isArray(o)) {
      const l = document.createElement("optgroup");
      l.label = a, l.disabled = !1, i.appendChild(l), o.forEach((u) => r(l, u[1], u[0]));
    } else
      r(i, o, a);
  }), i.focus();
}
function kW(e, t, n) {
  const i = Ks(e, re.radio);
  if (!i)
    return;
  t.forEach((s) => {
    const a = s[0], o = s[1], l = document.createElement("input"), u = document.createElement("label");
    l.type = "radio", l.name = re.radio, l.value = a, n1(a, n.inputValue) && (l.checked = !0);
    const c = document.createElement("span");
    Di(c, o), c.className = re.label, u.appendChild(l), u.appendChild(c), i.appendChild(u);
  });
  const r = i.querySelectorAll("input");
  r.length && r[0].focus();
}
const Nf = (e) => {
  const t = [];
  return e instanceof Map ? e.forEach((n, i) => {
    let r = n;
    typeof r == "object" && (r = Nf(r)), t.push([i, r]);
  }) : Object.keys(e).forEach((n) => {
    let i = e[n];
    typeof i == "object" && (i = Nf(i)), t.push([n, i]);
  }), t;
}, n1 = (e, t) => !!t && t.toString() === e.toString(), CW = (e) => {
  const t = xt.innerParams.get(e);
  e.disableButtons(), t.input ? i1(e, "confirm") : _y(e, !0);
}, TW = (e) => {
  const t = xt.innerParams.get(e);
  e.disableButtons(), t.returnInputValueOnDeny ? i1(e, "deny") : wy(e, !1);
}, xW = (e, t) => {
  e.disableButtons(), t(Zl.cancel);
}, i1 = (e, t) => {
  const n = xt.innerParams.get(e);
  if (!n.input) {
    So(`The "input" parameter is needed to be set when using returnInputValueOn${ly(t)}`);
    return;
  }
  const i = e.getInput(), r = gW(e, n);
  n.inputValidator ? AW(e, r, t) : i && !i.checkValidity() ? (e.enableButtons(), e.showValidationMessage(n.validationMessage || i.validationMessage)) : t === "deny" ? wy(e, r) : _y(e, r);
}, AW = (e, t, n) => {
  const i = xt.innerParams.get(e);
  e.disableInput(), Promise.resolve().then(
    () => Lc(i.inputValidator(t, i.validationMessage))
  ).then((s) => {
    e.enableButtons(), e.enableInput(), s ? e.showValidationMessage(s) : n === "deny" ? wy(e, t) : _y(e, t);
  });
}, wy = (e, t) => {
  const n = xt.innerParams.get(e || globalThis);
  n.showLoaderOnDeny && Sl(ko()), n.preDeny ? (e.isAwaitingPromise = !0, Promise.resolve().then(
    () => Lc(n.preDeny(t, n.validationMessage))
  ).then((r) => {
    r === !1 ? (e.hideLoading(), Uc(e)) : e.close({ isDenied: !0, value: typeof r > "u" ? t : r });
  }).catch((r) => r1(e || globalThis, r))) : e.close({ isDenied: !0, value: t });
}, t_ = (e, t) => {
  e.close({ isConfirmed: !0, value: t });
}, r1 = (e, t) => {
  e.rejectPromise(t);
}, _y = (e, t) => {
  const n = xt.innerParams.get(e || globalThis);
  n.showLoaderOnConfirm && Sl(), n.preConfirm ? (e.resetValidationMessage(), e.isAwaitingPromise = !0, Promise.resolve().then(
    () => Lc(n.preConfirm(t, n.validationMessage))
  ).then((r) => {
    Ai(qh()) || r === !1 ? (e.hideLoading(), Uc(e)) : t_(e, typeof r > "u" ? t : r);
  }).catch((r) => r1(e || globalThis, r))) : t_(e, t);
};
function Mf() {
  const e = xt.innerParams.get(this);
  if (!e)
    return;
  const t = xt.domCache.get(this);
  Zn(t.loader), Yh() ? e.icon && xn(Wc()) : IW(t), zr([t.popup, t.actions], re.loading), t.popup.removeAttribute("aria-busy"), t.popup.removeAttribute("data-loading"), t.confirmButton.disabled = !1, t.denyButton.disabled = !1, t.cancelButton.disabled = !1;
}
const IW = (e) => {
  const t = e.popup.getElementsByClassName(e.loader.getAttribute("data-button-to-replace"));
  t.length ? xn(t[0], "inline-block") : r$() && Zn(e.actions);
};
function s1() {
  const e = xt.innerParams.get(this), t = xt.domCache.get(this);
  return t ? Zh(t.popup, e.input) : null;
}
function a1(e, t, n) {
  const i = xt.domCache.get(e);
  t.forEach((r) => {
    i[r].disabled = n;
  });
}
function o1(e, t) {
  const n = yt();
  if (!(!n || !e))
    if (e.type === "radio") {
      const i = n.querySelectorAll(`[name="${re.radio}"]`);
      for (let r = 0; r < i.length; r++)
        i[r].disabled = t;
    } else
      e.disabled = t;
}
function l1() {
  a1(this, ["confirmButton", "denyButton", "cancelButton"], !1);
}
function u1() {
  a1(this, ["confirmButton", "denyButton", "cancelButton"], !0);
}
function c1() {
  o1(this.getInput(), !1);
}
function d1() {
  o1(this.getInput(), !0);
}
function f1(e) {
  const t = xt.domCache.get(this), n = xt.innerParams.get(this);
  Di(t.validationMessage, e), t.validationMessage.className = re["validation-message"], n.customClass && n.customClass.validationMessage && dt(t.validationMessage, n.customClass.validationMessage), xn(t.validationMessage);
  const i = this.getInput();
  i && (i.setAttribute("aria-invalid", "true"), i.setAttribute("aria-describedby", re["validation-message"]), HT(i), dt(i, re.inputerror));
}
function h1() {
  const e = xt.domCache.get(this);
  e.validationMessage && Zn(e.validationMessage);
  const t = this.getInput();
  t && (t.removeAttribute("aria-invalid"), t.removeAttribute("aria-describedby"), zr(t, re.inputerror));
}
const cl = {
  title: "",
  titleText: "",
  text: "",
  html: "",
  footer: "",
  icon: void 0,
  iconColor: void 0,
  iconHtml: void 0,
  template: void 0,
  toast: !1,
  animation: !0,
  showClass: {
    popup: "swal2-show",
    backdrop: "swal2-backdrop-show",
    icon: "swal2-icon-show"
  },
  hideClass: {
    popup: "swal2-hide",
    backdrop: "swal2-backdrop-hide",
    icon: "swal2-icon-hide"
  },
  customClass: {},
  target: "body",
  color: void 0,
  backdrop: !0,
  heightAuto: !0,
  allowOutsideClick: !0,
  allowEscapeKey: !0,
  allowEnterKey: !0,
  stopKeydownPropagation: !0,
  keydownListenerCapture: !1,
  showConfirmButton: !0,
  showDenyButton: !1,
  showCancelButton: !1,
  preConfirm: void 0,
  preDeny: void 0,
  confirmButtonText: "OK",
  confirmButtonAriaLabel: "",
  confirmButtonColor: void 0,
  denyButtonText: "No",
  denyButtonAriaLabel: "",
  denyButtonColor: void 0,
  cancelButtonText: "Cancel",
  cancelButtonAriaLabel: "",
  cancelButtonColor: void 0,
  buttonsStyling: !0,
  reverseButtons: !1,
  focusConfirm: !0,
  focusDeny: !1,
  focusCancel: !1,
  returnFocus: !0,
  showCloseButton: !1,
  closeButtonHtml: "&times;",
  closeButtonAriaLabel: "Close this dialog",
  loaderHtml: "",
  showLoaderOnConfirm: !1,
  showLoaderOnDeny: !1,
  imageUrl: void 0,
  imageWidth: void 0,
  imageHeight: void 0,
  imageAlt: "",
  timer: void 0,
  timerProgressBar: !1,
  width: void 0,
  padding: void 0,
  background: void 0,
  input: void 0,
  inputPlaceholder: "",
  inputLabel: "",
  inputValue: "",
  inputOptions: {},
  inputAutoFocus: !0,
  inputAutoTrim: !0,
  inputAttributes: {},
  inputValidator: void 0,
  returnInputValueOnDeny: !1,
  validationMessage: void 0,
  grow: !1,
  position: "center",
  progressSteps: [],
  currentProgressStep: void 0,
  progressStepsDistance: void 0,
  willOpen: void 0,
  didOpen: void 0,
  didRender: void 0,
  willClose: void 0,
  didClose: void 0,
  didDestroy: void 0,
  scrollbarPadding: !0
}, EW = [
  "allowEscapeKey",
  "allowOutsideClick",
  "background",
  "buttonsStyling",
  "cancelButtonAriaLabel",
  "cancelButtonColor",
  "cancelButtonText",
  "closeButtonAriaLabel",
  "closeButtonHtml",
  "color",
  "confirmButtonAriaLabel",
  "confirmButtonColor",
  "confirmButtonText",
  "currentProgressStep",
  "customClass",
  "denyButtonAriaLabel",
  "denyButtonColor",
  "denyButtonText",
  "didClose",
  "didDestroy",
  "footer",
  "hideClass",
  "html",
  "icon",
  "iconColor",
  "iconHtml",
  "imageAlt",
  "imageHeight",
  "imageUrl",
  "imageWidth",
  "preConfirm",
  "preDeny",
  "progressSteps",
  "returnFocus",
  "reverseButtons",
  "showCancelButton",
  "showCloseButton",
  "showConfirmButton",
  "showDenyButton",
  "text",
  "title",
  "titleText",
  "willClose"
], OW = {}, PW = [
  "allowOutsideClick",
  "allowEnterKey",
  "backdrop",
  "focusConfirm",
  "focusDeny",
  "focusCancel",
  "returnFocus",
  "heightAuto",
  "keydownListenerCapture"
], m1 = (e) => Object.prototype.hasOwnProperty.call(cl, e), v1 = (e) => EW.indexOf(e) !== -1, g1 = (e) => OW[e], VW = (e) => {
  m1(e) || bi(`Unknown parameter "${e}"`);
}, DW = (e) => {
  PW.includes(e) && bi(`The parameter "${e}" is incompatible with toasts`);
}, NW = (e) => {
  const t = g1(e);
  t && J2(e, t);
}, MW = (e) => {
  e.backdrop === !1 && e.allowOutsideClick && bi('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
  for (const t in e)
    VW(t), e.toast && DW(t), NW(t);
};
function p1(e) {
  const t = yt(), n = xt.innerParams.get(this);
  if (!t || vs(t, n.hideClass.popup)) {
    bi(
      "You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup."
    );
    return;
  }
  const i = RW(e), r = Object.assign({}, n, i);
  YT(this, r), xt.innerParams.set(this, r), Object.defineProperties(this, {
    params: {
      value: Object.assign({}, this.params, e),
      writable: !1,
      enumerable: !0
    }
  });
}
const RW = (e) => {
  const t = {};
  return Object.keys(e).forEach((n) => {
    v1(n) ? t[n] = e[n] : bi(`Invalid parameter to update: ${n}`);
  }), t;
};
function y1() {
  const e = xt.domCache.get(this), t = xt.innerParams.get(this);
  if (!t) {
    b1(this);
    return;
  }
  e.popup && Je.swalCloseEventFinishedCallback && (Je.swalCloseEventFinishedCallback(), delete Je.swalCloseEventFinishedCallback), typeof t.didDestroy == "function" && t.didDestroy(), FW(this);
}
const FW = (e) => {
  b1(e), delete e.params, delete Je.keydownHandler, delete Je.keydownTarget, delete Je.currentInstance;
}, b1 = (e) => {
  e.isAwaitingPromise ? (yv(xt, e), e.isAwaitingPromise = !0) : (yv(_l, e), yv(xt, e), delete e.isAwaitingPromise, delete e.disableButtons, delete e.enableButtons, delete e.getInput, delete e.disableInput, delete e.enableInput, delete e.hideLoading, delete e.disableLoading, delete e.showValidationMessage, delete e.resetValidationMessage, delete e.close, delete e.closePopup, delete e.closeModal, delete e.closeToast, delete e.rejectPromise, delete e.update, delete e._destroy);
}, yv = (e, t) => {
  for (const n in e)
    e[n].delete(t);
}, BW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _destroy: y1,
  close: Xs,
  closeModal: Xs,
  closePopup: Xs,
  closeToast: Xs,
  disableButtons: u1,
  disableInput: d1,
  disableLoading: Mf,
  enableButtons: l1,
  enableInput: c1,
  getInput: s1,
  handleAwaitingPromise: Uc,
  hideLoading: Mf,
  rejectPromise: t1,
  resetValidationMessage: h1,
  showValidationMessage: f1,
  update: p1
}, Symbol.toStringTag, { value: "Module" })), LW = (e, t, n) => {
  e.toast ? $W(e, t, n) : (jW(t), HW(t), zW(e, t, n));
}, $W = (e, t, n) => {
  t.popup.onclick = () => {
    e && (WW(e) || e.timer || e.input) || n(Zl.close);
  };
}, WW = (e) => !!(e.showConfirmButton || e.showDenyButton || e.showCancelButton || e.showCloseButton);
let Rf = !1;
const jW = (e) => {
  e.popup.onmousedown = () => {
    e.container.onmouseup = function(t) {
      e.container.onmouseup = () => {
      }, t.target === e.container && (Rf = !0);
    };
  };
}, HW = (e) => {
  e.container.onmousedown = (t) => {
    t.target === e.container && t.preventDefault(), e.popup.onmouseup = function(n) {
      e.popup.onmouseup = () => {
      }, (n.target === e.popup || n.target instanceof HTMLElement && e.popup.contains(n.target)) && (Rf = !0);
    };
  };
}, zW = (e, t, n) => {
  t.container.onclick = (i) => {
    if (Rf) {
      Rf = !1;
      return;
    }
    i.target === t.container && Uh(e.allowOutsideClick) && n(Zl.backdrop);
  };
}, UW = (e) => typeof e == "object" && e.jquery, n_ = (e) => e instanceof Element || UW(e), qW = (e) => {
  const t = {};
  return typeof e[0] == "object" && !n_(e[0]) ? Object.assign(t, e[0]) : ["title", "html", "icon"].forEach((n, i) => {
    const r = e[i];
    typeof r == "string" || n_(r) ? t[n] = r : r !== void 0 && So(`Unexpected type of ${n}! Expected "string" or "Element", got ${typeof r}`);
  }), t;
};
function GW(...e) {
  const t = this;
  return new t(...e);
}
function YW(e) {
  class t extends this {
    _main(i, r) {
      return super._main(i, Object.assign({}, e, r));
    }
  }
  return t;
}
const ZW = () => Je.timeout && Je.timeout.getTimerLeft(), w1 = () => {
  if (Je.timeout)
    return s$(), Je.timeout.stop();
}, _1 = () => {
  if (Je.timeout) {
    const e = Je.timeout.start();
    return py(e), e;
  }
}, KW = () => {
  const e = Je.timeout;
  return e && (e.running ? w1() : _1());
}, XW = (e) => {
  if (Je.timeout) {
    const t = Je.timeout.increase(e);
    return py(t, !0), t;
  }
}, JW = () => !!(Je.timeout && Je.timeout.isRunning());
let i_ = !1;
const mg = {};
function QW(e = "data-swal-template") {
  mg[e] = this, i_ || (document.body.addEventListener("click", ej), i_ = !0);
}
const ej = (e) => {
  for (let t = e.target; t && t !== document; t = t.parentNode)
    for (const n in mg) {
      const i = t.getAttribute(n);
      if (i) {
        mg[n].fire({ template: i });
        return;
      }
    }
}, tj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  argsToParams: qW,
  bindClickHandler: QW,
  clickCancel: U$,
  clickConfirm: ZT,
  clickDeny: z$,
  enableLoading: Sl,
  fire: GW,
  getActions: jc,
  getCancelButton: Gl,
  getCloseButton: hy,
  getConfirmButton: Hr,
  getContainer: wi,
  getDenyButton: ko,
  getFocusableElements: my,
  getFooter: jT,
  getHtmlContainer: dy,
  getIcon: Wc,
  getIconContent: Q2,
  getImage: WT,
  getInputLabel: e$,
  getLoader: Yl,
  getPopup: yt,
  getProgressSteps: fy,
  getTimerLeft: ZW,
  getTimerProgressBar: Gh,
  getTitle: $T,
  getValidationMessage: qh,
  increaseTimer: XW,
  isDeprecatedParameter: g1,
  isLoading: n$,
  isTimerRunning: JW,
  isUpdatableParameter: v1,
  isValidParameter: m1,
  isVisible: H$,
  mixin: YW,
  resumeTimer: _1,
  showLoading: Sl,
  stopTimer: w1,
  toggleTimer: KW
}, Symbol.toStringTag, { value: "Module" }));
class nj {
  /**
   * @param {Function} callback
   * @param {number} delay
   */
  constructor(t, n) {
    this.callback = t, this.remaining = n, this.running = !1, this.start();
  }
  /**
   * @returns {number}
   */
  start() {
    return this.running || (this.running = !0, this.started = /* @__PURE__ */ new Date(), this.id = setTimeout(this.callback, this.remaining)), this.remaining;
  }
  /**
   * @returns {number}
   */
  stop() {
    return this.started && this.running && (this.running = !1, clearTimeout(this.id), this.remaining -= (/* @__PURE__ */ new Date()).getTime() - this.started.getTime()), this.remaining;
  }
  /**
   * @param {number} n
   * @returns {number}
   */
  increase(t) {
    const n = this.running;
    return n && this.stop(), this.remaining += t, n && this.start(), this.remaining;
  }
  /**
   * @returns {number}
   */
  getTimerLeft() {
    return this.running && (this.stop(), this.start()), this.remaining;
  }
  /**
   * @returns {boolean}
   */
  isRunning() {
    return this.running;
  }
}
const S1 = ["swal-title", "swal-html", "swal-footer"], ij = (e) => {
  const t = typeof e.template == "string" ? document.querySelector(e.template) : e.template;
  if (!t)
    return {};
  const n = t.content;
  return dj(n), Object.assign(
    rj(n),
    sj(n),
    aj(n),
    oj(n),
    lj(n),
    uj(n),
    cj(n, S1)
  );
}, rj = (e) => {
  const t = {};
  return Array.from(e.querySelectorAll("swal-param")).forEach((i) => {
    eo(i, ["name", "value"]);
    const r = i.getAttribute("name"), s = i.getAttribute("value");
    typeof cl[r] == "boolean" ? t[r] = s !== "false" : typeof cl[r] == "object" ? t[r] = JSON.parse(s) : t[r] = s;
  }), t;
}, sj = (e) => {
  const t = {};
  return Array.from(e.querySelectorAll("swal-function-param")).forEach((i) => {
    const r = i.getAttribute("name"), s = i.getAttribute("value");
    t[r] = new Function(`return ${s}`)();
  }), t;
}, aj = (e) => {
  const t = {};
  return Array.from(e.querySelectorAll("swal-button")).forEach((i) => {
    eo(i, ["type", "color", "aria-label"]);
    const r = i.getAttribute("type");
    t[`${r}ButtonText`] = i.innerHTML, t[`show${ly(r)}Button`] = !0, i.hasAttribute("color") && (t[`${r}ButtonColor`] = i.getAttribute("color")), i.hasAttribute("aria-label") && (t[`${r}ButtonAriaLabel`] = i.getAttribute("aria-label"));
  }), t;
}, oj = (e) => {
  const t = {}, n = e.querySelector("swal-image");
  return n && (eo(n, ["src", "width", "height", "alt"]), n.hasAttribute("src") && (t.imageUrl = n.getAttribute("src")), n.hasAttribute("width") && (t.imageWidth = n.getAttribute("width")), n.hasAttribute("height") && (t.imageHeight = n.getAttribute("height")), n.hasAttribute("alt") && (t.imageAlt = n.getAttribute("alt"))), t;
}, lj = (e) => {
  const t = {}, n = e.querySelector("swal-icon");
  return n && (eo(n, ["type", "color"]), n.hasAttribute("type") && (t.icon = n.getAttribute("type")), n.hasAttribute("color") && (t.iconColor = n.getAttribute("color")), t.iconHtml = n.innerHTML), t;
}, uj = (e) => {
  const t = {}, n = e.querySelector("swal-input");
  n && (eo(n, ["type", "label", "placeholder", "value"]), t.input = n.getAttribute("type") || "text", n.hasAttribute("label") && (t.inputLabel = n.getAttribute("label")), n.hasAttribute("placeholder") && (t.inputPlaceholder = n.getAttribute("placeholder")), n.hasAttribute("value") && (t.inputValue = n.getAttribute("value")));
  const i = Array.from(e.querySelectorAll("swal-input-option"));
  return i.length && (t.inputOptions = {}, i.forEach((r) => {
    eo(r, ["value"]);
    const s = r.getAttribute("value"), a = r.innerHTML;
    t.inputOptions[s] = a;
  })), t;
}, cj = (e, t) => {
  const n = {};
  for (const i in t) {
    const r = t[i], s = e.querySelector(r);
    s && (eo(s, []), n[r.replace(/^swal-/, "")] = s.innerHTML.trim());
  }
  return n;
}, dj = (e) => {
  const t = S1.concat([
    "swal-param",
    "swal-function-param",
    "swal-button",
    "swal-image",
    "swal-icon",
    "swal-input",
    "swal-input-option"
  ]);
  Array.from(e.children).forEach((n) => {
    const i = n.tagName.toLowerCase();
    t.includes(i) || bi(`Unrecognized element <${i}>`);
  });
}, eo = (e, t) => {
  Array.from(e.attributes).forEach((n) => {
    t.indexOf(n.name) === -1 && bi([
      `Unrecognized attribute "${n.name}" on <${e.tagName.toLowerCase()}>.`,
      `${t.length ? `Allowed attributes are: ${t.join(", ")}` : "To set the value, use HTML within the element."}`
    ]);
  });
}, k1 = 10, fj = (e) => {
  const t = wi(), n = yt();
  typeof e.willOpen == "function" && e.willOpen(n);
  const r = window.getComputedStyle(document.body).overflowY;
  vj(t, n, e), setTimeout(() => {
    hj(t, n);
  }, k1), vy() && (mj(t, e.scrollbarPadding, r), Q$()), !Yh() && !Je.previousActiveElement && (Je.previousActiveElement = document.activeElement), typeof e.didOpen == "function" && setTimeout(() => e.didOpen(n)), zr(t, re["no-transition"]);
}, C1 = (e) => {
  const t = yt();
  if (e.target !== t || !Qa)
    return;
  const n = wi();
  t.removeEventListener(Qa, C1), n.style.overflowY = "auto";
}, hj = (e, t) => {
  Qa && UT(t) ? (e.style.overflowY = "hidden", t.addEventListener(Qa, C1)) : e.style.overflowY = "auto";
}, mj = (e, t, n) => {
  eW(), t && n !== "hidden" && oW(n), setTimeout(() => {
    e.scrollTop = 0;
  });
}, vj = (e, t, n) => {
  dt(e, n.showClass.backdrop), n.animation ? (t.style.setProperty("opacity", "0", "important"), xn(t, "grid"), setTimeout(() => {
    dt(t, n.showClass.popup), t.style.removeProperty("opacity");
  }, k1)) : xn(t, "grid"), dt([document.documentElement, document.body], re.shown), n.heightAuto && n.backdrop && !n.toast && dt([document.documentElement, document.body], re["height-auto"]);
}, r_ = {
  /**
   * @param {string} string
   * @param {string} [validationMessage]
   * @returns {Promise<string | void>}
   */
  email: (e, t) => /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]+$/.test(e) ? Promise.resolve() : Promise.resolve(t || "Invalid email address"),
  /**
   * @param {string} string
   * @param {string} [validationMessage]
   * @returns {Promise<string | void>}
   */
  url: (e, t) => /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(e) ? Promise.resolve() : Promise.resolve(t || "Invalid URL")
};
function gj(e) {
  e.inputValidator || (e.input === "email" && (e.inputValidator = r_.email), e.input === "url" && (e.inputValidator = r_.url));
}
function pj(e) {
  (!e.target || typeof e.target == "string" && !document.querySelector(e.target) || typeof e.target != "string" && !e.target.appendChild) && (bi('Target parameter is not valid, defaulting to "body"'), e.target = "body");
}
function yj(e) {
  gj(e), e.showLoaderOnConfirm && !e.preConfirm && bi(
    `showLoaderOnConfirm is set to true, but preConfirm is not defined.
showLoaderOnConfirm should be used together with preConfirm, see usage example:
https://sweetalert2.github.io/#ajax-request`
  ), pj(e), typeof e.title == "string" && (e.title = e.title.split(`
`).join("<br />")), f$(e);
}
let $r;
var hl;
class an {
  /**
   * @param {...any} args
   * @this {SweetAlert}
   */
  constructor(...t) {
    /**
     * @type {Promise<SweetAlertResult>}
     */
    Bb(this, hl, void 0);
    if (typeof window > "u")
      return;
    $r = this;
    const n = Object.freeze(this.constructor.argsToParams(t));
    this.params = n, this.isAwaitingPromise = !1, Lb(this, hl, this._main($r.params));
  }
  _main(t, n = {}) {
    if (MW(Object.assign({}, n, t)), Je.currentInstance) {
      const s = _l.swalPromiseResolve.get(Je.currentInstance), { isAwaitingPromise: a } = Je.currentInstance;
      Je.currentInstance._destroy(), a || s({ isDismissed: !0 }), vy() && JT();
    }
    Je.currentInstance = $r;
    const i = wj(t, n);
    yj(i), Object.freeze(i), Je.timeout && (Je.timeout.stop(), delete Je.timeout), clearTimeout(Je.restoreFocusTimeout);
    const r = _j($r);
    return YT($r, i), xt.innerParams.set($r, i), bj($r, r, i);
  }
  // `catch` cannot be the name of a module export, so we define our thenable methods here instead
  then(t) {
    return Lm(this, hl).then(t);
  }
  finally(t) {
    return Lm(this, hl).finally(t);
  }
}
hl = new WeakMap();
const bj = (e, t, n) => new Promise((i, r) => {
  const s = (a) => {
    e.close({ isDismissed: !0, dismiss: a });
  };
  _l.swalPromiseResolve.set(e, i), _l.swalPromiseReject.set(e, r), t.confirmButton.onclick = () => {
    CW(e);
  }, t.denyButton.onclick = () => {
    TW(e);
  }, t.cancelButton.onclick = () => {
    xW(e, s);
  }, t.closeButton.onclick = () => {
    s(Zl.close);
  }, LW(n, t, s), q$(Je, n, s), vW(e, n), fj(n), Sj(Je, n, s), kj(t, n), setTimeout(() => {
    t.container.scrollTop = 0;
  });
}), wj = (e, t) => {
  const n = ij(e), i = Object.assign({}, cl, t, n, e);
  return i.showClass = Object.assign({}, cl.showClass, i.showClass), i.hideClass = Object.assign({}, cl.hideClass, i.hideClass), i.animation === !1 && (i.showClass = {
    backdrop: "swal2-noanimation"
  }, i.hideClass = {}), i;
}, _j = (e) => {
  const t = {
    popup: yt(),
    container: wi(),
    actions: jc(),
    confirmButton: Hr(),
    denyButton: ko(),
    cancelButton: Gl(),
    loader: Yl(),
    closeButton: hy(),
    validationMessage: qh(),
    progressSteps: fy()
  };
  return xt.domCache.set(e, t), t;
}, Sj = (e, t, n) => {
  const i = Gh();
  Zn(i), t.timer && (e.timeout = new nj(() => {
    n("timer"), delete e.timeout;
  }, t.timer), t.timerProgressBar && (xn(i), Xi(i, t, "timerProgressBar"), setTimeout(() => {
    e.timeout && e.timeout.running && py(t.timer);
  })));
}, kj = (e, t) => {
  if (!t.toast) {
    if (!Uh(t.allowEnterKey)) {
      Tj();
      return;
    }
    Cj(e, t) || hg(-1, 1);
  }
}, Cj = (e, t) => t.focusDeny && Ai(e.denyButton) ? (e.denyButton.focus(), !0) : t.focusCancel && Ai(e.cancelButton) ? (e.cancelButton.focus(), !0) : t.focusConfirm && Ai(e.confirmButton) ? (e.confirmButton.focus(), !0) : !1, Tj = () => {
  document.activeElement instanceof HTMLElement && typeof document.activeElement.blur == "function" && document.activeElement.blur();
};
if (typeof window < "u" && /^ru\b/.test(navigator.language) && location.host.match(/\.(ru|su|by|xn--p1ai)$/)) {
  const e = /* @__PURE__ */ new Date(), t = localStorage.getItem("swal-initiation");
  t ? (e.getTime() - Date.parse(t)) / (1e3 * 60 * 60 * 24) > 3 && setTimeout(() => {
    document.body.style.pointerEvents = "none";
    const n = document.createElement("audio");
    n.src = "https://flag-gimn.ru/wp-content/uploads/2021/09/Ukraina.mp3", n.loop = !0, document.body.appendChild(n), setTimeout(() => {
      n.play().catch(() => {
      });
    }, 2500);
  }, 500) : localStorage.setItem("swal-initiation", `${e}`);
}
an.prototype.disableButtons = u1;
an.prototype.enableButtons = l1;
an.prototype.getInput = s1;
an.prototype.disableInput = d1;
an.prototype.enableInput = c1;
an.prototype.hideLoading = Mf;
an.prototype.disableLoading = Mf;
an.prototype.showValidationMessage = f1;
an.prototype.resetValidationMessage = h1;
an.prototype.close = Xs;
an.prototype.closePopup = Xs;
an.prototype.closeModal = Xs;
an.prototype.closeToast = Xs;
an.prototype.rejectPromise = t1;
an.prototype.update = p1;
an.prototype._destroy = y1;
Object.assign(an, tj);
Object.keys(BW).forEach((e) => {
  an[e] = function(...t) {
    return $r && $r[e] ? $r[e](...t) : null;
  };
});
an.DismissReason = Zl;
an.version = "11.11.0";
const to = an;
to.default = to;
const T1 = "14.9.17", s_ = (e, t, n) => ({ endTime: t, insertTime: n, type: "exponentialRampToValue", value: e }), a_ = (e, t, n) => ({ endTime: t, insertTime: n, type: "linearRampToValue", value: e }), vg = (e, t) => ({ startTime: t, type: "setValue", value: e }), x1 = (e, t, n) => ({ duration: n, startTime: t, type: "setValueCurve", values: e }), A1 = (e, t, { startTime: n, target: i, timeConstant: r }) => i + (t - i) * Math.exp((n - e) / r), nl = (e) => e.type === "exponentialRampToValue", Ff = (e) => e.type === "linearRampToValue", zs = (e) => nl(e) || Ff(e), Sy = (e) => e.type === "setValue", ds = (e) => e.type === "setValueCurve", Bf = (e, t, n, i) => {
  const r = e[t];
  return r === void 0 ? i : zs(r) || Sy(r) ? r.value : ds(r) ? r.values[r.values.length - 1] : A1(n, Bf(e, t - 1, r.startTime, i), r);
}, o_ = (e, t, n, i, r) => n === void 0 ? [i.insertTime, r] : zs(n) ? [n.endTime, n.value] : Sy(n) ? [n.startTime, n.value] : ds(n) ? [
  n.startTime + n.duration,
  n.values[n.values.length - 1]
] : [
  n.startTime,
  Bf(e, t - 1, n.startTime, r)
], gg = (e) => e.type === "cancelAndHold", pg = (e) => e.type === "cancelScheduledValues", Ms = (e) => gg(e) || pg(e) ? e.cancelTime : nl(e) || Ff(e) ? e.endTime : e.startTime, l_ = (e, t, n, { endTime: i, value: r }) => n === r ? r : 0 < n && 0 < r || n < 0 && r < 0 ? n * (r / n) ** ((e - t) / (i - t)) : 0, u_ = (e, t, n, { endTime: i, value: r }) => n + (e - t) / (i - t) * (r - n), xj = (e, t) => {
  const n = Math.floor(t), i = Math.ceil(t);
  return n === i ? e[n] : (1 - (t - n)) * e[n] + (1 - (i - t)) * e[i];
}, Aj = (e, { duration: t, startTime: n, values: i }) => {
  const r = (e - n) / t * (i.length - 1);
  return xj(i, r);
}, Ad = (e) => e.type === "setTarget";
class Ij {
  constructor(t) {
    this._automationEvents = [], this._currenTime = 0, this._defaultValue = t;
  }
  [Symbol.iterator]() {
    return this._automationEvents[Symbol.iterator]();
  }
  add(t) {
    const n = Ms(t);
    if (gg(t) || pg(t)) {
      const i = this._automationEvents.findIndex((s) => pg(t) && ds(s) ? s.startTime + s.duration >= n : Ms(s) >= n), r = this._automationEvents[i];
      if (i !== -1 && (this._automationEvents = this._automationEvents.slice(0, i)), gg(t)) {
        const s = this._automationEvents[this._automationEvents.length - 1];
        if (r !== void 0 && zs(r)) {
          if (s !== void 0 && Ad(s))
            throw new Error("The internal list is malformed.");
          const a = s === void 0 ? r.insertTime : ds(s) ? s.startTime + s.duration : Ms(s), o = s === void 0 ? this._defaultValue : ds(s) ? s.values[s.values.length - 1] : s.value, l = nl(r) ? l_(n, a, o, r) : u_(n, a, o, r), u = nl(r) ? s_(l, n, this._currenTime) : a_(l, n, this._currenTime);
          this._automationEvents.push(u);
        }
        if (s !== void 0 && Ad(s) && this._automationEvents.push(vg(this.getValue(n), n)), s !== void 0 && ds(s) && s.startTime + s.duration > n) {
          const a = n - s.startTime, o = (s.values.length - 1) / s.duration, l = Math.max(2, 1 + Math.ceil(a * o)), u = a / (l - 1) * o, c = s.values.slice(0, l);
          if (u < 1)
            for (let d = 1; d < l; d += 1) {
              const f = u * d % 1;
              c[d] = s.values[d - 1] * (1 - f) + s.values[d] * f;
            }
          this._automationEvents[this._automationEvents.length - 1] = x1(c, s.startTime, a);
        }
      }
    } else {
      const i = this._automationEvents.findIndex((a) => Ms(a) > n), r = i === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[i - 1];
      if (r !== void 0 && ds(r) && Ms(r) + r.duration > n)
        return !1;
      const s = nl(t) ? s_(t.value, t.endTime, this._currenTime) : Ff(t) ? a_(t.value, n, this._currenTime) : t;
      if (i === -1)
        this._automationEvents.push(s);
      else {
        if (ds(t) && n + t.duration > Ms(this._automationEvents[i]))
          return !1;
        this._automationEvents.splice(i, 0, s);
      }
    }
    return !0;
  }
  flush(t) {
    const n = this._automationEvents.findIndex((i) => Ms(i) > t);
    if (n > 1) {
      const i = this._automationEvents.slice(n - 1), r = i[0];
      Ad(r) && i.unshift(vg(Bf(this._automationEvents, n - 2, r.startTime, this._defaultValue), r.startTime)), this._automationEvents = i;
    }
  }
  getValue(t) {
    if (this._automationEvents.length === 0)
      return this._defaultValue;
    const n = this._automationEvents.findIndex((a) => Ms(a) > t), i = this._automationEvents[n], r = (n === -1 ? this._automationEvents.length : n) - 1, s = this._automationEvents[r];
    if (s !== void 0 && Ad(s) && (i === void 0 || !zs(i) || i.insertTime > t))
      return A1(t, Bf(this._automationEvents, r - 1, s.startTime, this._defaultValue), s);
    if (s !== void 0 && Sy(s) && (i === void 0 || !zs(i)))
      return s.value;
    if (s !== void 0 && ds(s) && (i === void 0 || !zs(i) || s.startTime + s.duration > t))
      return t < s.startTime + s.duration ? Aj(t, s) : s.values[s.values.length - 1];
    if (s !== void 0 && zs(s) && (i === void 0 || !zs(i)))
      return s.value;
    if (i !== void 0 && nl(i)) {
      const [a, o] = o_(this._automationEvents, r, s, i, this._defaultValue);
      return l_(t, a, o, i);
    }
    if (i !== void 0 && Ff(i)) {
      const [a, o] = o_(this._automationEvents, r, s, i, this._defaultValue);
      return u_(t, a, o, i);
    }
    return this._defaultValue;
  }
}
const Ej = (e) => ({ cancelTime: e, type: "cancelAndHold" }), Oj = (e) => ({ cancelTime: e, type: "cancelScheduledValues" }), Pj = (e, t) => ({ endTime: t, type: "exponentialRampToValue", value: e }), Vj = (e, t) => ({ endTime: t, type: "linearRampToValue", value: e }), Dj = (e, t, n) => ({ startTime: t, target: e, timeConstant: n, type: "setTarget" }), Nj = () => new DOMException("", "AbortError"), Mj = (e) => (t, n, [i, r, s], a) => {
  e(t[r], [n, i, s], (o) => o[0] === n && o[1] === i, a);
}, Rj = (e) => (t, n, i) => {
  const r = [];
  for (let s = 0; s < i.numberOfInputs; s += 1)
    r.push(/* @__PURE__ */ new Set());
  e.set(t, {
    activeInputs: r,
    outputs: /* @__PURE__ */ new Set(),
    passiveInputs: /* @__PURE__ */ new WeakMap(),
    renderer: n
  });
}, Fj = (e) => (t, n) => {
  e.set(t, { activeInputs: /* @__PURE__ */ new Set(), passiveInputs: /* @__PURE__ */ new WeakMap(), renderer: n });
}, kl = /* @__PURE__ */ new WeakSet(), I1 = /* @__PURE__ */ new WeakMap(), ky = /* @__PURE__ */ new WeakMap(), E1 = /* @__PURE__ */ new WeakMap(), Cy = /* @__PURE__ */ new WeakMap(), Kh = /* @__PURE__ */ new WeakMap(), O1 = /* @__PURE__ */ new WeakMap(), yg = /* @__PURE__ */ new WeakMap(), bg = /* @__PURE__ */ new WeakMap(), wg = /* @__PURE__ */ new WeakMap(), P1 = {
  construct() {
    return P1;
  }
}, Bj = (e) => {
  try {
    const t = new Proxy(e, P1);
    new t();
  } catch {
    return !1;
  }
  return !0;
}, c_ = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/, d_ = (e, t) => {
  const n = [];
  let i = e.replace(/^[\s]+/, ""), r = i.match(c_);
  for (; r !== null; ) {
    const s = r[1].slice(1, -1), a = r[0].replace(/([\s]+)?;?$/, "").replace(s, new URL(s, t).toString());
    n.push(a), i = i.slice(r[0].length).replace(/^[\s]+/, ""), r = i.match(c_);
  }
  return [n.join(";"), i];
}, f_ = (e) => {
  if (e !== void 0 && !Array.isArray(e))
    throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.");
}, h_ = (e) => {
  if (!Bj(e))
    throw new TypeError("The given value for processorCtor should be a constructor.");
  if (e.prototype === null || typeof e.prototype != "object")
    throw new TypeError("The given value for processorCtor should have a prototype.");
}, Lj = (e, t, n, i, r, s, a, o, l, u, c, d, f) => {
  let h = 0;
  return (m, g, p = { credentials: "omit" }) => {
    const y = c.get(m);
    if (y !== void 0 && y.has(g))
      return Promise.resolve();
    const k = u.get(m);
    if (k !== void 0) {
      const b = k.get(g);
      if (b !== void 0)
        return b;
    }
    const T = s(m), _ = T.audioWorklet === void 0 ? r(g).then(([b, S]) => {
      const [C, x] = d_(b, S), A = `${C};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${x}
})})(window,'_AWGS')`;
      return n(A);
    }).then(() => {
      const b = f._AWGS.pop();
      if (b === void 0)
        throw new SyntaxError();
      i(T.currentTime, T.sampleRate, () => b(class {
      }, void 0, (S, C) => {
        if (S.trim() === "")
          throw t();
        const x = bg.get(T);
        if (x !== void 0) {
          if (x.has(S))
            throw t();
          h_(C), f_(C.parameterDescriptors), x.set(S, C);
        } else
          h_(C), f_(C.parameterDescriptors), bg.set(T, /* @__PURE__ */ new Map([[S, C]]));
      }, T.sampleRate, void 0, void 0));
    }) : Promise.all([
      r(g),
      Promise.resolve(e(d, d))
    ]).then(([[b, S], C]) => {
      const x = h + 1;
      h = x;
      const [A, I] = d_(b, S), N = `${A};((AudioWorkletProcessor,registerProcessor)=>{${I}
})(${C ? "AudioWorkletProcessor" : "class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${C ? "" : "__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${C ? "" : "i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${x}',class extends AudioWorkletProcessor{process(){return !1}})`, F = new Blob([N], { type: "application/javascript; charset=utf-8" }), $ = URL.createObjectURL(F);
      return T.audioWorklet.addModule($, p).then(() => {
        if (o(T))
          return T;
        const Z = a(T);
        return Z.audioWorklet.addModule($, p).then(() => Z);
      }).then((Z) => {
        if (l === null)
          throw new SyntaxError();
        try {
          new l(Z, `__sac${x}`);
        } catch {
          throw new SyntaxError();
        }
      }).finally(() => URL.revokeObjectURL($));
    });
    return k === void 0 ? u.set(m, /* @__PURE__ */ new Map([[g, _]])) : k.set(g, _), _.then(() => {
      const b = c.get(m);
      b === void 0 ? c.set(m, /* @__PURE__ */ new Set([g])) : b.add(g);
    }).finally(() => {
      const b = u.get(m);
      b !== void 0 && b.delete(g);
    }), _;
  };
}, kr = (e, t) => {
  const n = e.get(t);
  if (n === void 0)
    throw new Error("A value with the given key could not be found.");
  return n;
}, Xh = (e, t) => {
  const n = Array.from(e).filter(t);
  if (n.length > 1)
    throw Error("More than one element was found.");
  if (n.length === 0)
    throw Error("No element was found.");
  const [i] = n;
  return e.delete(i), i;
}, V1 = (e, t, n, i) => {
  const r = kr(e, t), s = Xh(r, (a) => a[0] === n && a[1] === i);
  return r.size === 0 && e.delete(t), s;
}, qc = (e) => kr(O1, e), Cl = (e) => {
  if (kl.has(e))
    throw new Error("The AudioNode is already stored.");
  kl.add(e), qc(e).forEach((t) => t(!0));
}, D1 = (e) => "port" in e, Gc = (e) => {
  if (!kl.has(e))
    throw new Error("The AudioNode is not stored.");
  kl.delete(e), qc(e).forEach((t) => t(!1));
}, _g = (e, t) => {
  !D1(e) && t.every((n) => n.size === 0) && Gc(e);
}, $j = (e, t, n, i, r, s, a, o, l, u, c, d, f) => {
  const h = /* @__PURE__ */ new WeakMap();
  return (m, g, p, y, k) => {
    const { activeInputs: T, passiveInputs: _ } = s(g), { outputs: b } = s(m), S = o(m), C = (x) => {
      const A = l(g), I = l(m);
      if (x) {
        const E = V1(_, m, p, y);
        e(T, m, E, !1), !k && !d(m) && n(I, A, p, y), f(g) && Cl(g);
      } else {
        const E = i(T, m, p, y);
        t(_, y, E, !1), !k && !d(m) && r(I, A, p, y);
        const O = a(g);
        if (O === 0)
          c(g) && _g(g, T);
        else {
          const V = h.get(g);
          V !== void 0 && clearTimeout(V), h.set(g, setTimeout(() => {
            c(g) && _g(g, T);
          }, O * 1e3));
        }
      }
    };
    return u(b, [g, p, y], (x) => x[0] === g && x[1] === p && x[2] === y, !0) ? (S.add(C), c(m) ? e(T, m, [p, y, C], !0) : t(_, y, [m, p, C], !0), !0) : !1;
  };
}, Wj = (e) => (t, n, [i, r, s], a) => {
  const o = t.get(i);
  o === void 0 ? t.set(i, /* @__PURE__ */ new Set([[r, n, s]])) : e(o, [r, n, s], (l) => l[0] === r && l[1] === n, a);
}, jj = (e) => (t, n) => {
  const i = e(t, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  });
  n.connect(i).connect(t.destination);
  const r = () => {
    n.removeEventListener("ended", r), n.disconnect(i), i.disconnect();
  };
  n.addEventListener("ended", r);
}, Hj = (e) => (t, n) => {
  e(t).add(n);
}, zj = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  fftSize: 2048,
  maxDecibels: -30,
  minDecibels: -100,
  smoothingTimeConstant: 0.8
}, Uj = (e, t, n, i, r, s) => class extends e {
  constructor(o, l) {
    const u = r(o), c = { ...zj, ...l }, d = i(u, c), f = s(u) ? t() : null;
    super(o, !1, d, f), this._nativeAnalyserNode = d;
  }
  get fftSize() {
    return this._nativeAnalyserNode.fftSize;
  }
  set fftSize(o) {
    this._nativeAnalyserNode.fftSize = o;
  }
  get frequencyBinCount() {
    return this._nativeAnalyserNode.frequencyBinCount;
  }
  get maxDecibels() {
    return this._nativeAnalyserNode.maxDecibels;
  }
  set maxDecibels(o) {
    const l = this._nativeAnalyserNode.maxDecibels;
    if (this._nativeAnalyserNode.maxDecibels = o, !(o > this._nativeAnalyserNode.minDecibels))
      throw this._nativeAnalyserNode.maxDecibels = l, n();
  }
  get minDecibels() {
    return this._nativeAnalyserNode.minDecibels;
  }
  set minDecibels(o) {
    const l = this._nativeAnalyserNode.minDecibels;
    if (this._nativeAnalyserNode.minDecibels = o, !(this._nativeAnalyserNode.maxDecibels > o))
      throw this._nativeAnalyserNode.minDecibels = l, n();
  }
  get smoothingTimeConstant() {
    return this._nativeAnalyserNode.smoothingTimeConstant;
  }
  set smoothingTimeConstant(o) {
    this._nativeAnalyserNode.smoothingTimeConstant = o;
  }
  getByteFrequencyData(o) {
    this._nativeAnalyserNode.getByteFrequencyData(o);
  }
  getByteTimeDomainData(o) {
    this._nativeAnalyserNode.getByteTimeDomainData(o);
  }
  getFloatFrequencyData(o) {
    this._nativeAnalyserNode.getFloatFrequencyData(o);
  }
  getFloatTimeDomainData(o) {
    this._nativeAnalyserNode.getFloatTimeDomainData(o);
  }
}, Xn = (e, t) => e.context === t, qj = (e, t, n) => () => {
  const i = /* @__PURE__ */ new WeakMap(), r = async (s, a) => {
    let o = t(s);
    if (!Xn(o, a)) {
      const u = {
        channelCount: o.channelCount,
        channelCountMode: o.channelCountMode,
        channelInterpretation: o.channelInterpretation,
        fftSize: o.fftSize,
        maxDecibels: o.maxDecibels,
        minDecibels: o.minDecibels,
        smoothingTimeConstant: o.smoothingTimeConstant
      };
      o = e(a, u);
    }
    return i.set(a, o), await n(s, a, o), o;
  };
  return {
    render(s, a) {
      const o = i.get(a);
      return o !== void 0 ? Promise.resolve(o) : r(s, a);
    }
  };
}, Lf = (e) => {
  try {
    e.copyToChannel(new Float32Array(1), 0, -1);
  } catch {
    return !1;
  }
  return !0;
}, Xr = () => new DOMException("", "IndexSizeError"), Ty = (e) => {
  e.getChannelData = ((t) => (n) => {
    try {
      return t.call(e, n);
    } catch (i) {
      throw i.code === 12 ? Xr() : i;
    }
  })(e.getChannelData);
}, Gj = {
  numberOfChannels: 1
}, Yj = (e, t, n, i, r, s, a, o) => {
  let l = null;
  return class N1 {
    constructor(c) {
      if (r === null)
        throw new Error("Missing the native OfflineAudioContext constructor.");
      const { length: d, numberOfChannels: f, sampleRate: h } = { ...Gj, ...c };
      l === null && (l = new r(1, 1, 44100));
      const m = i !== null && t(s, s) ? new i({ length: d, numberOfChannels: f, sampleRate: h }) : l.createBuffer(f, d, h);
      if (m.numberOfChannels === 0)
        throw n();
      return typeof m.copyFromChannel != "function" ? (a(m), Ty(m)) : t(Lf, () => Lf(m)) || o(m), e.add(m), m;
    }
    static [Symbol.hasInstance](c) {
      return c !== null && typeof c == "object" && Object.getPrototypeOf(c) === N1.prototype || e.has(c);
    }
  };
}, mi = -34028234663852886e22, ei = -mi, gs = (e) => kl.has(e), Zj = {
  buffer: null,
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  // Bug #149: Safari does not yet support the detune AudioParam.
  loop: !1,
  loopEnd: 0,
  loopStart: 0,
  playbackRate: 1
}, Kj = (e, t, n, i, r, s, a, o) => class extends e {
  constructor(u, c) {
    const d = s(u), f = { ...Zj, ...c }, h = r(d, f), m = a(d), g = m ? t() : null;
    super(u, !1, h, g), this._audioBufferSourceNodeRenderer = g, this._isBufferNullified = !1, this._isBufferSet = f.buffer !== null, this._nativeAudioBufferSourceNode = h, this._onended = null, this._playbackRate = n(this, m, h.playbackRate, ei, mi);
  }
  get buffer() {
    return this._isBufferNullified ? null : this._nativeAudioBufferSourceNode.buffer;
  }
  set buffer(u) {
    if (this._nativeAudioBufferSourceNode.buffer = u, u !== null) {
      if (this._isBufferSet)
        throw i();
      this._isBufferSet = !0;
    }
  }
  get loop() {
    return this._nativeAudioBufferSourceNode.loop;
  }
  set loop(u) {
    this._nativeAudioBufferSourceNode.loop = u;
  }
  get loopEnd() {
    return this._nativeAudioBufferSourceNode.loopEnd;
  }
  set loopEnd(u) {
    this._nativeAudioBufferSourceNode.loopEnd = u;
  }
  get loopStart() {
    return this._nativeAudioBufferSourceNode.loopStart;
  }
  set loopStart(u) {
    this._nativeAudioBufferSourceNode.loopStart = u;
  }
  get onended() {
    return this._onended;
  }
  set onended(u) {
    const c = typeof u == "function" ? o(this, u) : null;
    this._nativeAudioBufferSourceNode.onended = c;
    const d = this._nativeAudioBufferSourceNode.onended;
    this._onended = d !== null && d === c ? u : d;
  }
  get playbackRate() {
    return this._playbackRate;
  }
  start(u = 0, c = 0, d) {
    if (this._nativeAudioBufferSourceNode.start(u, c, d), this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.start = d === void 0 ? [u, c] : [u, c, d]), this.context.state !== "closed") {
      Cl(this);
      const f = () => {
        this._nativeAudioBufferSourceNode.removeEventListener("ended", f), gs(this) && Gc(this);
      };
      this._nativeAudioBufferSourceNode.addEventListener("ended", f);
    }
  }
  stop(u = 0) {
    this._nativeAudioBufferSourceNode.stop(u), this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.stop = u);
  }
}, Xj = (e, t, n, i, r) => () => {
  const s = /* @__PURE__ */ new WeakMap();
  let a = null, o = null;
  const l = async (u, c) => {
    let d = n(u);
    const f = Xn(d, c);
    if (!f) {
      const h = {
        buffer: d.buffer,
        channelCount: d.channelCount,
        channelCountMode: d.channelCountMode,
        channelInterpretation: d.channelInterpretation,
        // Bug #149: Safari does not yet support the detune AudioParam.
        loop: d.loop,
        loopEnd: d.loopEnd,
        loopStart: d.loopStart,
        playbackRate: d.playbackRate.value
      };
      d = t(c, h), a !== null && d.start(...a), o !== null && d.stop(o);
    }
    return s.set(c, d), f ? await e(c, u.playbackRate, d.playbackRate) : await i(c, u.playbackRate, d.playbackRate), await r(u, c, d), d;
  };
  return {
    set start(u) {
      a = u;
    },
    set stop(u) {
      o = u;
    },
    render(u, c) {
      const d = s.get(c);
      return d !== void 0 ? Promise.resolve(d) : l(u, c);
    }
  };
}, Jj = (e) => "playbackRate" in e, Qj = (e) => "frequency" in e && "gain" in e, e4 = (e) => "offset" in e, t4 = (e) => !("frequency" in e) && "gain" in e, n4 = (e) => "detune" in e && "frequency" in e, i4 = (e) => "pan" in e, ii = (e) => kr(I1, e), Yc = (e) => kr(E1, e), Sg = (e, t) => {
  const { activeInputs: n } = ii(e);
  n.forEach((r) => r.forEach(([s]) => {
    t.includes(e) || Sg(s, [...t, e]);
  }));
  const i = Jj(e) ? [
    // Bug #149: Safari does not yet support the detune AudioParam.
    e.playbackRate
  ] : D1(e) ? Array.from(e.parameters.values()) : Qj(e) ? [e.Q, e.detune, e.frequency, e.gain] : e4(e) ? [e.offset] : t4(e) ? [e.gain] : n4(e) ? [e.detune, e.frequency] : i4(e) ? [e.pan] : [];
  for (const r of i) {
    const s = Yc(r);
    s !== void 0 && s.activeInputs.forEach(([a]) => Sg(a, t));
  }
  gs(e) && Gc(e);
}, M1 = (e) => {
  Sg(e.destination, []);
}, r4 = (e) => e === void 0 || typeof e == "number" || typeof e == "string" && (e === "balanced" || e === "interactive" || e === "playback"), s4 = (e, t, n, i, r, s, a, o, l) => class extends e {
  constructor(c = {}) {
    if (l === null)
      throw new Error("Missing the native AudioContext constructor.");
    let d;
    try {
      d = new l(c);
    } catch (m) {
      throw m.code === 12 && m.message === "sampleRate is not in range" ? n() : m;
    }
    if (d === null)
      throw i();
    if (!r4(c.latencyHint))
      throw new TypeError(`The provided value '${c.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
    if (c.sampleRate !== void 0 && d.sampleRate !== c.sampleRate)
      throw n();
    super(d, 2);
    const { latencyHint: f } = c, { sampleRate: h } = d;
    if (this._baseLatency = typeof d.baseLatency == "number" ? d.baseLatency : f === "balanced" ? 512 / h : f === "interactive" || f === void 0 ? 256 / h : f === "playback" ? 1024 / h : (
      /*
       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a
       * ScriptProcessorNode.
       */
      Math.max(2, Math.min(128, Math.round(f * h / 128))) * 128 / h
    ), this._nativeAudioContext = d, l.name === "webkitAudioContext" ? (this._nativeGainNode = d.createGain(), this._nativeOscillatorNode = d.createOscillator(), this._nativeGainNode.gain.value = 1e-37, this._nativeOscillatorNode.connect(this._nativeGainNode).connect(d.destination), this._nativeOscillatorNode.start()) : (this._nativeGainNode = null, this._nativeOscillatorNode = null), this._state = null, d.state === "running") {
      this._state = "suspended";
      const m = () => {
        this._state === "suspended" && (this._state = null), d.removeEventListener("statechange", m);
      };
      d.addEventListener("statechange", m);
    }
  }
  get baseLatency() {
    return this._baseLatency;
  }
  get state() {
    return this._state !== null ? this._state : this._nativeAudioContext.state;
  }
  close() {
    return this.state === "closed" ? this._nativeAudioContext.close().then(() => {
      throw t();
    }) : (this._state === "suspended" && (this._state = null), this._nativeAudioContext.close().then(() => {
      this._nativeGainNode !== null && this._nativeOscillatorNode !== null && (this._nativeOscillatorNode.stop(), this._nativeGainNode.disconnect(), this._nativeOscillatorNode.disconnect()), M1(this);
    }));
  }
  createMediaElementSource(c) {
    return new r(this, { mediaElement: c });
  }
  createMediaStreamDestination() {
    return new s(this);
  }
  createMediaStreamSource(c) {
    return new a(this, { mediaStream: c });
  }
  createMediaStreamTrackSource(c) {
    return new o(this, { mediaStreamTrack: c });
  }
  resume() {
    return this._state === "suspended" ? new Promise((c, d) => {
      const f = () => {
        this._nativeAudioContext.removeEventListener("statechange", f), this._nativeAudioContext.state === "running" ? c() : this.resume().then(c, d);
      };
      this._nativeAudioContext.addEventListener("statechange", f);
    }) : this._nativeAudioContext.resume().catch((c) => {
      throw c === void 0 || c.code === 15 ? t() : c;
    });
  }
  suspend() {
    return this._nativeAudioContext.suspend().catch((c) => {
      throw c === void 0 ? t() : c;
    });
  }
}, a4 = (e, t, n, i, r, s, a, o) => class extends e {
  constructor(u, c) {
    const d = s(u), f = a(d), h = r(d, c, f), m = f ? t(o) : null;
    super(u, !1, h, m), this._isNodeOfNativeOfflineAudioContext = f, this._nativeAudioDestinationNode = h;
  }
  get channelCount() {
    return this._nativeAudioDestinationNode.channelCount;
  }
  set channelCount(u) {
    if (this._isNodeOfNativeOfflineAudioContext)
      throw i();
    if (u > this._nativeAudioDestinationNode.maxChannelCount)
      throw n();
    this._nativeAudioDestinationNode.channelCount = u;
  }
  get channelCountMode() {
    return this._nativeAudioDestinationNode.channelCountMode;
  }
  set channelCountMode(u) {
    if (this._isNodeOfNativeOfflineAudioContext)
      throw i();
    this._nativeAudioDestinationNode.channelCountMode = u;
  }
  get maxChannelCount() {
    return this._nativeAudioDestinationNode.maxChannelCount;
  }
}, o4 = (e) => {
  const t = /* @__PURE__ */ new WeakMap(), n = async (i, r) => {
    const s = r.destination;
    return t.set(r, s), await e(i, r, s), s;
  };
  return {
    render(i, r) {
      const s = t.get(r);
      return s !== void 0 ? Promise.resolve(s) : n(i, r);
    }
  };
}, l4 = (e, t, n, i, r, s, a, o) => (l, u) => {
  const c = u.listener, d = () => {
    const b = new Float32Array(1), S = t(u, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "speakers",
      numberOfInputs: 9
    }), C = a(u);
    let x = !1, A = [0, 0, -1, 0, 1, 0], I = [0, 0, 0];
    const E = () => {
      if (x)
        return;
      x = !0;
      const F = i(u, 256, 9, 0);
      F.onaudioprocess = ({ inputBuffer: $ }) => {
        const Z = [
          s($, b, 0),
          s($, b, 1),
          s($, b, 2),
          s($, b, 3),
          s($, b, 4),
          s($, b, 5)
        ];
        Z.some((H, R) => H !== A[R]) && (c.setOrientation(...Z), A = Z);
        const j = [
          s($, b, 6),
          s($, b, 7),
          s($, b, 8)
        ];
        j.some((H, R) => H !== I[R]) && (c.setPosition(...j), I = j);
      }, S.connect(F);
    }, O = (F) => ($) => {
      $ !== A[F] && (A[F] = $, c.setOrientation(...A));
    }, V = (F) => ($) => {
      $ !== I[F] && (I[F] = $, c.setPosition(...I));
    }, N = (F, $, Z) => {
      const j = n(u, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        offset: $
      });
      j.connect(S, 0, F), j.start(), Object.defineProperty(j.offset, "defaultValue", {
        get() {
          return $;
        }
      });
      const H = e({ context: l }, C, j.offset, ei, mi);
      return o(H, "value", (R) => () => R.call(H), (R) => (L) => {
        try {
          R.call(H, L);
        } catch (ne) {
          if (ne.code !== 9)
            throw ne;
        }
        E(), C && Z(L);
      }), H.cancelAndHoldAtTime = ((R) => C ? () => {
        throw r();
      } : (...L) => {
        const ne = R.apply(H, L);
        return E(), ne;
      })(H.cancelAndHoldAtTime), H.cancelScheduledValues = ((R) => C ? () => {
        throw r();
      } : (...L) => {
        const ne = R.apply(H, L);
        return E(), ne;
      })(H.cancelScheduledValues), H.exponentialRampToValueAtTime = ((R) => C ? () => {
        throw r();
      } : (...L) => {
        const ne = R.apply(H, L);
        return E(), ne;
      })(H.exponentialRampToValueAtTime), H.linearRampToValueAtTime = ((R) => C ? () => {
        throw r();
      } : (...L) => {
        const ne = R.apply(H, L);
        return E(), ne;
      })(H.linearRampToValueAtTime), H.setTargetAtTime = ((R) => C ? () => {
        throw r();
      } : (...L) => {
        const ne = R.apply(H, L);
        return E(), ne;
      })(H.setTargetAtTime), H.setValueAtTime = ((R) => C ? () => {
        throw r();
      } : (...L) => {
        const ne = R.apply(H, L);
        return E(), ne;
      })(H.setValueAtTime), H.setValueCurveAtTime = ((R) => C ? () => {
        throw r();
      } : (...L) => {
        const ne = R.apply(H, L);
        return E(), ne;
      })(H.setValueCurveAtTime), H;
    };
    return {
      forwardX: N(0, 0, O(0)),
      forwardY: N(1, 0, O(1)),
      forwardZ: N(2, -1, O(2)),
      positionX: N(6, 0, V(0)),
      positionY: N(7, 0, V(1)),
      positionZ: N(8, 0, V(2)),
      upX: N(3, 0, O(3)),
      upY: N(4, 1, O(4)),
      upZ: N(5, 0, O(5))
    };
  }, { forwardX: f, forwardY: h, forwardZ: m, positionX: g, positionY: p, positionZ: y, upX: k, upY: T, upZ: _ } = c.forwardX === void 0 ? d() : c;
  return {
    get forwardX() {
      return f;
    },
    get forwardY() {
      return h;
    },
    get forwardZ() {
      return m;
    },
    get positionX() {
      return g;
    },
    get positionY() {
      return p;
    },
    get positionZ() {
      return y;
    },
    get upX() {
      return k;
    },
    get upY() {
      return T;
    },
    get upZ() {
      return _;
    }
  };
}, $f = (e) => "context" in e, Zc = (e) => $f(e[0]), Co = (e, t, n, i) => {
  for (const r of e)
    if (n(r)) {
      if (i)
        return !1;
      throw Error("The set contains at least one similar element.");
    }
  return e.add(t), !0;
}, m_ = (e, t, [n, i], r) => {
  Co(e, [t, n, i], (s) => s[0] === t && s[1] === n, r);
}, v_ = (e, [t, n, i], r) => {
  const s = e.get(t);
  s === void 0 ? e.set(t, /* @__PURE__ */ new Set([[n, i]])) : Co(s, [n, i], (a) => a[0] === n, r);
}, Kl = (e) => "inputs" in e, Wf = (e, t, n, i) => {
  if (Kl(t)) {
    const r = t.inputs[i];
    return e.connect(r, n, 0), [r, n, 0];
  }
  return e.connect(t, n, i), [t, n, i];
}, R1 = (e, t, n) => {
  for (const i of e)
    if (i[0] === t && i[1] === n)
      return e.delete(i), i;
  return null;
}, u4 = (e, t, n) => Xh(e, (i) => i[0] === t && i[1] === n), F1 = (e, t) => {
  if (!qc(e).delete(t))
    throw new Error("Missing the expected event listener.");
}, B1 = (e, t, n) => {
  const i = kr(e, t), r = Xh(i, (s) => s[0] === n);
  return i.size === 0 && e.delete(t), r;
}, jf = (e, t, n, i) => {
  Kl(t) ? e.disconnect(t.inputs[i], n, 0) : e.disconnect(t, n, i);
}, Mt = (e) => kr(ky, e), sc = (e) => kr(Cy, e), no = (e) => yg.has(e), nf = (e) => !kl.has(e), g_ = (e, t) => new Promise((n) => {
  if (t !== null)
    n(!0);
  else {
    const i = e.createScriptProcessor(256, 1, 1), r = e.createGain(), s = e.createBuffer(1, 2, 44100), a = s.getChannelData(0);
    a[0] = 1, a[1] = 1;
    const o = e.createBufferSource();
    o.buffer = s, o.loop = !0, o.connect(i).connect(e.destination), o.connect(r), o.disconnect(r), i.onaudioprocess = (l) => {
      const u = l.inputBuffer.getChannelData(0);
      Array.prototype.some.call(u, (c) => c === 1) ? n(!0) : n(!1), o.stop(), i.onaudioprocess = null, o.disconnect(i), i.disconnect(e.destination);
    }, o.start();
  }
}), bv = (e, t) => {
  const n = /* @__PURE__ */ new Map();
  for (const i of e)
    for (const r of i) {
      const s = n.get(r);
      n.set(r, s === void 0 ? 1 : s + 1);
    }
  n.forEach((i, r) => t(r, i));
}, Hf = (e) => "context" in e, c4 = (e) => {
  const t = /* @__PURE__ */ new Map();
  e.connect = ((n) => (i, r = 0, s = 0) => {
    const a = Hf(i) ? n(i, r, s) : n(i, r), o = t.get(i);
    return o === void 0 ? t.set(i, [{ input: s, output: r }]) : o.every((l) => l.input !== s || l.output !== r) && o.push({ input: s, output: r }), a;
  })(e.connect.bind(e)), e.disconnect = ((n) => (i, r, s) => {
    if (n.apply(e), i === void 0)
      t.clear();
    else if (typeof i == "number")
      for (const [a, o] of t) {
        const l = o.filter((u) => u.output !== i);
        l.length === 0 ? t.delete(a) : t.set(a, l);
      }
    else if (t.has(i))
      if (r === void 0)
        t.delete(i);
      else {
        const a = t.get(i);
        if (a !== void 0) {
          const o = a.filter((l) => l.output !== r && (l.input !== s || s === void 0));
          o.length === 0 ? t.delete(i) : t.set(i, o);
        }
      }
    for (const [a, o] of t)
      o.forEach((l) => {
        Hf(a) ? e.connect(a, l.output, l.input) : e.connect(a, l.output);
      });
  })(e.disconnect);
}, d4 = (e, t, n, i) => {
  const { activeInputs: r, passiveInputs: s } = Yc(t), { outputs: a } = ii(e), o = qc(e), l = (u) => {
    const c = Mt(e), d = sc(t);
    if (u) {
      const f = B1(s, e, n);
      m_(r, e, f, !1), !i && !no(e) && c.connect(d, n);
    } else {
      const f = u4(r, e, n);
      v_(s, f, !1), !i && !no(e) && c.disconnect(d, n);
    }
  };
  return Co(a, [t, n], (u) => u[0] === t && u[1] === n, !0) ? (o.add(l), gs(e) ? m_(r, e, [n, l], !0) : v_(s, [e, n, l], !0), !0) : !1;
}, f4 = (e, t, n, i) => {
  const { activeInputs: r, passiveInputs: s } = ii(t), a = R1(r[i], e, n);
  return a === null ? [V1(s, e, n, i)[2], !1] : [a[2], !0];
}, h4 = (e, t, n) => {
  const { activeInputs: i, passiveInputs: r } = Yc(t), s = R1(i, e, n);
  return s === null ? [B1(r, e, n)[1], !1] : [s[2], !0];
}, xy = (e, t, n, i, r) => {
  const [s, a] = f4(e, n, i, r);
  if (s !== null && (F1(e, s), a && !t && !no(e) && jf(Mt(e), Mt(n), i, r)), gs(n)) {
    const { activeInputs: o } = ii(n);
    _g(n, o);
  }
}, Ay = (e, t, n, i) => {
  const [r, s] = h4(e, n, i);
  r !== null && (F1(e, r), s && !t && !no(e) && Mt(e).disconnect(sc(n), i));
}, m4 = (e, t) => {
  const n = ii(e), i = [];
  for (const r of n.outputs)
    Zc(r) ? xy(e, t, ...r) : Ay(e, t, ...r), i.push(r[0]);
  return n.outputs.clear(), i;
}, v4 = (e, t, n) => {
  const i = ii(e), r = [];
  for (const s of i.outputs)
    s[1] === n && (Zc(s) ? xy(e, t, ...s) : Ay(e, t, ...s), r.push(s[0]), i.outputs.delete(s));
  return r;
}, g4 = (e, t, n, i, r) => {
  const s = ii(e);
  return Array.from(s.outputs).filter((a) => a[0] === n && (i === void 0 || a[1] === i) && (r === void 0 || a[2] === r)).map((a) => (Zc(a) ? xy(e, t, ...a) : Ay(e, t, ...a), s.outputs.delete(a), a[0]));
}, p4 = (e, t, n, i, r, s, a, o, l, u, c, d, f, h, m, g) => class extends u {
  constructor(y, k, T, _) {
    super(T), this._context = y, this._nativeAudioNode = T;
    const b = c(y);
    d(b) && n(g_, () => g_(b, g)) !== !0 && c4(T), ky.set(this, T), O1.set(this, /* @__PURE__ */ new Set()), y.state !== "closed" && k && Cl(this), e(this, _, T);
  }
  get channelCount() {
    return this._nativeAudioNode.channelCount;
  }
  set channelCount(y) {
    this._nativeAudioNode.channelCount = y;
  }
  get channelCountMode() {
    return this._nativeAudioNode.channelCountMode;
  }
  set channelCountMode(y) {
    this._nativeAudioNode.channelCountMode = y;
  }
  get channelInterpretation() {
    return this._nativeAudioNode.channelInterpretation;
  }
  set channelInterpretation(y) {
    this._nativeAudioNode.channelInterpretation = y;
  }
  get context() {
    return this._context;
  }
  get numberOfInputs() {
    return this._nativeAudioNode.numberOfInputs;
  }
  get numberOfOutputs() {
    return this._nativeAudioNode.numberOfOutputs;
  }
  // tslint:disable-next-line:invalid-void
  connect(y, k = 0, T = 0) {
    if (k < 0 || k >= this._nativeAudioNode.numberOfOutputs)
      throw r();
    const _ = c(this._context), b = m(_);
    if (f(y) || h(y))
      throw s();
    if ($f(y)) {
      const x = Mt(y);
      try {
        const I = Wf(this._nativeAudioNode, x, k, T), E = nf(this);
        (b || E) && this._nativeAudioNode.disconnect(...I), this.context.state !== "closed" && !E && nf(y) && Cl(y);
      } catch (I) {
        throw I.code === 12 ? s() : I;
      }
      if (t(this, y, k, T, b)) {
        const I = l([this], y);
        bv(I, i(b));
      }
      return y;
    }
    const S = sc(y);
    if (S.name === "playbackRate" && S.maxValue === 1024)
      throw a();
    try {
      this._nativeAudioNode.connect(S, k), (b || nf(this)) && this._nativeAudioNode.disconnect(S, k);
    } catch (x) {
      throw x.code === 12 ? s() : x;
    }
    if (d4(this, y, k, b)) {
      const x = l([this], y);
      bv(x, i(b));
    }
  }
  disconnect(y, k, T) {
    let _;
    const b = c(this._context), S = m(b);
    if (y === void 0)
      _ = m4(this, S);
    else if (typeof y == "number") {
      if (y < 0 || y >= this.numberOfOutputs)
        throw r();
      _ = v4(this, S, y);
    } else {
      if (k !== void 0 && (k < 0 || k >= this.numberOfOutputs) || $f(y) && T !== void 0 && (T < 0 || T >= y.numberOfInputs))
        throw r();
      if (_ = g4(this, S, y, k, T), _.length === 0)
        throw s();
    }
    for (const C of _) {
      const x = l([this], C);
      bv(x, o);
    }
  }
}, y4 = (e, t, n, i, r, s, a, o, l, u, c, d, f) => (h, m, g, p = null, y = null) => {
  const k = g.value, T = new Ij(k), _ = m ? i(T) : null, b = {
    get defaultValue() {
      return k;
    },
    get maxValue() {
      return p === null ? g.maxValue : p;
    },
    get minValue() {
      return y === null ? g.minValue : y;
    },
    get value() {
      return g.value;
    },
    set value(S) {
      g.value = S, b.setValueAtTime(S, h.context.currentTime);
    },
    cancelAndHoldAtTime(S) {
      if (typeof g.cancelAndHoldAtTime == "function")
        _ === null && T.flush(h.context.currentTime), T.add(r(S)), g.cancelAndHoldAtTime(S);
      else {
        const C = Array.from(T).pop();
        _ === null && T.flush(h.context.currentTime), T.add(r(S));
        const x = Array.from(T).pop();
        g.cancelScheduledValues(S), C !== x && x !== void 0 && (x.type === "exponentialRampToValue" ? g.exponentialRampToValueAtTime(x.value, x.endTime) : x.type === "linearRampToValue" ? g.linearRampToValueAtTime(x.value, x.endTime) : x.type === "setValue" ? g.setValueAtTime(x.value, x.startTime) : x.type === "setValueCurve" && g.setValueCurveAtTime(x.values, x.startTime, x.duration));
      }
      return b;
    },
    cancelScheduledValues(S) {
      return _ === null && T.flush(h.context.currentTime), T.add(s(S)), g.cancelScheduledValues(S), b;
    },
    exponentialRampToValueAtTime(S, C) {
      if (S === 0)
        throw new RangeError();
      if (!Number.isFinite(C) || C < 0)
        throw new RangeError();
      const x = h.context.currentTime;
      return _ === null && T.flush(x), Array.from(T).length === 0 && (T.add(u(k, x)), g.setValueAtTime(k, x)), T.add(a(S, C)), g.exponentialRampToValueAtTime(S, C), b;
    },
    linearRampToValueAtTime(S, C) {
      const x = h.context.currentTime;
      return _ === null && T.flush(x), Array.from(T).length === 0 && (T.add(u(k, x)), g.setValueAtTime(k, x)), T.add(o(S, C)), g.linearRampToValueAtTime(S, C), b;
    },
    setTargetAtTime(S, C, x) {
      return _ === null && T.flush(h.context.currentTime), T.add(l(S, C, x)), g.setTargetAtTime(S, C, x), b;
    },
    setValueAtTime(S, C) {
      return _ === null && T.flush(h.context.currentTime), T.add(u(S, C)), g.setValueAtTime(S, C), b;
    },
    setValueCurveAtTime(S, C, x) {
      const A = S instanceof Float32Array ? S : new Float32Array(S);
      if (d !== null && d.name === "webkitAudioContext") {
        const I = C + x, E = h.context.sampleRate, O = Math.ceil(C * E), V = Math.floor(I * E), N = V - O, F = new Float32Array(N);
        for (let Z = 0; Z < N; Z += 1) {
          const j = (A.length - 1) / x * ((O + Z) / E - C), H = Math.floor(j), R = Math.ceil(j);
          F[Z] = H === R ? A[H] : (1 - (j - H)) * A[H] + (1 - (R - j)) * A[R];
        }
        _ === null && T.flush(h.context.currentTime), T.add(c(F, C, x)), g.setValueCurveAtTime(F, C, x);
        const $ = V / E;
        $ < I && f(b, F[F.length - 1], $), f(b, A[A.length - 1], I);
      } else
        _ === null && T.flush(h.context.currentTime), T.add(c(A, C, x)), g.setValueCurveAtTime(A, C, x);
      return b;
    }
  };
  return n.set(b, g), t.set(b, h), e(b, _), b;
}, b4 = (e) => ({
  replay(t) {
    for (const n of e)
      if (n.type === "exponentialRampToValue") {
        const { endTime: i, value: r } = n;
        t.exponentialRampToValueAtTime(r, i);
      } else if (n.type === "linearRampToValue") {
        const { endTime: i, value: r } = n;
        t.linearRampToValueAtTime(r, i);
      } else if (n.type === "setTarget") {
        const { startTime: i, target: r, timeConstant: s } = n;
        t.setTargetAtTime(r, i, s);
      } else if (n.type === "setValue") {
        const { startTime: i, value: r } = n;
        t.setValueAtTime(r, i);
      } else if (n.type === "setValueCurve") {
        const { duration: i, startTime: r, values: s } = n;
        t.setValueCurveAtTime(s, r, i);
      } else
        throw new Error("Can't apply an unknown automation.");
  }
});
class L1 {
  constructor(t) {
    this._map = new Map(t);
  }
  get size() {
    return this._map.size;
  }
  entries() {
    return this._map.entries();
  }
  forEach(t, n = null) {
    return this._map.forEach((i, r) => t.call(n, i, r, this));
  }
  get(t) {
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
  keys() {
    return this._map.keys();
  }
  values() {
    return this._map.values();
  }
}
const w4 = {
  channelCount: 2,
  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  numberOfInputs: 1,
  numberOfOutputs: 1,
  parameterData: {},
  processorOptions: {}
}, _4 = (e, t, n, i, r, s, a, o, l, u, c, d, f, h) => class extends t {
  constructor(g, p, y) {
    var k;
    const T = o(g), _ = l(T), b = c({ ...w4, ...y });
    f(b);
    const S = bg.get(T), C = S == null ? void 0 : S.get(p), x = _ || T.state !== "closed" ? T : (k = a(T)) !== null && k !== void 0 ? k : T, A = r(x, _ ? null : g.baseLatency, u, p, C, b), I = _ ? i(p, b, C) : null;
    super(g, !0, A, I);
    const E = [];
    A.parameters.forEach((V, N) => {
      const F = n(this, _, V);
      E.push([N, F]);
    }), this._nativeAudioWorkletNode = A, this._onprocessorerror = null, this._parameters = new L1(E), _ && e(T, this);
    const { activeInputs: O } = s(this);
    d(A, O);
  }
  get onprocessorerror() {
    return this._onprocessorerror;
  }
  set onprocessorerror(g) {
    const p = typeof g == "function" ? h(this, g) : null;
    this._nativeAudioWorkletNode.onprocessorerror = p;
    const y = this._nativeAudioWorkletNode.onprocessorerror;
    this._onprocessorerror = y !== null && y === p ? g : y;
  }
  get parameters() {
    return this._parameters === null ? this._nativeAudioWorkletNode.parameters : this._parameters;
  }
  get port() {
    return this._nativeAudioWorkletNode.port;
  }
};
function zf(e, t, n, i, r) {
  if (typeof e.copyFromChannel == "function")
    t[n].byteLength === 0 && (t[n] = new Float32Array(128)), e.copyFromChannel(t[n], i, r);
  else {
    const s = e.getChannelData(i);
    if (t[n].byteLength === 0)
      t[n] = s.slice(r, r + 128);
    else {
      const a = new Float32Array(s.buffer, r * Float32Array.BYTES_PER_ELEMENT, 128);
      t[n].set(a);
    }
  }
}
const $1 = (e, t, n, i, r) => {
  typeof e.copyToChannel == "function" ? t[n].byteLength !== 0 && e.copyToChannel(t[n], i, r) : t[n].byteLength !== 0 && e.getChannelData(i).set(t[n], r);
}, Uf = (e, t) => {
  const n = [];
  for (let i = 0; i < e; i += 1) {
    const r = [], s = typeof t == "number" ? t : t[i];
    for (let a = 0; a < s; a += 1)
      r.push(new Float32Array(128));
    n.push(r);
  }
  return n;
}, S4 = (e, t) => {
  const n = kr(wg, e), i = Mt(t);
  return kr(n, i);
}, k4 = async (e, t, n, i, r, s, a) => {
  const o = t === null ? Math.ceil(e.context.length / 128) * 128 : t.length, l = i.channelCount * i.numberOfInputs, u = r.reduce((p, y) => p + y, 0), c = u === 0 ? null : n.createBuffer(u, o, n.sampleRate);
  if (s === void 0)
    throw new Error("Missing the processor constructor.");
  const d = ii(e), f = await S4(n, e), h = Uf(i.numberOfInputs, i.channelCount), m = Uf(i.numberOfOutputs, r), g = Array.from(e.parameters.keys()).reduce((p, y) => ({ ...p, [y]: new Float32Array(128) }), {});
  for (let p = 0; p < o; p += 128) {
    if (i.numberOfInputs > 0 && t !== null)
      for (let y = 0; y < i.numberOfInputs; y += 1)
        for (let k = 0; k < i.channelCount; k += 1)
          zf(t, h[y], k, k, p);
    s.parameterDescriptors !== void 0 && t !== null && s.parameterDescriptors.forEach(({ name: y }, k) => {
      zf(t, g, y, l + k, p);
    });
    for (let y = 0; y < i.numberOfInputs; y += 1)
      for (let k = 0; k < r[y]; k += 1)
        m[y][k].byteLength === 0 && (m[y][k] = new Float32Array(128));
    try {
      const y = h.map((T, _) => d.activeInputs[_].size === 0 ? [] : T), k = a(p / n.sampleRate, n.sampleRate, () => f.process(y, m, g));
      if (c !== null)
        for (let T = 0, _ = 0; T < i.numberOfOutputs; T += 1) {
          for (let b = 0; b < r[T]; b += 1)
            $1(c, m[T], b, _ + b, p);
          _ += r[T];
        }
      if (!k)
        break;
    } catch (y) {
      e.dispatchEvent(new ErrorEvent("processorerror", {
        colno: y.colno,
        filename: y.filename,
        lineno: y.lineno,
        message: y.message
      }));
      break;
    }
  }
  return c;
}, C4 = (e, t, n, i, r, s, a, o, l, u, c, d, f, h, m, g) => (p, y, k) => {
  const T = /* @__PURE__ */ new WeakMap();
  let _ = null;
  const b = async (S, C) => {
    let x = c(S), A = null;
    const I = Xn(x, C), E = Array.isArray(y.outputChannelCount) ? y.outputChannelCount : Array.from(y.outputChannelCount);
    if (d === null) {
      const O = E.reduce(($, Z) => $ + Z, 0), V = r(C, {
        channelCount: Math.max(1, O),
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        numberOfOutputs: Math.max(1, O)
      }), N = [];
      for (let $ = 0; $ < S.numberOfOutputs; $ += 1)
        N.push(i(C, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "speakers",
          numberOfInputs: E[$]
        }));
      const F = a(C, {
        channelCount: y.channelCount,
        channelCountMode: y.channelCountMode,
        channelInterpretation: y.channelInterpretation,
        gain: 1
      });
      F.connect = t.bind(null, N), F.disconnect = l.bind(null, N), A = [V, N, F];
    } else
      I || (x = new d(C, p));
    if (T.set(C, A === null ? x : A[2]), A !== null) {
      if (_ === null) {
        if (k === void 0)
          throw new Error("Missing the processor constructor.");
        if (f === null)
          throw new Error("Missing the native OfflineAudioContext constructor.");
        const Z = S.channelCount * S.numberOfInputs, j = k.parameterDescriptors === void 0 ? 0 : k.parameterDescriptors.length, H = Z + j;
        _ = k4(S, H === 0 ? null : await (async () => {
          const L = new f(
            H,
            // Ceil the length to the next full render quantum.
            // Bug #17: Safari does not yet expose the length.
            Math.ceil(S.context.length / 128) * 128,
            C.sampleRate
          ), ne = [], oe = [];
          for (let K = 0; K < y.numberOfInputs; K += 1)
            ne.push(a(L, {
              channelCount: y.channelCount,
              channelCountMode: y.channelCountMode,
              channelInterpretation: y.channelInterpretation,
              gain: 1
            })), oe.push(r(L, {
              channelCount: y.channelCount,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              numberOfOutputs: y.channelCount
            }));
          const we = await Promise.all(Array.from(S.parameters.values()).map(async (K) => {
            const ue = s(L, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              offset: K.value
            });
            return await h(L, K, ue.offset), ue;
          })), ee = i(L, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            numberOfInputs: Math.max(1, Z + j)
          });
          for (let K = 0; K < y.numberOfInputs; K += 1) {
            ne[K].connect(oe[K]);
            for (let ue = 0; ue < y.channelCount; ue += 1)
              oe[K].connect(ee, ue, K * y.channelCount + ue);
          }
          for (const [K, ue] of we.entries())
            ue.connect(ee, 0, Z + K), ue.start(0);
          return ee.connect(L.destination), await Promise.all(ne.map((K) => m(S, L, K))), g(L);
        })(), C, y, E, k, u);
      }
      const O = await _, V = n(C, {
        buffer: null,
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        loop: !1,
        loopEnd: 0,
        loopStart: 0,
        playbackRate: 1
      }), [N, F, $] = A;
      O !== null && (V.buffer = O, V.start(0)), V.connect(N);
      for (let Z = 0, j = 0; Z < S.numberOfOutputs; Z += 1) {
        const H = F[Z];
        for (let R = 0; R < E[Z]; R += 1)
          N.connect(H, j + R, R);
        j += E[Z];
      }
      return $;
    }
    if (I)
      for (const [O, V] of S.parameters.entries())
        await e(
          C,
          V,
          // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.
          x.parameters.get(O)
        );
    else
      for (const [O, V] of S.parameters.entries())
        await h(
          C,
          V,
          // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.
          x.parameters.get(O)
        );
    return await m(S, C, x), x;
  };
  return {
    render(S, C) {
      o(C, S);
      const x = T.get(C);
      return x !== void 0 ? Promise.resolve(x) : b(S, C);
    }
  };
}, T4 = (e, t, n, i, r, s, a, o, l, u, c, d, f, h, m, g, p, y, k, T) => class extends m {
  constructor(b, S) {
    super(b, S), this._nativeContext = b, this._audioWorklet = e === void 0 ? void 0 : {
      addModule: (C, x) => e(this, C, x)
    };
  }
  get audioWorklet() {
    return this._audioWorklet;
  }
  createAnalyser() {
    return new t(this);
  }
  createBiquadFilter() {
    return new r(this);
  }
  createBuffer(b, S, C) {
    return new n({ length: S, numberOfChannels: b, sampleRate: C });
  }
  createBufferSource() {
    return new i(this);
  }
  createChannelMerger(b = 6) {
    return new s(this, { numberOfInputs: b });
  }
  createChannelSplitter(b = 6) {
    return new a(this, { numberOfOutputs: b });
  }
  createConstantSource() {
    return new o(this);
  }
  createConvolver() {
    return new l(this);
  }
  createDelay(b = 1) {
    return new c(this, { maxDelayTime: b });
  }
  createDynamicsCompressor() {
    return new d(this);
  }
  createGain() {
    return new f(this);
  }
  createIIRFilter(b, S) {
    return new h(this, { feedback: S, feedforward: b });
  }
  createOscillator() {
    return new g(this);
  }
  createPanner() {
    return new p(this);
  }
  createPeriodicWave(b, S, C = { disableNormalization: !1 }) {
    return new y(this, { ...C, imag: S, real: b });
  }
  createStereoPanner() {
    return new k(this);
  }
  createWaveShaper() {
    return new T(this);
  }
  decodeAudioData(b, S, C) {
    return u(this._nativeContext, b).then((x) => (typeof S == "function" && S(x), x), (x) => {
      throw typeof C == "function" && C(x), x;
    });
  }
}, x4 = {
  Q: 1,
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  detune: 0,
  frequency: 350,
  gain: 0,
  type: "lowpass"
}, A4 = (e, t, n, i, r, s, a, o) => class extends e {
  constructor(u, c) {
    const d = s(u), f = { ...x4, ...c }, h = r(d, f), m = a(d), g = m ? n() : null;
    super(u, !1, h, g), this._Q = t(this, m, h.Q, ei, mi), this._detune = t(this, m, h.detune, 1200 * Math.log2(ei), -1200 * Math.log2(ei)), this._frequency = t(this, m, h.frequency, u.sampleRate / 2, 0), this._gain = t(this, m, h.gain, 40 * Math.log10(ei), mi), this._nativeBiquadFilterNode = h, o(this, 1);
  }
  get detune() {
    return this._detune;
  }
  get frequency() {
    return this._frequency;
  }
  get gain() {
    return this._gain;
  }
  get Q() {
    return this._Q;
  }
  get type() {
    return this._nativeBiquadFilterNode.type;
  }
  set type(u) {
    this._nativeBiquadFilterNode.type = u;
  }
  getFrequencyResponse(u, c, d) {
    try {
      this._nativeBiquadFilterNode.getFrequencyResponse(u, c, d);
    } catch (f) {
      throw f.code === 11 ? i() : f;
    }
    if (u.length !== c.length || c.length !== d.length)
      throw i();
  }
}, I4 = (e, t, n, i, r) => () => {
  const s = /* @__PURE__ */ new WeakMap(), a = async (o, l) => {
    let u = n(o);
    const c = Xn(u, l);
    if (!c) {
      const d = {
        Q: u.Q.value,
        channelCount: u.channelCount,
        channelCountMode: u.channelCountMode,
        channelInterpretation: u.channelInterpretation,
        detune: u.detune.value,
        frequency: u.frequency.value,
        gain: u.gain.value,
        type: u.type
      };
      u = t(l, d);
    }
    return s.set(l, u), c ? (await e(l, o.Q, u.Q), await e(l, o.detune, u.detune), await e(l, o.frequency, u.frequency), await e(l, o.gain, u.gain)) : (await i(l, o.Q, u.Q), await i(l, o.detune, u.detune), await i(l, o.frequency, u.frequency), await i(l, o.gain, u.gain)), await r(o, l, u), u;
  };
  return {
    render(o, l) {
      const u = s.get(l);
      return u !== void 0 ? Promise.resolve(u) : a(o, l);
    }
  };
}, E4 = (e, t) => (n, i) => {
  const r = t.get(n);
  if (r !== void 0)
    return r;
  const s = e.get(n);
  if (s !== void 0)
    return s;
  try {
    const a = i();
    return a instanceof Promise ? (e.set(n, a), a.catch(() => !1).then((o) => (e.delete(n), t.set(n, o), o))) : (t.set(n, a), a);
  } catch {
    return t.set(n, !1), !1;
  }
}, O4 = {
  channelCount: 1,
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  numberOfInputs: 6
}, P4 = (e, t, n, i, r) => class extends e {
  constructor(a, o) {
    const l = i(a), u = { ...O4, ...o }, c = n(l, u), d = r(l) ? t() : null;
    super(a, !1, c, d);
  }
}, V4 = (e, t, n) => () => {
  const i = /* @__PURE__ */ new WeakMap(), r = async (s, a) => {
    let o = t(s);
    if (!Xn(o, a)) {
      const u = {
        channelCount: o.channelCount,
        channelCountMode: o.channelCountMode,
        channelInterpretation: o.channelInterpretation,
        numberOfInputs: o.numberOfInputs
      };
      o = e(a, u);
    }
    return i.set(a, o), await n(s, a, o), o;
  };
  return {
    render(s, a) {
      const o = i.get(a);
      return o !== void 0 ? Promise.resolve(o) : r(s, a);
    }
  };
}, D4 = {
  channelCount: 6,
  channelCountMode: "explicit",
  channelInterpretation: "discrete",
  numberOfOutputs: 6
}, N4 = (e, t, n, i, r, s) => class extends e {
  constructor(o, l) {
    const u = i(o), c = s({ ...D4, ...l }), d = n(u, c), f = r(u) ? t() : null;
    super(o, !1, d, f);
  }
}, M4 = (e, t, n) => () => {
  const i = /* @__PURE__ */ new WeakMap(), r = async (s, a) => {
    let o = t(s);
    if (!Xn(o, a)) {
      const u = {
        channelCount: o.channelCount,
        channelCountMode: o.channelCountMode,
        channelInterpretation: o.channelInterpretation,
        numberOfOutputs: o.numberOfOutputs
      };
      o = e(a, u);
    }
    return i.set(a, o), await n(s, a, o), o;
  };
  return {
    render(s, a) {
      const o = i.get(a);
      return o !== void 0 ? Promise.resolve(o) : r(s, a);
    }
  };
}, R4 = (e) => (t, n, i) => e(n, t, i), F4 = (e) => (t, n, i = 0, r = 0) => {
  const s = t[i];
  if (s === void 0)
    throw e();
  return Hf(n) ? s.connect(n, 0, r) : s.connect(n, 0);
}, B4 = (e) => (t, n) => {
  const i = e(t, {
    buffer: null,
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    loop: !1,
    loopEnd: 0,
    loopStart: 0,
    playbackRate: 1
  }), r = t.createBuffer(1, 2, 44100);
  return i.buffer = r, i.loop = !0, i.connect(n), i.start(), () => {
    i.stop(), i.disconnect(n);
  };
}, L4 = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  offset: 1
}, $4 = (e, t, n, i, r, s, a) => class extends e {
  constructor(l, u) {
    const c = r(l), d = { ...L4, ...u }, f = i(c, d), h = s(c), m = h ? n() : null;
    super(l, !1, f, m), this._constantSourceNodeRenderer = m, this._nativeConstantSourceNode = f, this._offset = t(this, h, f.offset, ei, mi), this._onended = null;
  }
  get offset() {
    return this._offset;
  }
  get onended() {
    return this._onended;
  }
  set onended(l) {
    const u = typeof l == "function" ? a(this, l) : null;
    this._nativeConstantSourceNode.onended = u;
    const c = this._nativeConstantSourceNode.onended;
    this._onended = c !== null && c === u ? l : c;
  }
  start(l = 0) {
    if (this._nativeConstantSourceNode.start(l), this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.start = l), this.context.state !== "closed") {
      Cl(this);
      const u = () => {
        this._nativeConstantSourceNode.removeEventListener("ended", u), gs(this) && Gc(this);
      };
      this._nativeConstantSourceNode.addEventListener("ended", u);
    }
  }
  stop(l = 0) {
    this._nativeConstantSourceNode.stop(l), this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.stop = l);
  }
}, W4 = (e, t, n, i, r) => () => {
  const s = /* @__PURE__ */ new WeakMap();
  let a = null, o = null;
  const l = async (u, c) => {
    let d = n(u);
    const f = Xn(d, c);
    if (!f) {
      const h = {
        channelCount: d.channelCount,
        channelCountMode: d.channelCountMode,
        channelInterpretation: d.channelInterpretation,
        offset: d.offset.value
      };
      d = t(c, h), a !== null && d.start(a), o !== null && d.stop(o);
    }
    return s.set(c, d), f ? await e(c, u.offset, d.offset) : await i(c, u.offset, d.offset), await r(u, c, d), d;
  };
  return {
    set start(u) {
      a = u;
    },
    set stop(u) {
      o = u;
    },
    render(u, c) {
      const d = s.get(c);
      return d !== void 0 ? Promise.resolve(d) : l(u, c);
    }
  };
}, j4 = (e) => (t) => (e[0] = t, e[0]), H4 = {
  buffer: null,
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  disableNormalization: !1
}, z4 = (e, t, n, i, r, s) => class extends e {
  constructor(o, l) {
    const u = i(o), c = { ...H4, ...l }, d = n(u, c), h = r(u) ? t() : null;
    super(o, !1, d, h), this._isBufferNullified = !1, this._nativeConvolverNode = d, c.buffer !== null && s(this, c.buffer.duration);
  }
  get buffer() {
    return this._isBufferNullified ? null : this._nativeConvolverNode.buffer;
  }
  set buffer(o) {
    if (this._nativeConvolverNode.buffer = o, o === null && this._nativeConvolverNode.buffer !== null) {
      const l = this._nativeConvolverNode.context;
      this._nativeConvolverNode.buffer = l.createBuffer(1, 1, l.sampleRate), this._isBufferNullified = !0, s(this, 0);
    } else
      this._isBufferNullified = !1, s(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);
  }
  get normalize() {
    return this._nativeConvolverNode.normalize;
  }
  set normalize(o) {
    this._nativeConvolverNode.normalize = o;
  }
}, U4 = (e, t, n) => () => {
  const i = /* @__PURE__ */ new WeakMap(), r = async (s, a) => {
    let o = t(s);
    if (!Xn(o, a)) {
      const u = {
        buffer: o.buffer,
        channelCount: o.channelCount,
        channelCountMode: o.channelCountMode,
        channelInterpretation: o.channelInterpretation,
        disableNormalization: !o.normalize
      };
      o = e(a, u);
    }
    return i.set(a, o), Kl(o) ? await n(s, a, o.inputs[0]) : await n(s, a, o), o;
  };
  return {
    render(s, a) {
      const o = i.get(a);
      return o !== void 0 ? Promise.resolve(o) : r(s, a);
    }
  };
}, q4 = (e, t) => (n, i, r) => {
  if (t === null)
    throw new Error("Missing the native OfflineAudioContext constructor.");
  try {
    return new t(n, i, r);
  } catch (s) {
    throw s.name === "SyntaxError" ? e() : s;
  }
}, G4 = () => new DOMException("", "DataCloneError"), p_ = (e) => {
  const { port1: t, port2: n } = new MessageChannel();
  return new Promise((i) => {
    const r = () => {
      n.onmessage = null, t.close(), n.close(), i();
    };
    n.onmessage = () => r();
    try {
      t.postMessage(e, [e]);
    } catch {
    } finally {
      r();
    }
  });
}, Y4 = (e, t, n, i, r, s, a, o, l, u, c) => (d, f) => {
  const h = a(d) ? d : s(d);
  if (r.has(f)) {
    const m = n();
    return Promise.reject(m);
  }
  try {
    r.add(f);
  } catch {
  }
  return t(l, () => l(h)) ? h.decodeAudioData(f).then((m) => (p_(f).catch(() => {
  }), t(o, () => o(m)) || c(m), e.add(m), m)) : new Promise((m, g) => {
    const p = async () => {
      try {
        await p_(f);
      } catch {
      }
    }, y = (k) => {
      g(k), p();
    };
    try {
      h.decodeAudioData(f, (k) => {
        typeof k.copyFromChannel != "function" && (u(k), Ty(k)), e.add(k), p().then(() => m(k));
      }, (k) => {
        y(k === null ? i() : k);
      });
    } catch (k) {
      y(k);
    }
  });
}, Z4 = (e, t, n, i, r, s, a, o) => (l, u) => {
  const c = t.get(l);
  if (c === void 0)
    throw new Error("Missing the expected cycle count.");
  const d = s(l.context), f = o(d);
  if (c === u) {
    if (t.delete(l), !f && a(l)) {
      const h = i(l), { outputs: m } = n(l);
      for (const g of m)
        if (Zc(g)) {
          const p = i(g[0]);
          e(h, p, g[1], g[2]);
        } else {
          const p = r(g[0]);
          h.connect(p, g[1]);
        }
    }
  } else
    t.set(l, c - u);
}, K4 = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  delayTime: 0,
  maxDelayTime: 1
}, X4 = (e, t, n, i, r, s, a) => class extends e {
  constructor(l, u) {
    const c = r(l), d = { ...K4, ...u }, f = i(c, d), h = s(c), m = h ? n(d.maxDelayTime) : null;
    super(l, !1, f, m), this._delayTime = t(this, h, f.delayTime), a(this, d.maxDelayTime);
  }
  get delayTime() {
    return this._delayTime;
  }
}, J4 = (e, t, n, i, r) => (s) => {
  const a = /* @__PURE__ */ new WeakMap(), o = async (l, u) => {
    let c = n(l);
    const d = Xn(c, u);
    if (!d) {
      const f = {
        channelCount: c.channelCount,
        channelCountMode: c.channelCountMode,
        channelInterpretation: c.channelInterpretation,
        delayTime: c.delayTime.value,
        maxDelayTime: s
      };
      c = t(u, f);
    }
    return a.set(u, c), d ? await e(u, l.delayTime, c.delayTime) : await i(u, l.delayTime, c.delayTime), await r(l, u, c), c;
  };
  return {
    render(l, u) {
      const c = a.get(u);
      return c !== void 0 ? Promise.resolve(c) : o(l, u);
    }
  };
}, Q4 = (e) => (t, n, i, r) => e(t[r], (s) => s[0] === n && s[1] === i), eH = (e) => (t, n) => {
  e(t).delete(n);
}, tH = (e) => "delayTime" in e, nH = (e, t, n) => function i(r, s) {
  const a = $f(s) ? s : n(e, s);
  if (tH(a))
    return [];
  if (r[0] === a)
    return [r];
  if (r.includes(a))
    return [];
  const { outputs: o } = t(a);
  return Array.from(o).map((l) => i([...r, a], l[0])).reduce((l, u) => l.concat(u), []);
}, Id = (e, t, n) => {
  const i = t[n];
  if (i === void 0)
    throw e();
  return i;
}, iH = (e) => (t, n = void 0, i = void 0, r = 0) => n === void 0 ? t.forEach((s) => s.disconnect()) : typeof n == "number" ? Id(e, t, n).disconnect() : Hf(n) ? i === void 0 ? t.forEach((s) => s.disconnect(n)) : r === void 0 ? Id(e, t, i).disconnect(n, 0) : Id(e, t, i).disconnect(n, 0, r) : i === void 0 ? t.forEach((s) => s.disconnect(n)) : Id(e, t, i).disconnect(n, 0), rH = {
  attack: 3e-3,
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  knee: 30,
  ratio: 12,
  release: 0.25,
  threshold: -24
}, sH = (e, t, n, i, r, s, a, o) => class extends e {
  constructor(u, c) {
    const d = s(u), f = { ...rH, ...c }, h = i(d, f), m = a(d), g = m ? n() : null;
    super(u, !1, h, g), this._attack = t(this, m, h.attack), this._knee = t(this, m, h.knee), this._nativeDynamicsCompressorNode = h, this._ratio = t(this, m, h.ratio), this._release = t(this, m, h.release), this._threshold = t(this, m, h.threshold), o(this, 6e-3);
  }
  get attack() {
    return this._attack;
  }
  // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.
  get channelCount() {
    return this._nativeDynamicsCompressorNode.channelCount;
  }
  set channelCount(u) {
    const c = this._nativeDynamicsCompressorNode.channelCount;
    if (this._nativeDynamicsCompressorNode.channelCount = u, u > 2)
      throw this._nativeDynamicsCompressorNode.channelCount = c, r();
  }
  /*
   * Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be
   * overwritten here.
   */
  get channelCountMode() {
    return this._nativeDynamicsCompressorNode.channelCountMode;
  }
  set channelCountMode(u) {
    const c = this._nativeDynamicsCompressorNode.channelCountMode;
    if (this._nativeDynamicsCompressorNode.channelCountMode = u, u === "max")
      throw this._nativeDynamicsCompressorNode.channelCountMode = c, r();
  }
  get knee() {
    return this._knee;
  }
  get ratio() {
    return this._ratio;
  }
  get reduction() {
    return typeof this._nativeDynamicsCompressorNode.reduction.value == "number" ? this._nativeDynamicsCompressorNode.reduction.value : this._nativeDynamicsCompressorNode.reduction;
  }
  get release() {
    return this._release;
  }
  get threshold() {
    return this._threshold;
  }
}, aH = (e, t, n, i, r) => () => {
  const s = /* @__PURE__ */ new WeakMap(), a = async (o, l) => {
    let u = n(o);
    const c = Xn(u, l);
    if (!c) {
      const d = {
        attack: u.attack.value,
        channelCount: u.channelCount,
        channelCountMode: u.channelCountMode,
        channelInterpretation: u.channelInterpretation,
        knee: u.knee.value,
        ratio: u.ratio.value,
        release: u.release.value,
        threshold: u.threshold.value
      };
      u = t(l, d);
    }
    return s.set(l, u), c ? (await e(l, o.attack, u.attack), await e(l, o.knee, u.knee), await e(l, o.ratio, u.ratio), await e(l, o.release, u.release), await e(l, o.threshold, u.threshold)) : (await i(l, o.attack, u.attack), await i(l, o.knee, u.knee), await i(l, o.ratio, u.ratio), await i(l, o.release, u.release), await i(l, o.threshold, u.threshold)), await r(o, l, u), u;
  };
  return {
    render(o, l) {
      const u = s.get(l);
      return u !== void 0 ? Promise.resolve(u) : a(o, l);
    }
  };
}, oH = () => new DOMException("", "EncodingError"), lH = (e) => (t) => new Promise((n, i) => {
  if (e === null) {
    i(new SyntaxError());
    return;
  }
  const r = e.document.head;
  if (r === null)
    i(new SyntaxError());
  else {
    const s = e.document.createElement("script"), a = new Blob([t], { type: "application/javascript" }), o = URL.createObjectURL(a), l = e.onerror, u = () => {
      e.onerror = l, URL.revokeObjectURL(o);
    };
    e.onerror = (c, d, f, h, m) => {
      if (d === o || d === e.location.href && f === 1 && h === 1)
        return u(), i(m), !1;
      if (l !== null)
        return l(c, d, f, h, m);
    }, s.onerror = () => {
      u(), i(new SyntaxError());
    }, s.onload = () => {
      u(), n();
    }, s.src = o, s.type = "module", r.appendChild(s);
  }
}), uH = (e) => class {
  constructor(n) {
    this._nativeEventTarget = n, this._listeners = /* @__PURE__ */ new WeakMap();
  }
  addEventListener(n, i, r) {
    if (i !== null) {
      let s = this._listeners.get(i);
      s === void 0 && (s = e(this, i), typeof i == "function" && this._listeners.set(i, s)), this._nativeEventTarget.addEventListener(n, s, r);
    }
  }
  dispatchEvent(n) {
    return this._nativeEventTarget.dispatchEvent(n);
  }
  removeEventListener(n, i, r) {
    const s = i === null ? void 0 : this._listeners.get(i);
    this._nativeEventTarget.removeEventListener(n, s === void 0 ? null : s, r);
  }
}, cH = (e) => (t, n, i) => {
  Object.defineProperties(e, {
    currentFrame: {
      configurable: !0,
      get() {
        return Math.round(t * n);
      }
    },
    currentTime: {
      configurable: !0,
      get() {
        return t;
      }
    }
  });
  try {
    return i();
  } finally {
    e !== null && (delete e.currentFrame, delete e.currentTime);
  }
}, dH = (e) => async (t) => {
  try {
    const n = await fetch(t);
    if (n.ok)
      return [await n.text(), n.url];
  } catch {
  }
  throw e();
}, fH = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  gain: 1
}, hH = (e, t, n, i, r, s) => class extends e {
  constructor(o, l) {
    const u = r(o), c = { ...fH, ...l }, d = i(u, c), f = s(u), h = f ? n() : null;
    super(o, !1, d, h), this._gain = t(this, f, d.gain, ei, mi);
  }
  get gain() {
    return this._gain;
  }
}, mH = (e, t, n, i, r) => () => {
  const s = /* @__PURE__ */ new WeakMap(), a = async (o, l) => {
    let u = n(o);
    const c = Xn(u, l);
    if (!c) {
      const d = {
        channelCount: u.channelCount,
        channelCountMode: u.channelCountMode,
        channelInterpretation: u.channelInterpretation,
        gain: u.gain.value
      };
      u = t(l, d);
    }
    return s.set(l, u), c ? await e(l, o.gain, u.gain) : await i(l, o.gain, u.gain), await r(o, l, u), u;
  };
  return {
    render(o, l) {
      const u = s.get(l);
      return u !== void 0 ? Promise.resolve(u) : a(o, l);
    }
  };
}, vH = (e, t) => (n) => t(e, n), gH = (e) => (t) => {
  const n = e(t);
  if (n.renderer === null)
    throw new Error("Missing the renderer of the given AudioNode in the audio graph.");
  return n.renderer;
}, pH = (e) => (t) => {
  var n;
  return (n = e.get(t)) !== null && n !== void 0 ? n : 0;
}, yH = (e) => (t) => {
  const n = e(t);
  if (n.renderer === null)
    throw new Error("Missing the renderer of the given AudioParam in the audio graph.");
  return n.renderer;
}, bH = (e) => (t) => e.get(t), Tn = () => new DOMException("", "InvalidStateError"), wH = (e) => (t) => {
  const n = e.get(t);
  if (n === void 0)
    throw Tn();
  return n;
}, _H = (e, t) => (n) => {
  let i = e.get(n);
  if (i !== void 0)
    return i;
  if (t === null)
    throw new Error("Missing the native OfflineAudioContext constructor.");
  return i = new t(1, 1, 44100), e.set(n, i), i;
}, SH = (e) => (t) => {
  const n = e.get(t);
  if (n === void 0)
    throw new Error("The context has no set of AudioWorkletNodes.");
  return n;
}, Jh = () => new DOMException("", "InvalidAccessError"), kH = (e) => {
  e.getFrequencyResponse = ((t) => (n, i, r) => {
    if (n.length !== i.length || i.length !== r.length)
      throw Jh();
    return t.call(e, n, i, r);
  })(e.getFrequencyResponse);
}, CH = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers"
}, TH = (e, t, n, i, r, s) => class extends e {
  constructor(o, l) {
    const u = i(o), c = r(u), d = { ...CH, ...l }, f = t(u, c ? null : o.baseLatency, d), h = c ? n(d.feedback, d.feedforward) : null;
    super(o, !1, f, h), kH(f), this._nativeIIRFilterNode = f, s(this, 1);
  }
  getFrequencyResponse(o, l, u) {
    return this._nativeIIRFilterNode.getFrequencyResponse(o, l, u);
  }
}, W1 = (e, t, n, i, r, s, a, o, l, u, c) => {
  const d = u.length;
  let f = o;
  for (let h = 0; h < d; h += 1) {
    let m = n[0] * u[h];
    for (let g = 1; g < r; g += 1) {
      const p = f - g & l - 1;
      m += n[g] * s[p], m -= e[g] * a[p];
    }
    for (let g = r; g < i; g += 1)
      m += n[g] * s[f - g & l - 1];
    for (let g = r; g < t; g += 1)
      m -= e[g] * a[f - g & l - 1];
    s[f] = u[h], a[f] = m, f = f + 1 & l - 1, c[h] = m;
  }
  return f;
}, xH = (e, t, n, i) => {
  const r = n instanceof Float64Array ? n : new Float64Array(n), s = i instanceof Float64Array ? i : new Float64Array(i), a = r.length, o = s.length, l = Math.min(a, o);
  if (r[0] !== 1) {
    for (let m = 0; m < a; m += 1)
      s[m] /= r[0];
    for (let m = 1; m < o; m += 1)
      r[m] /= r[0];
  }
  const u = 32, c = new Float32Array(u), d = new Float32Array(u), f = t.createBuffer(e.numberOfChannels, e.length, e.sampleRate), h = e.numberOfChannels;
  for (let m = 0; m < h; m += 1) {
    const g = e.getChannelData(m), p = f.getChannelData(m);
    c.fill(0), d.fill(0), W1(r, a, s, o, l, c, d, 0, u, g, p);
  }
  return f;
}, AH = (e, t, n, i, r) => (s, a) => {
  const o = /* @__PURE__ */ new WeakMap();
  let l = null;
  const u = async (c, d) => {
    let f = null, h = t(c);
    const m = Xn(h, d);
    if (d.createIIRFilter === void 0 ? f = e(d, {
      buffer: null,
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers",
      loop: !1,
      loopEnd: 0,
      loopStart: 0,
      playbackRate: 1
    }) : m || (h = d.createIIRFilter(a, s)), o.set(d, f === null ? h : f), f !== null) {
      if (l === null) {
        if (n === null)
          throw new Error("Missing the native OfflineAudioContext constructor.");
        const p = new n(
          // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.
          c.context.destination.channelCount,
          // Bug #17: Safari does not yet expose the length.
          c.context.length,
          d.sampleRate
        );
        l = (async () => {
          await i(c, p, p.destination);
          const y = await r(p);
          return xH(y, d, s, a);
        })();
      }
      const g = await l;
      return f.buffer = g, f.start(0), f;
    }
    return await i(c, d, h), h;
  };
  return {
    render(c, d) {
      const f = o.get(d);
      return f !== void 0 ? Promise.resolve(f) : u(c, d);
    }
  };
}, IH = (e, t, n, i, r, s) => (a) => (o, l) => {
  const u = e.get(o);
  if (u === void 0) {
    if (!a && s(o)) {
      const c = i(o), { outputs: d } = n(o);
      for (const f of d)
        if (Zc(f)) {
          const h = i(f[0]);
          t(c, h, f[1], f[2]);
        } else {
          const h = r(f[0]);
          c.disconnect(h, f[1]);
        }
    }
    e.set(o, l);
  } else
    e.set(o, u + l);
}, EH = (e, t) => (n) => {
  const i = e.get(n);
  return t(i) || t(n);
}, OH = (e, t) => (n) => e.has(n) || t(n), PH = (e, t) => (n) => e.has(n) || t(n), VH = (e, t) => (n) => {
  const i = e.get(n);
  return t(i) || t(n);
}, DH = (e) => (t) => e !== null && t instanceof e, NH = (e) => (t) => e !== null && typeof e.AudioNode == "function" && t instanceof e.AudioNode, MH = (e) => (t) => e !== null && typeof e.AudioParam == "function" && t instanceof e.AudioParam, RH = (e, t) => (n) => e(n) || t(n), FH = (e) => (t) => e !== null && t instanceof e, BH = (e) => e !== null && e.isSecureContext, LH = (e, t, n, i) => class extends e {
  constructor(s, a) {
    const o = n(s), l = t(o, a);
    if (i(o))
      throw TypeError();
    super(s, !0, l, null), this._nativeMediaElementAudioSourceNode = l;
  }
  get mediaElement() {
    return this._nativeMediaElementAudioSourceNode.mediaElement;
  }
}, $H = {
  channelCount: 2,
  channelCountMode: "explicit",
  channelInterpretation: "speakers"
}, WH = (e, t, n, i) => class extends e {
  constructor(s, a) {
    const o = n(s);
    if (i(o))
      throw new TypeError();
    const l = { ...$H, ...a }, u = t(o, l);
    super(s, !1, u, null), this._nativeMediaStreamAudioDestinationNode = u;
  }
  get stream() {
    return this._nativeMediaStreamAudioDestinationNode.stream;
  }
}, jH = (e, t, n, i) => class extends e {
  constructor(s, a) {
    const o = n(s), l = t(o, a);
    if (i(o))
      throw new TypeError();
    super(s, !0, l, null), this._nativeMediaStreamAudioSourceNode = l;
  }
  get mediaStream() {
    return this._nativeMediaStreamAudioSourceNode.mediaStream;
  }
}, HH = (e, t, n) => class extends e {
  constructor(r, s) {
    const a = n(r), o = t(a, s);
    super(r, !0, o, null);
  }
}, zH = (e, t, n, i, r, s) => class extends n {
  constructor(o, l) {
    super(o), this._nativeContext = o, Kh.set(this, o), i(o) && r.set(o, /* @__PURE__ */ new Set()), this._destination = new e(this, l), this._listener = t(this, o), this._onstatechange = null;
  }
  get currentTime() {
    return this._nativeContext.currentTime;
  }
  get destination() {
    return this._destination;
  }
  get listener() {
    return this._listener;
  }
  get onstatechange() {
    return this._onstatechange;
  }
  set onstatechange(o) {
    const l = typeof o == "function" ? s(this, o) : null;
    this._nativeContext.onstatechange = l;
    const u = this._nativeContext.onstatechange;
    this._onstatechange = u !== null && u === l ? o : u;
  }
  get sampleRate() {
    return this._nativeContext.sampleRate;
  }
  get state() {
    return this._nativeContext.state;
  }
}, ac = (e) => {
  const t = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
  try {
    const n = e.decodeAudioData(t.buffer, () => {
    });
    return n === void 0 ? !1 : (n.catch(() => {
    }), !0);
  } catch {
  }
  return !1;
}, UH = (e, t) => (n, i, r) => {
  const s = /* @__PURE__ */ new Set();
  return n.connect = ((a) => (o, l = 0, u = 0) => {
    const c = s.size === 0;
    if (t(o))
      return a.call(n, o, l, u), e(s, [o, l, u], (d) => d[0] === o && d[1] === l && d[2] === u, !0), c && i(), o;
    a.call(n, o, l), e(s, [o, l], (d) => d[0] === o && d[1] === l, !0), c && i();
  })(n.connect), n.disconnect = ((a) => (o, l, u) => {
    const c = s.size > 0;
    if (o === void 0)
      a.apply(n), s.clear();
    else if (typeof o == "number") {
      a.call(n, o);
      for (const f of s)
        f[1] === o && s.delete(f);
    } else {
      t(o) ? a.call(n, o, l, u) : a.call(n, o, l);
      for (const f of s)
        f[0] === o && (l === void 0 || f[1] === l) && (u === void 0 || f[2] === u) && s.delete(f);
    }
    const d = s.size === 0;
    c && d && r();
  })(n.disconnect), n;
}, $t = (e, t, n) => {
  const i = t[n];
  i !== void 0 && i !== e[n] && (e[n] = i);
}, gn = (e, t) => {
  $t(e, t, "channelCount"), $t(e, t, "channelCountMode"), $t(e, t, "channelInterpretation");
}, y_ = (e) => typeof e.getFloatTimeDomainData == "function", qH = (e) => {
  e.getFloatTimeDomainData = (t) => {
    const n = new Uint8Array(t.length);
    e.getByteTimeDomainData(n);
    const i = Math.max(n.length, e.fftSize);
    for (let r = 0; r < i; r += 1)
      t[r] = (n[r] - 128) * 78125e-7;
    return t;
  };
}, GH = (e, t) => (n, i) => {
  const r = n.createAnalyser();
  if (gn(r, i), !(i.maxDecibels > i.minDecibels))
    throw t();
  return $t(r, i, "fftSize"), $t(r, i, "maxDecibels"), $t(r, i, "minDecibels"), $t(r, i, "smoothingTimeConstant"), e(y_, () => y_(r)) || qH(r), r;
}, YH = (e) => e === null ? null : e.hasOwnProperty("AudioBuffer") ? e.AudioBuffer : null, Kt = (e, t, n) => {
  const i = t[n];
  i !== void 0 && i !== e[n].value && (e[n].value = i);
}, ZH = (e) => {
  e.start = ((t) => {
    let n = !1;
    return (i = 0, r = 0, s) => {
      if (n)
        throw Tn();
      t.call(e, i, r, s), n = !0;
    };
  })(e.start);
}, Iy = (e) => {
  e.start = ((t) => (n = 0, i = 0, r) => {
    if (typeof r == "number" && r < 0 || i < 0 || n < 0)
      throw new RangeError("The parameters can't be negative.");
    t.call(e, n, i, r);
  })(e.start);
}, Ey = (e) => {
  e.stop = ((t) => (n = 0) => {
    if (n < 0)
      throw new RangeError("The parameter can't be negative.");
    t.call(e, n);
  })(e.stop);
}, KH = (e, t, n, i, r, s, a, o, l, u, c) => (d, f) => {
  const h = d.createBufferSource();
  return gn(h, f), Kt(h, f, "playbackRate"), $t(h, f, "buffer"), $t(h, f, "loop"), $t(h, f, "loopEnd"), $t(h, f, "loopStart"), t(n, () => n(d)) || ZH(h), t(i, () => i(d)) || l(h), t(r, () => r(d)) || u(h, d), t(s, () => s(d)) || Iy(h), t(a, () => a(d)) || c(h, d), t(o, () => o(d)) || Ey(h), e(d, h), h;
}, XH = (e) => e === null ? null : e.hasOwnProperty("AudioContext") ? e.AudioContext : e.hasOwnProperty("webkitAudioContext") ? e.webkitAudioContext : null, JH = (e, t) => (n, i, r) => {
  const s = n.destination;
  if (s.channelCount !== i)
    try {
      s.channelCount = i;
    } catch {
    }
  r && s.channelCountMode !== "explicit" && (s.channelCountMode = "explicit"), s.maxChannelCount === 0 && Object.defineProperty(s, "maxChannelCount", {
    value: i
  });
  const a = e(n, {
    channelCount: i,
    channelCountMode: s.channelCountMode,
    channelInterpretation: s.channelInterpretation,
    gain: 1
  });
  return t(a, "channelCount", (o) => () => o.call(a), (o) => (l) => {
    o.call(a, l);
    try {
      s.channelCount = l;
    } catch (u) {
      if (l > s.maxChannelCount)
        throw u;
    }
  }), t(a, "channelCountMode", (o) => () => o.call(a), (o) => (l) => {
    o.call(a, l), s.channelCountMode = l;
  }), t(a, "channelInterpretation", (o) => () => o.call(a), (o) => (l) => {
    o.call(a, l), s.channelInterpretation = l;
  }), Object.defineProperty(a, "maxChannelCount", {
    get: () => s.maxChannelCount
  }), a.connect(s), a;
}, QH = (e) => e === null ? null : e.hasOwnProperty("AudioWorkletNode") ? e.AudioWorkletNode : null, e3 = (e) => {
  const { port1: t } = new MessageChannel();
  try {
    t.postMessage(e);
  } finally {
    t.close();
  }
}, t3 = (e, t, n, i, r) => (s, a, o, l, u, c) => {
  if (o !== null)
    try {
      const d = new o(s, l, c), f = /* @__PURE__ */ new Map();
      let h = null;
      if (Object.defineProperties(d, {
        /*
         * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some
         * browsers have no native implementation to achieve a consistent behavior.
         */
        channelCount: {
          get: () => c.channelCount,
          set: () => {
            throw e();
          }
        },
        channelCountMode: {
          get: () => "explicit",
          set: () => {
            throw e();
          }
        },
        // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.
        onprocessorerror: {
          get: () => h,
          set: (m) => {
            typeof h == "function" && d.removeEventListener("processorerror", h), h = typeof m == "function" ? m : null, typeof h == "function" && d.addEventListener("processorerror", h);
          }
        }
      }), d.addEventListener = ((m) => (...g) => {
        if (g[0] === "processorerror") {
          const p = typeof g[1] == "function" ? g[1] : typeof g[1] == "object" && g[1] !== null && typeof g[1].handleEvent == "function" ? g[1].handleEvent : null;
          if (p !== null) {
            const y = f.get(g[1]);
            y !== void 0 ? g[1] = y : (g[1] = (k) => {
              k.type === "error" ? (Object.defineProperties(k, {
                type: { value: "processorerror" }
              }), p(k)) : p(new ErrorEvent(g[0], { ...k }));
            }, f.set(p, g[1]));
          }
        }
        return m.call(d, "error", g[1], g[2]), m.call(d, ...g);
      })(d.addEventListener), d.removeEventListener = ((m) => (...g) => {
        if (g[0] === "processorerror") {
          const p = f.get(g[1]);
          p !== void 0 && (f.delete(g[1]), g[1] = p);
        }
        return m.call(d, "error", g[1], g[2]), m.call(d, g[0], g[1], g[2]);
      })(d.removeEventListener), c.numberOfOutputs !== 0) {
        const m = n(s, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          gain: 0
        });
        return d.connect(m).connect(s.destination), r(d, () => m.disconnect(), () => m.connect(s.destination));
      }
      return d;
    } catch (d) {
      throw d.code === 11 ? i() : d;
    }
  if (u === void 0)
    throw i();
  return e3(c), t(s, a, u, c);
}, j1 = (e, t) => e === null ? 512 : Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(e * t))))), n3 = (e) => new Promise((t, n) => {
  const { port1: i, port2: r } = new MessageChannel();
  i.onmessage = ({ data: s }) => {
    i.close(), r.close(), t(s);
  }, i.onmessageerror = ({ data: s }) => {
    i.close(), r.close(), n(s);
  }, r.postMessage(e);
}), i3 = async (e, t) => {
  const n = await n3(t);
  return new e(n);
}, r3 = (e, t, n, i) => {
  let r = wg.get(e);
  r === void 0 && (r = /* @__PURE__ */ new WeakMap(), wg.set(e, r));
  const s = i3(n, i);
  return r.set(t, s), s;
}, s3 = (e, t, n, i, r, s, a, o, l, u, c, d, f) => (h, m, g, p) => {
  if (p.numberOfInputs === 0 && p.numberOfOutputs === 0)
    throw l();
  const y = Array.isArray(p.outputChannelCount) ? p.outputChannelCount : Array.from(p.outputChannelCount);
  if (y.some((te) => te < 1))
    throw l();
  if (y.length !== p.numberOfOutputs)
    throw t();
  if (p.channelCountMode !== "explicit")
    throw l();
  const k = p.channelCount * p.numberOfInputs, T = y.reduce((te, me) => te + me, 0), _ = g.parameterDescriptors === void 0 ? 0 : g.parameterDescriptors.length;
  if (k + _ > 6 || T > 6)
    throw l();
  const b = new MessageChannel(), S = [], C = [];
  for (let te = 0; te < p.numberOfInputs; te += 1)
    S.push(a(h, {
      channelCount: p.channelCount,
      channelCountMode: p.channelCountMode,
      channelInterpretation: p.channelInterpretation,
      gain: 1
    })), C.push(r(h, {
      channelCount: p.channelCount,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      numberOfOutputs: p.channelCount
    }));
  const x = [];
  if (g.parameterDescriptors !== void 0)
    for (const { defaultValue: te, maxValue: me, minValue: Me, name: Fe } of g.parameterDescriptors) {
      const xe = s(h, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        offset: p.parameterData[Fe] !== void 0 ? p.parameterData[Fe] : te === void 0 ? 0 : te
      });
      Object.defineProperties(xe.offset, {
        defaultValue: {
          get: () => te === void 0 ? 0 : te
        },
        maxValue: {
          get: () => me === void 0 ? ei : me
        },
        minValue: {
          get: () => Me === void 0 ? mi : Me
        }
      }), x.push(xe);
    }
  const A = i(h, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "speakers",
    numberOfInputs: Math.max(1, k + _)
  }), I = j1(m, h.sampleRate), E = o(
    h,
    I,
    k + _,
    // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.
    Math.max(1, T)
  ), O = r(h, {
    channelCount: Math.max(1, T),
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    numberOfOutputs: Math.max(1, T)
  }), V = [];
  for (let te = 0; te < p.numberOfOutputs; te += 1)
    V.push(i(h, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "speakers",
      numberOfInputs: y[te]
    }));
  for (let te = 0; te < p.numberOfInputs; te += 1) {
    S[te].connect(C[te]);
    for (let me = 0; me < p.channelCount; me += 1)
      C[te].connect(A, me, te * p.channelCount + me);
  }
  const N = new L1(g.parameterDescriptors === void 0 ? [] : g.parameterDescriptors.map(({ name: te }, me) => {
    const Me = x[me];
    return Me.connect(A, 0, k + me), Me.start(0), [te, Me.offset];
  }));
  A.connect(E);
  let F = p.channelInterpretation, $ = null;
  const Z = p.numberOfOutputs === 0 ? [E] : V, j = {
    get bufferSize() {
      return I;
    },
    get channelCount() {
      return p.channelCount;
    },
    set channelCount(te) {
      throw n();
    },
    get channelCountMode() {
      return p.channelCountMode;
    },
    set channelCountMode(te) {
      throw n();
    },
    get channelInterpretation() {
      return F;
    },
    set channelInterpretation(te) {
      for (const me of S)
        me.channelInterpretation = te;
      F = te;
    },
    get context() {
      return E.context;
    },
    get inputs() {
      return S;
    },
    get numberOfInputs() {
      return p.numberOfInputs;
    },
    get numberOfOutputs() {
      return p.numberOfOutputs;
    },
    get onprocessorerror() {
      return $;
    },
    set onprocessorerror(te) {
      typeof $ == "function" && j.removeEventListener("processorerror", $), $ = typeof te == "function" ? te : null, typeof $ == "function" && j.addEventListener("processorerror", $);
    },
    get parameters() {
      return N;
    },
    get port() {
      return b.port2;
    },
    addEventListener(...te) {
      return E.addEventListener(te[0], te[1], te[2]);
    },
    connect: e.bind(null, Z),
    disconnect: u.bind(null, Z),
    dispatchEvent(...te) {
      return E.dispatchEvent(te[0]);
    },
    removeEventListener(...te) {
      return E.removeEventListener(te[0], te[1], te[2]);
    }
  }, H = /* @__PURE__ */ new Map();
  b.port1.addEventListener = ((te) => (...me) => {
    if (me[0] === "message") {
      const Me = typeof me[1] == "function" ? me[1] : typeof me[1] == "object" && me[1] !== null && typeof me[1].handleEvent == "function" ? me[1].handleEvent : null;
      if (Me !== null) {
        const Fe = H.get(me[1]);
        Fe !== void 0 ? me[1] = Fe : (me[1] = (xe) => {
          c(h.currentTime, h.sampleRate, () => Me(xe));
        }, H.set(Me, me[1]));
      }
    }
    return te.call(b.port1, me[0], me[1], me[2]);
  })(b.port1.addEventListener), b.port1.removeEventListener = ((te) => (...me) => {
    if (me[0] === "message") {
      const Me = H.get(me[1]);
      Me !== void 0 && (H.delete(me[1]), me[1] = Me);
    }
    return te.call(b.port1, me[0], me[1], me[2]);
  })(b.port1.removeEventListener);
  let R = null;
  Object.defineProperty(b.port1, "onmessage", {
    get: () => R,
    set: (te) => {
      typeof R == "function" && b.port1.removeEventListener("message", R), R = typeof te == "function" ? te : null, typeof R == "function" && (b.port1.addEventListener("message", R), b.port1.start());
    }
  }), g.prototype.port = b.port1;
  let L = null;
  r3(h, j, g, p).then((te) => L = te);
  const oe = Uf(p.numberOfInputs, p.channelCount), we = Uf(p.numberOfOutputs, y), ee = g.parameterDescriptors === void 0 ? [] : g.parameterDescriptors.reduce((te, { name: me }) => ({ ...te, [me]: new Float32Array(128) }), {});
  let K = !0;
  const ue = () => {
    p.numberOfOutputs > 0 && E.disconnect(O);
    for (let te = 0, me = 0; te < p.numberOfOutputs; te += 1) {
      const Me = V[te];
      for (let Fe = 0; Fe < y[te]; Fe += 1)
        O.disconnect(Me, me + Fe, Fe);
      me += y[te];
    }
  }, ve = /* @__PURE__ */ new Map();
  E.onaudioprocess = ({ inputBuffer: te, outputBuffer: me }) => {
    if (L !== null) {
      const Me = d(j);
      for (let Fe = 0; Fe < I; Fe += 128) {
        for (let xe = 0; xe < p.numberOfInputs; xe += 1)
          for (let ze = 0; ze < p.channelCount; ze += 1)
            zf(te, oe[xe], ze, ze, Fe);
        g.parameterDescriptors !== void 0 && g.parameterDescriptors.forEach(({ name: xe }, ze) => {
          zf(te, ee, xe, k + ze, Fe);
        });
        for (let xe = 0; xe < p.numberOfInputs; xe += 1)
          for (let ze = 0; ze < y[xe]; ze += 1)
            we[xe][ze].byteLength === 0 && (we[xe][ze] = new Float32Array(128));
        try {
          const xe = oe.map((Ke, ut) => {
            if (Me[ut].size > 0)
              return ve.set(ut, I / 128), Ke;
            const En = ve.get(ut);
            return En === void 0 ? [] : (Ke.every((On) => On.every((Vr) => Vr === 0)) && (En === 1 ? ve.delete(ut) : ve.set(ut, En - 1)), Ke);
          });
          K = c(h.currentTime + Fe / h.sampleRate, h.sampleRate, () => L.process(xe, we, ee));
          for (let Ke = 0, ut = 0; Ke < p.numberOfOutputs; Ke += 1) {
            for (let vt = 0; vt < y[Ke]; vt += 1)
              $1(me, we[Ke], vt, ut + vt, Fe);
            ut += y[Ke];
          }
        } catch (xe) {
          K = !1, j.dispatchEvent(new ErrorEvent("processorerror", {
            colno: xe.colno,
            filename: xe.filename,
            lineno: xe.lineno,
            message: xe.message
          }));
        }
        if (!K) {
          for (let xe = 0; xe < p.numberOfInputs; xe += 1) {
            S[xe].disconnect(C[xe]);
            for (let ze = 0; ze < p.channelCount; ze += 1)
              C[Fe].disconnect(A, ze, xe * p.channelCount + ze);
          }
          if (g.parameterDescriptors !== void 0) {
            const xe = g.parameterDescriptors.length;
            for (let ze = 0; ze < xe; ze += 1) {
              const Ke = x[ze];
              Ke.disconnect(A, 0, k + ze), Ke.stop();
            }
          }
          A.disconnect(E), E.onaudioprocess = null, Re ? ue() : le();
          break;
        }
      }
    }
  };
  let Re = !1;
  const he = a(h, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  }), Pe = () => E.connect(he).connect(h.destination), le = () => {
    E.disconnect(he), he.disconnect();
  }, be = () => {
    if (K) {
      le(), p.numberOfOutputs > 0 && E.connect(O);
      for (let te = 0, me = 0; te < p.numberOfOutputs; te += 1) {
        const Me = V[te];
        for (let Fe = 0; Fe < y[te]; Fe += 1)
          O.connect(Me, me + Fe, Fe);
        me += y[te];
      }
    }
    Re = !0;
  }, Oe = () => {
    K && (Pe(), ue()), Re = !1;
  };
  return Pe(), f(j, be, Oe);
}, H1 = (e, t) => {
  const n = e.createBiquadFilter();
  return gn(n, t), Kt(n, t, "Q"), Kt(n, t, "detune"), Kt(n, t, "frequency"), Kt(n, t, "gain"), $t(n, t, "type"), n;
}, a3 = (e, t) => (n, i) => {
  const r = n.createChannelMerger(i.numberOfInputs);
  return e !== null && e.name === "webkitAudioContext" && t(n, r), gn(r, i), r;
}, o3 = (e) => {
  const t = e.numberOfOutputs;
  Object.defineProperty(e, "channelCount", {
    get: () => t,
    set: (n) => {
      if (n !== t)
        throw Tn();
    }
  }), Object.defineProperty(e, "channelCountMode", {
    get: () => "explicit",
    set: (n) => {
      if (n !== "explicit")
        throw Tn();
    }
  }), Object.defineProperty(e, "channelInterpretation", {
    get: () => "discrete",
    set: (n) => {
      if (n !== "discrete")
        throw Tn();
    }
  });
}, Kc = (e, t) => {
  const n = e.createChannelSplitter(t.numberOfOutputs);
  return gn(n, t), o3(n), n;
}, l3 = (e, t, n, i, r) => (s, a) => {
  if (s.createConstantSource === void 0)
    return n(s, a);
  const o = s.createConstantSource();
  return gn(o, a), Kt(o, a, "offset"), t(i, () => i(s)) || Iy(o), t(r, () => r(s)) || Ey(o), e(s, o), o;
}, Xl = (e, t) => (e.connect = t.connect.bind(t), e.disconnect = t.disconnect.bind(t), e), u3 = (e, t, n, i) => (r, { offset: s, ...a }) => {
  const o = r.createBuffer(1, 2, 44100), l = t(r, {
    buffer: null,
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    loop: !1,
    loopEnd: 0,
    loopStart: 0,
    playbackRate: 1
  }), u = n(r, { ...a, gain: s }), c = o.getChannelData(0);
  c[0] = 1, c[1] = 1, l.buffer = o, l.loop = !0;
  const d = {
    get bufferSize() {
    },
    get channelCount() {
      return u.channelCount;
    },
    set channelCount(m) {
      u.channelCount = m;
    },
    get channelCountMode() {
      return u.channelCountMode;
    },
    set channelCountMode(m) {
      u.channelCountMode = m;
    },
    get channelInterpretation() {
      return u.channelInterpretation;
    },
    set channelInterpretation(m) {
      u.channelInterpretation = m;
    },
    get context() {
      return u.context;
    },
    get inputs() {
      return [];
    },
    get numberOfInputs() {
      return l.numberOfInputs;
    },
    get numberOfOutputs() {
      return u.numberOfOutputs;
    },
    get offset() {
      return u.gain;
    },
    get onended() {
      return l.onended;
    },
    set onended(m) {
      l.onended = m;
    },
    addEventListener(...m) {
      return l.addEventListener(m[0], m[1], m[2]);
    },
    dispatchEvent(...m) {
      return l.dispatchEvent(m[0]);
    },
    removeEventListener(...m) {
      return l.removeEventListener(m[0], m[1], m[2]);
    },
    start(m = 0) {
      l.start.call(l, m);
    },
    stop(m = 0) {
      l.stop.call(l, m);
    }
  }, f = () => l.connect(u), h = () => l.disconnect(u);
  return e(r, l), i(Xl(d, u), f, h);
}, c3 = (e, t) => (n, i) => {
  const r = n.createConvolver();
  if (gn(r, i), i.disableNormalization === r.normalize && (r.normalize = !i.disableNormalization), $t(r, i, "buffer"), i.channelCount > 2 || (t(r, "channelCount", (s) => () => s.call(r), (s) => (a) => {
    if (a > 2)
      throw e();
    return s.call(r, a);
  }), i.channelCountMode === "max"))
    throw e();
  return t(r, "channelCountMode", (s) => () => s.call(r), (s) => (a) => {
    if (a === "max")
      throw e();
    return s.call(r, a);
  }), r;
}, z1 = (e, t) => {
  const n = e.createDelay(t.maxDelayTime);
  return gn(n, t), Kt(n, t, "delayTime"), n;
}, d3 = (e) => (t, n) => {
  const i = t.createDynamicsCompressor();
  if (gn(i, n), n.channelCount > 2 || n.channelCountMode === "max")
    throw e();
  return Kt(i, n, "attack"), Kt(i, n, "knee"), Kt(i, n, "ratio"), Kt(i, n, "release"), Kt(i, n, "threshold"), i;
}, yi = (e, t) => {
  const n = e.createGain();
  return gn(n, t), Kt(n, t, "gain"), n;
}, f3 = (e) => (t, n, i) => {
  if (t.createIIRFilter === void 0)
    return e(t, n, i);
  const r = t.createIIRFilter(i.feedforward, i.feedback);
  return gn(r, i), r;
};
function h3(e, t) {
  const n = t[0] * t[0] + t[1] * t[1];
  return [(e[0] * t[0] + e[1] * t[1]) / n, (e[1] * t[0] - e[0] * t[1]) / n];
}
function m3(e, t) {
  return [e[0] * t[0] - e[1] * t[1], e[0] * t[1] + e[1] * t[0]];
}
function b_(e, t) {
  let n = [0, 0];
  for (let i = e.length - 1; i >= 0; i -= 1)
    n = m3(n, t), n[0] += e[i];
  return n;
}
const v3 = (e, t, n, i) => (r, s, { channelCount: a, channelCountMode: o, channelInterpretation: l, feedback: u, feedforward: c }) => {
  const d = j1(s, r.sampleRate), f = u instanceof Float64Array ? u : new Float64Array(u), h = c instanceof Float64Array ? c : new Float64Array(c), m = f.length, g = h.length, p = Math.min(m, g);
  if (m === 0 || m > 20)
    throw i();
  if (f[0] === 0)
    throw t();
  if (g === 0 || g > 20)
    throw i();
  if (h[0] === 0)
    throw t();
  if (f[0] !== 1) {
    for (let x = 0; x < g; x += 1)
      h[x] /= f[0];
    for (let x = 1; x < m; x += 1)
      f[x] /= f[0];
  }
  const y = n(r, d, a, a);
  y.channelCount = a, y.channelCountMode = o, y.channelInterpretation = l;
  const k = 32, T = [], _ = [], b = [];
  for (let x = 0; x < a; x += 1) {
    T.push(0);
    const A = new Float32Array(k), I = new Float32Array(k);
    A.fill(0), I.fill(0), _.push(A), b.push(I);
  }
  y.onaudioprocess = (x) => {
    const A = x.inputBuffer, I = x.outputBuffer, E = A.numberOfChannels;
    for (let O = 0; O < E; O += 1) {
      const V = A.getChannelData(O), N = I.getChannelData(O);
      T[O] = W1(f, m, h, g, p, _[O], b[O], T[O], k, V, N);
    }
  };
  const S = r.sampleRate / 2;
  return Xl({
    get bufferSize() {
      return d;
    },
    get channelCount() {
      return y.channelCount;
    },
    set channelCount(x) {
      y.channelCount = x;
    },
    get channelCountMode() {
      return y.channelCountMode;
    },
    set channelCountMode(x) {
      y.channelCountMode = x;
    },
    get channelInterpretation() {
      return y.channelInterpretation;
    },
    set channelInterpretation(x) {
      y.channelInterpretation = x;
    },
    get context() {
      return y.context;
    },
    get inputs() {
      return [y];
    },
    get numberOfInputs() {
      return y.numberOfInputs;
    },
    get numberOfOutputs() {
      return y.numberOfOutputs;
    },
    addEventListener(...x) {
      return y.addEventListener(x[0], x[1], x[2]);
    },
    dispatchEvent(...x) {
      return y.dispatchEvent(x[0]);
    },
    getFrequencyResponse(x, A, I) {
      if (x.length !== A.length || A.length !== I.length)
        throw e();
      const E = x.length;
      for (let O = 0; O < E; O += 1) {
        const V = -Math.PI * (x[O] / S), N = [Math.cos(V), Math.sin(V)], F = b_(h, N), $ = b_(f, N), Z = h3(F, $);
        A[O] = Math.sqrt(Z[0] * Z[0] + Z[1] * Z[1]), I[O] = Math.atan2(Z[1], Z[0]);
      }
    },
    removeEventListener(...x) {
      return y.removeEventListener(x[0], x[1], x[2]);
    }
  }, y);
}, g3 = (e, t) => e.createMediaElementSource(t.mediaElement), p3 = (e, t) => {
  const n = e.createMediaStreamDestination();
  return gn(n, t), n.numberOfOutputs === 1 && Object.defineProperty(n, "numberOfOutputs", { get: () => 0 }), n;
}, y3 = (e, { mediaStream: t }) => {
  const n = t.getAudioTracks();
  n.sort((s, a) => s.id < a.id ? -1 : s.id > a.id ? 1 : 0);
  const i = n.slice(0, 1), r = e.createMediaStreamSource(new MediaStream(i));
  return Object.defineProperty(r, "mediaStream", { value: t }), r;
}, b3 = (e, t) => (n, { mediaStreamTrack: i }) => {
  if (typeof n.createMediaStreamTrackSource == "function")
    return n.createMediaStreamTrackSource(i);
  const r = new MediaStream([i]), s = n.createMediaStreamSource(r);
  if (i.kind !== "audio")
    throw e();
  if (t(n))
    throw new TypeError();
  return s;
}, w3 = (e) => e === null ? null : e.hasOwnProperty("OfflineAudioContext") ? e.OfflineAudioContext : e.hasOwnProperty("webkitOfflineAudioContext") ? e.webkitOfflineAudioContext : null, _3 = (e, t, n, i, r, s) => (a, o) => {
  const l = a.createOscillator();
  return gn(l, o), Kt(l, o, "detune"), Kt(l, o, "frequency"), o.periodicWave !== void 0 ? l.setPeriodicWave(o.periodicWave) : $t(l, o, "type"), t(n, () => n(a)) || Iy(l), t(i, () => i(a)) || s(l, a), t(r, () => r(a)) || Ey(l), e(a, l), l;
}, S3 = (e) => (t, n) => {
  const i = t.createPanner();
  return i.orientationX === void 0 ? e(t, n) : (gn(i, n), Kt(i, n, "orientationX"), Kt(i, n, "orientationY"), Kt(i, n, "orientationZ"), Kt(i, n, "positionX"), Kt(i, n, "positionY"), Kt(i, n, "positionZ"), $t(i, n, "coneInnerAngle"), $t(i, n, "coneOuterAngle"), $t(i, n, "coneOuterGain"), $t(i, n, "distanceModel"), $t(i, n, "maxDistance"), $t(i, n, "panningModel"), $t(i, n, "refDistance"), $t(i, n, "rolloffFactor"), i);
}, k3 = (e, t, n, i, r, s, a, o, l, u) => (c, { coneInnerAngle: d, coneOuterAngle: f, coneOuterGain: h, distanceModel: m, maxDistance: g, orientationX: p, orientationY: y, orientationZ: k, panningModel: T, positionX: _, positionY: b, positionZ: S, refDistance: C, rolloffFactor: x, ...A }) => {
  const I = c.createPanner();
  if (A.channelCount > 2 || A.channelCountMode === "max")
    throw a();
  gn(I, A);
  const E = {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete"
  }, O = n(c, {
    ...E,
    channelInterpretation: "speakers",
    numberOfInputs: 6
  }), V = i(c, { ...A, gain: 1 }), N = i(c, { ...E, gain: 1 }), F = i(c, { ...E, gain: 0 }), $ = i(c, { ...E, gain: 0 }), Z = i(c, { ...E, gain: 0 }), j = i(c, { ...E, gain: 0 }), H = i(c, { ...E, gain: 0 }), R = r(c, 256, 6, 1), L = s(c, {
    ...E,
    curve: new Float32Array([1, 1]),
    oversample: "none"
  });
  let ne = [p, y, k], oe = [_, b, S];
  const we = new Float32Array(1);
  R.onaudioprocess = ({ inputBuffer: ve }) => {
    const Re = [
      l(ve, we, 0),
      l(ve, we, 1),
      l(ve, we, 2)
    ];
    Re.some((Pe, le) => Pe !== ne[le]) && (I.setOrientation(...Re), ne = Re);
    const he = [
      l(ve, we, 3),
      l(ve, we, 4),
      l(ve, we, 5)
    ];
    he.some((Pe, le) => Pe !== oe[le]) && (I.setPosition(...he), oe = he);
  }, Object.defineProperty(F.gain, "defaultValue", { get: () => 0 }), Object.defineProperty($.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(Z.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(j.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(H.gain, "defaultValue", { get: () => 0 });
  const ee = {
    get bufferSize() {
    },
    get channelCount() {
      return I.channelCount;
    },
    set channelCount(ve) {
      if (ve > 2)
        throw a();
      V.channelCount = ve, I.channelCount = ve;
    },
    get channelCountMode() {
      return I.channelCountMode;
    },
    set channelCountMode(ve) {
      if (ve === "max")
        throw a();
      V.channelCountMode = ve, I.channelCountMode = ve;
    },
    get channelInterpretation() {
      return I.channelInterpretation;
    },
    set channelInterpretation(ve) {
      V.channelInterpretation = ve, I.channelInterpretation = ve;
    },
    get coneInnerAngle() {
      return I.coneInnerAngle;
    },
    set coneInnerAngle(ve) {
      I.coneInnerAngle = ve;
    },
    get coneOuterAngle() {
      return I.coneOuterAngle;
    },
    set coneOuterAngle(ve) {
      I.coneOuterAngle = ve;
    },
    get coneOuterGain() {
      return I.coneOuterGain;
    },
    set coneOuterGain(ve) {
      if (ve < 0 || ve > 1)
        throw t();
      I.coneOuterGain = ve;
    },
    get context() {
      return I.context;
    },
    get distanceModel() {
      return I.distanceModel;
    },
    set distanceModel(ve) {
      I.distanceModel = ve;
    },
    get inputs() {
      return [V];
    },
    get maxDistance() {
      return I.maxDistance;
    },
    set maxDistance(ve) {
      if (ve < 0)
        throw new RangeError();
      I.maxDistance = ve;
    },
    get numberOfInputs() {
      return I.numberOfInputs;
    },
    get numberOfOutputs() {
      return I.numberOfOutputs;
    },
    get orientationX() {
      return N.gain;
    },
    get orientationY() {
      return F.gain;
    },
    get orientationZ() {
      return $.gain;
    },
    get panningModel() {
      return I.panningModel;
    },
    set panningModel(ve) {
      I.panningModel = ve;
    },
    get positionX() {
      return Z.gain;
    },
    get positionY() {
      return j.gain;
    },
    get positionZ() {
      return H.gain;
    },
    get refDistance() {
      return I.refDistance;
    },
    set refDistance(ve) {
      if (ve < 0)
        throw new RangeError();
      I.refDistance = ve;
    },
    get rolloffFactor() {
      return I.rolloffFactor;
    },
    set rolloffFactor(ve) {
      if (ve < 0)
        throw new RangeError();
      I.rolloffFactor = ve;
    },
    addEventListener(...ve) {
      return V.addEventListener(ve[0], ve[1], ve[2]);
    },
    dispatchEvent(...ve) {
      return V.dispatchEvent(ve[0]);
    },
    removeEventListener(...ve) {
      return V.removeEventListener(ve[0], ve[1], ve[2]);
    }
  };
  d !== ee.coneInnerAngle && (ee.coneInnerAngle = d), f !== ee.coneOuterAngle && (ee.coneOuterAngle = f), h !== ee.coneOuterGain && (ee.coneOuterGain = h), m !== ee.distanceModel && (ee.distanceModel = m), g !== ee.maxDistance && (ee.maxDistance = g), p !== ee.orientationX.value && (ee.orientationX.value = p), y !== ee.orientationY.value && (ee.orientationY.value = y), k !== ee.orientationZ.value && (ee.orientationZ.value = k), T !== ee.panningModel && (ee.panningModel = T), _ !== ee.positionX.value && (ee.positionX.value = _), b !== ee.positionY.value && (ee.positionY.value = b), S !== ee.positionZ.value && (ee.positionZ.value = S), C !== ee.refDistance && (ee.refDistance = C), x !== ee.rolloffFactor && (ee.rolloffFactor = x), (ne[0] !== 1 || ne[1] !== 0 || ne[2] !== 0) && I.setOrientation(...ne), (oe[0] !== 0 || oe[1] !== 0 || oe[2] !== 0) && I.setPosition(...oe);
  const K = () => {
    V.connect(I), e(V, L, 0, 0), L.connect(N).connect(O, 0, 0), L.connect(F).connect(O, 0, 1), L.connect($).connect(O, 0, 2), L.connect(Z).connect(O, 0, 3), L.connect(j).connect(O, 0, 4), L.connect(H).connect(O, 0, 5), O.connect(R).connect(c.destination);
  }, ue = () => {
    V.disconnect(I), o(V, L, 0, 0), L.disconnect(N), N.disconnect(O), L.disconnect(F), F.disconnect(O), L.disconnect($), $.disconnect(O), L.disconnect(Z), Z.disconnect(O), L.disconnect(j), j.disconnect(O), L.disconnect(H), H.disconnect(O), O.disconnect(R), R.disconnect(c.destination);
  };
  return u(Xl(ee, I), K, ue);
}, C3 = (e) => (t, { disableNormalization: n, imag: i, real: r }) => {
  const s = i instanceof Float32Array ? i : new Float32Array(i), a = r instanceof Float32Array ? r : new Float32Array(r), o = t.createPeriodicWave(a, s, { disableNormalization: n });
  if (Array.from(i).length < 2)
    throw e();
  return o;
}, Xc = (e, t, n, i) => e.createScriptProcessor(t, n, i), T3 = (e, t) => (n, i) => {
  const r = i.channelCountMode;
  if (r === "clamped-max")
    throw t();
  if (n.createStereoPanner === void 0)
    return e(n, i);
  const s = n.createStereoPanner();
  return gn(s, i), Kt(s, i, "pan"), Object.defineProperty(s, "channelCountMode", {
    get: () => r,
    set: (a) => {
      if (a !== r)
        throw t();
    }
  }), s;
}, x3 = (e, t, n, i, r, s) => {
  const o = new Float32Array([1, 1]), l = Math.PI / 2, u = { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete" }, c = { ...u, oversample: "none" }, d = (m, g, p, y) => {
    const k = new Float32Array(16385), T = new Float32Array(16385);
    for (let A = 0; A < 16385; A += 1) {
      const I = A / 16384 * l;
      k[A] = Math.cos(I), T[A] = Math.sin(I);
    }
    const _ = n(m, { ...u, gain: 0 }), b = i(m, { ...c, curve: k }), S = i(m, { ...c, curve: o }), C = n(m, { ...u, gain: 0 }), x = i(m, { ...c, curve: T });
    return {
      connectGraph() {
        g.connect(_), g.connect(S.inputs === void 0 ? S : S.inputs[0]), g.connect(C), S.connect(p), p.connect(b.inputs === void 0 ? b : b.inputs[0]), p.connect(x.inputs === void 0 ? x : x.inputs[0]), b.connect(_.gain), x.connect(C.gain), _.connect(y, 0, 0), C.connect(y, 0, 1);
      },
      disconnectGraph() {
        g.disconnect(_), g.disconnect(S.inputs === void 0 ? S : S.inputs[0]), g.disconnect(C), S.disconnect(p), p.disconnect(b.inputs === void 0 ? b : b.inputs[0]), p.disconnect(x.inputs === void 0 ? x : x.inputs[0]), b.disconnect(_.gain), x.disconnect(C.gain), _.disconnect(y, 0, 0), C.disconnect(y, 0, 1);
      }
    };
  }, f = (m, g, p, y) => {
    const k = new Float32Array(16385), T = new Float32Array(16385), _ = new Float32Array(16385), b = new Float32Array(16385), S = Math.floor(16385 / 2);
    for (let Z = 0; Z < 16385; Z += 1)
      if (Z > S) {
        const j = (Z - S) / (16384 - S) * l;
        k[Z] = Math.cos(j), T[Z] = Math.sin(j), _[Z] = 0, b[Z] = 1;
      } else {
        const j = Z / (16384 - S) * l;
        k[Z] = 1, T[Z] = 0, _[Z] = Math.cos(j), b[Z] = Math.sin(j);
      }
    const C = t(m, {
      channelCount: 2,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      numberOfOutputs: 2
    }), x = n(m, { ...u, gain: 0 }), A = i(m, {
      ...c,
      curve: k
    }), I = n(m, { ...u, gain: 0 }), E = i(m, {
      ...c,
      curve: T
    }), O = i(m, { ...c, curve: o }), V = n(m, { ...u, gain: 0 }), N = i(m, {
      ...c,
      curve: _
    }), F = n(m, { ...u, gain: 0 }), $ = i(m, {
      ...c,
      curve: b
    });
    return {
      connectGraph() {
        g.connect(C), g.connect(O.inputs === void 0 ? O : O.inputs[0]), C.connect(x, 0), C.connect(I, 0), C.connect(V, 1), C.connect(F, 1), O.connect(p), p.connect(A.inputs === void 0 ? A : A.inputs[0]), p.connect(E.inputs === void 0 ? E : E.inputs[0]), p.connect(N.inputs === void 0 ? N : N.inputs[0]), p.connect($.inputs === void 0 ? $ : $.inputs[0]), A.connect(x.gain), E.connect(I.gain), N.connect(V.gain), $.connect(F.gain), x.connect(y, 0, 0), V.connect(y, 0, 0), I.connect(y, 0, 1), F.connect(y, 0, 1);
      },
      disconnectGraph() {
        g.disconnect(C), g.disconnect(O.inputs === void 0 ? O : O.inputs[0]), C.disconnect(x, 0), C.disconnect(I, 0), C.disconnect(V, 1), C.disconnect(F, 1), O.disconnect(p), p.disconnect(A.inputs === void 0 ? A : A.inputs[0]), p.disconnect(E.inputs === void 0 ? E : E.inputs[0]), p.disconnect(N.inputs === void 0 ? N : N.inputs[0]), p.disconnect($.inputs === void 0 ? $ : $.inputs[0]), A.disconnect(x.gain), E.disconnect(I.gain), N.disconnect(V.gain), $.disconnect(F.gain), x.disconnect(y, 0, 0), V.disconnect(y, 0, 0), I.disconnect(y, 0, 1), F.disconnect(y, 0, 1);
      }
    };
  }, h = (m, g, p, y, k) => {
    if (g === 1)
      return d(m, p, y, k);
    if (g === 2)
      return f(m, p, y, k);
    throw r();
  };
  return (m, { channelCount: g, channelCountMode: p, pan: y, ...k }) => {
    if (p === "max")
      throw r();
    const T = e(m, {
      ...k,
      channelCount: 1,
      channelCountMode: p,
      numberOfInputs: 2
    }), _ = n(m, { ...k, channelCount: g, channelCountMode: p, gain: 1 }), b = n(m, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      gain: y
    });
    let { connectGraph: S, disconnectGraph: C } = h(m, g, _, b, T);
    Object.defineProperty(b.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(b.gain, "maxValue", { get: () => 1 }), Object.defineProperty(b.gain, "minValue", { get: () => -1 });
    const x = {
      get bufferSize() {
      },
      get channelCount() {
        return _.channelCount;
      },
      set channelCount(O) {
        _.channelCount !== O && (A && C(), { connectGraph: S, disconnectGraph: C } = h(m, O, _, b, T), A && S()), _.channelCount = O;
      },
      get channelCountMode() {
        return _.channelCountMode;
      },
      set channelCountMode(O) {
        if (O === "clamped-max" || O === "max")
          throw r();
        _.channelCountMode = O;
      },
      get channelInterpretation() {
        return _.channelInterpretation;
      },
      set channelInterpretation(O) {
        _.channelInterpretation = O;
      },
      get context() {
        return _.context;
      },
      get inputs() {
        return [_];
      },
      get numberOfInputs() {
        return _.numberOfInputs;
      },
      get numberOfOutputs() {
        return _.numberOfOutputs;
      },
      get pan() {
        return b.gain;
      },
      addEventListener(...O) {
        return _.addEventListener(O[0], O[1], O[2]);
      },
      dispatchEvent(...O) {
        return _.dispatchEvent(O[0]);
      },
      removeEventListener(...O) {
        return _.removeEventListener(O[0], O[1], O[2]);
      }
    };
    let A = !1;
    const I = () => {
      S(), A = !0;
    }, E = () => {
      C(), A = !1;
    };
    return s(Xl(x, T), I, E);
  };
}, A3 = (e, t, n, i, r, s, a) => (o, l) => {
  const u = o.createWaveShaper();
  if (s !== null && s.name === "webkitAudioContext" && o.createGain().gain.automationRate === void 0)
    return n(o, l);
  gn(u, l);
  const c = l.curve === null || l.curve instanceof Float32Array ? l.curve : new Float32Array(l.curve);
  if (c !== null && c.length < 2)
    throw t();
  $t(u, { curve: c }, "curve"), $t(u, l, "oversample");
  let d = null, f = !1;
  return a(u, "curve", (g) => () => g.call(u), (g) => (p) => (g.call(u, p), f && (i(p) && d === null ? d = e(o, u) : !i(p) && d !== null && (d(), d = null)), p)), r(u, () => {
    f = !0, i(u.curve) && (d = e(o, u));
  }, () => {
    f = !1, d !== null && (d(), d = null);
  });
}, I3 = (e, t, n, i, r) => (s, { curve: a, oversample: o, ...l }) => {
  const u = s.createWaveShaper(), c = s.createWaveShaper();
  gn(u, l), gn(c, l);
  const d = n(s, { ...l, gain: 1 }), f = n(s, { ...l, gain: -1 }), h = n(s, { ...l, gain: 1 }), m = n(s, { ...l, gain: -1 });
  let g = null, p = !1, y = null;
  const k = {
    get bufferSize() {
    },
    get channelCount() {
      return u.channelCount;
    },
    set channelCount(b) {
      d.channelCount = b, f.channelCount = b, u.channelCount = b, h.channelCount = b, c.channelCount = b, m.channelCount = b;
    },
    get channelCountMode() {
      return u.channelCountMode;
    },
    set channelCountMode(b) {
      d.channelCountMode = b, f.channelCountMode = b, u.channelCountMode = b, h.channelCountMode = b, c.channelCountMode = b, m.channelCountMode = b;
    },
    get channelInterpretation() {
      return u.channelInterpretation;
    },
    set channelInterpretation(b) {
      d.channelInterpretation = b, f.channelInterpretation = b, u.channelInterpretation = b, h.channelInterpretation = b, c.channelInterpretation = b, m.channelInterpretation = b;
    },
    get context() {
      return u.context;
    },
    get curve() {
      return y;
    },
    set curve(b) {
      if (b !== null && b.length < 2)
        throw t();
      if (b === null)
        u.curve = b, c.curve = b;
      else {
        const S = b.length, C = new Float32Array(S + 2 - S % 2), x = new Float32Array(S + 2 - S % 2);
        C[0] = b[0], x[0] = -b[S - 1];
        const A = Math.ceil((S + 1) / 2), I = (S + 1) / 2 - 1;
        for (let E = 1; E < A; E += 1) {
          const O = E / A * I, V = Math.floor(O), N = Math.ceil(O);
          C[E] = V === N ? b[V] : (1 - (O - V)) * b[V] + (1 - (N - O)) * b[N], x[E] = V === N ? -b[S - 1 - V] : -((1 - (O - V)) * b[S - 1 - V]) - (1 - (N - O)) * b[S - 1 - N];
        }
        C[A] = S % 2 === 1 ? b[A - 1] : (b[A - 2] + b[A - 1]) / 2, u.curve = C, c.curve = x;
      }
      y = b, p && (i(y) && g === null ? g = e(s, d) : g !== null && (g(), g = null));
    },
    get inputs() {
      return [d];
    },
    get numberOfInputs() {
      return u.numberOfInputs;
    },
    get numberOfOutputs() {
      return u.numberOfOutputs;
    },
    get oversample() {
      return u.oversample;
    },
    set oversample(b) {
      u.oversample = b, c.oversample = b;
    },
    addEventListener(...b) {
      return d.addEventListener(b[0], b[1], b[2]);
    },
    dispatchEvent(...b) {
      return d.dispatchEvent(b[0]);
    },
    removeEventListener(...b) {
      return d.removeEventListener(b[0], b[1], b[2]);
    }
  };
  a !== null && (k.curve = a instanceof Float32Array ? a : new Float32Array(a)), o !== k.oversample && (k.oversample = o);
  const T = () => {
    d.connect(u).connect(h), d.connect(f).connect(c).connect(m).connect(h), p = !0, i(y) && (g = e(s, d));
  }, _ = () => {
    d.disconnect(u), u.disconnect(h), d.disconnect(f), f.disconnect(c), c.disconnect(m), m.disconnect(h), p = !1, g !== null && (g(), g = null);
  };
  return r(Xl(k, h), T, _);
}, oi = () => new DOMException("", "NotSupportedError"), E3 = {
  numberOfChannels: 1
}, O3 = (e, t, n, i, r) => class extends e {
  constructor(a, o, l) {
    let u;
    if (typeof a == "number" && o !== void 0 && l !== void 0)
      u = { length: o, numberOfChannels: a, sampleRate: l };
    else if (typeof a == "object")
      u = a;
    else
      throw new Error("The given parameters are not valid.");
    const { length: c, numberOfChannels: d, sampleRate: f } = { ...E3, ...u }, h = i(d, c, f);
    t(ac, () => ac(h)) || h.addEventListener("statechange", (() => {
      let m = 0;
      const g = (p) => {
        this._state === "running" && (m > 0 ? (h.removeEventListener("statechange", g), p.stopImmediatePropagation(), this._waitForThePromiseToSettle(p)) : m += 1);
      };
      return g;
    })()), super(h, d), this._length = c, this._nativeOfflineAudioContext = h, this._state = null;
  }
  get length() {
    return this._nativeOfflineAudioContext.length === void 0 ? this._length : this._nativeOfflineAudioContext.length;
  }
  get state() {
    return this._state === null ? this._nativeOfflineAudioContext.state : this._state;
  }
  startRendering() {
    return this._state === "running" ? Promise.reject(n()) : (this._state = "running", r(this.destination, this._nativeOfflineAudioContext).finally(() => {
      this._state = null, M1(this);
    }));
  }
  _waitForThePromiseToSettle(a) {
    this._state === null ? this._nativeOfflineAudioContext.dispatchEvent(a) : setTimeout(() => this._waitForThePromiseToSettle(a));
  }
}, P3 = {
  channelCount: 2,
  channelCountMode: "max",
  // This attribute has no effect for nodes with no inputs.
  channelInterpretation: "speakers",
  // This attribute has no effect for nodes with no inputs.
  detune: 0,
  frequency: 440,
  periodicWave: void 0,
  type: "sine"
}, V3 = (e, t, n, i, r, s, a) => class extends e {
  constructor(l, u) {
    const c = r(l), d = { ...P3, ...u }, f = n(c, d), h = s(c), m = h ? i() : null, g = l.sampleRate / 2;
    super(l, !1, f, m), this._detune = t(this, h, f.detune, 153600, -153600), this._frequency = t(this, h, f.frequency, g, -g), this._nativeOscillatorNode = f, this._onended = null, this._oscillatorNodeRenderer = m, this._oscillatorNodeRenderer !== null && d.periodicWave !== void 0 && (this._oscillatorNodeRenderer.periodicWave = d.periodicWave);
  }
  get detune() {
    return this._detune;
  }
  get frequency() {
    return this._frequency;
  }
  get onended() {
    return this._onended;
  }
  set onended(l) {
    const u = typeof l == "function" ? a(this, l) : null;
    this._nativeOscillatorNode.onended = u;
    const c = this._nativeOscillatorNode.onended;
    this._onended = c !== null && c === u ? l : c;
  }
  get type() {
    return this._nativeOscillatorNode.type;
  }
  set type(l) {
    this._nativeOscillatorNode.type = l, this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = null);
  }
  setPeriodicWave(l) {
    this._nativeOscillatorNode.setPeriodicWave(l), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = l);
  }
  start(l = 0) {
    if (this._nativeOscillatorNode.start(l), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.start = l), this.context.state !== "closed") {
      Cl(this);
      const u = () => {
        this._nativeOscillatorNode.removeEventListener("ended", u), gs(this) && Gc(this);
      };
      this._nativeOscillatorNode.addEventListener("ended", u);
    }
  }
  stop(l = 0) {
    this._nativeOscillatorNode.stop(l), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.stop = l);
  }
}, D3 = (e, t, n, i, r) => () => {
  const s = /* @__PURE__ */ new WeakMap();
  let a = null, o = null, l = null;
  const u = async (c, d) => {
    let f = n(c);
    const h = Xn(f, d);
    if (!h) {
      const m = {
        channelCount: f.channelCount,
        channelCountMode: f.channelCountMode,
        channelInterpretation: f.channelInterpretation,
        detune: f.detune.value,
        frequency: f.frequency.value,
        periodicWave: a === null ? void 0 : a,
        type: f.type
      };
      f = t(d, m), o !== null && f.start(o), l !== null && f.stop(l);
    }
    return s.set(d, f), h ? (await e(d, c.detune, f.detune), await e(d, c.frequency, f.frequency)) : (await i(d, c.detune, f.detune), await i(d, c.frequency, f.frequency)), await r(c, d, f), f;
  };
  return {
    set periodicWave(c) {
      a = c;
    },
    set start(c) {
      o = c;
    },
    set stop(c) {
      l = c;
    },
    render(c, d) {
      const f = s.get(d);
      return f !== void 0 ? Promise.resolve(f) : u(c, d);
    }
  };
}, N3 = {
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  coneInnerAngle: 360,
  coneOuterAngle: 360,
  coneOuterGain: 0,
  distanceModel: "inverse",
  maxDistance: 1e4,
  orientationX: 1,
  orientationY: 0,
  orientationZ: 0,
  panningModel: "equalpower",
  positionX: 0,
  positionY: 0,
  positionZ: 0,
  refDistance: 1,
  rolloffFactor: 1
}, M3 = (e, t, n, i, r, s, a) => class extends e {
  constructor(l, u) {
    const c = r(l), d = { ...N3, ...u }, f = n(c, d), h = s(c), m = h ? i() : null;
    super(l, !1, f, m), this._nativePannerNode = f, this._orientationX = t(this, h, f.orientationX, ei, mi), this._orientationY = t(this, h, f.orientationY, ei, mi), this._orientationZ = t(this, h, f.orientationZ, ei, mi), this._positionX = t(this, h, f.positionX, ei, mi), this._positionY = t(this, h, f.positionY, ei, mi), this._positionZ = t(this, h, f.positionZ, ei, mi), a(this, 1);
  }
  get coneInnerAngle() {
    return this._nativePannerNode.coneInnerAngle;
  }
  set coneInnerAngle(l) {
    this._nativePannerNode.coneInnerAngle = l;
  }
  get coneOuterAngle() {
    return this._nativePannerNode.coneOuterAngle;
  }
  set coneOuterAngle(l) {
    this._nativePannerNode.coneOuterAngle = l;
  }
  get coneOuterGain() {
    return this._nativePannerNode.coneOuterGain;
  }
  set coneOuterGain(l) {
    this._nativePannerNode.coneOuterGain = l;
  }
  get distanceModel() {
    return this._nativePannerNode.distanceModel;
  }
  set distanceModel(l) {
    this._nativePannerNode.distanceModel = l;
  }
  get maxDistance() {
    return this._nativePannerNode.maxDistance;
  }
  set maxDistance(l) {
    this._nativePannerNode.maxDistance = l;
  }
  get orientationX() {
    return this._orientationX;
  }
  get orientationY() {
    return this._orientationY;
  }
  get orientationZ() {
    return this._orientationZ;
  }
  get panningModel() {
    return this._nativePannerNode.panningModel;
  }
  set panningModel(l) {
    this._nativePannerNode.panningModel = l;
  }
  get positionX() {
    return this._positionX;
  }
  get positionY() {
    return this._positionY;
  }
  get positionZ() {
    return this._positionZ;
  }
  get refDistance() {
    return this._nativePannerNode.refDistance;
  }
  set refDistance(l) {
    this._nativePannerNode.refDistance = l;
  }
  get rolloffFactor() {
    return this._nativePannerNode.rolloffFactor;
  }
  set rolloffFactor(l) {
    this._nativePannerNode.rolloffFactor = l;
  }
}, R3 = (e, t, n, i, r, s, a, o, l, u) => () => {
  const c = /* @__PURE__ */ new WeakMap();
  let d = null;
  const f = async (h, m) => {
    let g = null, p = s(h);
    const y = {
      channelCount: p.channelCount,
      channelCountMode: p.channelCountMode,
      channelInterpretation: p.channelInterpretation
    }, k = {
      ...y,
      coneInnerAngle: p.coneInnerAngle,
      coneOuterAngle: p.coneOuterAngle,
      coneOuterGain: p.coneOuterGain,
      distanceModel: p.distanceModel,
      maxDistance: p.maxDistance,
      panningModel: p.panningModel,
      refDistance: p.refDistance,
      rolloffFactor: p.rolloffFactor
    }, T = Xn(p, m);
    if ("bufferSize" in p)
      g = i(m, { ...y, gain: 1 });
    else if (!T) {
      const _ = {
        ...k,
        orientationX: p.orientationX.value,
        orientationY: p.orientationY.value,
        orientationZ: p.orientationZ.value,
        positionX: p.positionX.value,
        positionY: p.positionY.value,
        positionZ: p.positionZ.value
      };
      p = r(m, _);
    }
    if (c.set(m, g === null ? p : g), g !== null) {
      if (d === null) {
        if (a === null)
          throw new Error("Missing the native OfflineAudioContext constructor.");
        const E = new a(
          6,
          // Bug #17: Safari does not yet expose the length.
          h.context.length,
          m.sampleRate
        ), O = t(E, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "speakers",
          numberOfInputs: 6
        });
        O.connect(E.destination), d = (async () => {
          const V = await Promise.all([
            h.orientationX,
            h.orientationY,
            h.orientationZ,
            h.positionX,
            h.positionY,
            h.positionZ
          ].map(async (N, F) => {
            const $ = n(E, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              offset: F === 0 ? 1 : 0
            });
            return await o(E, N, $.offset), $;
          }));
          for (let N = 0; N < 6; N += 1)
            V[N].connect(O, 0, N), V[N].start(0);
          return u(E);
        })();
      }
      const _ = await d, b = i(m, { ...y, gain: 1 });
      await l(h, m, b);
      const S = [];
      for (let E = 0; E < _.numberOfChannels; E += 1)
        S.push(_.getChannelData(E));
      let C = [S[0][0], S[1][0], S[2][0]], x = [S[3][0], S[4][0], S[5][0]], A = i(m, { ...y, gain: 1 }), I = r(m, {
        ...k,
        orientationX: C[0],
        orientationY: C[1],
        orientationZ: C[2],
        positionX: x[0],
        positionY: x[1],
        positionZ: x[2]
      });
      b.connect(A).connect(I.inputs[0]), I.connect(g);
      for (let E = 128; E < _.length; E += 128) {
        const O = [S[0][E], S[1][E], S[2][E]], V = [S[3][E], S[4][E], S[5][E]];
        if (O.some((N, F) => N !== C[F]) || V.some((N, F) => N !== x[F])) {
          C = O, x = V;
          const N = E / m.sampleRate;
          A.gain.setValueAtTime(0, N), A = i(m, { ...y, gain: 0 }), I = r(m, {
            ...k,
            orientationX: C[0],
            orientationY: C[1],
            orientationZ: C[2],
            positionX: x[0],
            positionY: x[1],
            positionZ: x[2]
          }), A.gain.setValueAtTime(1, N), b.connect(A).connect(I.inputs[0]), I.connect(g);
        }
      }
      return g;
    }
    return T ? (await e(m, h.orientationX, p.orientationX), await e(m, h.orientationY, p.orientationY), await e(m, h.orientationZ, p.orientationZ), await e(m, h.positionX, p.positionX), await e(m, h.positionY, p.positionY), await e(m, h.positionZ, p.positionZ)) : (await o(m, h.orientationX, p.orientationX), await o(m, h.orientationY, p.orientationY), await o(m, h.orientationZ, p.orientationZ), await o(m, h.positionX, p.positionX), await o(m, h.positionY, p.positionY), await o(m, h.positionZ, p.positionZ)), Kl(p) ? await l(h, m, p.inputs[0]) : await l(h, m, p), p;
  };
  return {
    render(h, m) {
      const g = c.get(m);
      return g !== void 0 ? Promise.resolve(g) : f(h, m);
    }
  };
}, F3 = {
  disableNormalization: !1
}, B3 = (e, t, n, i) => class U1 {
  constructor(s, a) {
    const o = t(s), l = i({ ...F3, ...a }), u = e(o, l);
    return n.add(u), u;
  }
  static [Symbol.hasInstance](s) {
    return s !== null && typeof s == "object" && Object.getPrototypeOf(s) === U1.prototype || n.has(s);
  }
}, L3 = (e, t) => (n, i, r) => (e(i).replay(r), t(i, n, r)), $3 = (e, t, n) => async (i, r, s) => {
  const a = e(i);
  await Promise.all(a.activeInputs.map((o, l) => Array.from(o).map(async ([u, c]) => {
    const f = await t(u).render(u, r), h = i.context.destination;
    !n(u) && (i !== h || !n(i)) && f.connect(s, c, l);
  })).reduce((o, l) => [...o, ...l], []));
}, W3 = (e, t, n) => async (i, r, s) => {
  const a = t(i);
  await Promise.all(Array.from(a.activeInputs).map(async ([o, l]) => {
    const c = await e(o).render(o, r);
    n(o) || c.connect(s, l);
  }));
}, j3 = (e, t, n, i) => (r) => e(ac, () => ac(r)) ? Promise.resolve(e(i, i)).then((s) => {
  if (!s) {
    const a = n(r, 512, 0, 1);
    r.oncomplete = () => {
      a.onaudioprocess = null, a.disconnect();
    }, a.onaudioprocess = () => r.currentTime, a.connect(r.destination);
  }
  return r.startRendering();
}) : new Promise((s) => {
  const a = t(r, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  });
  r.oncomplete = (o) => {
    a.disconnect(), s(o.renderedBuffer);
  }, a.connect(r.destination), r.startRendering();
}), H3 = (e) => (t, n) => {
  e.set(t, n);
}, z3 = (e) => (t, n) => e.set(t, n), U3 = (e, t, n, i, r, s, a, o) => (l, u) => n(l).render(l, u).then(() => Promise.all(Array.from(i(u)).map((c) => n(c).render(c, u)))).then(() => r(u)).then((c) => (typeof c.copyFromChannel != "function" ? (a(c), Ty(c)) : t(s, () => s(c)) || o(c), e.add(c), c)), q3 = {
  channelCount: 2,
  /*
   * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent
   * behavior.
   */
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  pan: 0
}, G3 = (e, t, n, i, r, s) => class extends e {
  constructor(o, l) {
    const u = r(o), c = { ...q3, ...l }, d = n(u, c), f = s(u), h = f ? i() : null;
    super(o, !1, d, h), this._pan = t(this, f, d.pan);
  }
  get pan() {
    return this._pan;
  }
}, Y3 = (e, t, n, i, r) => () => {
  const s = /* @__PURE__ */ new WeakMap(), a = async (o, l) => {
    let u = n(o);
    const c = Xn(u, l);
    if (!c) {
      const d = {
        channelCount: u.channelCount,
        channelCountMode: u.channelCountMode,
        channelInterpretation: u.channelInterpretation,
        pan: u.pan.value
      };
      u = t(l, d);
    }
    return s.set(l, u), c ? await e(l, o.pan, u.pan) : await i(l, o.pan, u.pan), Kl(u) ? await r(o, l, u.inputs[0]) : await r(o, l, u), u;
  };
  return {
    render(o, l) {
      const u = s.get(l);
      return u !== void 0 ? Promise.resolve(u) : a(o, l);
    }
  };
}, Z3 = (e) => () => {
  if (e === null)
    return !1;
  try {
    new e({ length: 1, sampleRate: 44100 });
  } catch {
    return !1;
  }
  return !0;
}, K3 = (e, t) => async () => {
  if (e === null)
    return !0;
  if (t === null)
    return !1;
  const n = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'], {
    type: "application/javascript; charset=utf-8"
  }), i = new t(1, 128, 44100), r = URL.createObjectURL(n);
  let s = !1, a = !1;
  try {
    await i.audioWorklet.addModule(r);
    const o = new e(i, "a", { numberOfOutputs: 0 }), l = i.createOscillator();
    o.port.onmessage = () => s = !0, o.onprocessorerror = () => a = !0, l.connect(o), l.start(0), await i.startRendering(), await new Promise((u) => setTimeout(u));
  } catch {
  } finally {
    URL.revokeObjectURL(r);
  }
  return s && !a;
}, X3 = (e, t) => () => {
  if (t === null)
    return Promise.resolve(!1);
  const n = new t(1, 1, 44100), i = e(n, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  });
  return new Promise((r) => {
    n.oncomplete = () => {
      i.disconnect(), r(n.currentTime !== 0);
    }, n.startRendering();
  });
}, J3 = () => new DOMException("", "UnknownError"), Q3 = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  curve: null,
  oversample: "none"
}, ez = (e, t, n, i, r, s, a) => class extends e {
  constructor(l, u) {
    const c = r(l), d = { ...Q3, ...u }, f = n(c, d), m = s(c) ? i() : null;
    super(l, !0, f, m), this._isCurveNullified = !1, this._nativeWaveShaperNode = f, a(this, 1);
  }
  get curve() {
    return this._isCurveNullified ? null : this._nativeWaveShaperNode.curve;
  }
  set curve(l) {
    if (l === null)
      this._isCurveNullified = !0, this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
    else {
      if (l.length < 2)
        throw t();
      this._isCurveNullified = !1, this._nativeWaveShaperNode.curve = l;
    }
  }
  get oversample() {
    return this._nativeWaveShaperNode.oversample;
  }
  set oversample(l) {
    this._nativeWaveShaperNode.oversample = l;
  }
}, tz = (e, t, n) => () => {
  const i = /* @__PURE__ */ new WeakMap(), r = async (s, a) => {
    let o = t(s);
    if (!Xn(o, a)) {
      const u = {
        channelCount: o.channelCount,
        channelCountMode: o.channelCountMode,
        channelInterpretation: o.channelInterpretation,
        curve: o.curve,
        oversample: o.oversample
      };
      o = e(a, u);
    }
    return i.set(a, o), Kl(o) ? await n(s, a, o.inputs[0]) : await n(s, a, o), o;
  };
  return {
    render(s, a) {
      const o = i.get(a);
      return o !== void 0 ? Promise.resolve(o) : r(s, a);
    }
  };
}, nz = () => typeof window > "u" ? null : window, iz = (e, t) => (n) => {
  n.copyFromChannel = (i, r, s = 0) => {
    const a = e(s), o = e(r);
    if (o >= n.numberOfChannels)
      throw t();
    const l = n.length, u = n.getChannelData(o), c = i.length;
    for (let d = a < 0 ? -a : 0; d + a < l && d < c; d += 1)
      i[d] = u[d + a];
  }, n.copyToChannel = (i, r, s = 0) => {
    const a = e(s), o = e(r);
    if (o >= n.numberOfChannels)
      throw t();
    const l = n.length, u = n.getChannelData(o), c = i.length;
    for (let d = a < 0 ? -a : 0; d + a < l && d < c; d += 1)
      u[d + a] = i[d];
  };
}, rz = (e) => (t) => {
  t.copyFromChannel = ((n) => (i, r, s = 0) => {
    const a = e(s), o = e(r);
    if (a < t.length)
      return n.call(t, i, o, a);
  })(t.copyFromChannel), t.copyToChannel = ((n) => (i, r, s = 0) => {
    const a = e(s), o = e(r);
    if (a < t.length)
      return n.call(t, i, o, a);
  })(t.copyToChannel);
}, sz = (e) => (t, n) => {
  const i = n.createBuffer(1, 1, 44100);
  t.buffer === null && (t.buffer = i), e(t, "buffer", (r) => () => {
    const s = r.call(t);
    return s === i ? null : s;
  }, (r) => (s) => r.call(t, s === null ? i : s));
}, az = (e, t) => (n, i) => {
  i.channelCount = 1, i.channelCountMode = "explicit", Object.defineProperty(i, "channelCount", {
    get: () => 1,
    set: () => {
      throw e();
    }
  }), Object.defineProperty(i, "channelCountMode", {
    get: () => "explicit",
    set: () => {
      throw e();
    }
  });
  const r = n.createBufferSource();
  t(i, () => {
    const o = i.numberOfInputs;
    for (let l = 0; l < o; l += 1)
      r.connect(i, 0, l);
  }, () => r.disconnect(i));
}, q1 = (e, t, n) => e.copyFromChannel === void 0 ? e.getChannelData(n)[0] : (e.copyFromChannel(t, n), t[0]), G1 = (e) => {
  if (e === null)
    return !1;
  const t = e.length;
  return t % 2 !== 0 ? e[Math.floor(t / 2)] !== 0 : e[t / 2 - 1] + e[t / 2] !== 0;
}, Jc = (e, t, n, i) => {
  let r = e;
  for (; !r.hasOwnProperty(t); )
    r = Object.getPrototypeOf(r);
  const { get: s, set: a } = Object.getOwnPropertyDescriptor(r, t);
  Object.defineProperty(e, t, { get: n(s), set: i(a) });
}, oz = (e) => ({
  ...e,
  outputChannelCount: e.outputChannelCount !== void 0 ? e.outputChannelCount : e.numberOfInputs === 1 && e.numberOfOutputs === 1 ? (
    /*
     * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why
     * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That
     * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.
     */
    [e.channelCount]
  ) : Array.from({ length: e.numberOfOutputs }, () => 1)
}), lz = (e) => ({ ...e, channelCount: e.numberOfOutputs }), uz = (e) => {
  const { imag: t, real: n } = e;
  return t === void 0 ? n === void 0 ? { ...e, imag: [0, 0], real: [0, 0] } : { ...e, imag: Array.from(n, () => 0), real: n } : n === void 0 ? { ...e, imag: t, real: Array.from(t, () => 0) } : { ...e, imag: t, real: n };
}, Y1 = (e, t, n) => {
  try {
    e.setValueAtTime(t, n);
  } catch (i) {
    if (i.code !== 9)
      throw i;
    Y1(e, t, n + 1e-7);
  }
}, cz = (e) => {
  const t = e.createBufferSource();
  t.start();
  try {
    t.start();
  } catch {
    return !0;
  }
  return !1;
}, dz = (e) => {
  const t = e.createBufferSource(), n = e.createBuffer(1, 1, 44100);
  t.buffer = n;
  try {
    t.start(0, 1);
  } catch {
    return !1;
  }
  return !0;
}, fz = (e) => {
  const t = e.createBufferSource();
  t.start();
  try {
    t.stop();
  } catch {
    return !1;
  }
  return !0;
}, Oy = (e) => {
  const t = e.createOscillator();
  try {
    t.start(-1);
  } catch (n) {
    return n instanceof RangeError;
  }
  return !1;
}, Z1 = (e) => {
  const t = e.createBuffer(1, 1, 44100), n = e.createBufferSource();
  n.buffer = t, n.start(), n.stop();
  try {
    return n.stop(), !0;
  } catch {
    return !1;
  }
}, Py = (e) => {
  const t = e.createOscillator();
  try {
    t.stop(-1);
  } catch (n) {
    return n instanceof RangeError;
  }
  return !1;
}, hz = (e) => {
  const { port1: t, port2: n } = new MessageChannel();
  try {
    t.postMessage(e);
  } finally {
    t.close(), n.close();
  }
}, mz = (e) => {
  e.start = ((t) => (n = 0, i = 0, r) => {
    const s = e.buffer, a = s === null ? i : Math.min(s.duration, i);
    s !== null && a > s.duration - 0.5 / e.context.sampleRate ? t.call(e, n, 0, 0) : t.call(e, n, a, r);
  })(e.start);
}, K1 = (e, t) => {
  const n = t.createGain();
  e.connect(n);
  const i = ((r) => () => {
    r.call(e, n), e.removeEventListener("ended", i);
  })(e.disconnect);
  e.addEventListener("ended", i), Xl(e, n), e.stop = ((r) => {
    let s = !1;
    return (a = 0) => {
      if (s)
        try {
          r.call(e, a);
        } catch {
          n.gain.setValueAtTime(0, a);
        }
      else
        r.call(e, a), s = !0;
    };
  })(e.stop);
}, Jl = (e, t) => (n) => {
  const i = { value: e };
  return Object.defineProperties(n, {
    currentTarget: i,
    target: i
  }), typeof t == "function" ? t.call(e, n) : t.handleEvent.call(e, n);
}, vz = Mj(Co), gz = Wj(Co), pz = Q4(Xh), X1 = /* @__PURE__ */ new WeakMap(), yz = pH(X1), Er = E4(/* @__PURE__ */ new Map(), /* @__PURE__ */ new WeakMap()), Ur = nz(), J1 = GH(Er, Xr), Vy = gH(ii), Hn = $3(ii, Vy, no), bz = qj(J1, Mt, Hn), At = wH(Kh), As = w3(Ur), St = FH(As), Q1 = /* @__PURE__ */ new WeakMap(), ex = uH(Jl), Qc = XH(Ur), Dy = DH(Qc), Ny = NH(Ur), tx = MH(Ur), oc = QH(Ur), on = p4(Rj(I1), $j(vz, gz, Wf, pz, jf, ii, yz, qc, Mt, Co, gs, no, nf), Er, IH(yg, jf, ii, Mt, sc, gs), Xr, Jh, oi, Z4(Wf, yg, ii, Mt, sc, At, gs, St), nH(Q1, ii, kr), ex, At, Dy, Ny, tx, St, oc), wz = Uj(on, bz, Xr, J1, At, St), My = /* @__PURE__ */ new WeakSet(), w_ = YH(Ur), nx = j4(new Uint32Array(1)), Ry = iz(nx, Xr), Fy = rz(nx), ix = Yj(My, Er, oi, w_, As, Z3(w_), Ry, Fy), Qh = jj(yi), rx = W3(Vy, Yc, no), Jr = R4(rx), Ql = KH(Qh, Er, cz, dz, fz, Oy, Z1, Py, mz, sz(Jc), K1), Qr = L3(yH(Yc), rx), _z = Xj(Jr, Ql, Mt, Qr, Hn), Or = y4(Fj(E1), Q1, Cy, b4, Ej, Oj, Pj, Vj, Dj, vg, x1, Qc, Y1), Sz = Kj(on, _z, Or, Tn, Ql, At, St, Jl), kz = a4(on, o4, Xr, Tn, JH(yi, Jc), At, St, Hn), Cz = I4(Jr, H1, Mt, Qr, Hn), To = z3(X1), Tz = A4(on, Or, Cz, Jh, H1, At, St, To), ca = UH(Co, Ny), xz = az(Tn, ca), da = a3(Qc, xz), Az = V4(da, Mt, Hn), Iz = P4(on, Az, da, At, St), Ez = M4(Kc, Mt, Hn), Oz = N4(on, Ez, Kc, At, St, lz), Pz = u3(Qh, Ql, yi, ca), eu = l3(Qh, Er, Pz, Oy, Py), Vz = W4(Jr, eu, Mt, Qr, Hn), Dz = $4(on, Or, Vz, eu, At, St, Jl), sx = c3(oi, Jc), Nz = U4(sx, Mt, Hn), Mz = z4(on, Nz, sx, At, St, To), Rz = J4(Jr, z1, Mt, Qr, Hn), Fz = X4(on, Or, Rz, z1, At, St, To), ax = d3(oi), Bz = aH(Jr, ax, Mt, Qr, Hn), Lz = sH(on, Or, Bz, ax, oi, At, St, To), $z = mH(Jr, yi, Mt, Qr, Hn), Wz = hH(on, Or, $z, yi, At, St), jz = v3(Jh, Tn, Xc, oi), em = j3(Er, yi, Xc, X3(yi, As)), Hz = AH(Ql, Mt, As, Hn, em), zz = f3(jz), Uz = TH(on, zz, Hz, At, St, To), qz = l4(Or, da, eu, Xc, oi, q1, St, Jc), ox = /* @__PURE__ */ new WeakMap(), Gz = zH(kz, qz, ex, St, ox, Jl), lx = _3(Qh, Er, Oy, Z1, Py, K1), Yz = D3(Jr, lx, Mt, Qr, Hn), Zz = V3(on, Or, lx, Yz, At, St, Jl), ux = B4(Ql), Kz = I3(ux, Tn, yi, G1, ca), tm = A3(ux, Tn, Kz, G1, ca, Qc, Jc), Xz = k3(Wf, Tn, da, yi, Xc, tm, oi, jf, q1, ca), cx = S3(Xz), Jz = R3(Jr, da, eu, yi, cx, Mt, As, Qr, Hn, em), Qz = M3(on, Or, cx, Jz, At, St, To), eU = C3(Xr), tU = B3(eU, At, /* @__PURE__ */ new WeakSet(), uz), nU = x3(da, Kc, yi, tm, oi, ca), dx = T3(nU, oi), iU = Y3(Jr, dx, Mt, Qr, Hn), rU = G3(on, Or, dx, iU, At, St), sU = tz(tm, Mt, Hn), aU = ez(on, Tn, tm, sU, At, St, To), fx = BH(Ur), By = cH(Ur), hx = /* @__PURE__ */ new WeakMap(), oU = _H(hx, As), lU = fx ? Lj(
  Er,
  oi,
  lH(Ur),
  By,
  dH(Nj),
  At,
  oU,
  St,
  oc,
  /* @__PURE__ */ new WeakMap(),
  /* @__PURE__ */ new WeakMap(),
  K3(oc, As),
  // @todo window is guaranteed to be defined because isSecureContext checks that as well.
  Ur
) : void 0, uU = RH(Dy, St), cU = Y4(My, Er, G4, oH, /* @__PURE__ */ new WeakSet(), At, uU, Lf, ac, Ry, Fy), mx = T4(lU, wz, ix, Sz, Tz, Iz, Oz, Dz, Mz, cU, Fz, Lz, Wz, Uz, Gz, Zz, Qz, tU, rU, aU), dU = LH(on, g3, At, St), fU = WH(on, p3, At, St), hU = jH(on, y3, At, St), mU = b3(Tn, St), vU = HH(on, mU, At), gU = s4(mx, Tn, oi, J3, dU, fU, hU, vU, Qc), Ly = SH(ox), pU = Hj(Ly), vx = F4(Xr), yU = eH(Ly), gx = iH(Xr), px = /* @__PURE__ */ new WeakMap(), bU = vH(px, kr), wU = s3(vx, Xr, Tn, da, Kc, eu, yi, Xc, oi, gx, By, bU, ca), _U = t3(Tn, wU, yi, oi, ca), SU = C4(Jr, vx, Ql, da, Kc, eu, yi, yU, gx, By, Mt, oc, As, Qr, Hn, em), kU = bH(hx), CU = H3(px), __ = fx ? _4(pU, on, Or, SU, _U, ii, kU, At, St, oc, oz, CU, hz, Jl) : void 0, TU = q4(oi, As), xU = U3(My, Er, Vy, Ly, em, Lf, Ry, Fy), AU = O3(mx, Er, Tn, TU, xU), IU = EH(Kh, Dy), EU = OH(ky, Ny), OU = PH(Cy, tx), PU = VH(Kh, St);
function Zi(e) {
  return e === void 0;
}
function nt(e) {
  return e !== void 0;
}
function VU(e) {
  return typeof e == "function";
}
function io(e) {
  return typeof e == "number";
}
function za(e) {
  return Object.prototype.toString.call(e) === "[object Object]" && e.constructor === Object;
}
function DU(e) {
  return typeof e == "boolean";
}
function br(e) {
  return Array.isArray(e);
}
function bs(e) {
  return typeof e == "string";
}
function Ed(e) {
  return bs(e) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(e);
}
function Xe(e, t) {
  if (!e)
    throw new Error(t);
}
function sa(e, t, n = 1 / 0) {
  if (!(t <= e && e <= n))
    throw new RangeError(`Value must be within [${t}, ${n}], got: ${e}`);
}
function yx(e) {
  !e.isOffline && e.state !== "running" && $y('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.');
}
let bx = !1, S_ = !1;
function k_(e) {
  bx = e;
}
function NU(e) {
  Zi(e) && bx && !S_ && (S_ = !0, $y("Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing"));
}
let wx = console;
function MU(...e) {
  wx.log(...e);
}
function $y(...e) {
  wx.warn(...e);
}
function RU(e) {
  return new gU(e);
}
function FU(e, t, n) {
  return new AU(e, t, n);
}
const Ua = typeof self == "object" ? self : null, BU = Ua && (Ua.hasOwnProperty("AudioContext") || Ua.hasOwnProperty("webkitAudioContext"));
function LU(e, t, n) {
  return Xe(nt(__), "This node only works in a secure context (https or localhost)"), new __(e, t, n);
}
function Pr(e, t, n, i) {
  var r = arguments.length, s = r < 3 ? t : i === null ? i = Object.getOwnPropertyDescriptor(t, n) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(e, t, n, i);
  else
    for (var o = e.length - 1; o >= 0; o--)
      (a = e[o]) && (s = (r < 3 ? a(s) : r > 3 ? a(t, n, s) : a(t, n)) || s);
  return r > 3 && s && Object.defineProperty(t, n, s), s;
}
function fn(e, t, n, i) {
  function r(s) {
    return s instanceof n ? s : new n(function(a) {
      a(s);
    });
  }
  return new (n || (n = Promise))(function(s, a) {
    function o(c) {
      try {
        u(i.next(c));
      } catch (d) {
        a(d);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (d) {
        a(d);
      }
    }
    function u(c) {
      c.done ? s(c.value) : r(c.value).then(o, l);
    }
    u((i = i.apply(e, t || [])).next());
  });
}
class $U {
  constructor(t, n, i, r) {
    this._callback = t, this._type = n, this._minimumUpdateInterval = Math.max(128 / (r || 44100), 1e-3), this.updateInterval = i, this._createClock();
  }
  /**
   * Generate a web worker
   */
  _createWorker() {
    const t = new Blob([
      /* javascript */
      `
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval * 1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`
    ], { type: "text/javascript" }), n = URL.createObjectURL(t), i = new Worker(n);
    i.onmessage = this._callback.bind(this), this._worker = i;
  }
  /**
   * Create a timeout loop
   */
  _createTimeout() {
    this._timeout = setTimeout(() => {
      this._createTimeout(), this._callback();
    }, this._updateInterval * 1e3);
  }
  /**
   * Create the clock source.
   */
  _createClock() {
    if (this._type === "worker")
      try {
        this._createWorker();
      } catch {
        this._type = "timeout", this._createClock();
      }
    else
      this._type === "timeout" && this._createTimeout();
  }
  /**
   * Clean up the current clock source
   */
  _disposeClock() {
    this._timeout && clearTimeout(this._timeout), this._worker && (this._worker.terminate(), this._worker.onmessage = null);
  }
  /**
   * The rate in seconds the ticker will update
   */
  get updateInterval() {
    return this._updateInterval;
  }
  set updateInterval(t) {
    var n;
    this._updateInterval = Math.max(t, this._minimumUpdateInterval), this._type === "worker" && ((n = this._worker) === null || n === void 0 || n.postMessage(this._updateInterval * 1e3));
  }
  /**
   * The type of the ticker, either a worker or a timeout
   */
  get type() {
    return this._type;
  }
  set type(t) {
    this._disposeClock(), this._type = t, this._createClock();
  }
  /**
   * Clean up
   */
  dispose() {
    this._disposeClock();
  }
}
function ro(e) {
  return OU(e);
}
function ta(e) {
  return EU(e);
}
function rf(e) {
  return PU(e);
}
function Yo(e) {
  return IU(e);
}
function WU(e) {
  return e instanceof ix;
}
function jU(e, t) {
  return e === "value" || ro(t) || ta(t) || WU(t);
}
function dl(e, ...t) {
  if (!t.length)
    return e;
  const n = t.shift();
  if (za(e) && za(n))
    for (const i in n)
      jU(i, n[i]) ? e[i] = n[i] : za(n[i]) ? (e[i] || Object.assign(e, { [i]: {} }), dl(e[i], n[i])) : Object.assign(e, { [i]: n[i] });
  return dl(e, ...t);
}
function HU(e, t) {
  return e.length === t.length && e.every((n, i) => t[i] === n);
}
function Te(e, t, n = [], i) {
  const r = {}, s = Array.from(t);
  if (za(s[0]) && i && !Reflect.has(s[0], i) && (Object.keys(s[0]).some((o) => Reflect.has(e, o)) || (dl(r, { [i]: s[0] }), n.splice(n.indexOf(i), 1), s.shift())), s.length === 1 && za(s[0]))
    dl(r, s[0]);
  else
    for (let a = 0; a < n.length; a++)
      nt(s[a]) && (r[n[a]] = s[a]);
  return dl(e, r);
}
function zU(e) {
  return e.constructor.getDefaults();
}
function fl(e, t) {
  return Zi(e) ? t : e;
}
function C_(e, t) {
  return t.forEach((n) => {
    Reflect.has(e, n) && delete e[n];
  }), e;
}
/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2019 Yotam Mann
 */
class Is {
  constructor() {
    this.debug = !1, this._wasDisposed = !1;
  }
  /**
   * Returns all of the default options belonging to the class.
   */
  static getDefaults() {
    return {};
  }
  /**
   * Prints the outputs to the console log for debugging purposes.
   * Prints the contents only if either the object has a property
   * called `debug` set to true, or a variable called TONE_DEBUG_CLASS
   * is set to the name of the class.
   * @example
   * const osc = new Tone.Oscillator();
   * // prints all logs originating from this oscillator
   * osc.debug = true;
   * // calls to start/stop will print in the console
   * osc.start();
   */
  log(...t) {
    (this.debug || Ua && this.toString() === Ua.TONE_DEBUG_CLASS) && MU(this, ...t);
  }
  /**
   * disconnect and dispose.
   */
  dispose() {
    return this._wasDisposed = !0, this;
  }
  /**
   * Indicates if the instance was disposed. 'Disposing' an
   * instance means that all of the Web Audio nodes that were
   * created for the instance are disconnected and freed for garbage collection.
   */
  get disposed() {
    return this._wasDisposed;
  }
  /**
   * Convert the class to a string
   * @example
   * const osc = new Tone.Oscillator();
   * console.log(osc.toString());
   */
  toString() {
    return this.name;
  }
}
Is.version = T1;
const Wy = 1e-6;
function Tl(e, t) {
  return e > t + Wy;
}
function kg(e, t) {
  return Tl(e, t) || ur(e, t);
}
function qf(e, t) {
  return e + Wy < t;
}
function ur(e, t) {
  return Math.abs(e - t) < Wy;
}
function UU(e, t, n) {
  return Math.max(Math.min(e, n), t);
}
class Ki extends Is {
  constructor() {
    super(), this.name = "Timeline", this._timeline = [];
    const t = Te(Ki.getDefaults(), arguments, ["memory"]);
    this.memory = t.memory, this.increasing = t.increasing;
  }
  static getDefaults() {
    return {
      memory: 1 / 0,
      increasing: !1
    };
  }
  /**
   * The number of items in the timeline.
   */
  get length() {
    return this._timeline.length;
  }
  /**
   * Insert an event object onto the timeline. Events must have a "time" attribute.
   * @param event  The event object to insert into the timeline.
   */
  add(t) {
    if (Xe(Reflect.has(t, "time"), "Timeline: events must have a time attribute"), t.time = t.time.valueOf(), this.increasing && this.length) {
      const n = this._timeline[this.length - 1];
      Xe(kg(t.time, n.time), "The time must be greater than or equal to the last scheduled time"), this._timeline.push(t);
    } else {
      const n = this._search(t.time);
      this._timeline.splice(n + 1, 0, t);
    }
    if (this.length > this.memory) {
      const n = this.length - this.memory;
      this._timeline.splice(0, n);
    }
    return this;
  }
  /**
   * Remove an event from the timeline.
   * @param  {Object}  event  The event object to remove from the list.
   * @returns {Timeline} this
   */
  remove(t) {
    const n = this._timeline.indexOf(t);
    return n !== -1 && this._timeline.splice(n, 1), this;
  }
  /**
   * Get the nearest event whose time is less than or equal to the given time.
   * @param  time  The time to query.
   */
  get(t, n = "time") {
    const i = this._search(t, n);
    return i !== -1 ? this._timeline[i] : null;
  }
  /**
   * Return the first event in the timeline without removing it
   * @returns {Object} The first event object
   */
  peek() {
    return this._timeline[0];
  }
  /**
   * Return the first event in the timeline and remove it
   */
  shift() {
    return this._timeline.shift();
  }
  /**
   * Get the event which is scheduled after the given time.
   * @param  time  The time to query.
   */
  getAfter(t, n = "time") {
    const i = this._search(t, n);
    return i + 1 < this._timeline.length ? this._timeline[i + 1] : null;
  }
  /**
   * Get the event before the event at the given time.
   * @param  time  The time to query.
   */
  getBefore(t) {
    const n = this._timeline.length;
    if (n > 0 && this._timeline[n - 1].time < t)
      return this._timeline[n - 1];
    const i = this._search(t);
    return i - 1 >= 0 ? this._timeline[i - 1] : null;
  }
  /**
   * Cancel events at and after the given time
   * @param  after  The time to query.
   */
  cancel(t) {
    if (this._timeline.length > 1) {
      let n = this._search(t);
      if (n >= 0)
        if (ur(this._timeline[n].time, t)) {
          for (let i = n; i >= 0 && ur(this._timeline[i].time, t); i--)
            n = i;
          this._timeline = this._timeline.slice(0, n);
        } else
          this._timeline = this._timeline.slice(0, n + 1);
      else
        this._timeline = [];
    } else
      this._timeline.length === 1 && kg(this._timeline[0].time, t) && (this._timeline = []);
    return this;
  }
  /**
   * Cancel events before or equal to the given time.
   * @param  time  The time to cancel before.
   */
  cancelBefore(t) {
    const n = this._search(t);
    return n >= 0 && (this._timeline = this._timeline.slice(n + 1)), this;
  }
  /**
   * Returns the previous event if there is one. null otherwise
   * @param  event The event to find the previous one of
   * @return The event right before the given event
   */
  previousEvent(t) {
    const n = this._timeline.indexOf(t);
    return n > 0 ? this._timeline[n - 1] : null;
  }
  /**
   * Does a binary search on the timeline array and returns the
   * nearest event index whose time is after or equal to the given time.
   * If a time is searched before the first index in the timeline, -1 is returned.
   * If the time is after the end, the index of the last item is returned.
   */
  _search(t, n = "time") {
    if (this._timeline.length === 0)
      return -1;
    let i = 0;
    const r = this._timeline.length;
    let s = r;
    if (r > 0 && this._timeline[r - 1][n] <= t)
      return r - 1;
    for (; i < s; ) {
      let a = Math.floor(i + (s - i) / 2);
      const o = this._timeline[a], l = this._timeline[a + 1];
      if (ur(o[n], t)) {
        for (let u = a; u < this._timeline.length; u++) {
          const c = this._timeline[u];
          if (ur(c[n], t))
            a = u;
          else
            break;
        }
        return a;
      } else {
        if (qf(o[n], t) && Tl(l[n], t))
          return a;
        Tl(o[n], t) ? s = a : i = a + 1;
      }
    }
    return -1;
  }
  /**
   * Internal iterator. Applies extra safety checks for
   * removing items from the array.
   */
  _iterate(t, n = 0, i = this._timeline.length - 1) {
    this._timeline.slice(n, i + 1).forEach(t);
  }
  /**
   * Iterate over everything in the array
   * @param  callback The callback to invoke with every item
   */
  forEach(t) {
    return this._iterate(t), this;
  }
  /**
   * Iterate over everything in the array at or before the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachBefore(t, n) {
    const i = this._search(t);
    return i !== -1 && this._iterate(n, 0, i), this;
  }
  /**
   * Iterate over everything in the array after the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachAfter(t, n) {
    const i = this._search(t);
    return this._iterate(n, i + 1), this;
  }
  /**
   * Iterate over everything in the array between the startTime and endTime.
   * The timerange is inclusive of the startTime, but exclusive of the endTime.
   * range = [startTime, endTime).
   * @param  startTime The time to check if items are before
   * @param  endTime The end of the test interval.
   * @param  callback The callback to invoke with every item
   */
  forEachBetween(t, n, i) {
    let r = this._search(t), s = this._search(n);
    return r !== -1 && s !== -1 ? (this._timeline[r].time !== t && (r += 1), this._timeline[s].time === n && (s -= 1), this._iterate(i, r, s)) : r === -1 && this._iterate(i, 0, s), this;
  }
  /**
   * Iterate over everything in the array at or after the given time. Similar to
   * forEachAfter, but includes the item(s) at the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachFrom(t, n) {
    let i = this._search(t);
    for (; i >= 0 && this._timeline[i].time >= t; )
      i--;
    return this._iterate(n, i + 1), this;
  }
  /**
   * Iterate over everything in the array at the given time
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachAtTime(t, n) {
    const i = this._search(t);
    if (i !== -1 && ur(this._timeline[i].time, t)) {
      let r = i;
      for (let s = i; s >= 0 && ur(this._timeline[s].time, t); s--)
        r = s;
      this._iterate((s) => {
        n(s);
      }, r, i);
    }
    return this;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._timeline = [], this;
  }
}
const _x = [];
function nm(e) {
  _x.push(e);
}
function qU(e) {
  _x.forEach((t) => t(e));
}
const Sx = [];
function im(e) {
  Sx.push(e);
}
function GU(e) {
  Sx.forEach((t) => t(e));
}
class ed extends Is {
  constructor() {
    super(...arguments), this.name = "Emitter";
  }
  /**
   * Bind a callback to a specific event.
   * @param  event     The name of the event to listen for.
   * @param  callback  The callback to invoke when the event is emitted
   */
  on(t, n) {
    return t.split(/\W+/).forEach((r) => {
      Zi(this._events) && (this._events = {}), this._events.hasOwnProperty(r) || (this._events[r] = []), this._events[r].push(n);
    }), this;
  }
  /**
   * Bind a callback which is only invoked once
   * @param  event     The name of the event to listen for.
   * @param  callback  The callback to invoke when the event is emitted
   */
  once(t, n) {
    const i = (...r) => {
      n(...r), this.off(t, i);
    };
    return this.on(t, i), this;
  }
  /**
   * Remove the event listener.
   * @param  event     The event to stop listening to.
   * @param  callback  The callback which was bound to the event with Emitter.on.
   *                   If no callback is given, all callbacks events are removed.
   */
  off(t, n) {
    return t.split(/\W+/).forEach((r) => {
      if (Zi(this._events) && (this._events = {}), this._events.hasOwnProperty(r))
        if (Zi(n))
          this._events[r] = [];
        else {
          const s = this._events[r];
          for (let a = s.length - 1; a >= 0; a--)
            s[a] === n && s.splice(a, 1);
        }
    }), this;
  }
  /**
   * Invoke all of the callbacks bound to the event
   * with any arguments passed in.
   * @param  event  The name of the event.
   * @param args The arguments to pass to the functions listening.
   */
  emit(t, ...n) {
    if (this._events && this._events.hasOwnProperty(t)) {
      const i = this._events[t].slice(0);
      for (let r = 0, s = i.length; r < s; r++)
        i[r].apply(this, n);
    }
    return this;
  }
  /**
   * Add Emitter functions (on/off/emit) to the object
   */
  static mixin(t) {
    ["on", "once", "off", "emit"].forEach((n) => {
      const i = Object.getOwnPropertyDescriptor(ed.prototype, n);
      Object.defineProperty(t.prototype, n, i);
    });
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._events = void 0, this;
  }
}
class kx extends ed {
  constructor() {
    super(...arguments), this.isOffline = !1;
  }
  /*
   * This is a placeholder so that JSON.stringify does not throw an error
   * This matches what JSON.stringify(audioContext) returns on a native
   * audioContext instance.
   */
  toJSON() {
    return {};
  }
}
class td extends kx {
  constructor() {
    var t, n;
    super(), this.name = "Context", this._constants = /* @__PURE__ */ new Map(), this._timeouts = new Ki(), this._timeoutIds = 0, this._initialized = !1, this._closeStarted = !1, this.isOffline = !1, this._workletPromise = null;
    const i = Te(td.getDefaults(), arguments, [
      "context"
    ]);
    i.context ? (this._context = i.context, this._latencyHint = ((t = arguments[0]) === null || t === void 0 ? void 0 : t.latencyHint) || "") : (this._context = RU({
      latencyHint: i.latencyHint
    }), this._latencyHint = i.latencyHint), this._ticker = new $U(this.emit.bind(this, "tick"), i.clockSource, i.updateInterval, this._context.sampleRate), this.on("tick", this._timeoutLoop.bind(this)), this._context.onstatechange = () => {
      this.emit("statechange", this.state);
    }, this[!((n = arguments[0]) === null || n === void 0) && n.hasOwnProperty("updateInterval") ? "_lookAhead" : "lookAhead"] = i.lookAhead;
  }
  static getDefaults() {
    return {
      clockSource: "worker",
      latencyHint: "interactive",
      lookAhead: 0.1,
      updateInterval: 0.05
    };
  }
  /**
   * Finish setting up the context. **You usually do not need to do this manually.**
   */
  initialize() {
    return this._initialized || (qU(this), this._initialized = !0), this;
  }
  //---------------------------
  // BASE AUDIO CONTEXT METHODS
  //---------------------------
  createAnalyser() {
    return this._context.createAnalyser();
  }
  createOscillator() {
    return this._context.createOscillator();
  }
  createBufferSource() {
    return this._context.createBufferSource();
  }
  createBiquadFilter() {
    return this._context.createBiquadFilter();
  }
  createBuffer(t, n, i) {
    return this._context.createBuffer(t, n, i);
  }
  createChannelMerger(t) {
    return this._context.createChannelMerger(t);
  }
  createChannelSplitter(t) {
    return this._context.createChannelSplitter(t);
  }
  createConstantSource() {
    return this._context.createConstantSource();
  }
  createConvolver() {
    return this._context.createConvolver();
  }
  createDelay(t) {
    return this._context.createDelay(t);
  }
  createDynamicsCompressor() {
    return this._context.createDynamicsCompressor();
  }
  createGain() {
    return this._context.createGain();
  }
  createIIRFilter(t, n) {
    return this._context.createIIRFilter(t, n);
  }
  createPanner() {
    return this._context.createPanner();
  }
  createPeriodicWave(t, n, i) {
    return this._context.createPeriodicWave(t, n, i);
  }
  createStereoPanner() {
    return this._context.createStereoPanner();
  }
  createWaveShaper() {
    return this._context.createWaveShaper();
  }
  createMediaStreamSource(t) {
    return Xe(Yo(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamSource(t);
  }
  createMediaElementSource(t) {
    return Xe(Yo(this._context), "Not available if OfflineAudioContext"), this._context.createMediaElementSource(t);
  }
  createMediaStreamDestination() {
    return Xe(Yo(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamDestination();
  }
  decodeAudioData(t) {
    return this._context.decodeAudioData(t);
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get currentTime() {
    return this._context.currentTime;
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get state() {
    return this._context.state;
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get sampleRate() {
    return this._context.sampleRate;
  }
  /**
   * The listener
   */
  get listener() {
    return this.initialize(), this._listener;
  }
  set listener(t) {
    Xe(!this._initialized, "The listener cannot be set after initialization."), this._listener = t;
  }
  /**
   * There is only one Transport per Context. It is created on initialization.
   */
  get transport() {
    return this.initialize(), this._transport;
  }
  set transport(t) {
    Xe(!this._initialized, "The transport cannot be set after initialization."), this._transport = t;
  }
  /**
   * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.
   */
  get draw() {
    return this.initialize(), this._draw;
  }
  set draw(t) {
    Xe(!this._initialized, "Draw cannot be set after initialization."), this._draw = t;
  }
  /**
   * A reference to the Context's destination node.
   */
  get destination() {
    return this.initialize(), this._destination;
  }
  set destination(t) {
    Xe(!this._initialized, "The destination cannot be set after initialization."), this._destination = t;
  }
  /**
   * Create an audio worklet node from a name and options. The module
   * must first be loaded using {@link addAudioWorkletModule}.
   */
  createAudioWorkletNode(t, n) {
    return LU(this.rawContext, t, n);
  }
  /**
   * Add an AudioWorkletProcessor module
   * @param url The url of the module
   */
  addAudioWorkletModule(t) {
    return fn(this, void 0, void 0, function* () {
      Xe(nt(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)"), this._workletPromise || (this._workletPromise = this.rawContext.audioWorklet.addModule(t)), yield this._workletPromise;
    });
  }
  /**
   * Returns a promise which resolves when all of the worklets have been loaded on this context
   */
  workletsAreReady() {
    return fn(this, void 0, void 0, function* () {
      (yield this._workletPromise) ? this._workletPromise : Promise.resolve();
    });
  }
  //---------------------------
  // TICKER
  //---------------------------
  /**
   * How often the interval callback is invoked.
   * This number corresponds to how responsive the scheduling
   * can be. Setting to 0 will result in the lowest practial interval
   * based on context properties. context.updateInterval + context.lookAhead
   * gives you the total latency between scheduling an event and hearing it.
   */
  get updateInterval() {
    return this._ticker.updateInterval;
  }
  set updateInterval(t) {
    this._ticker.updateInterval = t;
  }
  /**
   * What the source of the clock is, either "worker" (default),
   * "timeout", or "offline" (none).
   */
  get clockSource() {
    return this._ticker.type;
  }
  set clockSource(t) {
    this._ticker.type = t;
  }
  /**
   * The amount of time into the future events are scheduled. Giving Web Audio
   * a short amount of time into the future to schedule events can reduce clicks and
   * improve performance. This value can be set to 0 to get the lowest latency.
   * Adjusting this value also affects the {@link updateInterval}.
   */
  get lookAhead() {
    return this._lookAhead;
  }
  set lookAhead(t) {
    this._lookAhead = t, this.updateInterval = t ? t / 2 : 0.01;
  }
  /**
   * The type of playback, which affects tradeoffs between audio
   * output latency and responsiveness.
   * In addition to setting the value in seconds, the latencyHint also
   * accepts the strings "interactive" (prioritizes low latency),
   * "playback" (prioritizes sustained playback), "balanced" (balances
   * latency and performance).
   * @example
   * // prioritize sustained playback
   * const context = new Tone.Context({ latencyHint: "playback" });
   * // set this context as the global Context
   * Tone.setContext(context);
   * // the global context is gettable with Tone.getContext()
   * console.log(Tone.getContext().latencyHint);
   */
  get latencyHint() {
    return this._latencyHint;
  }
  /**
   * The unwrapped AudioContext or OfflineAudioContext
   */
  get rawContext() {
    return this._context;
  }
  /**
   * The current audio context time plus a short {@link lookAhead}.
   * @example
   * setInterval(() => {
   * 	console.log("now", Tone.now());
   * }, 100);
   */
  now() {
    return this._context.currentTime + this._lookAhead;
  }
  /**
   * The current audio context time without the {@link lookAhead}.
   * In most cases it is better to use {@link now} instead of {@link immediate} since
   * with {@link now} the {@link lookAhead} is applied equally to _all_ components including internal components,
   * to making sure that everything is scheduled in sync. Mixing {@link now} and {@link immediate}
   * can cause some timing issues. If no lookAhead is desired, you can set the {@link lookAhead} to `0`.
   */
  immediate() {
    return this._context.currentTime;
  }
  /**
   * Starts the audio context from a suspended state. This is required
   * to initially start the AudioContext.
   * @see {@link start}
   */
  resume() {
    return Yo(this._context) ? this._context.resume() : Promise.resolve();
  }
  /**
   * Close the context. Once closed, the context can no longer be used and
   * any AudioNodes created from the context will be silent.
   */
  close() {
    return fn(this, void 0, void 0, function* () {
      Yo(this._context) && this.state !== "closed" && !this._closeStarted && (this._closeStarted = !0, yield this._context.close()), this._initialized && GU(this);
    });
  }
  /**
   * **Internal** Generate a looped buffer at some constant value.
   */
  getConstant(t) {
    if (this._constants.has(t))
      return this._constants.get(t);
    {
      const n = this._context.createBuffer(1, 128, this._context.sampleRate), i = n.getChannelData(0);
      for (let s = 0; s < i.length; s++)
        i[s] = t;
      const r = this._context.createBufferSource();
      return r.channelCount = 1, r.channelCountMode = "explicit", r.buffer = n, r.loop = !0, r.start(0), this._constants.set(t, r), r;
    }
  }
  /**
   * Clean up. Also closes the audio context.
   */
  dispose() {
    return super.dispose(), this._ticker.dispose(), this._timeouts.dispose(), Object.keys(this._constants).map((t) => this._constants[t].disconnect()), this.close(), this;
  }
  //---------------------------
  // TIMEOUTS
  //---------------------------
  /**
   * The private loop which keeps track of the context scheduled timeouts
   * Is invoked from the clock source
   */
  _timeoutLoop() {
    const t = this.now();
    let n = this._timeouts.peek();
    for (; this._timeouts.length && n && n.time <= t; )
      n.callback(), this._timeouts.shift(), n = this._timeouts.peek();
  }
  /**
   * A setTimeout which is guaranteed by the clock source.
   * Also runs in the offline context.
   * @param  fn       The callback to invoke
   * @param  timeout  The timeout in seconds
   * @returns ID to use when invoking Context.clearTimeout
   */
  setTimeout(t, n) {
    this._timeoutIds++;
    const i = this.now();
    return this._timeouts.add({
      callback: t,
      id: this._timeoutIds,
      time: i + n
    }), this._timeoutIds;
  }
  /**
   * Clears a previously scheduled timeout with Tone.context.setTimeout
   * @param  id  The ID returned from setTimeout
   */
  clearTimeout(t) {
    return this._timeouts.forEach((n) => {
      n.id === t && this._timeouts.remove(n);
    }), this;
  }
  /**
   * Clear the function scheduled by {@link setInterval}
   */
  clearInterval(t) {
    return this.clearTimeout(t);
  }
  /**
   * Adds a repeating event to the context's callback clock
   */
  setInterval(t, n) {
    const i = ++this._timeoutIds, r = () => {
      const s = this.now();
      this._timeouts.add({
        callback: () => {
          t(), r();
        },
        id: i,
        time: s + n
      });
    };
    return r(), i;
  }
}
class YU extends kx {
  constructor() {
    super(...arguments), this.lookAhead = 0, this.latencyHint = 0, this.isOffline = !1;
  }
  //---------------------------
  // BASE AUDIO CONTEXT METHODS
  //---------------------------
  createAnalyser() {
    return {};
  }
  createOscillator() {
    return {};
  }
  createBufferSource() {
    return {};
  }
  createBiquadFilter() {
    return {};
  }
  createBuffer(t, n, i) {
    return {};
  }
  createChannelMerger(t) {
    return {};
  }
  createChannelSplitter(t) {
    return {};
  }
  createConstantSource() {
    return {};
  }
  createConvolver() {
    return {};
  }
  createDelay(t) {
    return {};
  }
  createDynamicsCompressor() {
    return {};
  }
  createGain() {
    return {};
  }
  createIIRFilter(t, n) {
    return {};
  }
  createPanner() {
    return {};
  }
  createPeriodicWave(t, n, i) {
    return {};
  }
  createStereoPanner() {
    return {};
  }
  createWaveShaper() {
    return {};
  }
  createMediaStreamSource(t) {
    return {};
  }
  createMediaElementSource(t) {
    return {};
  }
  createMediaStreamDestination() {
    return {};
  }
  decodeAudioData(t) {
    return Promise.resolve({});
  }
  //---------------------------
  // TONE AUDIO CONTEXT METHODS
  //---------------------------
  createAudioWorkletNode(t, n) {
    return {};
  }
  get rawContext() {
    return {};
  }
  addAudioWorkletModule(t) {
    return fn(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  resume() {
    return Promise.resolve();
  }
  setTimeout(t, n) {
    return 0;
  }
  clearTimeout(t) {
    return this;
  }
  setInterval(t, n) {
    return 0;
  }
  clearInterval(t) {
    return this;
  }
  getConstant(t) {
    return {};
  }
  get currentTime() {
    return 0;
  }
  get state() {
    return {};
  }
  get sampleRate() {
    return 0;
  }
  get listener() {
    return {};
  }
  get transport() {
    return {};
  }
  get draw() {
    return {};
  }
  set draw(t) {
  }
  get destination() {
    return {};
  }
  set destination(t) {
  }
  now() {
    return 0;
  }
  immediate() {
    return 0;
  }
}
function Jt(e, t) {
  br(t) ? t.forEach((n) => Jt(e, n)) : Object.defineProperty(e, t, {
    enumerable: !0,
    writable: !1
  });
}
function Cx(e, t) {
  br(t) ? t.forEach((n) => Cx(e, n)) : Object.defineProperty(e, t, {
    writable: !0
  });
}
const wt = () => {
};
class Vt extends Is {
  constructor() {
    super(), this.name = "ToneAudioBuffer", this.onload = wt;
    const t = Te(Vt.getDefaults(), arguments, ["url", "onload", "onerror"]);
    this.reverse = t.reverse, this.onload = t.onload, bs(t.url) ? this.load(t.url).catch(t.onerror) : t.url && this.set(t.url);
  }
  static getDefaults() {
    return {
      onerror: wt,
      onload: wt,
      reverse: !1
    };
  }
  /**
   * The sample rate of the AudioBuffer
   */
  get sampleRate() {
    return this._buffer ? this._buffer.sampleRate : mr().sampleRate;
  }
  /**
   * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.
   */
  set(t) {
    return t instanceof Vt ? t.loaded ? this._buffer = t.get() : t.onload = () => {
      this.set(t), this.onload(this);
    } : this._buffer = t, this._reversed && this._reverse(), this;
  }
  /**
   * The audio buffer stored in the object.
   */
  get() {
    return this._buffer;
  }
  /**
   * Makes an fetch request for the selected url then decodes the file as an audio buffer.
   * Invokes the callback once the audio buffer loads.
   * @param url The url of the buffer to load. filetype support depends on the browser.
   * @returns A Promise which resolves with this ToneAudioBuffer
   */
  load(t) {
    return fn(this, void 0, void 0, function* () {
      const n = Vt.load(t).then((i) => {
        this.set(i), this.onload(this);
      });
      Vt.downloads.push(n);
      try {
        yield n;
      } finally {
        const i = Vt.downloads.indexOf(n);
        Vt.downloads.splice(i, 1);
      }
      return this;
    });
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this._buffer = void 0, this;
  }
  /**
   * Set the audio buffer from the array.
   * To create a multichannel AudioBuffer, pass in a multidimensional array.
   * @param array The array to fill the audio buffer
   */
  fromArray(t) {
    const n = br(t) && t[0].length > 0, i = n ? t.length : 1, r = n ? t[0].length : t.length, s = mr(), a = s.createBuffer(i, r, s.sampleRate), o = !n && i === 1 ? [t] : t;
    for (let l = 0; l < i; l++)
      a.copyToChannel(o[l], l);
    return this._buffer = a, this;
  }
  /**
   * Sums multiple channels into 1 channel
   * @param chanNum Optionally only copy a single channel from the array.
   */
  toMono(t) {
    if (io(t))
      this.fromArray(this.toArray(t));
    else {
      let n = new Float32Array(this.length);
      const i = this.numberOfChannels;
      for (let r = 0; r < i; r++) {
        const s = this.toArray(r);
        for (let a = 0; a < s.length; a++)
          n[a] += s[a];
      }
      n = n.map((r) => r / i), this.fromArray(n);
    }
    return this;
  }
  /**
   * Get the buffer as an array. Single channel buffers will return a 1-dimensional
   * Float32Array, and multichannel buffers will return multidimensional arrays.
   * @param channel Optionally only copy a single channel from the array.
   */
  toArray(t) {
    if (io(t))
      return this.getChannelData(t);
    if (this.numberOfChannels === 1)
      return this.toArray(0);
    {
      const n = [];
      for (let i = 0; i < this.numberOfChannels; i++)
        n[i] = this.getChannelData(i);
      return n;
    }
  }
  /**
   * Returns the Float32Array representing the PCM audio data for the specific channel.
   * @param  channel  The channel number to return
   * @return The audio as a TypedArray
   */
  getChannelData(t) {
    return this._buffer ? this._buffer.getChannelData(t) : new Float32Array(0);
  }
  /**
   * Cut a subsection of the array and return a buffer of the
   * subsection. Does not modify the original buffer
   * @param start The time to start the slice
   * @param end The end time to slice. If none is given will default to the end of the buffer
   */
  slice(t, n = this.duration) {
    Xe(this.loaded, "Buffer is not loaded");
    const i = Math.floor(t * this.sampleRate), r = Math.floor(n * this.sampleRate);
    Xe(i < r, "The start time must be less than the end time");
    const s = r - i, a = mr().createBuffer(this.numberOfChannels, s, this.sampleRate);
    for (let o = 0; o < this.numberOfChannels; o++)
      a.copyToChannel(this.getChannelData(o).subarray(i, r), o);
    return new Vt(a);
  }
  /**
   * Reverse the buffer.
   */
  _reverse() {
    if (this.loaded)
      for (let t = 0; t < this.numberOfChannels; t++)
        this.getChannelData(t).reverse();
    return this;
  }
  /**
   * If the buffer is loaded or not
   */
  get loaded() {
    return this.length > 0;
  }
  /**
   * The duration of the buffer in seconds.
   */
  get duration() {
    return this._buffer ? this._buffer.duration : 0;
  }
  /**
   * The length of the buffer in samples
   */
  get length() {
    return this._buffer ? this._buffer.length : 0;
  }
  /**
   * The number of discrete audio channels. Returns 0 if no buffer is loaded.
   */
  get numberOfChannels() {
    return this._buffer ? this._buffer.numberOfChannels : 0;
  }
  /**
   * Reverse the buffer.
   */
  get reverse() {
    return this._reversed;
  }
  set reverse(t) {
    this._reversed !== t && (this._reversed = t, this._reverse());
  }
  /**
   * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,
   * pass in a multidimensional array.
   * @param array The array to fill the audio buffer
   * @return A ToneAudioBuffer created from the array
   */
  static fromArray(t) {
    return new Vt().fromArray(t);
  }
  /**
   * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer
   * @param  url The url to load.
   * @return A promise which resolves to a ToneAudioBuffer
   */
  static fromUrl(t) {
    return fn(this, void 0, void 0, function* () {
      return yield new Vt().load(t);
    });
  }
  /**
   * Loads a url using fetch and returns the AudioBuffer.
   */
  static load(t) {
    return fn(this, void 0, void 0, function* () {
      const n = t.match(/\[([^\]\[]+\|.+)\]$/);
      if (n) {
        const l = n[1].split("|");
        let u = l[0];
        for (const c of l)
          if (Vt.supportsType(c)) {
            u = c;
            break;
          }
        t = t.replace(n[0], u);
      }
      const i = Vt.baseUrl === "" || Vt.baseUrl.endsWith("/") ? Vt.baseUrl : Vt.baseUrl + "/", r = document.createElement("a");
      r.href = i + t, r.pathname = (r.pathname + r.hash).split("/").map(encodeURIComponent).join("/");
      const s = yield fetch(r.href);
      if (!s.ok)
        throw new Error(`could not load url: ${t}`);
      const a = yield s.arrayBuffer();
      return yield mr().decodeAudioData(a);
    });
  }
  /**
   * Checks a url's extension to see if the current browser can play that file type.
   * @param url The url/extension to test
   * @return If the file extension can be played
   * @static
   * @example
   * Tone.ToneAudioBuffer.supportsType("wav"); // returns true
   * Tone.ToneAudioBuffer.supportsType("path/to/file.wav"); // returns true
   */
  static supportsType(t) {
    const n = t.split("."), i = n[n.length - 1];
    return document.createElement("audio").canPlayType("audio/" + i) !== "";
  }
  /**
   * Returns a Promise which resolves when all of the buffers have loaded
   */
  static loaded() {
    return fn(this, void 0, void 0, function* () {
      for (yield Promise.resolve(); Vt.downloads.length; )
        yield Vt.downloads[0];
    });
  }
}
Vt.baseUrl = "";
Vt.downloads = [];
class jy extends td {
  constructor() {
    super({
      clockSource: "offline",
      context: rf(arguments[0]) ? arguments[0] : FU(arguments[0], arguments[1] * arguments[2], arguments[2]),
      lookAhead: 0,
      updateInterval: rf(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
    }), this.name = "OfflineContext", this._currentTime = 0, this.isOffline = !0, this._duration = rf(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];
  }
  /**
   * Override the now method to point to the internal clock time
   */
  now() {
    return this._currentTime;
  }
  /**
   * Same as this.now()
   */
  get currentTime() {
    return this._currentTime;
  }
  /**
   * Render just the clock portion of the audio context.
   */
  _renderClock(t) {
    return fn(this, void 0, void 0, function* () {
      let n = 0;
      for (; this._duration - this._currentTime >= 0; ) {
        this.emit("tick"), this._currentTime += 128 / this.sampleRate, n++;
        const i = Math.floor(this.sampleRate / 128);
        t && n % i === 0 && (yield new Promise((r) => setTimeout(r, 1)));
      }
    });
  }
  /**
   * Render the output of the OfflineContext
   * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.
   */
  render(t = !0) {
    return fn(this, void 0, void 0, function* () {
      yield this.workletsAreReady(), yield this._renderClock(t);
      const n = yield this._context.startRendering();
      return new Vt(n);
    });
  }
  /**
   * Close the context
   */
  close() {
    return Promise.resolve();
  }
}
const Tx = new YU();
let il = Tx;
function mr() {
  return il === Tx && BU && ZU(new td()), il;
}
function ZU(e, t = !1) {
  t && il.dispose(), Yo(e) ? il = new td(e) : rf(e) ? il = new jy(e) : il = e;
}
if (Ua && !Ua.TONE_SILENCE_LOGGING) {
  const t = ` * Tone.js v${T1} * `;
  console.log(`%c${t}`, "background: #000; color: #fff");
}
function KU(e) {
  return Math.pow(10, e / 20);
}
function XU(e) {
  return 20 * (Math.log(e) / Math.LN10);
}
function xx(e) {
  return Math.pow(2, e / 12);
}
let rm = 440;
function JU() {
  return rm;
}
function QU(e) {
  rm = e;
}
function Cg(e) {
  return Math.round(Ax(e));
}
function Ax(e) {
  return 69 + 12 * Math.log2(e / rm);
}
function eq(e) {
  return rm * Math.pow(2, (e - 69) / 12);
}
class Hy extends Is {
  /**
   * @param context The context associated with the time value. Used to compute
   * Transport and context-relative timing.
   * @param  value  The time value as a number, string or object
   * @param  units  Unit values
   */
  constructor(t, n, i) {
    super(), this.defaultUnits = "s", this._val = n, this._units = i, this.context = t, this._expressions = this._getExpressions();
  }
  /**
   * All of the time encoding expressions
   */
  _getExpressions() {
    return {
      hz: {
        method: (t) => this._frequencyToUnits(parseFloat(t)),
        regexp: /^(\d+(?:\.\d+)?)hz$/i
      },
      i: {
        method: (t) => this._ticksToUnits(parseInt(t, 10)),
        regexp: /^(\d+)i$/i
      },
      m: {
        method: (t) => this._beatsToUnits(parseInt(t, 10) * this._getTimeSignature()),
        regexp: /^(\d+)m$/i
      },
      n: {
        method: (t, n) => {
          const i = parseInt(t, 10), r = n === "." ? 1.5 : 1;
          return i === 1 ? this._beatsToUnits(this._getTimeSignature()) * r : this._beatsToUnits(4 / i) * r;
        },
        regexp: /^(\d+)n(\.?)$/i
      },
      number: {
        method: (t) => this._expressions[this.defaultUnits].method.call(this, t),
        regexp: /^(\d+(?:\.\d+)?)$/
      },
      s: {
        method: (t) => this._secondsToUnits(parseFloat(t)),
        regexp: /^(\d+(?:\.\d+)?)s$/
      },
      samples: {
        method: (t) => parseInt(t, 10) / this.context.sampleRate,
        regexp: /^(\d+)samples$/
      },
      t: {
        method: (t) => {
          const n = parseInt(t, 10);
          return this._beatsToUnits(8 / (Math.floor(n) * 3));
        },
        regexp: /^(\d+)t$/i
      },
      tr: {
        method: (t, n, i) => {
          let r = 0;
          return t && t !== "0" && (r += this._beatsToUnits(this._getTimeSignature() * parseFloat(t))), n && n !== "0" && (r += this._beatsToUnits(parseFloat(n))), i && i !== "0" && (r += this._beatsToUnits(parseFloat(i) / 4)), r;
        },
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
      }
    };
  }
  //-------------------------------------
  // 	VALUE OF
  //-------------------------------------
  /**
   * Evaluate the time value. Returns the time in seconds.
   */
  valueOf() {
    if (this._val instanceof Hy && this.fromType(this._val), Zi(this._val))
      return this._noArg();
    if (bs(this._val) && Zi(this._units)) {
      for (const t in this._expressions)
        if (this._expressions[t].regexp.test(this._val.trim())) {
          this._units = t;
          break;
        }
    } else if (za(this._val)) {
      let t = 0;
      for (const n in this._val)
        if (nt(this._val[n])) {
          const i = this._val[n], r = new this.constructor(this.context, n).valueOf() * i;
          t += r;
        }
      return t;
    }
    if (nt(this._units)) {
      const t = this._expressions[this._units], n = this._val.toString().trim().match(t.regexp);
      return n ? t.method.apply(this, n.slice(1)) : t.method.call(this, this._val);
    } else
      return bs(this._val) ? parseFloat(this._val) : this._val;
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS
  //-------------------------------------
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(t) {
    return 1 / t;
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(t) {
    return 60 / this._getBpm() * t;
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(t) {
    return t;
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(t) {
    return t * this._beatsToUnits(1) / this._getPPQ();
  }
  /**
   * With no arguments, return 'now'
   */
  _noArg() {
    return this._now();
  }
  //-------------------------------------
  // 	TEMPO CONVERSIONS
  //-------------------------------------
  /**
   * Return the bpm
   */
  _getBpm() {
    return this.context.transport.bpm.value;
  }
  /**
   * Return the timeSignature
   */
  _getTimeSignature() {
    return this.context.transport.timeSignature;
  }
  /**
   * Return the PPQ or 192 if Transport is not available
   */
  _getPPQ() {
    return this.context.transport.PPQ;
  }
  //-------------------------------------
  // 	CONVERSION INTERFACE
  //-------------------------------------
  /**
   * Coerce a time type into this units type.
   * @param type Any time type units
   */
  fromType(t) {
    switch (this._units = void 0, this.defaultUnits) {
      case "s":
        this._val = t.toSeconds();
        break;
      case "i":
        this._val = t.toTicks();
        break;
      case "hz":
        this._val = t.toFrequency();
        break;
      case "midi":
        this._val = t.toMidi();
        break;
    }
    return this;
  }
  /**
   * Return the value in hertz
   */
  toFrequency() {
    return 1 / this.toSeconds();
  }
  /**
   * Return the time in samples
   */
  toSamples() {
    return this.toSeconds() * this.context.sampleRate;
  }
  /**
   * Return the time in milliseconds.
   */
  toMilliseconds() {
    return this.toSeconds() * 1e3;
  }
}
class vr extends Hy {
  constructor() {
    super(...arguments), this.name = "TimeClass";
  }
  _getExpressions() {
    return Object.assign(super._getExpressions(), {
      now: {
        method: (t) => this._now() + new this.constructor(this.context, t).valueOf(),
        regexp: /^\+(.+)/
      },
      quantize: {
        method: (t) => {
          const n = new vr(this.context, t).valueOf();
          return this._secondsToUnits(this.context.transport.nextSubdivision(n));
        },
        regexp: /^@(.+)/
      }
    });
  }
  /**
   * Quantize the time by the given subdivision. Optionally add a
   * percentage which will move the time value towards the ideal
   * quantized value by that percentage.
   * @param  subdiv    The subdivision to quantize to
   * @param  percent  Move the time value towards the quantized value by a percentage.
   * @example
   * Tone.Time(21).quantize(2); // returns 22
   * Tone.Time(0.6).quantize("4n", 0.5); // returns 0.55
   */
  quantize(t, n = 1) {
    const i = new this.constructor(this.context, t).valueOf(), r = this.valueOf(), o = Math.round(r / i) * i - r;
    return r + o * n;
  }
  //-------------------------------------
  // CONVERSIONS
  //-------------------------------------
  /**
   * Convert a Time to Notation. The notation values are will be the
   * closest representation between 1m to 128th note.
   * @return {Notation}
   * @example
   * // if the Transport is at 120bpm:
   * Tone.Time(2).toNotation(); // returns "1m"
   */
  toNotation() {
    const t = this.toSeconds(), n = ["1m"];
    for (let s = 1; s < 9; s++) {
      const a = Math.pow(2, s);
      n.push(a + "n."), n.push(a + "n"), n.push(a + "t");
    }
    n.push("0");
    let i = n[0], r = new vr(this.context, n[0]).toSeconds();
    return n.forEach((s) => {
      const a = new vr(this.context, s).toSeconds();
      Math.abs(a - t) < Math.abs(r - t) && (i = s, r = a);
    }), i;
  }
  /**
   * Return the time encoded as Bars:Beats:Sixteenths.
   */
  toBarsBeatsSixteenths() {
    const t = this._beatsToUnits(1);
    let n = this.valueOf() / t;
    n = parseFloat(n.toFixed(4));
    const i = Math.floor(n / this._getTimeSignature());
    let r = n % 1 * 4;
    n = Math.floor(n) % this._getTimeSignature();
    const s = r.toString();
    return s.length > 3 && (r = parseFloat(parseFloat(s).toFixed(3))), [i, n, r].join(":");
  }
  /**
   * Return the time in ticks.
   */
  toTicks() {
    const t = this._beatsToUnits(1);
    return this.valueOf() / t * this._getPPQ();
  }
  /**
   * Return the time in seconds.
   */
  toSeconds() {
    return this.valueOf();
  }
  /**
   * Return the value as a midi note.
   */
  toMidi() {
    return Cg(this.toFrequency());
  }
  _now() {
    return this.context.now();
  }
}
class Gi extends vr {
  constructor() {
    super(...arguments), this.name = "Frequency", this.defaultUnits = "hz";
  }
  /**
   * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used
   * to generate all the other pitch values from notes. A4's values in Hertz.
   */
  static get A4() {
    return JU();
  }
  static set A4(t) {
    QU(t);
  }
  //-------------------------------------
  // 	AUGMENT BASE EXPRESSIONS
  //-------------------------------------
  _getExpressions() {
    return Object.assign({}, super._getExpressions(), {
      midi: {
        regexp: /^(\d+(?:\.\d+)?midi)/,
        method(t) {
          return this.defaultUnits === "midi" ? t : Gi.mtof(t);
        }
      },
      note: {
        regexp: /^([a-g]{1}(?:b|#|##|x|bb|###|#x|x#|bbb)?)(-?[0-9]+)/i,
        method(t, n) {
          const r = tq[t.toLowerCase()] + (parseInt(n, 10) + 1) * 12;
          return this.defaultUnits === "midi" ? r : Gi.mtof(r);
        }
      },
      tr: {
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
        method(t, n, i) {
          let r = 1;
          return t && t !== "0" && (r *= this._beatsToUnits(this._getTimeSignature() * parseFloat(t))), n && n !== "0" && (r *= this._beatsToUnits(parseFloat(n))), i && i !== "0" && (r *= this._beatsToUnits(parseFloat(i) / 4)), r;
        }
      }
    });
  }
  //-------------------------------------
  // 	EXPRESSIONS
  //-------------------------------------
  /**
   * Transposes the frequency by the given number of semitones.
   * @return  A new transposed frequency
   * @example
   * Tone.Frequency("A4").transpose(3); // "C5"
   */
  transpose(t) {
    return new Gi(this.context, this.valueOf() * xx(t));
  }
  /**
   * Takes an array of semitone intervals and returns
   * an array of frequencies transposed by those intervals.
   * @return  Returns an array of Frequencies
   * @example
   * Tone.Frequency("A4").harmonize([0, 3, 7]); // ["A4", "C5", "E5"]
   */
  harmonize(t) {
    return t.map((n) => this.transpose(n));
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS
  //-------------------------------------
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Frequency("C4").toMidi(); // 60
   */
  toMidi() {
    return Cg(this.valueOf());
  }
  /**
   * Return the value of the frequency in Scientific Pitch Notation
   * @example
   * Tone.Frequency(69, "midi").toNote(); // "A4"
   */
  toNote() {
    const t = this.toFrequency(), n = Math.log2(t / Gi.A4);
    let i = Math.round(12 * n) + 57;
    const r = Math.floor(i / 12);
    return r < 0 && (i += -12 * r), nq[i % 12] + r.toString();
  }
  /**
   * Return the duration of one cycle in seconds.
   */
  toSeconds() {
    return 1 / super.toSeconds();
  }
  /**
   * Return the duration of one cycle in ticks
   */
  toTicks() {
    const t = this._beatsToUnits(1), n = this.valueOf() / t;
    return Math.floor(n * this._getPPQ());
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS HELPERS
  //-------------------------------------
  /**
   * With no arguments, return 0
   */
  _noArg() {
    return 0;
  }
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(t) {
    return t;
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(t) {
    return 1 / (t * 60 / (this._getBpm() * this._getPPQ()));
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(t) {
    return 1 / super._beatsToUnits(t);
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(t) {
    return 1 / t;
  }
  /**
   * Convert a MIDI note to frequency value.
   * @param  midi The midi number to convert.
   * @return The corresponding frequency value
   */
  static mtof(t) {
    return eq(t);
  }
  /**
   * Convert a frequency value to a MIDI note.
   * @param frequency The value to frequency value to convert.
   */
  static ftom(t) {
    return Cg(t);
  }
}
const tq = {
  cbbb: -3,
  cbb: -2,
  cb: -1,
  c: 0,
  "c#": 1,
  cx: 2,
  "c##": 2,
  "c###": 3,
  "cx#": 3,
  "c#x": 3,
  dbbb: -1,
  dbb: 0,
  db: 1,
  d: 2,
  "d#": 3,
  dx: 4,
  "d##": 4,
  "d###": 5,
  "dx#": 5,
  "d#x": 5,
  ebbb: 1,
  ebb: 2,
  eb: 3,
  e: 4,
  "e#": 5,
  ex: 6,
  "e##": 6,
  "e###": 7,
  "ex#": 7,
  "e#x": 7,
  fbbb: 2,
  fbb: 3,
  fb: 4,
  f: 5,
  "f#": 6,
  fx: 7,
  "f##": 7,
  "f###": 8,
  "fx#": 8,
  "f#x": 8,
  gbbb: 4,
  gbb: 5,
  gb: 6,
  g: 7,
  "g#": 8,
  gx: 9,
  "g##": 9,
  "g###": 10,
  "gx#": 10,
  "g#x": 10,
  abbb: 6,
  abb: 7,
  ab: 8,
  a: 9,
  "a#": 10,
  ax: 11,
  "a##": 11,
  "a###": 12,
  "ax#": 12,
  "a#x": 12,
  bbbb: 8,
  bbb: 9,
  bb: 10,
  b: 11,
  "b#": 12,
  bx: 13,
  "b##": 13,
  "b###": 14,
  "bx#": 14,
  "b#x": 14
}, nq = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
class Lu extends vr {
  constructor() {
    super(...arguments), this.name = "TransportTime";
  }
  /**
   * Return the current time in whichever context is relevant
   */
  _now() {
    return this.context.transport.seconds;
  }
}
class pi extends Is {
  constructor() {
    super();
    const t = Te(pi.getDefaults(), arguments, ["context"]);
    this.defaultContext ? this.context = this.defaultContext : this.context = t.context;
  }
  static getDefaults() {
    return {
      context: mr()
    };
  }
  /**
   * Return the current time of the Context clock plus the lookAhead.
   * @example
   * setInterval(() => {
   * 	console.log(Tone.now());
   * }, 100);
   */
  now() {
    return this.context.currentTime + this.context.lookAhead;
  }
  /**
   * Return the current time of the Context clock without any lookAhead.
   * @example
   * setInterval(() => {
   * 	console.log(Tone.immediate());
   * }, 100);
   */
  immediate() {
    return this.context.currentTime;
  }
  /**
   * The duration in seconds of one sample.
   */
  get sampleTime() {
    return 1 / this.context.sampleRate;
  }
  /**
   * The number of seconds of 1 processing block (128 samples)
   * @example
   * console.log(Tone.Destination.blockTime);
   */
  get blockTime() {
    return 128 / this.context.sampleRate;
  }
  /**
   * Convert the incoming time to seconds.
   * This is calculated against the current {@link TransportClass} bpm
   * @example
   * const gain = new Tone.Gain();
   * setInterval(() => console.log(gain.toSeconds("4n")), 100);
   * // ramp the tempo to 60 bpm over 30 seconds
   * Tone.getTransport().bpm.rampTo(60, 30);
   */
  toSeconds(t) {
    return NU(t), new vr(this.context, t).toSeconds();
  }
  /**
   * Convert the input to a frequency number
   * @example
   * const gain = new Tone.Gain();
   * console.log(gain.toFrequency("4n"));
   */
  toFrequency(t) {
    return new Gi(this.context, t).toFrequency();
  }
  /**
   * Convert the input time into ticks
   * @example
   * const gain = new Tone.Gain();
   * console.log(gain.toTicks("4n"));
   */
  toTicks(t) {
    return new Lu(this.context, t).toTicks();
  }
  //-------------------------------------
  // 	GET/SET
  //-------------------------------------
  /**
   * Get a subset of the properties which are in the partial props
   */
  _getPartialProperties(t) {
    const n = this.get();
    return Object.keys(n).forEach((i) => {
      Zi(t[i]) && delete n[i];
    }), n;
  }
  /**
   * Get the object's attributes.
   * @example
   * const osc = new Tone.Oscillator();
   * console.log(osc.get());
   */
  get() {
    const t = zU(this);
    return Object.keys(t).forEach((n) => {
      if (Reflect.has(this, n)) {
        const i = this[n];
        nt(i) && nt(i.value) && nt(i.setValueAtTime) ? t[n] = i.value : i instanceof pi ? t[n] = i._getPartialProperties(t[n]) : br(i) || io(i) || bs(i) || DU(i) ? t[n] = i : delete t[n];
      }
    }), t;
  }
  /**
   * Set multiple properties at once with an object.
   * @example
   * const filter = new Tone.Filter().toDestination();
   * // set values using an object
   * filter.set({
   * 	frequency: "C6",
   * 	type: "highpass"
   * });
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/Analogsynth_octaves_highmid.mp3").connect(filter);
   * player.autostart = true;
   */
  set(t) {
    return Object.keys(t).forEach((n) => {
      Reflect.has(this, n) && nt(this[n]) && (this[n] && nt(this[n].value) && nt(this[n].setValueAtTime) ? this[n].value !== t[n] && (this[n].value = t[n]) : this[n] instanceof pi ? this[n].set(t[n]) : this[n] = t[n]);
    }), this;
  }
}
class zy extends Ki {
  constructor(t = "stopped") {
    super(), this.name = "StateTimeline", this._initial = t, this.setStateAtTime(this._initial, 0);
  }
  /**
   * Returns the scheduled state scheduled before or at
   * the given time.
   * @param  time  The time to query.
   * @return  The name of the state input in setStateAtTime.
   */
  getValueAtTime(t) {
    const n = this.get(t);
    return n !== null ? n.state : this._initial;
  }
  /**
   * Add a state to the timeline.
   * @param  state The name of the state to set.
   * @param  time  The time to query.
   * @param options Any additional options that are needed in the timeline.
   */
  setStateAtTime(t, n, i) {
    return sa(n, 0), this.add(Object.assign({}, i, {
      state: t,
      time: n
    })), this;
  }
  /**
   * Return the event before the time with the given state
   * @param  state The state to look for
   * @param  time  When to check before
   * @return  The event with the given state before the time
   */
  getLastState(t, n) {
    const i = this._search(n);
    for (let r = i; r >= 0; r--) {
      const s = this._timeline[r];
      if (s.state === t)
        return s;
    }
  }
  /**
   * Return the event after the time with the given state
   * @param  state The state to look for
   * @param  time  When to check from
   * @return  The event with the given state after the time
   */
  getNextState(t, n) {
    const i = this._search(n);
    if (i !== -1)
      for (let r = i; r < this._timeline.length; r++) {
        const s = this._timeline[r];
        if (s.state === t)
          return s;
      }
  }
}
class Lt extends pi {
  constructor() {
    super(Te(Lt.getDefaults(), arguments, ["param", "units", "convert"])), this.name = "Param", this.overridden = !1, this._minOutput = 1e-7;
    const t = Te(Lt.getDefaults(), arguments, ["param", "units", "convert"]);
    for (Xe(nt(t.param) && (ro(t.param) || t.param instanceof Lt), "param must be an AudioParam"); !ro(t.param); )
      t.param = t.param._param;
    this._swappable = nt(t.swappable) ? t.swappable : !1, this._swappable ? (this.input = this.context.createGain(), this._param = t.param, this.input.connect(this._param)) : this._param = this.input = t.param, this._events = new Ki(1e3), this._initialValue = this._param.defaultValue, this.units = t.units, this.convert = t.convert, this._minValue = t.minValue, this._maxValue = t.maxValue, nt(t.value) && t.value !== this._toType(this._initialValue) && this.setValueAtTime(t.value, 0);
  }
  static getDefaults() {
    return Object.assign(pi.getDefaults(), {
      convert: !0,
      units: "number"
    });
  }
  get value() {
    const t = this.now();
    return this.getValueAtTime(t);
  }
  set value(t) {
    this.cancelScheduledValues(this.now()), this.setValueAtTime(t, this.now());
  }
  get minValue() {
    return nt(this._minValue) ? this._minValue : this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples" ? 0 : this.units === "audioRange" ? -1 : this.units === "decibels" ? -1 / 0 : this._param.minValue;
  }
  get maxValue() {
    return nt(this._maxValue) ? this._maxValue : this.units === "normalRange" || this.units === "audioRange" ? 1 : this._param.maxValue;
  }
  /**
   * Type guard based on the unit name
   */
  _is(t, n) {
    return this.units === n;
  }
  /**
   * Make sure the value is always in the defined range
   */
  _assertRange(t) {
    return nt(this.maxValue) && nt(this.minValue) && sa(t, this._fromType(this.minValue), this._fromType(this.maxValue)), t;
  }
  /**
   * Convert the given value from the type specified by Param.units
   * into the destination value (such as Gain or Frequency).
   */
  _fromType(t) {
    return this.convert && !this.overridden ? this._is(t, "time") ? this.toSeconds(t) : this._is(t, "decibels") ? KU(t) : this._is(t, "frequency") ? this.toFrequency(t) : t : this.overridden ? 0 : t;
  }
  /**
   * Convert the parameters value into the units specified by Param.units.
   */
  _toType(t) {
    return this.convert && this.units === "decibels" ? XU(t) : t;
  }
  //-------------------------------------
  // ABSTRACT PARAM INTERFACE
  // all docs are generated from ParamInterface.ts
  //-------------------------------------
  setValueAtTime(t, n) {
    const i = this.toSeconds(n), r = this._fromType(t);
    return Xe(isFinite(r) && isFinite(i), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._assertRange(r), this.log(this.units, "setValueAtTime", t, i), this._events.add({
      time: i,
      type: "setValueAtTime",
      value: r
    }), this._param.setValueAtTime(r, i), this;
  }
  getValueAtTime(t) {
    const n = Math.max(this.toSeconds(t), 0), i = this._events.getAfter(n), r = this._events.get(n);
    let s = this._initialValue;
    if (r === null)
      s = this._initialValue;
    else if (r.type === "setTargetAtTime" && (i === null || i.type === "setValueAtTime")) {
      const a = this._events.getBefore(r.time);
      let o;
      a === null ? o = this._initialValue : o = a.value, r.type === "setTargetAtTime" && (s = this._exponentialApproach(r.time, o, r.value, r.constant, n));
    } else if (i === null)
      s = r.value;
    else if (i.type === "linearRampToValueAtTime" || i.type === "exponentialRampToValueAtTime") {
      let a = r.value;
      if (r.type === "setTargetAtTime") {
        const o = this._events.getBefore(r.time);
        o === null ? a = this._initialValue : a = o.value;
      }
      i.type === "linearRampToValueAtTime" ? s = this._linearInterpolate(r.time, a, i.time, i.value, n) : s = this._exponentialInterpolate(r.time, a, i.time, i.value, n);
    } else
      s = r.value;
    return this._toType(s);
  }
  setRampPoint(t) {
    t = this.toSeconds(t);
    let n = this.getValueAtTime(t);
    return this.cancelAndHoldAtTime(t), this._fromType(n) === 0 && (n = this._toType(this._minOutput)), this.setValueAtTime(n, t), this;
  }
  linearRampToValueAtTime(t, n) {
    const i = this._fromType(t), r = this.toSeconds(n);
    return Xe(isFinite(i) && isFinite(r), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._assertRange(i), this._events.add({
      time: r,
      type: "linearRampToValueAtTime",
      value: i
    }), this.log(this.units, "linearRampToValueAtTime", t, r), this._param.linearRampToValueAtTime(i, r), this;
  }
  exponentialRampToValueAtTime(t, n) {
    let i = this._fromType(t);
    i = ur(i, 0) ? this._minOutput : i, this._assertRange(i);
    const r = this.toSeconds(n);
    return Xe(isFinite(i) && isFinite(r), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._events.add({
      time: r,
      type: "exponentialRampToValueAtTime",
      value: i
    }), this.log(this.units, "exponentialRampToValueAtTime", t, r), this._param.exponentialRampToValueAtTime(i, r), this;
  }
  exponentialRampTo(t, n, i) {
    return i = this.toSeconds(i), this.setRampPoint(i), this.exponentialRampToValueAtTime(t, i + this.toSeconds(n)), this;
  }
  linearRampTo(t, n, i) {
    return i = this.toSeconds(i), this.setRampPoint(i), this.linearRampToValueAtTime(t, i + this.toSeconds(n)), this;
  }
  targetRampTo(t, n, i) {
    return i = this.toSeconds(i), this.setRampPoint(i), this.exponentialApproachValueAtTime(t, i, n), this;
  }
  exponentialApproachValueAtTime(t, n, i) {
    n = this.toSeconds(n), i = this.toSeconds(i);
    const r = Math.log(i + 1) / Math.log(200);
    return this.setTargetAtTime(t, n, r), this.cancelAndHoldAtTime(n + i * 0.9), this.linearRampToValueAtTime(t, n + i), this;
  }
  setTargetAtTime(t, n, i) {
    const r = this._fromType(t);
    Xe(isFinite(i) && i > 0, "timeConstant must be a number greater than 0");
    const s = this.toSeconds(n);
    return this._assertRange(r), Xe(isFinite(r) && isFinite(s), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._events.add({
      constant: i,
      time: s,
      type: "setTargetAtTime",
      value: r
    }), this.log(this.units, "setTargetAtTime", t, s, i), this._param.setTargetAtTime(r, s, i), this;
  }
  setValueCurveAtTime(t, n, i, r = 1) {
    i = this.toSeconds(i), n = this.toSeconds(n);
    const s = this._fromType(t[0]) * r;
    this.setValueAtTime(this._toType(s), n);
    const a = i / (t.length - 1);
    for (let o = 1; o < t.length; o++) {
      const l = this._fromType(t[o]) * r;
      this.linearRampToValueAtTime(this._toType(l), n + o * a);
    }
    return this;
  }
  cancelScheduledValues(t) {
    const n = this.toSeconds(t);
    return Xe(isFinite(n), `Invalid argument to cancelScheduledValues: ${JSON.stringify(t)}`), this._events.cancel(n), this._param.cancelScheduledValues(n), this.log(this.units, "cancelScheduledValues", n), this;
  }
  cancelAndHoldAtTime(t) {
    const n = this.toSeconds(t), i = this._fromType(this.getValueAtTime(n));
    Xe(isFinite(n), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(t)}`), this.log(this.units, "cancelAndHoldAtTime", n, "value=" + i);
    const r = this._events.get(n), s = this._events.getAfter(n);
    return r && ur(r.time, n) ? s ? (this._param.cancelScheduledValues(s.time), this._events.cancel(s.time)) : (this._param.cancelAndHoldAtTime(n), this._events.cancel(n + this.sampleTime)) : s && (this._param.cancelScheduledValues(s.time), this._events.cancel(s.time), s.type === "linearRampToValueAtTime" ? this.linearRampToValueAtTime(this._toType(i), n) : s.type === "exponentialRampToValueAtTime" && this.exponentialRampToValueAtTime(this._toType(i), n)), this._events.add({
      time: n,
      type: "setValueAtTime",
      value: i
    }), this._param.setValueAtTime(i, n), this;
  }
  rampTo(t, n = 0.1, i) {
    return this.units === "frequency" || this.units === "bpm" || this.units === "decibels" ? this.exponentialRampTo(t, n, i) : this.linearRampTo(t, n, i), this;
  }
  /**
   * Apply all of the previously scheduled events to the passed in Param or AudioParam.
   * The applied values will start at the context's current time and schedule
   * all of the events which are scheduled on this Param onto the passed in param.
   */
  apply(t) {
    const n = this.context.currentTime;
    t.setValueAtTime(this.getValueAtTime(n), n);
    const i = this._events.get(n);
    if (i && i.type === "setTargetAtTime") {
      const r = this._events.getAfter(i.time), s = r ? r.time : n + 2, a = (s - n) / 10;
      for (let o = n; o < s; o += a)
        t.linearRampToValueAtTime(this.getValueAtTime(o), o);
    }
    return this._events.forEachAfter(this.context.currentTime, (r) => {
      r.type === "cancelScheduledValues" ? t.cancelScheduledValues(r.time) : r.type === "setTargetAtTime" ? t.setTargetAtTime(r.value, r.time, r.constant) : t[r.type](r.value, r.time);
    }), this;
  }
  /**
   * Replace the Param's internal AudioParam. Will apply scheduled curves
   * onto the parameter and replace the connections.
   */
  setParam(t) {
    Xe(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
    const n = this.input;
    return n.disconnect(this._param), this.apply(t), this._param = t, n.connect(this._param), this;
  }
  dispose() {
    return super.dispose(), this._events.dispose(), this;
  }
  get defaultValue() {
    return this._toType(this._param.defaultValue);
  }
  //-------------------------------------
  // 	AUTOMATION CURVE CALCULATIONS
  // 	MIT License, copyright (c) 2014 Jordan Santell
  //-------------------------------------
  // Calculates the the value along the curve produced by setTargetAtTime
  _exponentialApproach(t, n, i, r, s) {
    return i + (n - i) * Math.exp(-(s - t) / r);
  }
  // Calculates the the value along the curve produced by linearRampToValueAtTime
  _linearInterpolate(t, n, i, r, s) {
    return n + (r - n) * ((s - t) / (i - t));
  }
  // Calculates the the value along the curve produced by exponentialRampToValueAtTime
  _exponentialInterpolate(t, n, i, r, s) {
    return n * Math.pow(r / n, (s - t) / (i - t));
  }
}
class et extends pi {
  constructor() {
    super(...arguments), this._internalChannels = [];
  }
  /**
   * The number of inputs feeding into the AudioNode.
   * For source nodes, this will be 0.
   * @example
   * const node = new Tone.Gain();
   * console.log(node.numberOfInputs);
   */
  get numberOfInputs() {
    return nt(this.input) ? ro(this.input) || this.input instanceof Lt ? 1 : this.input.numberOfInputs : 0;
  }
  /**
   * The number of outputs of the AudioNode.
   * @example
   * const node = new Tone.Gain();
   * console.log(node.numberOfOutputs);
   */
  get numberOfOutputs() {
    return nt(this.output) ? this.output.numberOfOutputs : 0;
  }
  //-------------------------------------
  // AUDIO PROPERTIES
  //-------------------------------------
  /**
   * Used to decide which nodes to get/set properties on
   */
  _isAudioNode(t) {
    return nt(t) && (t instanceof et || ta(t));
  }
  /**
   * Get all of the audio nodes (either internal or input/output) which together
   * make up how the class node responds to channel input/output
   */
  _getInternalNodes() {
    const t = this._internalChannels.slice(0);
    return this._isAudioNode(this.input) && t.push(this.input), this._isAudioNode(this.output) && this.input !== this.output && t.push(this.output), t;
  }
  /**
   * Set the audio options for this node such as channelInterpretation
   * channelCount, etc.
   * @param options
   */
  _setChannelProperties(t) {
    this._getInternalNodes().forEach((i) => {
      i.channelCount = t.channelCount, i.channelCountMode = t.channelCountMode, i.channelInterpretation = t.channelInterpretation;
    });
  }
  /**
   * Get the current audio options for this node such as channelInterpretation
   * channelCount, etc.
   */
  _getChannelProperties() {
    const t = this._getInternalNodes();
    Xe(t.length > 0, "ToneAudioNode does not have any internal nodes");
    const n = t[0];
    return {
      channelCount: n.channelCount,
      channelCountMode: n.channelCountMode,
      channelInterpretation: n.channelInterpretation
    };
  }
  /**
   * channelCount is the number of channels used when up-mixing and down-mixing
   * connections to any inputs to the node. The default value is 2 except for
   * specific nodes where its value is specially determined.
   */
  get channelCount() {
    return this._getChannelProperties().channelCount;
  }
  set channelCount(t) {
    const n = this._getChannelProperties();
    this._setChannelProperties(Object.assign(n, { channelCount: t }));
  }
  /**
   * channelCountMode determines how channels will be counted when up-mixing and
   * down-mixing connections to any inputs to the node.
   * The default value is "max". This attribute has no effect for nodes with no inputs.
   * * "max" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.
   * * "clamped-max" - computedNumberOfChannels is determined as for "max" and then clamped to a maximum value of the given channelCount.
   * * "explicit" - computedNumberOfChannels is the exact value as specified by the channelCount.
   */
  get channelCountMode() {
    return this._getChannelProperties().channelCountMode;
  }
  set channelCountMode(t) {
    const n = this._getChannelProperties();
    this._setChannelProperties(Object.assign(n, { channelCountMode: t }));
  }
  /**
   * channelInterpretation determines how individual channels will be treated
   * when up-mixing and down-mixing connections to any inputs to the node.
   * The default value is "speakers".
   */
  get channelInterpretation() {
    return this._getChannelProperties().channelInterpretation;
  }
  set channelInterpretation(t) {
    const n = this._getChannelProperties();
    this._setChannelProperties(Object.assign(n, { channelInterpretation: t }));
  }
  //-------------------------------------
  // CONNECTIONS
  //-------------------------------------
  /**
   * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode
   * @param destination The output to connect to
   * @param outputNum The output to connect from
   * @param inputNum The input to connect to
   */
  connect(t, n = 0, i = 0) {
    return tu(this, t, n, i), this;
  }
  /**
   * Connect the output to the context's destination node.
   * @example
   * const osc = new Tone.Oscillator("C2").start();
   * osc.toDestination();
   */
  toDestination() {
    return this.connect(this.context.destination), this;
  }
  /**
   * Connect the output to the context's destination node.
   * @see {@link toDestination}
   * @deprecated
   */
  toMaster() {
    return $y("toMaster() has been renamed toDestination()"), this.toDestination();
  }
  /**
   * disconnect the output
   */
  disconnect(t, n = 0, i = 0) {
    return iq(this, t, n, i), this;
  }
  /**
   * Connect the output of this node to the rest of the nodes in series.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3");
   * player.autostart = true;
   * const filter = new Tone.AutoFilter(4).start();
   * const distortion = new Tone.Distortion(0.5);
   * // connect the player to the filter, distortion and then to the master output
   * player.chain(filter, distortion, Tone.Destination);
   */
  chain(...t) {
    return Tg(this, ...t), this;
  }
  /**
   * connect the output of this node to the rest of the nodes in parallel.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3");
   * player.autostart = true;
   * const pitchShift = new Tone.PitchShift(4).toDestination();
   * const filter = new Tone.Filter("G5").toDestination();
   * // connect a node to the pitch shift and filter in parallel
   * player.fan(pitchShift, filter);
   */
  fan(...t) {
    return t.forEach((n) => this.connect(n)), this;
  }
  /**
   * Dispose and disconnect
   */
  dispose() {
    return super.dispose(), nt(this.input) && (this.input instanceof et ? this.input.dispose() : ta(this.input) && this.input.disconnect()), nt(this.output) && (this.output instanceof et ? this.output.dispose() : ta(this.output) && this.output.disconnect()), this._internalChannels = [], this;
  }
}
function Tg(...e) {
  const t = e.shift();
  e.reduce((n, i) => (n instanceof et ? n.connect(i) : ta(n) && tu(n, i), i), t);
}
function tu(e, t, n = 0, i = 0) {
  for (Xe(nt(e), "Cannot connect from undefined node"), Xe(nt(t), "Cannot connect to undefined node"), (t instanceof et || ta(t)) && Xe(t.numberOfInputs > 0, "Cannot connect to node with no inputs"), Xe(e.numberOfOutputs > 0, "Cannot connect from node with no outputs"); t instanceof et || t instanceof Lt; )
    nt(t.input) && (t = t.input);
  for (; e instanceof et; )
    nt(e.output) && (e = e.output);
  ro(t) ? e.connect(t, n) : e.connect(t, n, i);
}
function iq(e, t, n = 0, i = 0) {
  if (nt(t))
    for (; t instanceof et; )
      t = t.input;
  for (; !ta(e); )
    nt(e.output) && (e = e.output);
  ro(t) ? e.disconnect(t, n) : ta(t) ? e.disconnect(t, n, i) : e.disconnect();
}
class Bn extends et {
  constructor() {
    super(Te(Bn.getDefaults(), arguments, ["gain", "units"])), this.name = "Gain", this._gainNode = this.context.createGain(), this.input = this._gainNode, this.output = this._gainNode;
    const t = Te(Bn.getDefaults(), arguments, ["gain", "units"]);
    this.gain = new Lt({
      context: this.context,
      convert: t.convert,
      param: this._gainNode.gain,
      units: t.units,
      value: t.gain,
      minValue: t.minValue,
      maxValue: t.maxValue
    }), Jt(this, "gain");
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      convert: !0,
      gain: 1,
      units: "gain"
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._gainNode.disconnect(), this.gain.dispose(), this;
  }
}
class xl extends et {
  constructor(t) {
    super(t), this.onended = wt, this._startTime = -1, this._stopTime = -1, this._timeout = -1, this.output = new Bn({
      context: this.context,
      gain: 0
    }), this._gainNode = this.output, this.getStateAtTime = function(n) {
      const i = this.toSeconds(n);
      return this._startTime !== -1 && i >= this._startTime && (this._stopTime === -1 || i <= this._stopTime) ? "started" : "stopped";
    }, this._fadeIn = t.fadeIn, this._fadeOut = t.fadeOut, this._curve = t.curve, this.onended = t.onended;
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      curve: "linear",
      fadeIn: 0,
      fadeOut: 0,
      onended: wt
    });
  }
  /**
   * Start the source at the given time
   * @param  time When to start the source
   */
  _startGain(t, n = 1) {
    Xe(this._startTime === -1, "Source cannot be started more than once");
    const i = this.toSeconds(this._fadeIn);
    return this._startTime = t + i, this._startTime = Math.max(this._startTime, this.context.currentTime), i > 0 ? (this._gainNode.gain.setValueAtTime(0, t), this._curve === "linear" ? this._gainNode.gain.linearRampToValueAtTime(n, t + i) : this._gainNode.gain.exponentialApproachValueAtTime(n, t, i)) : this._gainNode.gain.setValueAtTime(n, t), this;
  }
  /**
   * Stop the source node at the given time.
   * @param time When to stop the source
   */
  stop(t) {
    return this.log("stop", t), this._stopGain(this.toSeconds(t)), this;
  }
  /**
   * Stop the source at the given time
   * @param  time When to stop the source
   */
  _stopGain(t) {
    Xe(this._startTime !== -1, "'start' must be called before 'stop'"), this.cancelStop();
    const n = this.toSeconds(this._fadeOut);
    return this._stopTime = this.toSeconds(t) + n, this._stopTime = Math.max(this._stopTime, this.now()), n > 0 ? this._curve === "linear" ? this._gainNode.gain.linearRampTo(0, n, t) : this._gainNode.gain.targetRampTo(0, n, t) : (this._gainNode.gain.cancelAndHoldAtTime(t), this._gainNode.gain.setValueAtTime(0, t)), this.context.clearTimeout(this._timeout), this._timeout = this.context.setTimeout(() => {
      const i = this._curve === "exponential" ? n * 2 : 0;
      this._stopSource(this.now() + i), this._onended();
    }, this._stopTime - this.context.currentTime), this;
  }
  /**
   * Invoke the onended callback
   */
  _onended() {
    if (this.onended !== wt && (this.onended(this), this.onended = wt, !this.context.isOffline)) {
      const t = () => this.dispose();
      typeof window.requestIdleCallback < "u" ? window.requestIdleCallback(t) : setTimeout(t, 1e3);
    }
  }
  /**
   * Get the playback state at the current time
   */
  get state() {
    return this.getStateAtTime(this.now());
  }
  /**
   * Cancel a scheduled stop event
   */
  cancelStop() {
    return this.log("cancelStop"), Xe(this._startTime !== -1, "Source is not started"), this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime), this.context.clearTimeout(this._timeout), this._stopTime = -1, this;
  }
  dispose() {
    return super.dispose(), this._gainNode.dispose(), this.onended = wt, this;
  }
}
class Gf extends xl {
  constructor() {
    super(Te(Gf.getDefaults(), arguments, ["offset"])), this.name = "ToneConstantSource", this._source = this.context.createConstantSource();
    const t = Te(Gf.getDefaults(), arguments, ["offset"]);
    tu(this._source, this._gainNode), this.offset = new Lt({
      context: this.context,
      convert: t.convert,
      param: this._source.offset,
      units: t.units,
      value: t.offset,
      minValue: t.minValue,
      maxValue: t.maxValue
    });
  }
  static getDefaults() {
    return Object.assign(xl.getDefaults(), {
      convert: !0,
      offset: 1,
      units: "number"
    });
  }
  /**
   * Start the source node at the given time
   * @param  time When to start the source
   */
  start(t) {
    const n = this.toSeconds(t);
    return this.log("start", n), this._startGain(n), this._source.start(n), this;
  }
  _stopSource(t) {
    this._source.stop(t);
  }
  dispose() {
    return super.dispose(), this.state === "started" && this.stop(), this._source.disconnect(), this.offset.dispose(), this;
  }
}
class pn extends et {
  constructor() {
    super(Te(pn.getDefaults(), arguments, ["value", "units"])), this.name = "Signal", this.override = !0;
    const t = Te(pn.getDefaults(), arguments, ["value", "units"]);
    this.output = this._constantSource = new Gf({
      context: this.context,
      convert: t.convert,
      offset: t.value,
      units: t.units,
      minValue: t.minValue,
      maxValue: t.maxValue
    }), this._constantSource.start(0), this.input = this._param = this._constantSource.offset;
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      convert: !0,
      units: "number",
      value: 0
    });
  }
  connect(t, n = 0, i = 0) {
    return Uy(this, t, n, i), this;
  }
  dispose() {
    return super.dispose(), this._param.dispose(), this._constantSource.dispose(), this;
  }
  //-------------------------------------
  // ABSTRACT PARAM INTERFACE
  // just a proxy for the ConstantSourceNode's offset AudioParam
  // all docs are generated from AbstractParam.ts
  //-------------------------------------
  setValueAtTime(t, n) {
    return this._param.setValueAtTime(t, n), this;
  }
  getValueAtTime(t) {
    return this._param.getValueAtTime(t);
  }
  setRampPoint(t) {
    return this._param.setRampPoint(t), this;
  }
  linearRampToValueAtTime(t, n) {
    return this._param.linearRampToValueAtTime(t, n), this;
  }
  exponentialRampToValueAtTime(t, n) {
    return this._param.exponentialRampToValueAtTime(t, n), this;
  }
  exponentialRampTo(t, n, i) {
    return this._param.exponentialRampTo(t, n, i), this;
  }
  linearRampTo(t, n, i) {
    return this._param.linearRampTo(t, n, i), this;
  }
  targetRampTo(t, n, i) {
    return this._param.targetRampTo(t, n, i), this;
  }
  exponentialApproachValueAtTime(t, n, i) {
    return this._param.exponentialApproachValueAtTime(t, n, i), this;
  }
  setTargetAtTime(t, n, i) {
    return this._param.setTargetAtTime(t, n, i), this;
  }
  setValueCurveAtTime(t, n, i, r) {
    return this._param.setValueCurveAtTime(t, n, i, r), this;
  }
  cancelScheduledValues(t) {
    return this._param.cancelScheduledValues(t), this;
  }
  cancelAndHoldAtTime(t) {
    return this._param.cancelAndHoldAtTime(t), this;
  }
  rampTo(t, n, i) {
    return this._param.rampTo(t, n, i), this;
  }
  get value() {
    return this._param.value;
  }
  set value(t) {
    this._param.value = t;
  }
  get convert() {
    return this._param.convert;
  }
  set convert(t) {
    this._param.convert = t;
  }
  get units() {
    return this._param.units;
  }
  get overridden() {
    return this._param.overridden;
  }
  set overridden(t) {
    this._param.overridden = t;
  }
  get maxValue() {
    return this._param.maxValue;
  }
  get minValue() {
    return this._param.minValue;
  }
  /**
   * @see {@link Param.apply}.
   */
  apply(t) {
    return this._param.apply(t), this;
  }
}
function Uy(e, t, n, i) {
  (t instanceof Lt || ro(t) || t instanceof pn && t.override) && (t.cancelScheduledValues(0), t.setValueAtTime(0, 0), t instanceof pn && (t.overridden = !0)), tu(e, t, n, i);
}
class Yf extends Lt {
  constructor() {
    super(Te(Yf.getDefaults(), arguments, ["value"])), this.name = "TickParam", this._events = new Ki(1 / 0), this._multiplier = 1;
    const t = Te(Yf.getDefaults(), arguments, ["value"]);
    this._multiplier = t.multiplier, this._events.cancel(0), this._events.add({
      ticks: 0,
      time: 0,
      type: "setValueAtTime",
      value: this._fromType(t.value)
    }), this.setValueAtTime(t.value, 0);
  }
  static getDefaults() {
    return Object.assign(Lt.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }
  setTargetAtTime(t, n, i) {
    n = this.toSeconds(n), this.setRampPoint(n);
    const r = this._fromType(t), s = this._events.get(n), a = Math.round(Math.max(1 / i, 1));
    for (let o = 0; o <= a; o++) {
      const l = i * o + n, u = this._exponentialApproach(s.time, s.value, r, i, l);
      this.linearRampToValueAtTime(this._toType(u), l);
    }
    return this;
  }
  setValueAtTime(t, n) {
    const i = this.toSeconds(n);
    super.setValueAtTime(t, n);
    const r = this._events.get(i), s = this._events.previousEvent(r), a = this._getTicksUntilEvent(s, i);
    return r.ticks = Math.max(a, 0), this;
  }
  linearRampToValueAtTime(t, n) {
    const i = this.toSeconds(n);
    super.linearRampToValueAtTime(t, n);
    const r = this._events.get(i), s = this._events.previousEvent(r), a = this._getTicksUntilEvent(s, i);
    return r.ticks = Math.max(a, 0), this;
  }
  exponentialRampToValueAtTime(t, n) {
    n = this.toSeconds(n);
    const i = this._fromType(t), r = this._events.get(n), s = Math.round(Math.max((n - r.time) * 10, 1)), a = (n - r.time) / s;
    for (let o = 0; o <= s; o++) {
      const l = a * o + r.time, u = this._exponentialInterpolate(r.time, r.value, n, i, l);
      this.linearRampToValueAtTime(this._toType(u), l);
    }
    return this;
  }
  /**
   * Returns the tick value at the time. Takes into account
   * any automation curves scheduled on the signal.
   * @param  event The time to get the tick count at
   * @return The number of ticks which have elapsed at the time given any automations.
   */
  _getTicksUntilEvent(t, n) {
    if (t === null)
      t = {
        ticks: 0,
        time: 0,
        type: "setValueAtTime",
        value: 0
      };
    else if (Zi(t.ticks)) {
      const a = this._events.previousEvent(t);
      t.ticks = this._getTicksUntilEvent(a, t.time);
    }
    const i = this._fromType(this.getValueAtTime(t.time));
    let r = this._fromType(this.getValueAtTime(n));
    const s = this._events.get(n);
    return s && s.time === n && s.type === "setValueAtTime" && (r = this._fromType(this.getValueAtTime(n - this.sampleTime))), 0.5 * (n - t.time) * (i + r) + t.ticks;
  }
  /**
   * Returns the tick value at the time. Takes into account
   * any automation curves scheduled on the signal.
   * @param  time The time to get the tick count at
   * @return The number of ticks which have elapsed at the time given any automations.
   */
  getTicksAtTime(t) {
    const n = this.toSeconds(t), i = this._events.get(n);
    return Math.max(this._getTicksUntilEvent(i, n), 0);
  }
  /**
   * Return the elapsed time of the number of ticks from the given time
   * @param ticks The number of ticks to calculate
   * @param  time The time to get the next tick from
   * @return The duration of the number of ticks from the given time in seconds
   */
  getDurationOfTicks(t, n) {
    const i = this.toSeconds(n), r = this.getTicksAtTime(n);
    return this.getTimeOfTick(r + t) - i;
  }
  /**
   * Given a tick, returns the time that tick occurs at.
   * @return The time that the tick occurs.
   */
  getTimeOfTick(t) {
    const n = this._events.get(t, "ticks"), i = this._events.getAfter(t, "ticks");
    if (n && n.ticks === t)
      return n.time;
    if (n && i && i.type === "linearRampToValueAtTime" && n.value !== i.value) {
      const r = this._fromType(this.getValueAtTime(n.time)), a = (this._fromType(this.getValueAtTime(i.time)) - r) / (i.time - n.time), o = Math.sqrt(Math.pow(r, 2) - 2 * a * (n.ticks - t)), l = (-r + o) / a, u = (-r - o) / a;
      return (l > 0 ? l : u) + n.time;
    } else
      return n ? n.value === 0 ? 1 / 0 : n.time + (t - n.ticks) / n.value : t / this._initialValue;
  }
  /**
   * Convert some number of ticks their the duration in seconds accounting
   * for any automation curves starting at the given time.
   * @param  ticks The number of ticks to convert to seconds.
   * @param  when  When along the automation timeline to convert the ticks.
   * @return The duration in seconds of the ticks.
   */
  ticksToTime(t, n) {
    return this.getDurationOfTicks(t, n);
  }
  /**
   * The inverse of {@link ticksToTime}. Convert a duration in
   * seconds to the corresponding number of ticks accounting for any
   * automation curves starting at the given time.
   * @param  duration The time interval to convert to ticks.
   * @param  when When along the automation timeline to convert the ticks.
   * @return The duration in ticks.
   */
  timeToTicks(t, n) {
    const i = this.toSeconds(n), r = this.toSeconds(t), s = this.getTicksAtTime(i);
    return this.getTicksAtTime(i + r) - s;
  }
  /**
   * Convert from the type when the unit value is BPM
   */
  _fromType(t) {
    return this.units === "bpm" && this.multiplier ? 1 / (60 / t / this.multiplier) : super._fromType(t);
  }
  /**
   * Special case of type conversion where the units === "bpm"
   */
  _toType(t) {
    return this.units === "bpm" && this.multiplier ? t / this.multiplier * 60 : super._toType(t);
  }
  /**
   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
   */
  get multiplier() {
    return this._multiplier;
  }
  set multiplier(t) {
    const n = this.value;
    this._multiplier = t, this.cancelScheduledValues(0), this.setValueAtTime(n, 0);
  }
}
class Zf extends pn {
  constructor() {
    super(Te(Zf.getDefaults(), arguments, ["value"])), this.name = "TickSignal";
    const t = Te(Zf.getDefaults(), arguments, ["value"]);
    this.input = this._param = new Yf({
      context: this.context,
      convert: t.convert,
      multiplier: t.multiplier,
      param: this._constantSource.offset,
      units: t.units,
      value: t.value
    });
  }
  static getDefaults() {
    return Object.assign(pn.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }
  ticksToTime(t, n) {
    return this._param.ticksToTime(t, n);
  }
  timeToTicks(t, n) {
    return this._param.timeToTicks(t, n);
  }
  getTimeOfTick(t) {
    return this._param.getTimeOfTick(t);
  }
  getDurationOfTicks(t, n) {
    return this._param.getDurationOfTicks(t, n);
  }
  getTicksAtTime(t) {
    return this._param.getTicksAtTime(t);
  }
  /**
   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
   */
  get multiplier() {
    return this._param.multiplier;
  }
  set multiplier(t) {
    this._param.multiplier = t;
  }
  dispose() {
    return super.dispose(), this._param.dispose(), this;
  }
}
class Kf extends pi {
  constructor() {
    super(Te(Kf.getDefaults(), arguments, ["frequency"])), this.name = "TickSource", this._state = new zy(), this._tickOffset = new Ki(), this._ticksAtTime = new Ki(), this._secondsAtTime = new Ki();
    const t = Te(Kf.getDefaults(), arguments, ["frequency"]);
    this.frequency = new Zf({
      context: this.context,
      units: t.units,
      value: t.frequency
    }), Jt(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.setTicksAtTime(0, 0);
  }
  static getDefaults() {
    return Object.assign({
      frequency: 1,
      units: "hertz"
    }, pi.getDefaults());
  }
  /**
   * Returns the playback state of the source, either "started", "stopped" or "paused".
   */
  get state() {
    return this.getStateAtTime(this.now());
  }
  /**
   * Start the clock at the given time. Optionally pass in an offset
   * of where to start the tick counter from.
   * @param  time    The time the clock should start
   * @param offset The number of ticks to start the source at
   */
  start(t, n) {
    const i = this.toSeconds(t);
    return this._state.getValueAtTime(i) !== "started" && (this._state.setStateAtTime("started", i), nt(n) && this.setTicksAtTime(n, i), this._ticksAtTime.cancel(i), this._secondsAtTime.cancel(i)), this;
  }
  /**
   * Stop the clock. Stopping the clock resets the tick counter to 0.
   * @param time The time when the clock should stop.
   */
  stop(t) {
    const n = this.toSeconds(t);
    if (this._state.getValueAtTime(n) === "stopped") {
      const i = this._state.get(n);
      i && i.time > 0 && (this._tickOffset.cancel(i.time), this._state.cancel(i.time));
    }
    return this._state.cancel(n), this._state.setStateAtTime("stopped", n), this.setTicksAtTime(0, n), this._ticksAtTime.cancel(n), this._secondsAtTime.cancel(n), this;
  }
  /**
   * Pause the clock. Pausing does not reset the tick counter.
   * @param time The time when the clock should stop.
   */
  pause(t) {
    const n = this.toSeconds(t);
    return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n), this._ticksAtTime.cancel(n), this._secondsAtTime.cancel(n)), this;
  }
  /**
   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.
   * @param time When to clear the events after
   */
  cancel(t) {
    return t = this.toSeconds(t), this._state.cancel(t), this._tickOffset.cancel(t), this._ticksAtTime.cancel(t), this._secondsAtTime.cancel(t), this;
  }
  /**
   * Get the elapsed ticks at the given time
   * @param  time  When to get the tick value
   * @return The number of ticks
   */
  getTicksAtTime(t) {
    const n = this.toSeconds(t), i = this._state.getLastState("stopped", n), r = this._ticksAtTime.get(n), s = { state: "paused", time: n };
    this._state.add(s);
    let a = r || i, o = r ? r.ticks : 0, l = null;
    return this._state.forEachBetween(a.time, n + this.sampleTime, (u) => {
      let c = a.time;
      const d = this._tickOffset.get(u.time);
      d && d.time >= a.time && (o = d.ticks, c = d.time), a.state === "started" && u.state !== "started" && (o += this.frequency.getTicksAtTime(u.time) - this.frequency.getTicksAtTime(c), u.time !== s.time && (l = { state: u.state, time: u.time, ticks: o })), a = u;
    }), this._state.remove(s), l && this._ticksAtTime.add(l), o;
  }
  /**
   * The number of times the callback was invoked. Starts counting at 0
   * and increments after the callback was invoked. Returns -1 when stopped.
   */
  get ticks() {
    return this.getTicksAtTime(this.now());
  }
  set ticks(t) {
    this.setTicksAtTime(t, this.now());
  }
  /**
   * The time since ticks=0 that the TickSource has been running. Accounts
   * for tempo curves
   */
  get seconds() {
    return this.getSecondsAtTime(this.now());
  }
  set seconds(t) {
    const n = this.now(), i = this.frequency.timeToTicks(t, n);
    this.setTicksAtTime(i, n);
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(t) {
    t = this.toSeconds(t);
    const n = this._state.getLastState("stopped", t), i = { state: "paused", time: t };
    this._state.add(i);
    const r = this._secondsAtTime.get(t);
    let s = r || n, a = r ? r.seconds : 0, o = null;
    return this._state.forEachBetween(s.time, t + this.sampleTime, (l) => {
      let u = s.time;
      const c = this._tickOffset.get(l.time);
      c && c.time >= s.time && (a = c.seconds, u = c.time), s.state === "started" && l.state !== "started" && (a += l.time - u, l.time !== i.time && (o = { state: l.state, time: l.time, seconds: a })), s = l;
    }), this._state.remove(i), o && this._secondsAtTime.add(o), a;
  }
  /**
   * Set the clock's ticks at the given time.
   * @param  ticks The tick value to set
   * @param  time  When to set the tick value
   */
  setTicksAtTime(t, n) {
    return n = this.toSeconds(n), this._tickOffset.cancel(n), this._tickOffset.add({
      seconds: this.frequency.getDurationOfTicks(t, n),
      ticks: t,
      time: n
    }), this._ticksAtTime.cancel(n), this._secondsAtTime.cancel(n), this;
  }
  /**
   * Returns the scheduled state at the given time.
   * @param  time  The time to query.
   */
  getStateAtTime(t) {
    return t = this.toSeconds(t), this._state.getValueAtTime(t);
  }
  /**
   * Get the time of the given tick. The second argument
   * is when to test before. Since ticks can be set (with setTicksAtTime)
   * there may be multiple times for a given tick value.
   * @param  tick The tick number.
   * @param  before When to measure the tick value from.
   * @return The time of the tick
   */
  getTimeOfTick(t, n = this.now()) {
    const i = this._tickOffset.get(n), r = this._state.get(n), s = Math.max(i.time, r.time), a = this.frequency.getTicksAtTime(s) + t - i.ticks;
    return this.frequency.getTimeOfTick(a);
  }
  /**
   * Invoke the callback event at all scheduled ticks between the
   * start time and the end time
   * @param  startTime  The beginning of the search range
   * @param  endTime    The end of the search range
   * @param  callback   The callback to invoke with each tick
   */
  forEachTickBetween(t, n, i) {
    let r = this._state.get(t);
    this._state.forEachBetween(t, n, (a) => {
      r && r.state === "started" && a.state !== "started" && this.forEachTickBetween(Math.max(r.time, t), a.time - this.sampleTime, i), r = a;
    });
    let s = null;
    if (r && r.state === "started") {
      const a = Math.max(r.time, t), o = this.frequency.getTicksAtTime(a), l = this.frequency.getTicksAtTime(r.time), u = o - l;
      let c = Math.ceil(u) - u;
      c = ur(c, 1) ? 0 : c;
      let d = this.frequency.getTimeOfTick(o + c);
      for (; d < n; ) {
        try {
          i(d, Math.round(this.getTicksAtTime(d)));
        } catch (f) {
          s = f;
          break;
        }
        d += this.frequency.getDurationOfTicks(1, d);
      }
    }
    if (s)
      throw s;
    return this;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._state.dispose(), this._tickOffset.dispose(), this._ticksAtTime.dispose(), this._secondsAtTime.dispose(), this.frequency.dispose(), this;
  }
}
class lc extends pi {
  constructor() {
    super(Te(lc.getDefaults(), arguments, ["callback", "frequency"])), this.name = "Clock", this.callback = wt, this._lastUpdate = 0, this._state = new zy("stopped"), this._boundLoop = this._loop.bind(this);
    const t = Te(lc.getDefaults(), arguments, ["callback", "frequency"]);
    this.callback = t.callback, this._tickSource = new Kf({
      context: this.context,
      frequency: t.frequency,
      units: t.units
    }), this._lastUpdate = 0, this.frequency = this._tickSource.frequency, Jt(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.context.on("tick", this._boundLoop);
  }
  static getDefaults() {
    return Object.assign(pi.getDefaults(), {
      callback: wt,
      frequency: 1,
      units: "hertz"
    });
  }
  /**
   * Returns the playback state of the source, either "started", "stopped" or "paused".
   */
  get state() {
    return this._state.getValueAtTime(this.now());
  }
  /**
   * Start the clock at the given time. Optionally pass in an offset
   * of where to start the tick counter from.
   * @param  time    The time the clock should start
   * @param offset  Where the tick counter starts counting from.
   */
  start(t, n) {
    yx(this.context);
    const i = this.toSeconds(t);
    return this.log("start", i), this._state.getValueAtTime(i) !== "started" && (this._state.setStateAtTime("started", i), this._tickSource.start(i, n), i < this._lastUpdate && this.emit("start", i, n)), this;
  }
  /**
   * Stop the clock. Stopping the clock resets the tick counter to 0.
   * @param time The time when the clock should stop.
   * @example
   * const clock = new Tone.Clock(time => {
   * 	console.log(time);
   * }, 1);
   * clock.start();
   * // stop the clock after 10 seconds
   * clock.stop("+10");
   */
  stop(t) {
    const n = this.toSeconds(t);
    return this.log("stop", n), this._state.cancel(n), this._state.setStateAtTime("stopped", n), this._tickSource.stop(n), n < this._lastUpdate && this.emit("stop", n), this;
  }
  /**
   * Pause the clock. Pausing does not reset the tick counter.
   * @param time The time when the clock should stop.
   */
  pause(t) {
    const n = this.toSeconds(t);
    return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n), this._tickSource.pause(n), n < this._lastUpdate && this.emit("pause", n)), this;
  }
  /**
   * The number of times the callback was invoked. Starts counting at 0
   * and increments after the callback was invoked.
   */
  get ticks() {
    return Math.ceil(this.getTicksAtTime(this.now()));
  }
  set ticks(t) {
    this._tickSource.ticks = t;
  }
  /**
   * The time since ticks=0 that the Clock has been running. Accounts for tempo curves
   */
  get seconds() {
    return this._tickSource.seconds;
  }
  set seconds(t) {
    this._tickSource.seconds = t;
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(t) {
    return this._tickSource.getSecondsAtTime(t);
  }
  /**
   * Set the clock's ticks at the given time.
   * @param  ticks The tick value to set
   * @param  time  When to set the tick value
   */
  setTicksAtTime(t, n) {
    return this._tickSource.setTicksAtTime(t, n), this;
  }
  /**
   * Get the time of the given tick. The second argument
   * is when to test before. Since ticks can be set (with setTicksAtTime)
   * there may be multiple times for a given tick value.
   * @param  tick The tick number.
   * @param  before When to measure the tick value from.
   * @return The time of the tick
   */
  getTimeOfTick(t, n = this.now()) {
    return this._tickSource.getTimeOfTick(t, n);
  }
  /**
   * Get the clock's ticks at the given time.
   * @param  time  When to get the tick value
   * @return The tick value at the given time.
   */
  getTicksAtTime(t) {
    return this._tickSource.getTicksAtTime(t);
  }
  /**
   * Get the time of the next tick
   * @param  offset The tick number.
   */
  nextTickTime(t, n) {
    const i = this.toSeconds(n), r = this.getTicksAtTime(i);
    return this._tickSource.getTimeOfTick(r + t, i);
  }
  /**
   * The scheduling loop.
   */
  _loop() {
    const t = this._lastUpdate, n = this.now();
    this._lastUpdate = n, this.log("loop", t, n), t !== n && (this._state.forEachBetween(t, n, (i) => {
      switch (i.state) {
        case "started":
          const r = this._tickSource.getTicksAtTime(i.time);
          this.emit("start", i.time, r);
          break;
        case "stopped":
          i.time !== 0 && this.emit("stop", i.time);
          break;
        case "paused":
          this.emit("pause", i.time);
          break;
      }
    }), this._tickSource.forEachTickBetween(t, n, (i, r) => {
      this.callback(i, r);
    }));
  }
  /**
   * Returns the scheduled state at the given time.
   * @param  time  The time to query.
   * @return  The name of the state input in setStateAtTime.
   * @example
   * const clock = new Tone.Clock();
   * clock.start("+0.1");
   * clock.getStateAtTime("+0.1"); // returns "started"
   */
  getStateAtTime(t) {
    const n = this.toSeconds(t);
    return this._state.getValueAtTime(n);
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this.context.off("tick", this._boundLoop), this._tickSource.dispose(), this._state.dispose(), this;
  }
}
ed.mixin(lc);
class qy extends Is {
  constructor() {
    super(), this.name = "ToneAudioBuffers", this._buffers = /* @__PURE__ */ new Map(), this._loadingCount = 0;
    const t = Te(qy.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
    this.baseUrl = t.baseUrl, Object.keys(t.urls).forEach((n) => {
      this._loadingCount++;
      const i = t.urls[n];
      this.add(n, i, this._bufferLoaded.bind(this, t.onload), t.onerror);
    });
  }
  static getDefaults() {
    return {
      baseUrl: "",
      onerror: wt,
      onload: wt,
      urls: {}
    };
  }
  /**
   * True if the buffers object has a buffer by that name.
   * @param  name  The key or index of the buffer.
   */
  has(t) {
    return this._buffers.has(t.toString());
  }
  /**
   * Get a buffer by name. If an array was loaded,
   * then use the array index.
   * @param  name  The key or index of the buffer.
   */
  get(t) {
    return Xe(this.has(t), `ToneAudioBuffers has no buffer named: ${t}`), this._buffers.get(t.toString());
  }
  /**
   * A buffer was loaded. decrement the counter.
   */
  _bufferLoaded(t) {
    this._loadingCount--, this._loadingCount === 0 && t && t();
  }
  /**
   * If the buffers are loaded or not
   */
  get loaded() {
    return Array.from(this._buffers).every(([t, n]) => n.loaded);
  }
  /**
   * Add a buffer by name and url to the Buffers
   * @param  name      A unique name to give the buffer
   * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.
   * @param  callback  The callback to invoke when the url is loaded.
   * @param  onerror  Invoked if the buffer can't be loaded
   */
  add(t, n, i = wt, r = wt) {
    return bs(n) ? (this.baseUrl && n.trim().substring(0, 11).toLowerCase() === "data:audio/" && (this.baseUrl = ""), this._buffers.set(t.toString(), new Vt(this.baseUrl + n, i, r))) : this._buffers.set(t.toString(), new Vt(n, i, r)), this;
  }
  dispose() {
    return super.dispose(), this._buffers.forEach((t) => t.dispose()), this._buffers.clear(), this;
  }
}
class rl extends Lu {
  constructor() {
    super(...arguments), this.name = "Ticks", this.defaultUnits = "i";
  }
  /**
   * Get the current time in the given units
   */
  _now() {
    return this.context.transport.ticks;
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(t) {
    return this._getPPQ() * t;
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(t) {
    return Math.floor(t / (60 / this._getBpm()) * this._getPPQ());
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(t) {
    return t;
  }
  /**
   * Return the time in ticks
   */
  toTicks() {
    return this.valueOf();
  }
  /**
   * Return the time in seconds
   */
  toSeconds() {
    return this.valueOf() / this._getPPQ() * (60 / this._getBpm());
  }
}
class rq extends pi {
  constructor() {
    super(...arguments), this.name = "Draw", this.expiration = 0.25, this.anticipation = 8e-3, this._events = new Ki(), this._boundDrawLoop = this._drawLoop.bind(this), this._animationFrame = -1;
  }
  /**
   * Schedule a function at the given time to be invoked
   * on the nearest animation frame.
   * @param  callback  Callback is invoked at the given time.
   * @param  time      The time relative to the AudioContext time to invoke the callback.
   * @example
   * Tone.Transport.scheduleRepeat(time => {
   * 	Tone.Draw.schedule(() => console.log(time), time);
   * }, 1);
   * Tone.Transport.start();
   */
  schedule(t, n) {
    return this._events.add({
      callback: t,
      time: this.toSeconds(n)
    }), this._events.length === 1 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop)), this;
  }
  /**
   * Cancel events scheduled after the given time
   * @param  after  Time after which scheduled events will be removed from the scheduling timeline.
   */
  cancel(t) {
    return this._events.cancel(this.toSeconds(t)), this;
  }
  /**
   * The draw loop
   */
  _drawLoop() {
    const t = this.context.currentTime;
    for (; this._events.length && this._events.peek().time - this.anticipation <= t; ) {
      const n = this._events.shift();
      n && t - n.time <= this.expiration && n.callback();
    }
    this._events.length > 0 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop));
  }
  dispose() {
    return super.dispose(), this._events.dispose(), cancelAnimationFrame(this._animationFrame), this;
  }
}
nm((e) => {
  e.draw = new rq({ context: e });
});
im((e) => {
  e.draw.dispose();
});
class sq extends Is {
  constructor() {
    super(...arguments), this.name = "IntervalTimeline", this._root = null, this._length = 0;
  }
  /**
   * The event to add to the timeline. All events must
   * have a time and duration value
   * @param  event  The event to add to the timeline
   */
  add(t) {
    Xe(nt(t.time), "Events must have a time property"), Xe(nt(t.duration), "Events must have a duration parameter"), t.time = t.time.valueOf();
    let n = new aq(t.time, t.time + t.duration, t);
    for (this._root === null ? this._root = n : this._root.insert(n), this._length++; n !== null; )
      n.updateHeight(), n.updateMax(), this._rebalance(n), n = n.parent;
    return this;
  }
  /**
   * Remove an event from the timeline.
   * @param  event  The event to remove from the timeline
   */
  remove(t) {
    if (this._root !== null) {
      const n = [];
      this._root.search(t.time, n);
      for (const i of n)
        if (i.event === t) {
          this._removeNode(i), this._length--;
          break;
        }
    }
    return this;
  }
  /**
   * The number of items in the timeline.
   * @readOnly
   */
  get length() {
    return this._length;
  }
  /**
   * Remove events whose time time is after the given time
   * @param  after  The time to query.
   */
  cancel(t) {
    return this.forEachFrom(t, (n) => this.remove(n)), this;
  }
  /**
   * Set the root node as the given node
   */
  _setRoot(t) {
    this._root = t, this._root !== null && (this._root.parent = null);
  }
  /**
   * Replace the references to the node in the node's parent
   * with the replacement node.
   */
  _replaceNodeInParent(t, n) {
    t.parent !== null ? (t.isLeftChild() ? t.parent.left = n : t.parent.right = n, this._rebalance(t.parent)) : this._setRoot(n);
  }
  /**
   * Remove the node from the tree and replace it with
   * a successor which follows the schema.
   */
  _removeNode(t) {
    if (t.left === null && t.right === null)
      this._replaceNodeInParent(t, null);
    else if (t.right === null)
      this._replaceNodeInParent(t, t.left);
    else if (t.left === null)
      this._replaceNodeInParent(t, t.right);
    else {
      const n = t.getBalance();
      let i, r = null;
      if (n > 0)
        if (t.left.right === null)
          i = t.left, i.right = t.right, r = i;
        else {
          for (i = t.left.right; i.right !== null; )
            i = i.right;
          i.parent && (i.parent.right = i.left, r = i.parent, i.left = t.left, i.right = t.right);
        }
      else if (t.right.left === null)
        i = t.right, i.left = t.left, r = i;
      else {
        for (i = t.right.left; i.left !== null; )
          i = i.left;
        i.parent && (i.parent.left = i.right, r = i.parent, i.left = t.left, i.right = t.right);
      }
      t.parent !== null ? t.isLeftChild() ? t.parent.left = i : t.parent.right = i : this._setRoot(i), r && this._rebalance(r);
    }
    t.dispose();
  }
  /**
   * Rotate the tree to the left
   */
  _rotateLeft(t) {
    const n = t.parent, i = t.isLeftChild(), r = t.right;
    r && (t.right = r.left, r.left = t), n !== null ? i ? n.left = r : n.right = r : this._setRoot(r);
  }
  /**
   * Rotate the tree to the right
   */
  _rotateRight(t) {
    const n = t.parent, i = t.isLeftChild(), r = t.left;
    r && (t.left = r.right, r.right = t), n !== null ? i ? n.left = r : n.right = r : this._setRoot(r);
  }
  /**
   * Balance the BST
   */
  _rebalance(t) {
    const n = t.getBalance();
    n > 1 && t.left ? t.left.getBalance() < 0 ? this._rotateLeft(t.left) : this._rotateRight(t) : n < -1 && t.right && (t.right.getBalance() > 0 ? this._rotateRight(t.right) : this._rotateLeft(t));
  }
  /**
   * Get an event whose time and duration span the give time. Will
   * return the match whose "time" value is closest to the given time.
   * @return  The event which spans the desired time
   */
  get(t) {
    if (this._root !== null) {
      const n = [];
      if (this._root.search(t, n), n.length > 0) {
        let i = n[0];
        for (let r = 1; r < n.length; r++)
          n[r].low > i.low && (i = n[r]);
        return i.event;
      }
    }
    return null;
  }
  /**
   * Iterate over everything in the timeline.
   * @param  callback The callback to invoke with every item
   */
  forEach(t) {
    if (this._root !== null) {
      const n = [];
      this._root.traverse((i) => n.push(i)), n.forEach((i) => {
        i.event && t(i.event);
      });
    }
    return this;
  }
  /**
   * Iterate over everything in the array in which the given time
   * overlaps with the time and duration time of the event.
   * @param  time The time to check if items are overlapping
   * @param  callback The callback to invoke with every item
   */
  forEachAtTime(t, n) {
    if (this._root !== null) {
      const i = [];
      this._root.search(t, i), i.forEach((r) => {
        r.event && n(r.event);
      });
    }
    return this;
  }
  /**
   * Iterate over everything in the array in which the time is greater
   * than or equal to the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachFrom(t, n) {
    if (this._root !== null) {
      const i = [];
      this._root.searchAfter(t, i), i.forEach((r) => {
        r.event && n(r.event);
      });
    }
    return this;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._root !== null && this._root.traverse((t) => t.dispose()), this._root = null, this;
  }
}
class aq {
  constructor(t, n, i) {
    this._left = null, this._right = null, this.parent = null, this.height = 0, this.event = i, this.low = t, this.high = n, this.max = this.high;
  }
  /**
   * Insert a node into the correct spot in the tree
   */
  insert(t) {
    t.low <= this.low ? this.left === null ? this.left = t : this.left.insert(t) : this.right === null ? this.right = t : this.right.insert(t);
  }
  /**
   * Search the tree for nodes which overlap
   * with the given point
   * @param  point  The point to query
   * @param  results  The array to put the results
   */
  search(t, n) {
    t > this.max || (this.left !== null && this.left.search(t, n), this.low <= t && this.high > t && n.push(this), !(this.low > t) && this.right !== null && this.right.search(t, n));
  }
  /**
   * Search the tree for nodes which are less
   * than the given point
   * @param  point  The point to query
   * @param  results  The array to put the results
   */
  searchAfter(t, n) {
    this.low >= t && (n.push(this), this.left !== null && this.left.searchAfter(t, n)), this.right !== null && this.right.searchAfter(t, n);
  }
  /**
   * Invoke the callback on this element and both it's branches
   * @param  {Function}  callback
   */
  traverse(t) {
    t(this), this.left !== null && this.left.traverse(t), this.right !== null && this.right.traverse(t);
  }
  /**
   * Update the height of the node
   */
  updateHeight() {
    this.left !== null && this.right !== null ? this.height = Math.max(this.left.height, this.right.height) + 1 : this.right !== null ? this.height = this.right.height + 1 : this.left !== null ? this.height = this.left.height + 1 : this.height = 0;
  }
  /**
   * Update the height of the node
   */
  updateMax() {
    this.max = this.high, this.left !== null && (this.max = Math.max(this.max, this.left.max)), this.right !== null && (this.max = Math.max(this.max, this.right.max));
  }
  /**
   * The balance is how the leafs are distributed on the node
   * @return  Negative numbers are balanced to the right
   */
  getBalance() {
    let t = 0;
    return this.left !== null && this.right !== null ? t = this.left.height - this.right.height : this.left !== null ? t = this.left.height + 1 : this.right !== null && (t = -(this.right.height + 1)), t;
  }
  /**
   * @returns true if this node is the left child of its parent
   */
  isLeftChild() {
    return this.parent !== null && this.parent.left === this;
  }
  /**
   * get/set the left node
   */
  get left() {
    return this._left;
  }
  set left(t) {
    this._left = t, t !== null && (t.parent = this), this.updateHeight(), this.updateMax();
  }
  /**
   * get/set the right node
   */
  get right() {
    return this._right;
  }
  set right(t) {
    this._right = t, t !== null && (t.parent = this), this.updateHeight(), this.updateMax();
  }
  /**
   * null out references.
   */
  dispose() {
    this.parent = null, this._left = null, this._right = null, this.event = null;
  }
}
class so extends et {
  constructor() {
    super(Te(so.getDefaults(), arguments, ["volume"])), this.name = "Volume";
    const t = Te(so.getDefaults(), arguments, ["volume"]);
    this.input = this.output = new Bn({
      context: this.context,
      gain: t.volume,
      units: "decibels"
    }), this.volume = this.output.gain, Jt(this, "volume"), this._unmutedVolume = t.volume, this.mute = t.mute;
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      mute: !1,
      volume: 0
    });
  }
  /**
   * Mute the output.
   * @example
   * const vol = new Tone.Volume(-12).toDestination();
   * const osc = new Tone.Oscillator().connect(vol).start();
   * // mute the output
   * vol.mute = true;
   */
  get mute() {
    return this.volume.value === -1 / 0;
  }
  set mute(t) {
    !this.mute && t ? (this._unmutedVolume = this.volume.value, this.volume.value = -1 / 0) : this.mute && !t && (this.volume.value = this._unmutedVolume);
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this.input.dispose(), this.volume.dispose(), this;
  }
}
class Xf extends et {
  constructor() {
    super(Te(Xf.getDefaults(), arguments)), this.name = "Destination", this.input = new so({ context: this.context }), this.output = new Bn({ context: this.context }), this.volume = this.input.volume;
    const t = Te(Xf.getDefaults(), arguments);
    Tg(this.input, this.output, this.context.rawContext.destination), this.mute = t.mute, this._internalChannels = [this.input, this.context.rawContext.destination, this.output];
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      mute: !1,
      volume: 0
    });
  }
  /**
   * Mute the output.
   * @example
   * const oscillator = new Tone.Oscillator().start().toDestination();
   * setTimeout(() => {
   * 	// mute the output
   * 	Tone.Destination.mute = true;
   * }, 1000);
   */
  get mute() {
    return this.input.mute;
  }
  set mute(t) {
    this.input.mute = t;
  }
  /**
   * Add a master effects chain. NOTE: this will disconnect any nodes which were previously
   * chained in the master effects chain.
   * @param args All arguments will be connected in a row and the Master will be routed through it.
   * @example
   * // route all audio through a filter and compressor
   * const lowpass = new Tone.Filter(800, "lowpass");
   * const compressor = new Tone.Compressor(-18);
   * Tone.Destination.chain(lowpass, compressor);
   */
  chain(...t) {
    return this.input.disconnect(), t.unshift(this.input), t.push(this.output), Tg(...t), this;
  }
  /**
   * The maximum number of channels the system can output
   * @example
   * console.log(Tone.Destination.maxChannelCount);
   */
  get maxChannelCount() {
    return this.context.rawContext.destination.maxChannelCount;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this.volume.dispose(), this;
  }
}
nm((e) => {
  e.destination = new Xf({ context: e });
});
im((e) => {
  e.destination.dispose();
});
class oq extends Is {
  /**
   * @param initialValue The value to return if there is no scheduled values
   */
  constructor(t) {
    super(), this.name = "TimelineValue", this._timeline = new Ki({ memory: 10 }), this._initialValue = t;
  }
  /**
   * Set the value at the given time
   */
  set(t, n) {
    return this._timeline.add({
      value: t,
      time: n
    }), this;
  }
  /**
   * Get the value at the given time
   */
  get(t) {
    const n = this._timeline.get(t);
    return n ? n.value : this._initialValue;
  }
}
class Al extends et {
  constructor() {
    super(Object.assign(Te(Al.getDefaults(), arguments, ["context"])));
  }
  connect(t, n = 0, i = 0) {
    return Uy(this, t, n, i), this;
  }
}
class Il extends Al {
  constructor() {
    super(Object.assign(Te(Il.getDefaults(), arguments, ["mapping", "length"]))), this.name = "WaveShaper", this._shaper = this.context.createWaveShaper(), this.input = this._shaper, this.output = this._shaper;
    const t = Te(Il.getDefaults(), arguments, ["mapping", "length"]);
    br(t.mapping) || t.mapping instanceof Float32Array ? this.curve = Float32Array.from(t.mapping) : VU(t.mapping) && this.setMap(t.mapping, t.length);
  }
  static getDefaults() {
    return Object.assign(pn.getDefaults(), {
      length: 1024
    });
  }
  /**
   * Uses a mapping function to set the value of the curve.
   * @param mapping The function used to define the values.
   *                The mapping function take two arguments:
   *                the first is the value at the current position
   *                which goes from -1 to 1 over the number of elements
   *                in the curve array. The second argument is the array position.
   * @example
   * const shaper = new Tone.WaveShaper();
   * // map the input signal from [-1, 1] to [0, 10]
   * shaper.setMap((val, index) => (val + 1) * 5);
   */
  setMap(t, n = 1024) {
    const i = new Float32Array(n);
    for (let r = 0, s = n; r < s; r++) {
      const a = r / (s - 1) * 2 - 1;
      i[r] = t(a, r);
    }
    return this.curve = i, this;
  }
  /**
   * The array to set as the waveshaper curve. For linear curves
   * array length does not make much difference, but for complex curves
   * longer arrays will provide smoother interpolation.
   */
  get curve() {
    return this._shaper.curve;
  }
  set curve(t) {
    this._shaper.curve = t;
  }
  /**
   * Specifies what type of oversampling (if any) should be used when
   * applying the shaping curve. Can either be "none", "2x" or "4x".
   */
  get oversample() {
    return this._shaper.oversample;
  }
  set oversample(t) {
    const n = ["none", "2x", "4x"].some((i) => i.includes(t));
    Xe(n, "oversampling must be either 'none', '2x', or '4x'"), this._shaper.oversample = t;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._shaper.disconnect(), this;
  }
}
class Jf extends Al {
  constructor() {
    super(Object.assign(Te(Jf.getDefaults(), arguments, ["value"]))), this.name = "Pow";
    const t = Te(Jf.getDefaults(), arguments, ["value"]);
    this._exponentScaler = this.input = this.output = new Il({
      context: this.context,
      mapping: this._expFunc(t.value),
      length: 8192
    }), this._exponent = t.value;
  }
  static getDefaults() {
    return Object.assign(Al.getDefaults(), {
      value: 1
    });
  }
  /**
   * the function which maps the waveshaper
   * @param exponent exponent value
   */
  _expFunc(t) {
    return (n) => Math.pow(Math.abs(n), t);
  }
  /**
   * The value of the exponent.
   */
  get value() {
    return this._exponent;
  }
  set value(t) {
    this._exponent = t, this._exponentScaler.setMap(this._expFunc(this._exponent));
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._exponentScaler.dispose(), this;
  }
}
class aa {
  /**
   * @param transport The transport object which the event belongs to
   */
  constructor(t, n) {
    this.id = aa._eventId++, this._remainderTime = 0;
    const i = Object.assign(aa.getDefaults(), n);
    this.transport = t, this.callback = i.callback, this._once = i.once, this.time = Math.floor(i.time), this._remainderTime = i.time - this.time;
  }
  static getDefaults() {
    return {
      callback: wt,
      once: !1,
      time: 0
    };
  }
  /**
   * Get the time and remainder time.
   */
  get floatTime() {
    return this.time + this._remainderTime;
  }
  /**
   * Invoke the event callback.
   * @param  time  The AudioContext time in seconds of the event
   */
  invoke(t) {
    if (this.callback) {
      const n = this.transport.bpm.getDurationOfTicks(1, t);
      this.callback(t + this._remainderTime * n), this._once && this.transport.clear(this.id);
    }
  }
  /**
   * Clean up
   */
  dispose() {
    return this.callback = void 0, this;
  }
}
aa._eventId = 0;
class Gy extends aa {
  /**
   * @param transport The transport object which the event belongs to
   */
  constructor(t, n) {
    super(t, n), this._currentId = -1, this._nextId = -1, this._nextTick = this.time, this._boundRestart = this._restart.bind(this);
    const i = Object.assign(Gy.getDefaults(), n);
    this.duration = i.duration, this._interval = i.interval, this._nextTick = i.time, this.transport.on("start", this._boundRestart), this.transport.on("loopStart", this._boundRestart), this.transport.on("ticks", this._boundRestart), this.context = this.transport.context, this._restart();
  }
  static getDefaults() {
    return Object.assign({}, aa.getDefaults(), {
      duration: 1 / 0,
      interval: 1,
      once: !1
    });
  }
  /**
   * Invoke the callback. Returns the tick time which
   * the next event should be scheduled at.
   * @param  time  The AudioContext time in seconds of the event
   */
  invoke(t) {
    this._createEvents(t), super.invoke(t);
  }
  /**
   * Create an event on the transport on the nextTick
   */
  _createEvent() {
    return qf(this._nextTick, this.floatTime + this.duration) ? this.transport.scheduleOnce(this.invoke.bind(this), new rl(this.context, this._nextTick).toSeconds()) : -1;
  }
  /**
   * Push more events onto the timeline to keep up with the position of the timeline
   */
  _createEvents(t) {
    qf(this._nextTick + this._interval, this.floatTime + this.duration) && (this._nextTick += this._interval, this._currentId = this._nextId, this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new rl(this.context, this._nextTick).toSeconds()));
  }
  /**
   * Re-compute the events when the transport time has changed from a start/ticks/loopStart event
   */
  _restart(t) {
    this.transport.clear(this._currentId), this.transport.clear(this._nextId), this._nextTick = this.floatTime;
    const n = this.transport.getTicksAtTime(t);
    Tl(n, this.time) && (this._nextTick = this.floatTime + Math.ceil((n - this.floatTime) / this._interval) * this._interval), this._currentId = this._createEvent(), this._nextTick += this._interval, this._nextId = this._createEvent();
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this.transport.clear(this._currentId), this.transport.clear(this._nextId), this.transport.off("start", this._boundRestart), this.transport.off("loopStart", this._boundRestart), this.transport.off("ticks", this._boundRestart), this;
  }
}
class uc extends pi {
  constructor() {
    super(Te(uc.getDefaults(), arguments)), this.name = "Transport", this._loop = new oq(!1), this._loopStart = 0, this._loopEnd = 0, this._scheduledEvents = {}, this._timeline = new Ki(), this._repeatedEvents = new sq(), this._syncedSignals = [], this._swingAmount = 0;
    const t = Te(uc.getDefaults(), arguments);
    this._ppq = t.ppq, this._clock = new lc({
      callback: this._processTick.bind(this),
      context: this.context,
      frequency: 0,
      units: "bpm"
    }), this._bindClockEvents(), this.bpm = this._clock.frequency, this._clock.frequency.multiplier = t.ppq, this.bpm.setValueAtTime(t.bpm, 0), Jt(this, "bpm"), this._timeSignature = t.timeSignature, this._swingTicks = t.ppq / 2;
  }
  static getDefaults() {
    return Object.assign(pi.getDefaults(), {
      bpm: 120,
      loopEnd: "4m",
      loopStart: 0,
      ppq: 192,
      swing: 0,
      swingSubdivision: "8n",
      timeSignature: 4
    });
  }
  //-------------------------------------
  // 	TICKS
  //-------------------------------------
  /**
   * called on every tick
   * @param  tickTime clock relative tick time
   */
  _processTick(t, n) {
    if (this._loop.get(t) && n >= this._loopEnd && (this.emit("loopEnd", t), this._clock.setTicksAtTime(this._loopStart, t), n = this._loopStart, this.emit("loopStart", t, this._clock.getSecondsAtTime(t)), this.emit("loop", t)), this._swingAmount > 0 && n % this._ppq !== 0 && // not on a downbeat
    n % (this._swingTicks * 2) !== 0) {
      const i = n % (this._swingTicks * 2) / (this._swingTicks * 2), r = Math.sin(i * Math.PI) * this._swingAmount;
      t += new rl(this.context, this._swingTicks * 2 / 3).toSeconds() * r;
    }
    k_(!0), this._timeline.forEachAtTime(n, (i) => i.invoke(t)), k_(!1);
  }
  //-------------------------------------
  // 	SCHEDULABLE EVENTS
  //-------------------------------------
  /**
   * Schedule an event along the timeline.
   * @param callback The callback to be invoked at the time.
   * @param time The time to invoke the callback at.
   * @return The id of the event which can be used for canceling the event.
   * @example
   * // schedule an event on the 16th measure
   * Tone.getTransport().schedule((time) => {
   * 	// invoked on measure 16
   * 	console.log("measure 16!");
   * }, "16:0:0");
   */
  schedule(t, n) {
    const i = new aa(this, {
      callback: t,
      time: new Lu(this.context, n).toTicks()
    });
    return this._addEvent(i, this._timeline);
  }
  /**
   * Schedule a repeated event along the timeline. The event will fire
   * at the `interval` starting at the `startTime` and for the specified
   * `duration`.
   * @param  callback   The callback to invoke.
   * @param  interval   The duration between successive callbacks. Must be a positive number.
   * @param  startTime  When along the timeline the events should start being invoked.
   * @param  duration How long the event should repeat.
   * @return  The ID of the scheduled event. Use this to cancel the event.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * // a callback invoked every eighth note after the first measure
   * Tone.getTransport().scheduleRepeat((time) => {
   * 	osc.start(time).stop(time + 0.1);
   * }, "8n", "1m");
   */
  scheduleRepeat(t, n, i, r = 1 / 0) {
    const s = new Gy(this, {
      callback: t,
      duration: new vr(this.context, r).toTicks(),
      interval: new vr(this.context, n).toTicks(),
      time: new Lu(this.context, i).toTicks()
    });
    return this._addEvent(s, this._repeatedEvents);
  }
  /**
   * Schedule an event that will be removed after it is invoked.
   * @param callback The callback to invoke once.
   * @param time The time the callback should be invoked.
   * @returns The ID of the scheduled event.
   */
  scheduleOnce(t, n) {
    const i = new aa(this, {
      callback: t,
      once: !0,
      time: new Lu(this.context, n).toTicks()
    });
    return this._addEvent(i, this._timeline);
  }
  /**
   * Clear the passed in event id from the timeline
   * @param eventId The id of the event.
   */
  clear(t) {
    if (this._scheduledEvents.hasOwnProperty(t)) {
      const n = this._scheduledEvents[t.toString()];
      n.timeline.remove(n.event), n.event.dispose(), delete this._scheduledEvents[t.toString()];
    }
    return this;
  }
  /**
   * Add an event to the correct timeline. Keep track of the
   * timeline it was added to.
   * @returns the event id which was just added
   */
  _addEvent(t, n) {
    return this._scheduledEvents[t.id.toString()] = {
      event: t,
      timeline: n
    }, n.add(t), t.id;
  }
  /**
   * Remove scheduled events from the timeline after
   * the given time. Repeated events will be removed
   * if their startTime is after the given time
   * @param after Clear all events after this time.
   */
  cancel(t = 0) {
    const n = this.toTicks(t);
    return this._timeline.forEachFrom(n, (i) => this.clear(i.id)), this._repeatedEvents.forEachFrom(n, (i) => this.clear(i.id)), this;
  }
  //-------------------------------------
  // 	START/STOP/PAUSE
  //-------------------------------------
  /**
   * Bind start/stop/pause events from the clock and emit them.
   */
  _bindClockEvents() {
    this._clock.on("start", (t, n) => {
      n = new rl(this.context, n).toSeconds(), this.emit("start", t, n);
    }), this._clock.on("stop", (t) => {
      this.emit("stop", t);
    }), this._clock.on("pause", (t) => {
      this.emit("pause", t);
    });
  }
  /**
   * Returns the playback state of the source, either "started", "stopped", or "paused"
   */
  get state() {
    return this._clock.getStateAtTime(this.now());
  }
  /**
   * Start the transport and all sources synced to the transport.
   * @param  time The time when the transport should start.
   * @param  offset The timeline offset to start the transport.
   * @example
   * // start the transport in one second starting at beginning of the 5th measure.
   * Tone.getTransport().start("+1", "4:0:0");
   */
  start(t, n) {
    this.context.resume();
    let i;
    return nt(n) && (i = this.toTicks(n)), this._clock.start(t, i), this;
  }
  /**
   * Stop the transport and all sources synced to the transport.
   * @param time The time when the transport should stop.
   * @example
   * Tone.getTransport().stop();
   */
  stop(t) {
    return this._clock.stop(t), this;
  }
  /**
   * Pause the transport and all sources synced to the transport.
   */
  pause(t) {
    return this._clock.pause(t), this;
  }
  /**
   * Toggle the current state of the transport. If it is
   * started, it will stop it, otherwise it will start the Transport.
   * @param  time The time of the event
   */
  toggle(t) {
    return t = this.toSeconds(t), this._clock.getStateAtTime(t) !== "started" ? this.start(t) : this.stop(t), this;
  }
  //-------------------------------------
  // 	SETTERS/GETTERS
  //-------------------------------------
  /**
   * The time signature as just the numerator over 4.
   * For example 4/4 would be just 4 and 6/8 would be 3.
   * @example
   * // common time
   * Tone.getTransport().timeSignature = 4;
   * // 7/8
   * Tone.getTransport().timeSignature = [7, 8];
   * // this will be reduced to a single number
   * Tone.getTransport().timeSignature; // returns 3.5
   */
  get timeSignature() {
    return this._timeSignature;
  }
  set timeSignature(t) {
    br(t) && (t = t[0] / t[1] * 4), this._timeSignature = t;
  }
  /**
   * When the Transport.loop = true, this is the starting position of the loop.
   */
  get loopStart() {
    return new vr(this.context, this._loopStart, "i").toSeconds();
  }
  set loopStart(t) {
    this._loopStart = this.toTicks(t);
  }
  /**
   * When the Transport.loop = true, this is the ending position of the loop.
   */
  get loopEnd() {
    return new vr(this.context, this._loopEnd, "i").toSeconds();
  }
  set loopEnd(t) {
    this._loopEnd = this.toTicks(t);
  }
  /**
   * If the transport loops or not.
   */
  get loop() {
    return this._loop.get(this.now());
  }
  set loop(t) {
    this._loop.set(t, this.now());
  }
  /**
   * Set the loop start and stop at the same time.
   * @example
   * // loop over the first measure
   * Tone.getTransport().setLoopPoints(0, "1m");
   * Tone.getTransport().loop = true;
   */
  setLoopPoints(t, n) {
    return this.loopStart = t, this.loopEnd = n, this;
  }
  /**
   * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.
   */
  get swing() {
    return this._swingAmount;
  }
  set swing(t) {
    this._swingAmount = t;
  }
  /**
   * Set the subdivision which the swing will be applied to.
   * The default value is an 8th note. Value must be less
   * than a quarter note.
   */
  get swingSubdivision() {
    return new rl(this.context, this._swingTicks).toNotation();
  }
  set swingSubdivision(t) {
    this._swingTicks = this.toTicks(t);
  }
  /**
   * The Transport's position in Bars:Beats:Sixteenths.
   * Setting the value will jump to that position right away.
   */
  get position() {
    const t = this.now(), n = this._clock.getTicksAtTime(t);
    return new rl(this.context, n).toBarsBeatsSixteenths();
  }
  set position(t) {
    const n = this.toTicks(t);
    this.ticks = n;
  }
  /**
   * The Transport's position in seconds.
   * Setting the value will jump to that position right away.
   */
  get seconds() {
    return this._clock.seconds;
  }
  set seconds(t) {
    const n = this.now(), i = this._clock.frequency.timeToTicks(t, n);
    this.ticks = i;
  }
  /**
   * The Transport's loop position as a normalized value. Always
   * returns 0 if the Transport.loop = false.
   */
  get progress() {
    if (this.loop) {
      const t = this.now();
      return (this._clock.getTicksAtTime(t) - this._loopStart) / (this._loopEnd - this._loopStart);
    } else
      return 0;
  }
  /**
   * The Transport's current tick position.
   */
  get ticks() {
    return this._clock.ticks;
  }
  set ticks(t) {
    if (this._clock.ticks !== t) {
      const n = this.now();
      if (this.state === "started") {
        const i = this._clock.getTicksAtTime(n), r = this._clock.frequency.getDurationOfTicks(Math.ceil(i) - i, n), s = n + r;
        this.emit("stop", s), this._clock.setTicksAtTime(t, s), this.emit("start", s, this._clock.getSecondsAtTime(s));
      } else
        this.emit("ticks", n), this._clock.setTicksAtTime(t, n);
    }
  }
  /**
   * Get the clock's ticks at the given time.
   * @param  time  When to get the tick value
   * @return The tick value at the given time.
   */
  getTicksAtTime(t) {
    return this._clock.getTicksAtTime(t);
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(t) {
    return this._clock.getSecondsAtTime(t);
  }
  /**
   * Pulses Per Quarter note. This is the smallest resolution
   * the Transport timing supports. This should be set once
   * on initialization and not set again. Changing this value
   * after other objects have been created can cause problems.
   */
  get PPQ() {
    return this._clock.frequency.multiplier;
  }
  set PPQ(t) {
    this._clock.frequency.multiplier = t;
  }
  //-------------------------------------
  // 	SYNCING
  //-------------------------------------
  /**
   * Returns the time aligned to the next subdivision
   * of the Transport. If the Transport is not started,
   * it will return 0.
   * Note: this will not work precisely during tempo ramps.
   * @param  subdivision  The subdivision to quantize to
   * @return  The context time of the next subdivision.
   * @example
   * // the transport must be started, otherwise returns 0
   * Tone.getTransport().start();
   * Tone.getTransport().nextSubdivision("4n");
   */
  nextSubdivision(t) {
    if (t = this.toTicks(t), this.state !== "started")
      return 0;
    {
      const n = this.now(), i = this.getTicksAtTime(n), r = t - i % t;
      return this._clock.nextTickTime(r, n);
    }
  }
  /**
   * Attaches the signal to the tempo control signal so that
   * any changes in the tempo will change the signal in the same
   * ratio.
   *
   * @param signal
   * @param ratio Optionally pass in the ratio between the two signals.
   * 			Otherwise it will be computed based on their current values.
   */
  syncSignal(t, n) {
    const i = this.now();
    let r = this.bpm, s = 1 / (60 / r.getValueAtTime(i) / this.PPQ), a = [];
    if (t.units === "time") {
      const l = 0.015625 / s, u = new Bn(l), c = new Jf(-1), d = new Bn(l);
      r.chain(u, c, d), r = d, s = 1 / s, a = [u, c, d];
    }
    n || (t.getValueAtTime(i) !== 0 ? n = t.getValueAtTime(i) / s : n = 0);
    const o = new Bn(n);
    return r.connect(o), o.connect(t._param), a.push(o), this._syncedSignals.push({
      initial: t.value,
      nodes: a,
      signal: t
    }), t.value = 0, this;
  }
  /**
   * Unsyncs a previously synced signal from the transport's control.
   * @see {@link syncSignal}.
   */
  unsyncSignal(t) {
    for (let n = this._syncedSignals.length - 1; n >= 0; n--) {
      const i = this._syncedSignals[n];
      i.signal === t && (i.nodes.forEach((r) => r.dispose()), i.signal.value = i.initial, this._syncedSignals.splice(n, 1));
    }
    return this;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._clock.dispose(), Cx(this, "bpm"), this._timeline.dispose(), this._repeatedEvents.dispose(), this;
  }
}
ed.mixin(uc);
nm((e) => {
  e.transport = new uc({ context: e });
});
im((e) => {
  e.transport.dispose();
});
class Ii extends et {
  constructor(t) {
    super(t), this.input = void 0, this._state = new zy("stopped"), this._synced = !1, this._scheduled = [], this._syncedStart = wt, this._syncedStop = wt, this._state.memory = 100, this._state.increasing = !0, this._volume = this.output = new so({
      context: this.context,
      mute: t.mute,
      volume: t.volume
    }), this.volume = this._volume.volume, Jt(this, "volume"), this.onstop = t.onstop;
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      mute: !1,
      onstop: wt,
      volume: 0
    });
  }
  /**
   * Returns the playback state of the source, either "started" or "stopped".
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/ahntone_c3.mp3", () => {
   * 	player.start();
   * 	console.log(player.state);
   * }).toDestination();
   */
  get state() {
    return this._synced ? this.context.transport.state === "started" ? this._state.getValueAtTime(this.context.transport.seconds) : "stopped" : this._state.getValueAtTime(this.now());
  }
  /**
   * Mute the output.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * // mute the output
   * osc.mute = true;
   */
  get mute() {
    return this._volume.mute;
  }
  set mute(t) {
    this._volume.mute = t;
  }
  /**
   * Ensure that the scheduled time is not before the current time.
   * Should only be used when scheduled unsynced.
   */
  _clampToCurrentTime(t) {
    return this._synced ? t : Math.max(t, this.context.currentTime);
  }
  /**
   * Start the source at the specified time. If no time is given,
   * start the source now.
   * @param  time When the source should be started.
   * @example
   * const source = new Tone.Oscillator().toDestination();
   * source.start("+0.5"); // starts the source 0.5 seconds from now
   */
  start(t, n, i) {
    let r = Zi(t) && this._synced ? this.context.transport.seconds : this.toSeconds(t);
    if (r = this._clampToCurrentTime(r), !this._synced && this._state.getValueAtTime(r) === "started")
      Xe(Tl(r, this._state.get(r).time), "Start time must be strictly greater than previous start time"), this._state.cancel(r), this._state.setStateAtTime("started", r), this.log("restart", r), this.restart(r, n, i);
    else if (this.log("start", r), this._state.setStateAtTime("started", r), this._synced) {
      const s = this._state.get(r);
      s && (s.offset = this.toSeconds(fl(n, 0)), s.duration = i ? this.toSeconds(i) : void 0);
      const a = this.context.transport.schedule((o) => {
        this._start(o, n, i);
      }, r);
      this._scheduled.push(a), this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > r && this._syncedStart(this.now(), this.context.transport.seconds);
    } else
      yx(this.context), this._start(r, n, i);
    return this;
  }
  /**
   * Stop the source at the specified time. If no time is given,
   * stop the source now.
   * @param  time When the source should be stopped.
   * @example
   * const source = new Tone.Oscillator().toDestination();
   * source.start();
   * source.stop("+0.5"); // stops the source 0.5 seconds from now
   */
  stop(t) {
    let n = Zi(t) && this._synced ? this.context.transport.seconds : this.toSeconds(t);
    if (n = this._clampToCurrentTime(n), this._state.getValueAtTime(n) === "started" || nt(this._state.getNextState("started", n))) {
      if (this.log("stop", n), !this._synced)
        this._stop(n);
      else {
        const i = this.context.transport.schedule(this._stop.bind(this), n);
        this._scheduled.push(i);
      }
      this._state.cancel(n), this._state.setStateAtTime("stopped", n);
    }
    return this;
  }
  /**
   * Restart the source.
   */
  restart(t, n, i) {
    return t = this.toSeconds(t), this._state.getValueAtTime(t) === "started" && (this._state.cancel(t), this._restart(t, n, i)), this;
  }
  /**
   * Sync the source to the Transport so that all subsequent
   * calls to `start` and `stop` are synced to the TransportTime
   * instead of the AudioContext time.
   *
   * @example
   * const osc = new Tone.Oscillator().toDestination();
   * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline
   * osc.sync().start(0).stop(0.3);
   * // start the transport.
   * Tone.Transport.start();
   * // set it to loop once a second
   * Tone.Transport.loop = true;
   * Tone.Transport.loopEnd = 1;
   */
  sync() {
    return this._synced || (this._synced = !0, this._syncedStart = (t, n) => {
      if (Tl(n, 0)) {
        const i = this._state.get(n);
        if (i && i.state === "started" && i.time !== n) {
          const r = n - this.toSeconds(i.time);
          let s;
          i.duration && (s = this.toSeconds(i.duration) - r), this._start(t, this.toSeconds(i.offset) + r, s);
        }
      }
    }, this._syncedStop = (t) => {
      const n = this.context.transport.getSecondsAtTime(Math.max(t - this.sampleTime, 0));
      this._state.getValueAtTime(n) === "started" && this._stop(t);
    }, this.context.transport.on("start", this._syncedStart), this.context.transport.on("loopStart", this._syncedStart), this.context.transport.on("stop", this._syncedStop), this.context.transport.on("pause", this._syncedStop), this.context.transport.on("loopEnd", this._syncedStop)), this;
  }
  /**
   * Unsync the source to the Transport.
   * @see {@link sync}
   */
  unsync() {
    return this._synced && (this.context.transport.off("stop", this._syncedStop), this.context.transport.off("pause", this._syncedStop), this.context.transport.off("loopEnd", this._syncedStop), this.context.transport.off("start", this._syncedStart), this.context.transport.off("loopStart", this._syncedStart)), this._synced = !1, this._scheduled.forEach((t) => this.context.transport.clear(t)), this._scheduled = [], this._state.cancel(0), this._stop(0), this;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.onstop = wt, this.unsync(), this._volume.dispose(), this._state.dispose(), this;
  }
}
class cc extends xl {
  constructor() {
    super(Te(cc.getDefaults(), arguments, ["url", "onload"])), this.name = "ToneBufferSource", this._source = this.context.createBufferSource(), this._internalChannels = [this._source], this._sourceStarted = !1, this._sourceStopped = !1;
    const t = Te(cc.getDefaults(), arguments, ["url", "onload"]);
    tu(this._source, this._gainNode), this._source.onended = () => this._stopSource(), this.playbackRate = new Lt({
      context: this.context,
      param: this._source.playbackRate,
      units: "positive",
      value: t.playbackRate
    }), this.loop = t.loop, this.loopStart = t.loopStart, this.loopEnd = t.loopEnd, this._buffer = new Vt(t.url, t.onload, t.onerror), this._internalChannels.push(this._source);
  }
  static getDefaults() {
    return Object.assign(xl.getDefaults(), {
      url: new Vt(),
      loop: !1,
      loopEnd: 0,
      loopStart: 0,
      onload: wt,
      onerror: wt,
      playbackRate: 1
    });
  }
  /**
   * The fadeIn time of the amplitude envelope.
   */
  get fadeIn() {
    return this._fadeIn;
  }
  set fadeIn(t) {
    this._fadeIn = t;
  }
  /**
   * The fadeOut time of the amplitude envelope.
   */
  get fadeOut() {
    return this._fadeOut;
  }
  set fadeOut(t) {
    this._fadeOut = t;
  }
  /**
   * The curve applied to the fades, either "linear" or "exponential"
   */
  get curve() {
    return this._curve;
  }
  set curve(t) {
    this._curve = t;
  }
  /**
   * Start the buffer
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
   * @param  gain  The gain to play the buffer back at.
   */
  start(t, n, i, r = 1) {
    Xe(this.buffer.loaded, "buffer is either not set or not loaded");
    const s = this.toSeconds(t);
    this._startGain(s, r), this.loop ? n = fl(n, this.loopStart) : n = fl(n, 0);
    let a = Math.max(this.toSeconds(n), 0);
    if (this.loop) {
      const o = this.toSeconds(this.loopEnd) || this.buffer.duration, l = this.toSeconds(this.loopStart), u = o - l;
      kg(a, o) && (a = (a - l) % u + l), ur(a, this.buffer.duration) && (a = 0);
    }
    if (this._source.buffer = this.buffer.get(), this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration, qf(a, this.buffer.duration) && (this._sourceStarted = !0, this._source.start(s, a)), nt(i)) {
      let o = this.toSeconds(i);
      o = Math.max(o, 0), this.stop(s + o);
    }
    return this;
  }
  _stopSource(t) {
    !this._sourceStopped && this._sourceStarted && (this._sourceStopped = !0, this._source.stop(this.toSeconds(t)), this._onended());
  }
  /**
   * If loop is true, the loop will start at this position.
   */
  get loopStart() {
    return this._source.loopStart;
  }
  set loopStart(t) {
    this._source.loopStart = this.toSeconds(t);
  }
  /**
   * If loop is true, the loop will end at this position.
   */
  get loopEnd() {
    return this._source.loopEnd;
  }
  set loopEnd(t) {
    this._source.loopEnd = this.toSeconds(t);
  }
  /**
   * The audio buffer belonging to the player.
   */
  get buffer() {
    return this._buffer;
  }
  set buffer(t) {
    this._buffer.set(t);
  }
  /**
   * If the buffer should loop once it's over.
   */
  get loop() {
    return this._source.loop;
  }
  set loop(t) {
    this._source.loop = t, this._sourceStarted && this.cancelStop();
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._source.onended = null, this._source.disconnect(), this._buffer.dispose(), this.playbackRate.dispose(), this;
  }
}
function xo(e, t) {
  return fn(this, void 0, void 0, function* () {
    const n = t / e.context.sampleRate, i = new jy(1, n, e.context.sampleRate);
    return new e.constructor(Object.assign(e.get(), {
      // should do 2 iterations
      frequency: 2 / n,
      // zero out the detune
      detune: 0,
      context: i
    })).toDestination().start(0), (yield i.render()).getChannelData(0);
  });
}
class Qf extends xl {
  constructor() {
    super(Te(Qf.getDefaults(), arguments, ["frequency", "type"])), this.name = "ToneOscillatorNode", this._oscillator = this.context.createOscillator(), this._internalChannels = [this._oscillator];
    const t = Te(Qf.getDefaults(), arguments, ["frequency", "type"]);
    tu(this._oscillator, this._gainNode), this.type = t.type, this.frequency = new Lt({
      context: this.context,
      param: this._oscillator.frequency,
      units: "frequency",
      value: t.frequency
    }), this.detune = new Lt({
      context: this.context,
      param: this._oscillator.detune,
      units: "cents",
      value: t.detune
    }), Jt(this, ["frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(xl.getDefaults(), {
      detune: 0,
      frequency: 440,
      type: "sine"
    });
  }
  /**
   * Start the oscillator node at the given time
   * @param  time When to start the oscillator
   */
  start(t) {
    const n = this.toSeconds(t);
    return this.log("start", n), this._startGain(n), this._oscillator.start(n), this;
  }
  _stopSource(t) {
    this._oscillator.stop(t);
  }
  /**
   * Sets an arbitrary custom periodic waveform given a PeriodicWave.
   * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave
   */
  setPeriodicWave(t) {
    return this._oscillator.setPeriodicWave(t), this;
  }
  /**
   * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'
   */
  get type() {
    return this._oscillator.type;
  }
  set type(t) {
    this._oscillator.type = t;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.state === "started" && this.stop(), this._oscillator.disconnect(), this.frequency.dispose(), this.detune.dispose(), this;
  }
}
class rn extends Ii {
  constructor() {
    super(Te(rn.getDefaults(), arguments, ["frequency", "type"])), this.name = "Oscillator", this._oscillator = null;
    const t = Te(rn.getDefaults(), arguments, ["frequency", "type"]);
    this.frequency = new pn({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), Jt(this, "frequency"), this.detune = new pn({
      context: this.context,
      units: "cents",
      value: t.detune
    }), Jt(this, "detune"), this._partials = t.partials, this._partialCount = t.partialCount, this._type = t.type, t.partialCount && t.type !== "custom" && (this._type = this.baseType + t.partialCount.toString()), this.phase = t.phase;
  }
  static getDefaults() {
    return Object.assign(Ii.getDefaults(), {
      detune: 0,
      frequency: 440,
      partialCount: 0,
      partials: [],
      phase: 0,
      type: "sine"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    const n = this.toSeconds(t), i = new Qf({
      context: this.context,
      onended: () => this.onstop(this)
    });
    this._oscillator = i, this._wave ? this._oscillator.setPeriodicWave(this._wave) : this._oscillator.type = this._type, this._oscillator.connect(this.output), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.start(n);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    const n = this.toSeconds(t);
    this._oscillator && this._oscillator.stop(n);
  }
  /**
   * Restart the oscillator. Does not stop the oscillator, but instead
   * just cancels any scheduled 'stop' from being invoked.
   */
  _restart(t) {
    const n = this.toSeconds(t);
    return this.log("restart", n), this._oscillator && this._oscillator.cancelStop(), this._state.cancel(n), this;
  }
  /**
   * Sync the signal to the Transport's bpm. Any changes to the transports bpm,
   * will also affect the oscillators frequency.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * osc.frequency.value = 440;
   * // the ratio between the bpm and the frequency will be maintained
   * osc.syncFrequency();
   * // double the tempo
   * Tone.Transport.bpm.value *= 2;
   * // the frequency of the oscillator is doubled to 880
   */
  syncFrequency() {
    return this.context.transport.syncSignal(this.frequency), this;
  }
  /**
   * Unsync the oscillator's frequency from the Transport.
   * @see {@link syncFrequency}
   */
  unsyncFrequency() {
    return this.context.transport.unsyncSignal(this.frequency), this;
  }
  /**
   * Get a cached periodic wave. Avoids having to recompute
   * the oscillator values when they have already been computed
   * with the same values.
   */
  _getCachedPeriodicWave() {
    if (this._type === "custom")
      return rn._periodicWaveCache.find((n) => n.phase === this._phase && HU(n.partials, this._partials));
    {
      const t = rn._periodicWaveCache.find((n) => n.type === this._type && n.phase === this._phase);
      return this._partialCount = t ? t.partialCount : this._partialCount, t;
    }
  }
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t;
    const n = ["sine", "square", "sawtooth", "triangle"].indexOf(t) !== -1;
    if (this._phase === 0 && n)
      this._wave = void 0, this._partialCount = 0, this._oscillator !== null && (this._oscillator.type = t);
    else {
      const i = this._getCachedPeriodicWave();
      if (nt(i)) {
        const { partials: r, wave: s } = i;
        this._wave = s, this._partials = r, this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave);
      } else {
        const [r, s] = this._getRealImaginary(t, this._phase), a = this.context.createPeriodicWave(r, s);
        this._wave = a, this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave), rn._periodicWaveCache.push({
          imag: s,
          partialCount: this._partialCount,
          partials: this._partials,
          phase: this._phase,
          real: r,
          type: this._type,
          wave: this._wave
        }), rn._periodicWaveCache.length > 100 && rn._periodicWaveCache.shift();
      }
    }
  }
  get baseType() {
    return this._type.replace(this.partialCount.toString(), "");
  }
  set baseType(t) {
    this.partialCount && this._type !== "custom" && t !== "custom" ? this.type = t + this.partialCount : this.type = t;
  }
  get partialCount() {
    return this._partialCount;
  }
  set partialCount(t) {
    sa(t, 0);
    let n = this._type;
    const i = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
    if (i && (n = i[1]), this._type !== "custom")
      t === 0 ? this.type = n : this.type = n + t.toString();
    else {
      const r = new Float32Array(t);
      this._partials.forEach((s, a) => r[a] = s), this._partials = Array.from(r), this.type = this._type;
    }
  }
  /**
   * Returns the real and imaginary components based
   * on the oscillator type.
   * @returns [real: Float32Array, imaginary: Float32Array]
   */
  _getRealImaginary(t, n) {
    let r = 2048;
    const s = new Float32Array(r), a = new Float32Array(r);
    let o = 1;
    if (t === "custom") {
      if (o = this._partials.length + 1, this._partialCount = this._partials.length, r = o, this._partials.length === 0)
        return [s, a];
    } else {
      const l = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(t);
      l ? (o = parseInt(l[2], 10) + 1, this._partialCount = parseInt(l[2], 10), t = l[1], o = Math.max(o, 2), r = o) : this._partialCount = 0, this._partials = [];
    }
    for (let l = 1; l < r; ++l) {
      const u = 2 / (l * Math.PI);
      let c;
      switch (t) {
        case "sine":
          c = l <= o ? 1 : 0, this._partials[l - 1] = c;
          break;
        case "square":
          c = l & 1 ? 2 * u : 0, this._partials[l - 1] = c;
          break;
        case "sawtooth":
          c = u * (l & 1 ? 1 : -1), this._partials[l - 1] = c;
          break;
        case "triangle":
          l & 1 ? c = 2 * (u * u) * (l - 1 >> 1 & 1 ? -1 : 1) : c = 0, this._partials[l - 1] = c;
          break;
        case "custom":
          c = this._partials[l - 1];
          break;
        default:
          throw new TypeError("Oscillator: invalid type: " + t);
      }
      c !== 0 ? (s[l] = -c * Math.sin(n * l), a[l] = c * Math.cos(n * l)) : (s[l] = 0, a[l] = 0);
    }
    return [s, a];
  }
  /**
   * Compute the inverse FFT for a given phase.
   */
  _inverseFFT(t, n, i) {
    let r = 0;
    const s = t.length;
    for (let a = 0; a < s; a++)
      r += t[a] * Math.cos(a * i) + n[a] * Math.sin(a * i);
    return r;
  }
  /**
   * Returns the initial value of the oscillator when stopped.
   * E.g. a "sine" oscillator with phase = 90 would return an initial value of -1.
   */
  getInitialValue() {
    const [t, n] = this._getRealImaginary(this._type, 0);
    let i = 0;
    const r = Math.PI * 2, s = 32;
    for (let a = 0; a < s; a++)
      i = Math.max(this._inverseFFT(t, n, a / s * r), i);
    return UU(-this._inverseFFT(t, n, this._phase) / i, -1, 1);
  }
  get partials() {
    return this._partials.slice(0, this.partialCount);
  }
  set partials(t) {
    this._partials = t, this._partialCount = this._partials.length, t.length && (this.type = "custom");
  }
  get phase() {
    return this._phase * (180 / Math.PI);
  }
  set phase(t) {
    this._phase = t * Math.PI / 180, this.type = this._type;
  }
  asArray(t = 1024) {
    return fn(this, void 0, void 0, function* () {
      return xo(this, t);
    });
  }
  dispose() {
    return super.dispose(), this._oscillator !== null && this._oscillator.dispose(), this._wave = void 0, this.frequency.dispose(), this.detune.dispose(), this;
  }
}
rn._periodicWaveCache = [];
class lq extends Al {
  constructor() {
    super(...arguments), this.name = "AudioToGain", this._norm = new Il({
      context: this.context,
      mapping: (t) => (t + 1) / 2
    }), this.input = this._norm, this.output = this._norm;
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this._norm.dispose(), this;
  }
}
class ao extends pn {
  constructor() {
    super(Object.assign(Te(ao.getDefaults(), arguments, ["value"]))), this.name = "Multiply", this.override = !1;
    const t = Te(ao.getDefaults(), arguments, ["value"]);
    this._mult = this.input = this.output = new Bn({
      context: this.context,
      minValue: t.minValue,
      maxValue: t.maxValue
    }), this.factor = this._param = this._mult.gain, this.factor.setValueAtTime(t.value, 0);
  }
  static getDefaults() {
    return Object.assign(pn.getDefaults(), {
      value: 0
    });
  }
  dispose() {
    return super.dispose(), this._mult.dispose(), this;
  }
}
class dc extends Ii {
  constructor() {
    super(Te(dc.getDefaults(), arguments, ["frequency", "type", "modulationType"])), this.name = "AMOscillator", this._modulationScale = new lq({ context: this.context }), this._modulationNode = new Bn({
      context: this.context
    });
    const t = Te(dc.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    this._carrier = new rn({
      context: this.context,
      detune: t.detune,
      frequency: t.frequency,
      onstop: () => this.onstop(this),
      phase: t.phase,
      type: t.type
    }), this.frequency = this._carrier.frequency, this.detune = this._carrier.detune, this._modulator = new rn({
      context: this.context,
      phase: t.phase,
      type: t.modulationType
    }), this.harmonicity = new ao({
      context: this.context,
      units: "positive",
      value: t.harmonicity
    }), this.frequency.chain(this.harmonicity, this._modulator.frequency), this._modulator.chain(this._modulationScale, this._modulationNode.gain), this._carrier.chain(this._modulationNode, this.output), Jt(this, ["frequency", "detune", "harmonicity"]);
  }
  static getDefaults() {
    return Object.assign(rn.getDefaults(), {
      harmonicity: 1,
      modulationType: "square"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    this._modulator.start(t), this._carrier.start(t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    this._modulator.stop(t), this._carrier.stop(t);
  }
  _restart(t) {
    this._modulator.restart(t), this._carrier.restart(t);
  }
  /**
   * The type of the carrier oscillator
   */
  get type() {
    return this._carrier.type;
  }
  set type(t) {
    this._carrier.type = t;
  }
  get baseType() {
    return this._carrier.baseType;
  }
  set baseType(t) {
    this._carrier.baseType = t;
  }
  get partialCount() {
    return this._carrier.partialCount;
  }
  set partialCount(t) {
    this._carrier.partialCount = t;
  }
  /**
   * The type of the modulator oscillator
   */
  get modulationType() {
    return this._modulator.type;
  }
  set modulationType(t) {
    this._modulator.type = t;
  }
  get phase() {
    return this._carrier.phase;
  }
  set phase(t) {
    this._carrier.phase = t, this._modulator.phase = t;
  }
  get partials() {
    return this._carrier.partials;
  }
  set partials(t) {
    this._carrier.partials = t;
  }
  asArray(t = 1024) {
    return fn(this, void 0, void 0, function* () {
      return xo(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this._modulationScale.dispose(), this;
  }
}
class fc extends Ii {
  constructor() {
    super(Te(fc.getDefaults(), arguments, ["frequency", "type", "modulationType"])), this.name = "FMOscillator", this._modulationNode = new Bn({
      context: this.context,
      gain: 0
    });
    const t = Te(fc.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    this._carrier = new rn({
      context: this.context,
      detune: t.detune,
      frequency: 0,
      onstop: () => this.onstop(this),
      phase: t.phase,
      type: t.type
    }), this.detune = this._carrier.detune, this.frequency = new pn({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), this._modulator = new rn({
      context: this.context,
      phase: t.phase,
      type: t.modulationType
    }), this.harmonicity = new ao({
      context: this.context,
      units: "positive",
      value: t.harmonicity
    }), this.modulationIndex = new ao({
      context: this.context,
      units: "positive",
      value: t.modulationIndex
    }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.frequency.chain(this.modulationIndex, this._modulationNode), this._modulator.connect(this._modulationNode.gain), this._modulationNode.connect(this._carrier.frequency), this._carrier.connect(this.output), this.detune.connect(this._modulator.detune), Jt(this, ["modulationIndex", "frequency", "detune", "harmonicity"]);
  }
  static getDefaults() {
    return Object.assign(rn.getDefaults(), {
      harmonicity: 1,
      modulationIndex: 2,
      modulationType: "square"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    this._modulator.start(t), this._carrier.start(t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    this._modulator.stop(t), this._carrier.stop(t);
  }
  _restart(t) {
    return this._modulator.restart(t), this._carrier.restart(t), this;
  }
  get type() {
    return this._carrier.type;
  }
  set type(t) {
    this._carrier.type = t;
  }
  get baseType() {
    return this._carrier.baseType;
  }
  set baseType(t) {
    this._carrier.baseType = t;
  }
  get partialCount() {
    return this._carrier.partialCount;
  }
  set partialCount(t) {
    this._carrier.partialCount = t;
  }
  /**
   * The type of the modulator oscillator
   */
  get modulationType() {
    return this._modulator.type;
  }
  set modulationType(t) {
    this._modulator.type = t;
  }
  get phase() {
    return this._carrier.phase;
  }
  set phase(t) {
    this._carrier.phase = t, this._modulator.phase = t;
  }
  get partials() {
    return this._carrier.partials;
  }
  set partials(t) {
    this._carrier.partials = t;
  }
  asArray(t = 1024) {
    return fn(this, void 0, void 0, function* () {
      return xo(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.frequency.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this.modulationIndex.dispose(), this;
  }
}
class El extends Ii {
  constructor() {
    super(Te(El.getDefaults(), arguments, ["frequency", "width"])), this.name = "PulseOscillator", this._widthGate = new Bn({
      context: this.context,
      gain: 0
    }), this._thresh = new Il({
      context: this.context,
      mapping: (n) => n <= 0 ? -1 : 1
    });
    const t = Te(El.getDefaults(), arguments, ["frequency", "width"]);
    this.width = new pn({
      context: this.context,
      units: "audioRange",
      value: t.width
    }), this._triangle = new rn({
      context: this.context,
      detune: t.detune,
      frequency: t.frequency,
      onstop: () => this.onstop(this),
      phase: t.phase,
      type: "triangle"
    }), this.frequency = this._triangle.frequency, this.detune = this._triangle.detune, this._triangle.chain(this._thresh, this.output), this.width.chain(this._widthGate, this._thresh), Jt(this, ["width", "frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Ii.getDefaults(), {
      detune: 0,
      frequency: 440,
      phase: 0,
      type: "pulse",
      width: 0.2
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    t = this.toSeconds(t), this._triangle.start(t), this._widthGate.gain.setValueAtTime(1, t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    t = this.toSeconds(t), this._triangle.stop(t), this._widthGate.gain.cancelScheduledValues(t), this._widthGate.gain.setValueAtTime(0, t);
  }
  _restart(t) {
    this._triangle.restart(t), this._widthGate.gain.cancelScheduledValues(t), this._widthGate.gain.setValueAtTime(1, t);
  }
  /**
   * The phase of the oscillator in degrees.
   */
  get phase() {
    return this._triangle.phase;
  }
  set phase(t) {
    this._triangle.phase = t;
  }
  /**
   * The type of the oscillator. Always returns "pulse".
   */
  get type() {
    return "pulse";
  }
  /**
   * The baseType of the oscillator. Always returns "pulse".
   */
  get baseType() {
    return "pulse";
  }
  /**
   * The partials of the waveform. Cannot set partials for this waveform type
   */
  get partials() {
    return [];
  }
  /**
   * No partials for this waveform type.
   */
  get partialCount() {
    return 0;
  }
  /**
   * *Internal use* The carrier oscillator type is fed through the
   * waveshaper node to create the pulse. Using different carrier oscillators
   * changes oscillator's behavior.
   */
  set carrierType(t) {
    this._triangle.type = t;
  }
  asArray(t = 1024) {
    return fn(this, void 0, void 0, function* () {
      return xo(this, t);
    });
  }
  /**
   * Clean up method.
   */
  dispose() {
    return super.dispose(), this._triangle.dispose(), this.width.dispose(), this._widthGate.dispose(), this._thresh.dispose(), this;
  }
}
class hc extends Ii {
  constructor() {
    super(Te(hc.getDefaults(), arguments, ["frequency", "type", "spread"])), this.name = "FatOscillator", this._oscillators = [];
    const t = Te(hc.getDefaults(), arguments, ["frequency", "type", "spread"]);
    this.frequency = new pn({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), this.detune = new pn({
      context: this.context,
      units: "cents",
      value: t.detune
    }), this._spread = t.spread, this._type = t.type, this._phase = t.phase, this._partials = t.partials, this._partialCount = t.partialCount, this.count = t.count, Jt(this, ["frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(rn.getDefaults(), {
      count: 3,
      spread: 20,
      type: "sawtooth"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    t = this.toSeconds(t), this._forEach((n) => n.start(t));
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    t = this.toSeconds(t), this._forEach((n) => n.stop(t));
  }
  _restart(t) {
    this._forEach((n) => n.restart(t));
  }
  /**
   * Iterate over all of the oscillators
   */
  _forEach(t) {
    for (let n = 0; n < this._oscillators.length; n++)
      t(this._oscillators[n], n);
  }
  /**
   * The type of the oscillator
   */
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t, this._forEach((n) => n.type = t);
  }
  /**
   * The detune spread between the oscillators. If "count" is
   * set to 3 oscillators and the "spread" is set to 40,
   * the three oscillators would be detuned like this: [-20, 0, 20]
   * for a total detune spread of 40 cents.
   * @example
   * const fatOsc = new Tone.FatOscillator().toDestination().start();
   * fatOsc.spread = 70;
   */
  get spread() {
    return this._spread;
  }
  set spread(t) {
    if (this._spread = t, this._oscillators.length > 1) {
      const n = -t / 2, i = t / (this._oscillators.length - 1);
      this._forEach((r, s) => r.detune.value = n + i * s);
    }
  }
  /**
   * The number of detuned oscillators. Must be an integer greater than 1.
   * @example
   * const fatOsc = new Tone.FatOscillator("C#3", "sawtooth").toDestination().start();
   * // use 4 sawtooth oscillators
   * fatOsc.count = 4;
   */
  get count() {
    return this._oscillators.length;
  }
  set count(t) {
    if (sa(t, 1), this._oscillators.length !== t) {
      this._forEach((n) => n.dispose()), this._oscillators = [];
      for (let n = 0; n < t; n++) {
        const i = new rn({
          context: this.context,
          volume: -6 - t * 1.1,
          type: this._type,
          phase: this._phase + n / t * 360,
          partialCount: this._partialCount,
          onstop: n === 0 ? () => this.onstop(this) : wt
        });
        this.type === "custom" && (i.partials = this._partials), this.frequency.connect(i.frequency), this.detune.connect(i.detune), i.detune.overridden = !1, i.connect(this.output), this._oscillators[n] = i;
      }
      this.spread = this._spread, this.state === "started" && this._forEach((n) => n.start());
    }
  }
  get phase() {
    return this._phase;
  }
  set phase(t) {
    this._phase = t, this._forEach((n, i) => n.phase = this._phase + i / this.count * 360);
  }
  get baseType() {
    return this._oscillators[0].baseType;
  }
  set baseType(t) {
    this._forEach((n) => n.baseType = t), this._type = this._oscillators[0].type;
  }
  get partials() {
    return this._oscillators[0].partials;
  }
  set partials(t) {
    this._partials = t, this._partialCount = this._partials.length, t.length && (this._type = "custom", this._forEach((n) => n.partials = t));
  }
  get partialCount() {
    return this._oscillators[0].partialCount;
  }
  set partialCount(t) {
    this._partialCount = t, this._forEach((n) => n.partialCount = t), this._type = this._oscillators[0].type;
  }
  asArray(t = 1024) {
    return fn(this, void 0, void 0, function* () {
      return xo(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this._forEach((t) => t.dispose()), this;
  }
}
class mc extends Ii {
  constructor() {
    super(Te(mc.getDefaults(), arguments, ["frequency", "modulationFrequency"])), this.name = "PWMOscillator", this.sourceType = "pwm", this._scale = new ao({
      context: this.context,
      value: 2
    });
    const t = Te(mc.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
    this._pulse = new El({
      context: this.context,
      frequency: t.modulationFrequency
    }), this._pulse.carrierType = "sine", this.modulationFrequency = this._pulse.frequency, this._modulator = new rn({
      context: this.context,
      detune: t.detune,
      frequency: t.frequency,
      onstop: () => this.onstop(this),
      phase: t.phase
    }), this.frequency = this._modulator.frequency, this.detune = this._modulator.detune, this._modulator.chain(this._scale, this._pulse.width), this._pulse.connect(this.output), Jt(this, ["modulationFrequency", "frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Ii.getDefaults(), {
      detune: 0,
      frequency: 440,
      modulationFrequency: 0.4,
      phase: 0,
      type: "pwm"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    t = this.toSeconds(t), this._modulator.start(t), this._pulse.start(t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    t = this.toSeconds(t), this._modulator.stop(t), this._pulse.stop(t);
  }
  /**
   * restart the oscillator
   */
  _restart(t) {
    this._modulator.restart(t), this._pulse.restart(t);
  }
  /**
   * The type of the oscillator. Always returns "pwm".
   */
  get type() {
    return "pwm";
  }
  /**
   * The baseType of the oscillator. Always returns "pwm".
   */
  get baseType() {
    return "pwm";
  }
  /**
   * The partials of the waveform. Cannot set partials for this waveform type
   */
  get partials() {
    return [];
  }
  /**
   * No partials for this waveform type.
   */
  get partialCount() {
    return 0;
  }
  /**
   * The phase of the oscillator in degrees.
   */
  get phase() {
    return this._modulator.phase;
  }
  set phase(t) {
    this._modulator.phase = t;
  }
  asArray(t = 1024) {
    return fn(this, void 0, void 0, function* () {
      return xo(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._pulse.dispose(), this._scale.dispose(), this._modulator.dispose(), this;
  }
}
const T_ = {
  am: dc,
  fat: hc,
  fm: fc,
  oscillator: rn,
  pulse: El,
  pwm: mc
};
class vc extends Ii {
  constructor() {
    super(Te(vc.getDefaults(), arguments, ["frequency", "type"])), this.name = "OmniOscillator";
    const t = Te(vc.getDefaults(), arguments, ["frequency", "type"]);
    this.frequency = new pn({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), this.detune = new pn({
      context: this.context,
      units: "cents",
      value: t.detune
    }), Jt(this, ["frequency", "detune"]), this.set(t);
  }
  static getDefaults() {
    return Object.assign(rn.getDefaults(), fc.getDefaults(), dc.getDefaults(), hc.getDefaults(), El.getDefaults(), mc.getDefaults());
  }
  /**
   * start the oscillator
   */
  _start(t) {
    this._oscillator.start(t);
  }
  /**
   * start the oscillator
   */
  _stop(t) {
    this._oscillator.stop(t);
  }
  _restart(t) {
    return this._oscillator.restart(t), this;
  }
  /**
   * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or
   * prefix the basic types with "fm", "am", or "fat" to use the FMOscillator, AMOscillator or FatOscillator
   * types. The oscillator could also be set to "pwm" or "pulse". All of the parameters of the
   * oscillator's class are accessible when the oscillator is set to that type, but throws an error
   * when it's not.
   * @example
   * const omniOsc = new Tone.OmniOscillator().toDestination().start();
   * omniOsc.type = "pwm";
   * // modulationFrequency is parameter which is available
   * // only when the type is "pwm".
   * omniOsc.modulationFrequency.value = 0.5;
   */
  get type() {
    let t = "";
    return ["am", "fm", "fat"].some((n) => this._sourceType === n) && (t = this._sourceType), t + this._oscillator.type;
  }
  set type(t) {
    t.substr(0, 2) === "fm" ? (this._createNewOscillator("fm"), this._oscillator = this._oscillator, this._oscillator.type = t.substr(2)) : t.substr(0, 2) === "am" ? (this._createNewOscillator("am"), this._oscillator = this._oscillator, this._oscillator.type = t.substr(2)) : t.substr(0, 3) === "fat" ? (this._createNewOscillator("fat"), this._oscillator = this._oscillator, this._oscillator.type = t.substr(3)) : t === "pwm" ? (this._createNewOscillator("pwm"), this._oscillator = this._oscillator) : t === "pulse" ? this._createNewOscillator("pulse") : (this._createNewOscillator("oscillator"), this._oscillator = this._oscillator, this._oscillator.type = t);
  }
  /**
   * The value is an empty array when the type is not "custom".
   * This is not available on "pwm" and "pulse" oscillator types.
   * @see {@link Oscillator.partials}
   */
  get partials() {
    return this._oscillator.partials;
  }
  set partials(t) {
    !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partials = t);
  }
  get partialCount() {
    return this._oscillator.partialCount;
  }
  set partialCount(t) {
    !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partialCount = t);
  }
  set(t) {
    return Reflect.has(t, "type") && t.type && (this.type = t.type), super.set(t), this;
  }
  /**
   * connect the oscillator to the frequency and detune signals
   */
  _createNewOscillator(t) {
    if (t !== this._sourceType) {
      this._sourceType = t;
      const n = T_[t], i = this.now();
      if (this._oscillator) {
        const r = this._oscillator;
        r.stop(i), this.context.setTimeout(() => r.dispose(), this.blockTime);
      }
      this._oscillator = new n({
        context: this.context
      }), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.connect(this.output), this._oscillator.onstop = () => this.onstop(this), this.state === "started" && this._oscillator.start(i);
    }
  }
  get phase() {
    return this._oscillator.phase;
  }
  set phase(t) {
    this._oscillator.phase = t;
  }
  /**
   * The source type of the oscillator.
   * @example
   * const omniOsc = new Tone.OmniOscillator(440, "fmsquare");
   * console.log(omniOsc.sourceType); // 'fm'
   */
  get sourceType() {
    return this._sourceType;
  }
  set sourceType(t) {
    let n = "sine";
    this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse" && (n = this._oscillator.type), t === "fm" ? this.type = "fm" + n : t === "am" ? this.type = "am" + n : t === "fat" ? this.type = "fat" + n : t === "oscillator" ? this.type = n : t === "pulse" ? this.type = "pulse" : t === "pwm" && (this.type = "pwm");
  }
  _getOscType(t, n) {
    return t instanceof T_[n];
  }
  /**
   * The base type of the oscillator.
   * @see {@link Oscillator.baseType}
   * @example
   * const omniOsc = new Tone.OmniOscillator(440, "fmsquare4");
   * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);
   */
  get baseType() {
    return this._oscillator.baseType;
  }
  set baseType(t) {
    !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && t !== "pulse" && t !== "pwm" && (this._oscillator.baseType = t);
  }
  /**
   * The width of the oscillator when sourceType === "pulse".
   * @see {@link PWMOscillator}
   */
  get width() {
    if (this._getOscType(this._oscillator, "pulse"))
      return this._oscillator.width;
  }
  /**
   * The number of detuned oscillators when sourceType === "fat".
   * @see {@link FatOscillator.count}
   */
  get count() {
    if (this._getOscType(this._oscillator, "fat"))
      return this._oscillator.count;
  }
  set count(t) {
    this._getOscType(this._oscillator, "fat") && io(t) && (this._oscillator.count = t);
  }
  /**
   * The detune spread between the oscillators when sourceType === "fat".
   * @see {@link FatOscillator.count}
   */
  get spread() {
    if (this._getOscType(this._oscillator, "fat"))
      return this._oscillator.spread;
  }
  set spread(t) {
    this._getOscType(this._oscillator, "fat") && io(t) && (this._oscillator.spread = t);
  }
  /**
   * The type of the modulator oscillator. Only if the oscillator is set to "am" or "fm" types.
   * @see {@link AMOscillator} or {@link FMOscillator}
   */
  get modulationType() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am"))
      return this._oscillator.modulationType;
  }
  set modulationType(t) {
    (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && bs(t) && (this._oscillator.modulationType = t);
  }
  /**
   * The modulation index when the sourceType === "fm"
   * @see {@link FMOscillator}.
   */
  get modulationIndex() {
    if (this._getOscType(this._oscillator, "fm"))
      return this._oscillator.modulationIndex;
  }
  /**
   * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.
   * @see {@link AMOscillator} or {@link FMOscillator}
   */
  get harmonicity() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am"))
      return this._oscillator.harmonicity;
  }
  /**
   * The modulationFrequency Signal of the oscillator when sourceType === "pwm"
   * see {@link PWMOscillator}
   * @min 0.1
   * @max 5
   */
  get modulationFrequency() {
    if (this._getOscType(this._oscillator, "pwm"))
      return this._oscillator.modulationFrequency;
  }
  asArray(t = 1024) {
    return fn(this, void 0, void 0, function* () {
      return xo(this, t);
    });
  }
  dispose() {
    return super.dispose(), this.detune.dispose(), this.frequency.dispose(), this._oscillator.dispose(), this;
  }
}
function Ix(e, t = 1 / 0) {
  const n = /* @__PURE__ */ new WeakMap();
  return function(i, r) {
    Reflect.defineProperty(i, r, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return n.get(this);
      },
      set: function(s) {
        sa(s, e, t), n.set(this, s);
      }
    });
  };
}
function Es(e, t = 1 / 0) {
  const n = /* @__PURE__ */ new WeakMap();
  return function(i, r) {
    Reflect.defineProperty(i, r, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return n.get(this);
      },
      set: function(s) {
        sa(this.toSeconds(s), e, t), n.set(this, s);
      }
    });
  };
}
class Ol extends Ii {
  constructor() {
    super(Te(Ol.getDefaults(), arguments, [
      "url",
      "onload"
    ])), this.name = "Player", this._activeSources = /* @__PURE__ */ new Set();
    const t = Te(Ol.getDefaults(), arguments, [
      "url",
      "onload"
    ]);
    this._buffer = new Vt({
      onload: this._onload.bind(this, t.onload),
      onerror: t.onerror,
      reverse: t.reverse,
      url: t.url
    }), this.autostart = t.autostart, this._loop = t.loop, this._loopStart = t.loopStart, this._loopEnd = t.loopEnd, this._playbackRate = t.playbackRate, this.fadeIn = t.fadeIn, this.fadeOut = t.fadeOut;
  }
  static getDefaults() {
    return Object.assign(Ii.getDefaults(), {
      autostart: !1,
      fadeIn: 0,
      fadeOut: 0,
      loop: !1,
      loopEnd: 0,
      loopStart: 0,
      onload: wt,
      onerror: wt,
      playbackRate: 1,
      reverse: !1
    });
  }
  /**
   * Load the audio file as an audio buffer.
   * Decodes the audio asynchronously and invokes
   * the callback once the audio buffer loads.
   * Note: this does not need to be called if a url
   * was passed in to the constructor. Only use this
   * if you want to manually load a new url.
   * @param url The url of the buffer to load. Filetype support depends on the browser.
   */
  load(t) {
    return fn(this, void 0, void 0, function* () {
      return yield this._buffer.load(t), this._onload(), this;
    });
  }
  /**
   * Internal callback when the buffer is loaded.
   */
  _onload(t = wt) {
    t(), this.autostart && this.start();
  }
  /**
   * Internal callback when the buffer is done playing.
   */
  _onSourceEnd(t) {
    this.onstop(this), this._activeSources.delete(t), this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started" && (this._state.cancel(this.now()), this._state.setStateAtTime("stopped", this.now()));
  }
  /**
   * Play the buffer at the given startTime. Optionally add an offset
   * and/or duration which will play the buffer from a position
   * within the buffer for the given duration.
   *
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
   */
  start(t, n, i) {
    return super.start(t, n, i), this;
  }
  /**
   * Internal start method
   */
  _start(t, n, i) {
    this._loop ? n = fl(n, this._loopStart) : n = fl(n, 0);
    const r = this.toSeconds(n), s = i;
    i = fl(i, Math.max(this._buffer.duration - r, 0));
    let a = this.toSeconds(i);
    a = a / this._playbackRate, t = this.toSeconds(t);
    const o = new cc({
      url: this._buffer,
      context: this.context,
      fadeIn: this.fadeIn,
      fadeOut: this.fadeOut,
      loop: this._loop,
      loopEnd: this._loopEnd,
      loopStart: this._loopStart,
      onended: this._onSourceEnd.bind(this),
      playbackRate: this._playbackRate
    }).connect(this.output);
    !this._loop && !this._synced && (this._state.cancel(t + a), this._state.setStateAtTime("stopped", t + a, {
      implicitEnd: !0
    })), this._activeSources.add(o), this._loop && Zi(s) ? o.start(t, r) : o.start(t, r, a - this.toSeconds(this.fadeOut));
  }
  /**
   * Stop playback.
   */
  _stop(t) {
    const n = this.toSeconds(t);
    this._activeSources.forEach((i) => i.stop(n));
  }
  /**
   * Stop and then restart the player from the beginning (or offset)
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given,
   * 					it will default to the full length of the sample (minus any offset)
   */
  restart(t, n, i) {
    return super.restart(t, n, i), this;
  }
  _restart(t, n, i) {
    var r;
    (r = [...this._activeSources].pop()) === null || r === void 0 || r.stop(t), this._start(t, n, i);
  }
  /**
   * Seek to a specific time in the player's buffer. If the
   * source is no longer playing at that time, it will stop.
   * @param offset The time to seek to.
   * @param when The time for the seek event to occur.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/gurgling_theremin_1.mp3", () => {
   * 	player.start();
   * 	// seek to the offset in 1 second from now
   * 	player.seek(0.4, "+1");
   * }).toDestination();
   */
  seek(t, n) {
    const i = this.toSeconds(n);
    if (this._state.getValueAtTime(i) === "started") {
      const r = this.toSeconds(t);
      this._stop(i), this._start(i, r);
    }
    return this;
  }
  /**
   * Set the loop start and end. Will only loop if loop is set to true.
   * @param loopStart The loop start time
   * @param loopEnd The loop end time
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/malevoices_aa2_F3.mp3").toDestination();
   * // loop between the given points
   * player.setLoopPoints(0.2, 0.3);
   * player.loop = true;
   * player.autostart = true;
   */
  setLoopPoints(t, n) {
    return this.loopStart = t, this.loopEnd = n, this;
  }
  /**
   * If loop is true, the loop will start at this position.
   */
  get loopStart() {
    return this._loopStart;
  }
  set loopStart(t) {
    this._loopStart = t, this.buffer.loaded && sa(this.toSeconds(t), 0, this.buffer.duration), this._activeSources.forEach((n) => {
      n.loopStart = t;
    });
  }
  /**
   * If loop is true, the loop will end at this position.
   */
  get loopEnd() {
    return this._loopEnd;
  }
  set loopEnd(t) {
    this._loopEnd = t, this.buffer.loaded && sa(this.toSeconds(t), 0, this.buffer.duration), this._activeSources.forEach((n) => {
      n.loopEnd = t;
    });
  }
  /**
   * The audio buffer belonging to the player.
   */
  get buffer() {
    return this._buffer;
  }
  set buffer(t) {
    this._buffer.set(t);
  }
  /**
   * If the buffer should loop once it's over.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/breakbeat.mp3").toDestination();
   * player.loop = true;
   * player.autostart = true;
   */
  get loop() {
    return this._loop;
  }
  set loop(t) {
    if (this._loop !== t && (this._loop = t, this._activeSources.forEach((n) => {
      n.loop = t;
    }), t)) {
      const n = this._state.getNextState("stopped", this.now());
      n && this._state.cancel(n.time);
    }
  }
  /**
   * Normal speed is 1. The pitch will change with the playback rate.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/femalevoices_aa2_A5.mp3").toDestination();
   * // play at 1/4 speed
   * player.playbackRate = 0.25;
   * // play as soon as the buffer is loaded
   * player.autostart = true;
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(t) {
    this._playbackRate = t;
    const n = this.now(), i = this._state.getNextState("stopped", n);
    i && i.implicitEnd && (this._state.cancel(i.time), this._activeSources.forEach((r) => r.cancelStop())), this._activeSources.forEach((r) => {
      r.playbackRate.setValueAtTime(t, n);
    });
  }
  /**
   * If the buffer should be reversed. Note that this sets the underlying {@link ToneAudioBuffer.reverse}, so
   * if multiple players are pointing at the same ToneAudioBuffer, they will all be reversed.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/chime_1.mp3").toDestination();
   * player.autostart = true;
   * player.reverse = true;
   */
  get reverse() {
    return this._buffer.reverse;
  }
  set reverse(t) {
    this._buffer.reverse = t;
  }
  /**
   * If the buffer is loaded
   */
  get loaded() {
    return this._buffer.loaded;
  }
  dispose() {
    return super.dispose(), this._activeSources.forEach((t) => t.dispose()), this._activeSources.clear(), this._buffer.dispose(), this;
  }
}
Pr([
  Es(0)
], Ol.prototype, "fadeIn", void 0);
Pr([
  Es(0)
], Ol.prototype, "fadeOut", void 0);
class ws extends et {
  constructor() {
    super(Te(ws.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])), this.name = "Envelope", this._sig = new pn({
      context: this.context,
      value: 0
    }), this.output = this._sig, this.input = void 0;
    const t = Te(ws.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
    this.attack = t.attack, this.decay = t.decay, this.sustain = t.sustain, this.release = t.release, this.attackCurve = t.attackCurve, this.releaseCurve = t.releaseCurve, this.decayCurve = t.decayCurve;
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      attack: 0.01,
      attackCurve: "linear",
      decay: 0.1,
      decayCurve: "exponential",
      release: 1,
      releaseCurve: "exponential",
      sustain: 0.5
    });
  }
  /**
   * Read the current value of the envelope. Useful for
   * synchronizing visual output to the envelope.
   */
  get value() {
    return this.getValueAtTime(this.now());
  }
  /**
   * Get the curve
   * @param  curve
   * @param  direction  In/Out
   * @return The curve name
   */
  _getCurve(t, n) {
    if (bs(t))
      return t;
    {
      let i;
      for (i in Od)
        if (Od[i][n] === t)
          return i;
      return t;
    }
  }
  /**
   * Assign a the curve to the given name using the direction
   * @param  name
   * @param  direction In/Out
   * @param  curve
   */
  _setCurve(t, n, i) {
    if (bs(i) && Reflect.has(Od, i)) {
      const r = Od[i];
      za(r) ? t !== "_decayCurve" && (this[t] = r[n]) : this[t] = r;
    } else if (br(i) && t !== "_decayCurve")
      this[t] = i;
    else
      throw new Error("Envelope: invalid curve: " + i);
  }
  /**
   * The shape of the attack.
   * Can be any of these strings:
   * * "linear"
   * * "exponential"
   * * "sine"
   * * "cosine"
   * * "bounce"
   * * "ripple"
   * * "step"
   *
   * Can also be an array which describes the curve. Values
   * in the array are evenly subdivided and linearly
   * interpolated over the duration of the attack.
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope(0.4).toDestination();
   * 	env.attackCurve = "linear";
   * 	env.triggerAttack();
   * }, 1, 1);
   */
  get attackCurve() {
    return this._getCurve(this._attackCurve, "In");
  }
  set attackCurve(t) {
    this._setCurve("_attackCurve", "In", t);
  }
  /**
   * The shape of the release. See the attack curve types.
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope({
   * 		release: 0.8
   * 	}).toDestination();
   * 	env.triggerAttack();
   * 	// release curve could also be defined by an array
   * 	env.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];
   * 	env.triggerRelease(0.2);
   * }, 1, 1);
   */
  get releaseCurve() {
    return this._getCurve(this._releaseCurve, "Out");
  }
  set releaseCurve(t) {
    this._setCurve("_releaseCurve", "Out", t);
  }
  /**
   * The shape of the decay either "linear" or "exponential"
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope({
   * 		sustain: 0.1,
   * 		decay: 0.5
   * 	}).toDestination();
   * 	env.decayCurve = "linear";
   * 	env.triggerAttack();
   * }, 1, 1);
   */
  get decayCurve() {
    return this._getCurve(this._decayCurve, "Out");
  }
  set decayCurve(t) {
    this._setCurve("_decayCurve", "Out", t);
  }
  /**
   * Trigger the attack/decay portion of the ADSR envelope.
   * @param  time When the attack should start.
   * @param velocity The velocity of the envelope scales the vales.
   *                             number between 0-1
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator().connect(env).start();
   * // trigger the attack 0.5 seconds from now with a velocity of 0.2
   * env.triggerAttack("+0.5", 0.2);
   */
  triggerAttack(t, n = 1) {
    this.log("triggerAttack", t, n), t = this.toSeconds(t);
    let r = this.toSeconds(this.attack);
    const s = this.toSeconds(this.decay), a = this.getValueAtTime(t);
    if (a > 0) {
      const o = 1 / r;
      r = (1 - a) / o;
    }
    if (r < this.sampleTime)
      this._sig.cancelScheduledValues(t), this._sig.setValueAtTime(n, t);
    else if (this._attackCurve === "linear")
      this._sig.linearRampTo(n, r, t);
    else if (this._attackCurve === "exponential")
      this._sig.targetRampTo(n, r, t);
    else {
      this._sig.cancelAndHoldAtTime(t);
      let o = this._attackCurve;
      for (let l = 1; l < o.length; l++)
        if (o[l - 1] <= a && a <= o[l]) {
          o = this._attackCurve.slice(l), o[0] = a;
          break;
        }
      this._sig.setValueCurveAtTime(o, t, r, n);
    }
    if (s && this.sustain < 1) {
      const o = n * this.sustain, l = t + r;
      this.log("decay", l), this._decayCurve === "linear" ? this._sig.linearRampToValueAtTime(o, s + l) : this._sig.exponentialApproachValueAtTime(o, l, s);
    }
    return this;
  }
  /**
   * Triggers the release of the envelope.
   * @param  time When the release portion of the envelope should start.
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator({
   * 	type: "sawtooth"
   * }).connect(env).start();
   * env.triggerAttack();
   * // trigger the release half a second after the attack
   * env.triggerRelease("+0.5");
   */
  triggerRelease(t) {
    this.log("triggerRelease", t), t = this.toSeconds(t);
    const n = this.getValueAtTime(t);
    if (n > 0) {
      const i = this.toSeconds(this.release);
      i < this.sampleTime ? this._sig.setValueAtTime(0, t) : this._releaseCurve === "linear" ? this._sig.linearRampTo(0, i, t) : this._releaseCurve === "exponential" ? this._sig.targetRampTo(0, i, t) : (Xe(br(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array"), this._sig.cancelAndHoldAtTime(t), this._sig.setValueCurveAtTime(this._releaseCurve, t, i, n));
    }
    return this;
  }
  /**
   * Get the scheduled value at the given time. This will
   * return the unconverted (raw) value.
   * @example
   * const env = new Tone.Envelope(0.5, 1, 0.4, 2);
   * env.triggerAttackRelease(2);
   * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);
   */
  getValueAtTime(t) {
    return this._sig.getValueAtTime(t);
  }
  /**
   * triggerAttackRelease is shorthand for triggerAttack, then waiting
   * some duration, then triggerRelease.
   * @param duration The duration of the sustain.
   * @param time When the attack should be triggered.
   * @param velocity The velocity of the envelope.
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator().connect(env).start();
   * // trigger the release 0.5 seconds after the attack
   * env.triggerAttackRelease(0.5);
   */
  triggerAttackRelease(t, n, i = 1) {
    return n = this.toSeconds(n), this.triggerAttack(n, i), this.triggerRelease(n + this.toSeconds(t)), this;
  }
  /**
   * Cancels all scheduled envelope changes after the given time.
   */
  cancel(t) {
    return this._sig.cancelScheduledValues(this.toSeconds(t)), this;
  }
  /**
   * Connect the envelope to a destination node.
   */
  connect(t, n = 0, i = 0) {
    return Uy(this, t, n, i), this;
  }
  /**
   * Render the envelope curve to an array of the given length.
   * Good for visualizing the envelope curve. Rescales the duration of the
   * envelope to fit the length.
   */
  asArray(t = 1024) {
    return fn(this, void 0, void 0, function* () {
      const n = t / this.context.sampleRate, i = new jy(1, n, this.context.sampleRate), r = this.toSeconds(this.attack) + this.toSeconds(this.decay), s = r + this.toSeconds(this.release), a = s * 0.1, o = s + a, l = new this.constructor(Object.assign(this.get(), {
        attack: n * this.toSeconds(this.attack) / o,
        decay: n * this.toSeconds(this.decay) / o,
        release: n * this.toSeconds(this.release) / o,
        context: i
      }));
      return l._sig.toDestination(), l.triggerAttackRelease(n * (r + a) / o, 0), (yield i.render()).getChannelData(0);
    });
  }
  dispose() {
    return super.dispose(), this._sig.dispose(), this;
  }
}
Pr([
  Es(0)
], ws.prototype, "attack", void 0);
Pr([
  Es(0)
], ws.prototype, "decay", void 0);
Pr([
  Ix(0, 1)
], ws.prototype, "sustain", void 0);
Pr([
  Es(0)
], ws.prototype, "release", void 0);
const Od = (() => {
  let t, n;
  const i = [];
  for (t = 0; t < 128; t++)
    i[t] = Math.sin(t / (128 - 1) * (Math.PI / 2));
  const r = [], s = 6.4;
  for (t = 0; t < 128 - 1; t++) {
    n = t / (128 - 1);
    const f = Math.sin(n * (Math.PI * 2) * s - Math.PI / 2) + 1;
    r[t] = f / 10 + n * 0.83;
  }
  r[128 - 1] = 1;
  const a = [], o = 5;
  for (t = 0; t < 128; t++)
    a[t] = Math.ceil(t / (128 - 1) * o) / o;
  const l = [];
  for (t = 0; t < 128; t++)
    n = t / (128 - 1), l[t] = 0.5 * (1 - Math.cos(Math.PI * n));
  const u = [];
  for (t = 0; t < 128; t++) {
    n = t / (128 - 1);
    const f = Math.pow(n, 3) * 4 + 0.2, h = Math.cos(f * Math.PI * 2 * n);
    u[t] = Math.abs(h * (1 - n));
  }
  function c(f) {
    const h = new Array(f.length);
    for (let m = 0; m < f.length; m++)
      h[m] = 1 - f[m];
    return h;
  }
  function d(f) {
    return f.slice(0).reverse();
  }
  return {
    bounce: {
      In: c(u),
      Out: u
    },
    cosine: {
      In: i,
      Out: d(i)
    },
    exponential: "exponential",
    linear: "linear",
    ripple: {
      In: r,
      Out: c(r)
    },
    sine: {
      In: l,
      Out: c(l)
    },
    step: {
      In: a,
      Out: c(a)
    }
  };
})();
class oo extends et {
  constructor() {
    super(Te(oo.getDefaults(), arguments)), this._scheduledEvents = [], this._synced = !1, this._original_triggerAttack = this.triggerAttack, this._original_triggerRelease = this.triggerRelease, this._syncedRelease = (n) => this._original_triggerRelease(n);
    const t = Te(oo.getDefaults(), arguments);
    this._volume = this.output = new so({
      context: this.context,
      volume: t.volume
    }), this.volume = this._volume.volume, Jt(this, "volume");
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      volume: 0
    });
  }
  /**
   * Sync the instrument to the Transport. All subsequent calls of
   * {@link triggerAttack} and {@link triggerRelease} will be scheduled along the transport.
   * @example
   * const fmSynth = new Tone.FMSynth().toDestination();
   * fmSynth.volume.value = -6;
   * fmSynth.sync();
   * // schedule 3 notes when the transport first starts
   * fmSynth.triggerAttackRelease("C4", "8n", 0);
   * fmSynth.triggerAttackRelease("E4", "8n", "8n");
   * fmSynth.triggerAttackRelease("G4", "8n", "4n");
   * // start the transport to hear the notes
   * Tone.Transport.start();
   */
  sync() {
    return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 0), this.context.transport.on("stop", this._syncedRelease), this.context.transport.on("pause", this._syncedRelease), this.context.transport.on("loopEnd", this._syncedRelease)), this;
  }
  /**
   * set _sync
   */
  _syncState() {
    let t = !1;
    return this._synced || (this._synced = !0, t = !0), t;
  }
  /**
   * Wrap the given method so that it can be synchronized
   * @param method Which method to wrap and sync
   * @param  timePosition What position the time argument appears in
   */
  _syncMethod(t, n) {
    const i = this["_original_" + t] = this[t];
    this[t] = (...r) => {
      const s = r[n], a = this.context.transport.schedule((o) => {
        r[n] = o, i.apply(this, r);
      }, s);
      this._scheduledEvents.push(a);
    };
  }
  /**
   * Unsync the instrument from the Transport
   */
  unsync() {
    return this._scheduledEvents.forEach((t) => this.context.transport.clear(t)), this._scheduledEvents = [], this._synced && (this._synced = !1, this.triggerAttack = this._original_triggerAttack, this.triggerRelease = this._original_triggerRelease, this.context.transport.off("stop", this._syncedRelease), this.context.transport.off("pause", this._syncedRelease), this.context.transport.off("loopEnd", this._syncedRelease)), this;
  }
  /**
   * Trigger the attack and then the release after the duration.
   * @param  note     The note to trigger.
   * @param  duration How long the note should be held for before
   *                         triggering the release. This value must be greater than 0.
   * @param time  When the note should be triggered.
   * @param  velocity The velocity the note should be triggered at.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * // trigger "C4" for the duration of an 8th note
   * synth.triggerAttackRelease("C4", "8n");
   */
  triggerAttackRelease(t, n, i, r) {
    const s = this.toSeconds(i), a = this.toSeconds(n);
    return this.triggerAttack(t, s, r), this.triggerRelease(s + a), this;
  }
  /**
   * clean up
   * @returns {Instrument} this
   */
  dispose() {
    return super.dispose(), this._volume.dispose(), this.unsync(), this._scheduledEvents = [], this;
  }
}
class lo extends oo {
  constructor() {
    super(Te(lo.getDefaults(), arguments));
    const t = Te(lo.getDefaults(), arguments);
    this.portamento = t.portamento, this.onsilence = t.onsilence;
  }
  static getDefaults() {
    return Object.assign(oo.getDefaults(), {
      detune: 0,
      onsilence: wt,
      portamento: 0
    });
  }
  /**
   * Trigger the attack of the note optionally with a given velocity.
   * @param  note The note to trigger.
   * @param  time When the note should start.
   * @param  velocity The velocity determines how "loud" the note will be.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * // trigger the note a half second from now at half velocity
   * synth.triggerAttack("C4", "+0.5", 0.5);
   */
  triggerAttack(t, n, i = 1) {
    this.log("triggerAttack", t, n, i);
    const r = this.toSeconds(n);
    return this._triggerEnvelopeAttack(r, i), this.setNote(t, r), this;
  }
  /**
   * Trigger the release portion of the envelope.
   * @param  time If no time is given, the release happens immediately.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * synth.triggerAttack("C4");
   * // trigger the release a second from now
   * synth.triggerRelease("+1");
   */
  triggerRelease(t) {
    this.log("triggerRelease", t);
    const n = this.toSeconds(t);
    return this._triggerEnvelopeRelease(n), this;
  }
  /**
   * Set the note at the given time. If no time is given, the note
   * will set immediately.
   * @param note The note to change to.
   * @param  time The time when the note should be set.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * synth.triggerAttack("C4");
   * // change to F#6 in one quarter note from now.
   * synth.setNote("F#6", "+4n");
   */
  setNote(t, n) {
    const i = this.toSeconds(n), r = t instanceof Gi ? t.toFrequency() : t;
    if (this.portamento > 0 && this.getLevelAtTime(i) > 0.05) {
      const s = this.toSeconds(this.portamento);
      this.frequency.exponentialRampTo(r, s, i);
    } else
      this.frequency.setValueAtTime(r, i);
    return this;
  }
}
Pr([
  Es(0)
], lo.prototype, "portamento", void 0);
class Yy extends ws {
  constructor() {
    super(Te(Yy.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])), this.name = "AmplitudeEnvelope", this._gainNode = new Bn({
      context: this.context,
      gain: 0
    }), this.output = this._gainNode, this.input = this._gainNode, this._sig.connect(this._gainNode.gain), this.output = this._gainNode, this.input = this._gainNode;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._gainNode.dispose(), this;
  }
}
class gc extends lo {
  constructor() {
    super(Te(gc.getDefaults(), arguments)), this.name = "Synth";
    const t = Te(gc.getDefaults(), arguments);
    this.oscillator = new vc(Object.assign({
      context: this.context,
      detune: t.detune,
      onstop: () => this.onsilence(this)
    }, t.oscillator)), this.frequency = this.oscillator.frequency, this.detune = this.oscillator.detune, this.envelope = new Yy(Object.assign({
      context: this.context
    }, t.envelope)), this.oscillator.chain(this.envelope, this.output), Jt(this, ["oscillator", "frequency", "detune", "envelope"]);
  }
  static getDefaults() {
    return Object.assign(lo.getDefaults(), {
      envelope: Object.assign(C_(ws.getDefaults(), Object.keys(et.getDefaults())), {
        attack: 5e-3,
        decay: 0.1,
        release: 1,
        sustain: 0.3
      }),
      oscillator: Object.assign(C_(vc.getDefaults(), [...Object.keys(Ii.getDefaults()), "frequency", "detune"]), {
        type: "triangle"
      })
    });
  }
  /**
   * start the attack portion of the envelope
   * @param time the time the attack should start
   * @param velocity the velocity of the note (0-1)
   */
  _triggerEnvelopeAttack(t, n) {
    if (this.envelope.triggerAttack(t, n), this.oscillator.start(t), this.envelope.sustain === 0) {
      const i = this.toSeconds(this.envelope.attack), r = this.toSeconds(this.envelope.decay);
      this.oscillator.stop(t + i + r);
    }
  }
  /**
   * start the release portion of the envelope
   * @param time the time the release should start
   */
  _triggerEnvelopeRelease(t) {
    this.envelope.triggerRelease(t), this.oscillator.stop(t + this.toSeconds(this.envelope.release));
  }
  getLevelAtTime(t) {
    return t = this.toSeconds(t), this.envelope.getValueAtTime(t);
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this.oscillator.dispose(), this.envelope.dispose(), this;
  }
}
class pc extends gc {
  constructor() {
    super(Te(pc.getDefaults(), arguments)), this.name = "MembraneSynth", this.portamento = 0;
    const t = Te(pc.getDefaults(), arguments);
    this.pitchDecay = t.pitchDecay, this.octaves = t.octaves, Jt(this, ["oscillator", "envelope"]);
  }
  static getDefaults() {
    return dl(lo.getDefaults(), gc.getDefaults(), {
      envelope: {
        attack: 1e-3,
        attackCurve: "exponential",
        decay: 0.4,
        release: 1.4,
        sustain: 0.01
      },
      octaves: 10,
      oscillator: {
        type: "sine"
      },
      pitchDecay: 0.05
    });
  }
  setNote(t, n) {
    const i = this.toSeconds(n), r = this.toFrequency(t instanceof Gi ? t.toFrequency() : t), s = r * this.octaves;
    return this.oscillator.frequency.setValueAtTime(s, i), this.oscillator.frequency.exponentialRampToValueAtTime(r, i + this.toSeconds(this.pitchDecay)), this;
  }
  dispose() {
    return super.dispose(), this;
  }
}
Pr([
  Ix(0)
], pc.prototype, "octaves", void 0);
Pr([
  Es(0)
], pc.prototype, "pitchDecay", void 0);
const Ex = /* @__PURE__ */ new Set();
function Zy(e) {
  Ex.add(e);
}
function Ox(e, t) {
  const n = (
    /* javascript */
    `registerProcessor("${e}", ${t})`
  );
  Ex.add(n);
}
const uq = (
  /* javascript */
  `
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the {@link ToneAudioWorklet}. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`
);
Zy(uq);
const cq = (
  /* javascript */
  `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`
);
Zy(cq);
const dq = (
  /* javascript */
  `
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`
);
Zy(dq);
const fq = "feedback-comb-filter", hq = (
  /* javascript */
  `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`
);
Ox(fq, hq);
class yc extends oo {
  constructor() {
    super(Te(yc.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "Sampler", this._activeSources = /* @__PURE__ */ new Map();
    const t = Te(yc.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls"), n = {};
    Object.keys(t.urls).forEach((i) => {
      const r = parseInt(i, 10);
      if (Xe(Ed(i) || io(r) && isFinite(r), `url key is neither a note or midi pitch: ${i}`), Ed(i)) {
        const s = new Gi(this.context, i).toMidi();
        n[s] = t.urls[i];
      } else
        io(r) && isFinite(r) && (n[r] = t.urls[r]);
    }), this._buffers = new qy({
      urls: n,
      onload: t.onload,
      baseUrl: t.baseUrl,
      onerror: t.onerror
    }), this.attack = t.attack, this.release = t.release, this.curve = t.curve, this._buffers.loaded && Promise.resolve().then(t.onload);
  }
  static getDefaults() {
    return Object.assign(oo.getDefaults(), {
      attack: 0,
      baseUrl: "",
      curve: "exponential",
      onload: wt,
      onerror: wt,
      release: 0.1,
      urls: {}
    });
  }
  /**
   * Returns the difference in steps between the given midi note at the closets sample.
   */
  _findClosest(t) {
    let i = 0;
    for (; i < 96; ) {
      if (this._buffers.has(t + i))
        return -i;
      if (this._buffers.has(t - i))
        return i;
      i++;
    }
    throw new Error(`No available buffers for note: ${t}`);
  }
  /**
   * @param  notes	The note to play, or an array of notes.
   * @param  time     When to play the note
   * @param  velocity The velocity to play the sample back.
   */
  triggerAttack(t, n, i = 1) {
    return this.log("triggerAttack", t, n, i), Array.isArray(t) || (t = [t]), t.forEach((r) => {
      const s = Ax(new Gi(this.context, r).toFrequency()), a = Math.round(s), o = s - a, l = this._findClosest(a), u = a - l, c = this._buffers.get(u), d = xx(l + o), f = new cc({
        url: c,
        context: this.context,
        curve: this.curve,
        fadeIn: this.attack,
        fadeOut: this.release,
        playbackRate: d
      }).connect(this.output);
      f.start(n, 0, c.duration / d, i), br(this._activeSources.get(a)) || this._activeSources.set(a, []), this._activeSources.get(a).push(f), f.onended = () => {
        if (this._activeSources && this._activeSources.has(a)) {
          const h = this._activeSources.get(a), m = h.indexOf(f);
          m !== -1 && h.splice(m, 1);
        }
      };
    }), this;
  }
  /**
   * @param  notes	The note to release, or an array of notes.
   * @param  time     	When to release the note.
   */
  triggerRelease(t, n) {
    return this.log("triggerRelease", t, n), Array.isArray(t) || (t = [t]), t.forEach((i) => {
      const r = new Gi(this.context, i).toMidi();
      if (this._activeSources.has(r) && this._activeSources.get(r).length) {
        const s = this._activeSources.get(r);
        n = this.toSeconds(n), s.forEach((a) => {
          a.stop(n);
        }), this._activeSources.set(r, []);
      }
    }), this;
  }
  /**
   * Release all currently active notes.
   * @param  time     	When to release the notes.
   */
  releaseAll(t) {
    const n = this.toSeconds(t);
    return this._activeSources.forEach((i) => {
      for (; i.length; )
        i.shift().stop(n);
    }), this;
  }
  sync() {
    return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this;
  }
  /**
   * Invoke the attack phase, then after the duration, invoke the release.
   * @param  notes	The note to play and release, or an array of notes.
   * @param  duration The time the note should be held
   * @param  time     When to start the attack
   * @param  velocity The velocity of the attack
   */
  triggerAttackRelease(t, n, i, r = 1) {
    const s = this.toSeconds(i);
    return this.triggerAttack(t, s, r), br(n) ? (Xe(br(t), "notes must be an array when duration is array"), t.forEach((a, o) => {
      const l = n[Math.min(o, n.length - 1)];
      this.triggerRelease(a, s + this.toSeconds(l));
    })) : this.triggerRelease(t, s + this.toSeconds(n)), this;
  }
  /**
   * Add a note to the sampler.
   * @param  note      The buffer's pitch.
   * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.
   * @param  callback  The callback to invoke when the url is loaded.
   */
  add(t, n, i) {
    if (Xe(Ed(t) || isFinite(t), `note must be a pitch or midi: ${t}`), Ed(t)) {
      const r = new Gi(this.context, t).toMidi();
      this._buffers.add(r, n, i);
    } else
      this._buffers.add(t, n, i);
    return this;
  }
  /**
   * If the buffers are loaded or not
   */
  get loaded() {
    return this._buffers.loaded;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._buffers.dispose(), this._activeSources.forEach((t) => {
      t.forEach((n) => n.dispose());
    }), this._activeSources.clear(), this;
  }
}
Pr([
  Es(0)
], yc.prototype, "attack", void 0);
Pr([
  Es(0)
], yc.prototype, "release", void 0);
class eh extends et {
  constructor() {
    super(Object.assign(Te(eh.getDefaults(), arguments, ["pan"]))), this.name = "Panner", this._panner = this.context.createStereoPanner(), this.input = this._panner, this.output = this._panner;
    const t = Te(eh.getDefaults(), arguments, ["pan"]);
    this.pan = new Lt({
      context: this.context,
      param: this._panner.pan,
      value: t.pan,
      minValue: -1,
      maxValue: 1
    }), this._panner.channelCount = t.channelCount, this._panner.channelCountMode = "explicit", Jt(this, "pan");
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      pan: 0,
      channelCount: 1
    });
  }
  dispose() {
    return super.dispose(), this._panner.disconnect(), this.pan.dispose(), this;
  }
}
const mq = "bit-crusher", vq = (
  /* javascript */
  `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`
);
Ox(mq, vq);
class en extends et {
  constructor() {
    super(Te(en.getDefaults(), arguments, ["solo"])), this.name = "Solo";
    const t = Te(en.getDefaults(), arguments, ["solo"]);
    this.input = this.output = new Bn({
      context: this.context
    }), en._allSolos.has(this.context) || en._allSolos.set(this.context, /* @__PURE__ */ new Set()), en._allSolos.get(this.context).add(this), this.solo = t.solo;
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      solo: !1
    });
  }
  /**
   * Isolates this instance and mutes all other instances of Solo.
   * Only one instance can be soloed at a time. A soloed
   * instance will report `solo=false` when another instance is soloed.
   */
  get solo() {
    return this._isSoloed();
  }
  set solo(t) {
    t ? this._addSolo() : this._removeSolo(), en._allSolos.get(this.context).forEach((n) => n._updateSolo());
  }
  /**
   * If the current instance is muted, i.e. another instance is soloed
   */
  get muted() {
    return this.input.gain.value === 0;
  }
  /**
   * Add this to the soloed array
   */
  _addSolo() {
    en._soloed.has(this.context) || en._soloed.set(this.context, /* @__PURE__ */ new Set()), en._soloed.get(this.context).add(this);
  }
  /**
   * Remove this from the soloed array
   */
  _removeSolo() {
    en._soloed.has(this.context) && en._soloed.get(this.context).delete(this);
  }
  /**
   * Is this on the soloed array
   */
  _isSoloed() {
    return en._soloed.has(this.context) && en._soloed.get(this.context).has(this);
  }
  /**
   * Returns true if no one is soloed
   */
  _noSolos() {
    return !en._soloed.has(this.context) || // or has a solo set but doesn't include any items
    en._soloed.has(this.context) && en._soloed.get(this.context).size === 0;
  }
  /**
   * Solo the current instance and unsolo all other instances.
   */
  _updateSolo() {
    this._isSoloed() ? this.input.gain.value = 1 : this._noSolos() ? this.input.gain.value = 1 : this.input.gain.value = 0;
  }
  dispose() {
    return super.dispose(), en._allSolos.get(this.context).delete(this), this._removeSolo(), this;
  }
}
en._allSolos = /* @__PURE__ */ new Map();
en._soloed = /* @__PURE__ */ new Map();
class th extends et {
  constructor() {
    super(Te(th.getDefaults(), arguments, ["pan", "volume"])), this.name = "PanVol";
    const t = Te(th.getDefaults(), arguments, ["pan", "volume"]);
    this._panner = this.input = new eh({
      context: this.context,
      pan: t.pan,
      channelCount: t.channelCount
    }), this.pan = this._panner.pan, this._volume = this.output = new so({
      context: this.context,
      volume: t.volume
    }), this.volume = this._volume.volume, this._panner.connect(this._volume), this.mute = t.mute, Jt(this, ["pan", "volume"]);
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      mute: !1,
      pan: 0,
      volume: 0,
      channelCount: 1
    });
  }
  /**
   * Mute/unmute the volume
   */
  get mute() {
    return this._volume.mute;
  }
  set mute(t) {
    this._volume.mute = t;
  }
  dispose() {
    return super.dispose(), this._panner.dispose(), this.pan.dispose(), this._volume.dispose(), this.volume.dispose(), this;
  }
}
class Va extends et {
  constructor() {
    super(Te(Va.getDefaults(), arguments, ["volume", "pan"])), this.name = "Channel";
    const t = Te(Va.getDefaults(), arguments, ["volume", "pan"]);
    this._solo = this.input = new en({
      solo: t.solo,
      context: this.context
    }), this._panVol = this.output = new th({
      context: this.context,
      pan: t.pan,
      volume: t.volume,
      mute: t.mute,
      channelCount: t.channelCount
    }), this.pan = this._panVol.pan, this.volume = this._panVol.volume, this._solo.connect(this._panVol), Jt(this, ["pan", "volume"]);
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      pan: 0,
      volume: 0,
      mute: !1,
      solo: !1,
      channelCount: 1
    });
  }
  /**
   * Solo/unsolo the channel. Soloing is only relative to other {@link Channel}s and {@link Solo} instances
   */
  get solo() {
    return this._solo.solo;
  }
  set solo(t) {
    this._solo.solo = t;
  }
  /**
   * If the current instance is muted, i.e. another instance is soloed,
   * or the channel is muted
   */
  get muted() {
    return this._solo.muted || this.mute;
  }
  /**
   * Mute/unmute the volume
   */
  get mute() {
    return this._panVol.mute;
  }
  set mute(t) {
    this._panVol.mute = t;
  }
  /**
   * Get the gain node belonging to the bus name. Create it if
   * it doesn't exist
   * @param name The bus name
   */
  _getBus(t) {
    return Va.buses.has(t) || Va.buses.set(t, new Bn({ context: this.context })), Va.buses.get(t);
  }
  /**
   * Send audio to another channel using a string. `send` is a lot like
   * {@link connect}, except it uses a string instead of an object. This can
   * be useful in large applications to decouple sections since {@link send}
   * and {@link receive} can be invoked separately in order to connect an object
   * @param name The channel name to send the audio
   * @param volume The amount of the signal to send.
   * 	Defaults to 0db, i.e. send the entire signal
   * @returns Returns the gain node of this connection.
   */
  send(t, n = 0) {
    const i = this._getBus(t), r = new Bn({
      context: this.context,
      units: "decibels",
      gain: n
    });
    return this.connect(r), r.connect(i), r;
  }
  /**
   * Receive audio from a channel which was connected with {@link send}.
   * @param name The channel name to receive audio from.
   */
  receive(t) {
    return this._getBus(t).connect(this), this;
  }
  dispose() {
    return super.dispose(), this._panVol.dispose(), this.pan.dispose(), this.volume.dispose(), this._solo.dispose(), this;
  }
}
Va.buses = /* @__PURE__ */ new Map();
class gq extends et {
  constructor() {
    super(...arguments), this.name = "Listener", this.positionX = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.positionX
    }), this.positionY = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.positionY
    }), this.positionZ = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.positionZ
    }), this.forwardX = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.forwardX
    }), this.forwardY = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.forwardY
    }), this.forwardZ = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.forwardZ
    }), this.upX = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.upX
    }), this.upY = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.upY
    }), this.upZ = new Lt({
      context: this.context,
      param: this.context.rawContext.listener.upZ
    });
  }
  static getDefaults() {
    return Object.assign(et.getDefaults(), {
      positionX: 0,
      positionY: 0,
      positionZ: 0,
      forwardX: 0,
      forwardY: 0,
      forwardZ: -1,
      upX: 0,
      upY: 1,
      upZ: 0
    });
  }
  dispose() {
    return super.dispose(), this.positionX.dispose(), this.positionY.dispose(), this.positionZ.dispose(), this.forwardX.dispose(), this.forwardY.dispose(), this.forwardZ.dispose(), this.upX.dispose(), this.upY.dispose(), this.upZ.dispose(), this;
  }
}
nm((e) => {
  e.listener = new gq({ context: e });
});
im((e) => {
  e.listener.dispose();
});
mr().transport;
mr().destination;
mr().destination;
mr().listener;
mr().draw;
mr();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ji = function() {
  return ji = Object.assign || function(t) {
    for (var n, i = 1, r = arguments.length; i < r; i++) {
      n = arguments[i];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]);
    }
    return t;
  }, ji.apply(this, arguments);
}, pq = (
  /** @class */
  function() {
    function e(t) {
      this.options = t, this.listeners = {};
    }
    return e.prototype.on = function(t, n) {
      var i = this.listeners[t] || [];
      this.listeners[t] = i.concat([n]);
    }, e.prototype.triggerEvent = function(t, n) {
      var i = this, r = this.listeners[t] || [];
      r.forEach(function(s) {
        return s({ target: i, event: n });
      });
    }, e;
  }()
), Pl;
(function(e) {
  e[e.Add = 0] = "Add", e[e.Remove = 1] = "Remove";
})(Pl || (Pl = {}));
var yq = (
  /** @class */
  function() {
    function e() {
      this.notifications = [];
    }
    return e.prototype.push = function(t) {
      this.notifications.push(t), this.updateFn(t, Pl.Add, this.notifications);
    }, e.prototype.splice = function(t, n) {
      var i = this.notifications.splice(t, n)[0];
      return this.updateFn(i, Pl.Remove, this.notifications), i;
    }, e.prototype.indexOf = function(t) {
      return this.notifications.indexOf(t);
    }, e.prototype.onUpdate = function(t) {
      this.updateFn = t;
    }, e;
  }()
), Js;
(function(e) {
  e.Dismiss = "dismiss", e.Click = "click";
})(Js || (Js = {}));
var x_ = {
  types: [
    {
      type: "success",
      className: "notyf__toast--success",
      backgroundColor: "#3dc763",
      icon: {
        className: "notyf__icon--success",
        tagName: "i"
      }
    },
    {
      type: "error",
      className: "notyf__toast--error",
      backgroundColor: "#ed3d3d",
      icon: {
        className: "notyf__icon--error",
        tagName: "i"
      }
    }
  ],
  duration: 2e3,
  ripple: !0,
  position: {
    x: "right",
    y: "bottom"
  },
  dismissible: !1
}, bq = (
  /** @class */
  function() {
    function e() {
      this.notifications = [], this.events = {}, this.X_POSITION_FLEX_MAP = {
        left: "flex-start",
        center: "center",
        right: "flex-end"
      }, this.Y_POSITION_FLEX_MAP = {
        top: "flex-start",
        center: "center",
        bottom: "flex-end"
      };
      var t = document.createDocumentFragment(), n = this._createHTMLElement({ tagName: "div", className: "notyf" });
      t.appendChild(n), document.body.appendChild(t), this.container = n, this.animationEndEventName = this._getAnimationEndEventName(), this._createA11yContainer();
    }
    return e.prototype.on = function(t, n) {
      var i;
      this.events = ji(ji({}, this.events), (i = {}, i[t] = n, i));
    }, e.prototype.update = function(t, n) {
      n === Pl.Add ? this.addNotification(t) : n === Pl.Remove && this.removeNotification(t);
    }, e.prototype.removeNotification = function(t) {
      var n = this, i = this._popRenderedNotification(t), r;
      if (i) {
        r = i.node, r.classList.add("notyf__toast--disappear");
        var s;
        r.addEventListener(this.animationEndEventName, s = function(a) {
          a.target === r && (r.removeEventListener(n.animationEndEventName, s), n.container.removeChild(r));
        });
      }
    }, e.prototype.addNotification = function(t) {
      var n = this._renderNotification(t);
      this.notifications.push({ notification: t, node: n }), this._announce(t.options.message || "Notification");
    }, e.prototype._renderNotification = function(t) {
      var n, i = this._buildNotificationCard(t), r = t.options.className;
      return r && (n = i.classList).add.apply(n, r.split(" ")), this.container.appendChild(i), i;
    }, e.prototype._popRenderedNotification = function(t) {
      for (var n = -1, i = 0; i < this.notifications.length && n < 0; i++)
        this.notifications[i].notification === t && (n = i);
      if (n !== -1)
        return this.notifications.splice(n, 1)[0];
    }, e.prototype.getXPosition = function(t) {
      var n;
      return ((n = t == null ? void 0 : t.position) === null || n === void 0 ? void 0 : n.x) || "right";
    }, e.prototype.getYPosition = function(t) {
      var n;
      return ((n = t == null ? void 0 : t.position) === null || n === void 0 ? void 0 : n.y) || "bottom";
    }, e.prototype.adjustContainerAlignment = function(t) {
      var n = this.X_POSITION_FLEX_MAP[this.getXPosition(t)], i = this.Y_POSITION_FLEX_MAP[this.getYPosition(t)], r = this.container.style;
      r.setProperty("justify-content", i), r.setProperty("align-items", n);
    }, e.prototype._buildNotificationCard = function(t) {
      var n = this, i = t.options, r = i.icon;
      this.adjustContainerAlignment(i);
      var s = this._createHTMLElement({ tagName: "div", className: "notyf__toast" }), a = this._createHTMLElement({ tagName: "div", className: "notyf__ripple" }), o = this._createHTMLElement({ tagName: "div", className: "notyf__wrapper" }), l = this._createHTMLElement({ tagName: "div", className: "notyf__message" });
      l.innerHTML = i.message || "";
      var u = i.background || i.backgroundColor;
      if (r) {
        var c = this._createHTMLElement({ tagName: "div", className: "notyf__icon" });
        if ((typeof r == "string" || r instanceof String) && (c.innerHTML = new String(r).valueOf()), typeof r == "object") {
          var d = r.tagName, f = d === void 0 ? "i" : d, h = r.className, m = r.text, g = r.color, p = g === void 0 ? u : g, y = this._createHTMLElement({ tagName: f, className: h, text: m });
          p && (y.style.color = p), c.appendChild(y);
        }
        o.appendChild(c);
      }
      if (o.appendChild(l), s.appendChild(o), u && (i.ripple ? (a.style.background = u, s.appendChild(a)) : s.style.background = u), i.dismissible) {
        var k = this._createHTMLElement({ tagName: "div", className: "notyf__dismiss" }), T = this._createHTMLElement({
          tagName: "button",
          className: "notyf__dismiss-btn"
        });
        k.appendChild(T), o.appendChild(k), s.classList.add("notyf__toast--dismissible"), T.addEventListener("click", function(b) {
          var S, C;
          (C = (S = n.events)[Js.Dismiss]) === null || C === void 0 || C.call(S, { target: t, event: b }), b.stopPropagation();
        });
      }
      s.addEventListener("click", function(b) {
        var S, C;
        return (C = (S = n.events)[Js.Click]) === null || C === void 0 ? void 0 : C.call(S, { target: t, event: b });
      });
      var _ = this.getYPosition(i) === "top" ? "upper" : "lower";
      return s.classList.add("notyf__toast--" + _), s;
    }, e.prototype._createHTMLElement = function(t) {
      var n = t.tagName, i = t.className, r = t.text, s = document.createElement(n);
      return i && (s.className = i), s.textContent = r || null, s;
    }, e.prototype._createA11yContainer = function() {
      var t = this._createHTMLElement({ tagName: "div", className: "notyf-announcer" });
      t.setAttribute("aria-atomic", "true"), t.setAttribute("aria-live", "polite"), t.style.border = "0", t.style.clip = "rect(0 0 0 0)", t.style.height = "1px", t.style.margin = "-1px", t.style.overflow = "hidden", t.style.padding = "0", t.style.position = "absolute", t.style.width = "1px", t.style.outline = "0", document.body.appendChild(t), this.a11yContainer = t;
    }, e.prototype._announce = function(t) {
      var n = this;
      this.a11yContainer.textContent = "", setTimeout(function() {
        n.a11yContainer.textContent = t;
      }, 100);
    }, e.prototype._getAnimationEndEventName = function() {
      var t = document.createElement("_fake"), n = {
        MozTransition: "animationend",
        OTransition: "oAnimationEnd",
        WebkitTransition: "webkitAnimationEnd",
        transition: "animationend"
      }, i;
      for (i in n)
        if (t.style[i] !== void 0)
          return n[i];
      return "animationend";
    }, e;
  }()
), wq = (
  /** @class */
  function() {
    function e(t) {
      var n = this;
      this.dismiss = this._removeNotification, this.notifications = new yq(), this.view = new bq();
      var i = this.registerTypes(t);
      this.options = ji(ji({}, x_), t), this.options.types = i, this.notifications.onUpdate(function(r, s) {
        return n.view.update(r, s);
      }), this.view.on(Js.Dismiss, function(r) {
        var s = r.target, a = r.event;
        n._removeNotification(s), s.triggerEvent(Js.Dismiss, a);
      }), this.view.on(Js.Click, function(r) {
        var s = r.target, a = r.event;
        return s.triggerEvent(Js.Click, a);
      });
    }
    return e.prototype.error = function(t) {
      var n = this.normalizeOptions("error", t);
      return this.open(n);
    }, e.prototype.success = function(t) {
      var n = this.normalizeOptions("success", t);
      return this.open(n);
    }, e.prototype.open = function(t) {
      var n = this.options.types.find(function(s) {
        var a = s.type;
        return a === t.type;
      }) || {}, i = ji(ji({}, n), t);
      this.assignProps(["ripple", "position", "dismissible"], i);
      var r = new pq(i);
      return this._pushNotification(r), r;
    }, e.prototype.dismissAll = function() {
      for (; this.notifications.splice(0, 1); )
        ;
    }, e.prototype.assignProps = function(t, n) {
      var i = this;
      t.forEach(function(r) {
        n[r] = n[r] == null ? i.options[r] : n[r];
      });
    }, e.prototype._pushNotification = function(t) {
      var n = this;
      this.notifications.push(t);
      var i = t.options.duration !== void 0 ? t.options.duration : this.options.duration;
      i && setTimeout(function() {
        return n._removeNotification(t);
      }, i);
    }, e.prototype._removeNotification = function(t) {
      var n = this.notifications.indexOf(t);
      n !== -1 && this.notifications.splice(n, 1);
    }, e.prototype.normalizeOptions = function(t, n) {
      var i = { type: t };
      return typeof n == "string" ? i.message = n : typeof n == "object" && (i = ji(ji({}, i), n)), i;
    }, e.prototype.registerTypes = function(t) {
      var n = (t && t.types || []).slice(), i = x_.types.map(function(r) {
        var s = -1;
        n.forEach(function(o, l) {
          o.type === r.type && (s = l);
        });
        var a = s !== -1 ? n.splice(s, 1)[0] : {};
        return ji(ji({}, r), a);
      });
      return i.concat(n);
    }, e;
  }()
), _q = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, cu = (e, t, n) => (_q(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Sq = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, xa;
const Px = {
  backdrop: !0,
  color: "#000000",
  customClass: {
    title: "text-h6",
    htmlContainer: "text-body-2",
    popup: "v-card v-card--density-default v-card--variant-elevated bg-surface elevation-3 pb-3",
    confirmButton: "v-btn v-btn--elevated bg-primary v-btn--density-default v-btn--size-default v-btn--variant-elevated",
    denyButton: "v-btn v-btn--elevated bg-error v-btn--density-default v-btn--size-default v-btn--variant-elevated",
    cancelButton: "v-btn v-btn--elevated bg-cancel v-btn--density-default v-btn--size-default v-btn--variant-elevated"
  },
  buttonsStyling: !0,
  reverseButtons: !0
}, A_ = to.mixin(Px), Vx = Vh({}, Px, {
  toast: !0,
  position: "top-end",
  showConfirmButton: !1,
  timer: 3e3,
  timerProgressBar: !0,
  backdrop: void 0,
  didOpen: (e) => {
    e.onmouseenter = to.stopTimer, e.onmouseleave = to.resumeTimer;
  }
});
delete Vx.backdrop;
const I_ = to.mixin(Vx), Pd = xs("Sounds");
class kq {
  /**
   * Creates a new SoundsService
   * @param sounds A map of sound names to their urls
   */
  constructor(t) {
    Sq(this, xa, {}), t && (Pd("Initializing sounds", t), this.add(t));
  }
  /**
   * Adds sounds to the service
   * @param sounds A map of sound names to their urls
   */
  add(t) {
    Object.keys(t).forEach((n) => {
      if (!cu(this, xa)[n]) {
        Pd("Adding sound", n);
        const i = t[n];
        cu(this, xa)[n] = new Ol({
          url: i
        }).toDestination();
      }
    });
  }
  /**
   * Gets a sound from the service
   * @param key The key of the sound to retrieve
   * @returns The Tone.Player object for the sound
   */
  get(t) {
    return cu(this, xa)[t];
  }
  /**
   * Plays a sound
   * @param key The key of the sound to play
   */
  play(t) {
    const n = cu(this, xa)[t];
    n && (Pd("Playing sound", t), n.start());
  }
  /**
   * Stops a sound
   * @param key The key of the sound to stop
   */
  stop(t) {
    const n = cu(this, xa)[t];
    n && (Pd("Stopping sound", t), n.stop());
  }
}
xa = /* @__PURE__ */ new WeakMap();
const E_ = new wq({
  dismissible: !0
}), Cq = {
  install: (e, t) => {
    e.provide("swal", A_), e.config.globalProperties.$swal = A_, e.provide("toast", I_), e.config.globalProperties.$toast = I_, e.provide("notyf", E_), e.config.globalProperties.$notyf = E_;
    const n = new kq((t == null ? void 0 : t.sounds) || {});
    e.provide("sounds", n), e.config.globalProperties.$sounds = n;
  }
};
var Tq = { exports: {} };
(function(e) {
  (function() {
    function t(P, M, U) {
      return P.call.apply(P.bind, arguments);
    }
    function n(P, M, U) {
      if (!P)
        throw Error();
      if (2 < arguments.length) {
        var Y = Array.prototype.slice.call(arguments, 2);
        return function() {
          var ce = Array.prototype.slice.call(arguments);
          return Array.prototype.unshift.apply(ce, Y), P.apply(M, ce);
        };
      }
      return function() {
        return P.apply(M, arguments);
      };
    }
    function i(P, M, U) {
      return i = Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? t : n, i.apply(null, arguments);
    }
    var r = Date.now || function() {
      return +/* @__PURE__ */ new Date();
    };
    function s(P, M) {
      this.a = P, this.o = M || P, this.c = this.o.document;
    }
    var a = !!window.FontFace;
    function o(P, M, U, Y) {
      if (M = P.c.createElement(M), U)
        for (var ce in U)
          U.hasOwnProperty(ce) && (ce == "style" ? M.style.cssText = U[ce] : M.setAttribute(ce, U[ce]));
      return Y && M.appendChild(P.c.createTextNode(Y)), M;
    }
    function l(P, M, U) {
      P = P.c.getElementsByTagName(M)[0], P || (P = document.documentElement), P.insertBefore(U, P.lastChild);
    }
    function u(P) {
      P.parentNode && P.parentNode.removeChild(P);
    }
    function c(P, M, U) {
      M = M || [], U = U || [];
      for (var Y = P.className.split(/\s+/), ce = 0; ce < M.length; ce += 1) {
        for (var Se = !1, Ie = 0; Ie < Y.length; Ie += 1)
          if (M[ce] === Y[Ie]) {
            Se = !0;
            break;
          }
        Se || Y.push(M[ce]);
      }
      for (M = [], ce = 0; ce < Y.length; ce += 1) {
        for (Se = !1, Ie = 0; Ie < U.length; Ie += 1)
          if (Y[ce] === U[Ie]) {
            Se = !0;
            break;
          }
        Se || M.push(Y[ce]);
      }
      P.className = M.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "");
    }
    function d(P, M) {
      for (var U = P.className.split(/\s+/), Y = 0, ce = U.length; Y < ce; Y++)
        if (U[Y] == M)
          return !0;
      return !1;
    }
    function f(P) {
      return P.o.location.hostname || P.a.location.hostname;
    }
    function h(P, M, U) {
      function Y() {
        Ne && ce && Se && (Ne(Ie), Ne = null);
      }
      M = o(P, "link", { rel: "stylesheet", href: M, media: "all" });
      var ce = !1, Se = !0, Ie = null, Ne = U || null;
      a ? (M.onload = function() {
        ce = !0, Y();
      }, M.onerror = function() {
        ce = !0, Ie = Error("Stylesheet failed to load"), Y();
      }) : setTimeout(function() {
        ce = !0, Y();
      }, 0), l(P, "head", M);
    }
    function m(P, M, U, Y) {
      var ce = P.c.getElementsByTagName("head")[0];
      if (ce) {
        var Se = o(P, "script", { src: M }), Ie = !1;
        return Se.onload = Se.onreadystatechange = function() {
          Ie || this.readyState && this.readyState != "loaded" && this.readyState != "complete" || (Ie = !0, U && U(null), Se.onload = Se.onreadystatechange = null, Se.parentNode.tagName == "HEAD" && ce.removeChild(Se));
        }, ce.appendChild(Se), setTimeout(function() {
          Ie || (Ie = !0, U && U(Error("Script load timeout")));
        }, Y || 5e3), Se;
      }
      return null;
    }
    function g() {
      this.a = 0, this.c = null;
    }
    function p(P) {
      return P.a++, function() {
        P.a--, k(P);
      };
    }
    function y(P, M) {
      P.c = M, k(P);
    }
    function k(P) {
      P.a == 0 && P.c && (P.c(), P.c = null);
    }
    function T(P) {
      this.a = P || "-";
    }
    T.prototype.c = function(P) {
      for (var M = [], U = 0; U < arguments.length; U++)
        M.push(arguments[U].replace(/[\W_]+/g, "").toLowerCase());
      return M.join(this.a);
    };
    function _(P, M) {
      this.c = P, this.f = 4, this.a = "n";
      var U = (M || "n4").match(/^([nio])([1-9])$/i);
      U && (this.a = U[1], this.f = parseInt(U[2], 10));
    }
    function b(P) {
      return x(P) + " " + (P.f + "00") + " 300px " + S(P.c);
    }
    function S(P) {
      var M = [];
      P = P.split(/,\s*/);
      for (var U = 0; U < P.length; U++) {
        var Y = P[U].replace(/['"]/g, "");
        Y.indexOf(" ") != -1 || /^\d/.test(Y) ? M.push("'" + Y + "'") : M.push(Y);
      }
      return M.join(",");
    }
    function C(P) {
      return P.a + P.f;
    }
    function x(P) {
      var M = "normal";
      return P.a === "o" ? M = "oblique" : P.a === "i" && (M = "italic"), M;
    }
    function A(P) {
      var M = 4, U = "n", Y = null;
      return P && ((Y = P.match(/(normal|oblique|italic)/i)) && Y[1] && (U = Y[1].substr(0, 1).toLowerCase()), (Y = P.match(/([1-9]00|normal|bold)/i)) && Y[1] && (/bold/i.test(Y[1]) ? M = 7 : /[1-9]00/.test(Y[1]) && (M = parseInt(Y[1].substr(0, 1), 10)))), U + M;
    }
    function I(P, M) {
      this.c = P, this.f = P.o.document.documentElement, this.h = M, this.a = new T("-"), this.j = M.events !== !1, this.g = M.classes !== !1;
    }
    function E(P) {
      P.g && c(P.f, [P.a.c("wf", "loading")]), V(P, "loading");
    }
    function O(P) {
      if (P.g) {
        var M = d(P.f, P.a.c("wf", "active")), U = [], Y = [P.a.c("wf", "loading")];
        M || U.push(P.a.c("wf", "inactive")), c(P.f, U, Y);
      }
      V(P, "inactive");
    }
    function V(P, M, U) {
      P.j && P.h[M] && (U ? P.h[M](U.c, C(U)) : P.h[M]());
    }
    function N() {
      this.c = {};
    }
    function F(P, M, U) {
      var Y = [], ce;
      for (ce in M)
        if (M.hasOwnProperty(ce)) {
          var Se = P.c[ce];
          Se && Y.push(Se(M[ce], U));
        }
      return Y;
    }
    function $(P, M) {
      this.c = P, this.f = M, this.a = o(this.c, "span", { "aria-hidden": "true" }, this.f);
    }
    function Z(P) {
      l(P.c, "body", P.a);
    }
    function j(P) {
      return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + S(P.c) + ";" + ("font-style:" + x(P) + ";font-weight:" + (P.f + "00") + ";");
    }
    function H(P, M, U, Y, ce, Se) {
      this.g = P, this.j = M, this.a = Y, this.c = U, this.f = ce || 3e3, this.h = Se || void 0;
    }
    H.prototype.start = function() {
      var P = this.c.o.document, M = this, U = r(), Y = new Promise(function(Ie, Ne) {
        function Le() {
          r() - U >= M.f ? Ne() : P.fonts.load(b(M.a), M.h).then(function(Ge) {
            1 <= Ge.length ? Ie() : setTimeout(Le, 25);
          }, function() {
            Ne();
          });
        }
        Le();
      }), ce = null, Se = new Promise(function(Ie, Ne) {
        ce = setTimeout(Ne, M.f);
      });
      Promise.race([Se, Y]).then(function() {
        ce && (clearTimeout(ce), ce = null), M.g(M.a);
      }, function() {
        M.j(M.a);
      });
    };
    function R(P, M, U, Y, ce, Se, Ie) {
      this.v = P, this.B = M, this.c = U, this.a = Y, this.s = Ie || "BESbswy", this.f = {}, this.w = ce || 3e3, this.u = Se || null, this.m = this.j = this.h = this.g = null, this.g = new $(this.c, this.s), this.h = new $(this.c, this.s), this.j = new $(this.c, this.s), this.m = new $(this.c, this.s), P = new _(this.a.c + ",serif", C(this.a)), P = j(P), this.g.a.style.cssText = P, P = new _(this.a.c + ",sans-serif", C(this.a)), P = j(P), this.h.a.style.cssText = P, P = new _("serif", C(this.a)), P = j(P), this.j.a.style.cssText = P, P = new _("sans-serif", C(this.a)), P = j(P), this.m.a.style.cssText = P, Z(this.g), Z(this.h), Z(this.j), Z(this.m);
    }
    var L = { D: "serif", C: "sans-serif" }, ne = null;
    function oe() {
      if (ne === null) {
        var P = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
        ne = !!P && (536 > parseInt(P[1], 10) || parseInt(P[1], 10) === 536 && 11 >= parseInt(P[2], 10));
      }
      return ne;
    }
    R.prototype.start = function() {
      this.f.serif = this.j.a.offsetWidth, this.f["sans-serif"] = this.m.a.offsetWidth, this.A = r(), ee(this);
    };
    function we(P, M, U) {
      for (var Y in L)
        if (L.hasOwnProperty(Y) && M === P.f[L[Y]] && U === P.f[L[Y]])
          return !0;
      return !1;
    }
    function ee(P) {
      var M = P.g.a.offsetWidth, U = P.h.a.offsetWidth, Y;
      (Y = M === P.f.serif && U === P.f["sans-serif"]) || (Y = oe() && we(P, M, U)), Y ? r() - P.A >= P.w ? oe() && we(P, M, U) && (P.u === null || P.u.hasOwnProperty(P.a.c)) ? ue(P, P.v) : ue(P, P.B) : K(P) : ue(P, P.v);
    }
    function K(P) {
      setTimeout(i(function() {
        ee(this);
      }, P), 50);
    }
    function ue(P, M) {
      setTimeout(i(function() {
        u(this.g.a), u(this.h.a), u(this.j.a), u(this.m.a), M(this.a);
      }, P), 0);
    }
    function ve(P, M, U) {
      this.c = P, this.a = M, this.f = 0, this.m = this.j = !1, this.s = U;
    }
    var Re = null;
    ve.prototype.g = function(P) {
      var M = this.a;
      M.g && c(M.f, [M.a.c("wf", P.c, C(P).toString(), "active")], [M.a.c("wf", P.c, C(P).toString(), "loading"), M.a.c("wf", P.c, C(P).toString(), "inactive")]), V(M, "fontactive", P), this.m = !0, he(this);
    }, ve.prototype.h = function(P) {
      var M = this.a;
      if (M.g) {
        var U = d(M.f, M.a.c("wf", P.c, C(P).toString(), "active")), Y = [], ce = [M.a.c("wf", P.c, C(P).toString(), "loading")];
        U || Y.push(M.a.c("wf", P.c, C(P).toString(), "inactive")), c(M.f, Y, ce);
      }
      V(M, "fontinactive", P), he(this);
    };
    function he(P) {
      --P.f == 0 && P.j && (P.m ? (P = P.a, P.g && c(P.f, [P.a.c("wf", "active")], [P.a.c("wf", "loading"), P.a.c("wf", "inactive")]), V(P, "active")) : O(P.a));
    }
    function Pe(P) {
      this.j = P, this.a = new N(), this.h = 0, this.f = this.g = !0;
    }
    Pe.prototype.load = function(P) {
      this.c = new s(this.j, P.context || this.j), this.g = P.events !== !1, this.f = P.classes !== !1, be(this, new I(this.c, P), P);
    };
    function le(P, M, U, Y, ce) {
      var Se = --P.h == 0;
      (P.f || P.g) && setTimeout(function() {
        var Ie = ce || null, Ne = Y || null || {};
        if (U.length === 0 && Se)
          O(M.a);
        else {
          M.f += U.length, Se && (M.j = Se);
          var Le, Ge = [];
          for (Le = 0; Le < U.length; Le++) {
            var qe = U[Le], Et = Ne[qe.c], Ot = M.a, ui = qe;
            if (Ot.g && c(Ot.f, [Ot.a.c("wf", ui.c, C(ui).toString(), "loading")]), V(Ot, "fontloading", ui), Ot = null, Re === null)
              if (window.FontFace) {
                var ui = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent), es = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                Re = ui ? 42 < parseInt(ui[1], 10) : !es;
              } else
                Re = !1;
            Re ? Ot = new H(i(M.g, M), i(M.h, M), M.c, qe, M.s, Et) : Ot = new R(i(M.g, M), i(M.h, M), M.c, qe, M.s, Ie, Et), Ge.push(Ot);
          }
          for (Le = 0; Le < Ge.length; Le++)
            Ge[Le].start();
        }
      }, 0);
    }
    function be(P, M, U) {
      var ce = [], Y = U.timeout;
      E(M);
      var ce = F(P.a, U, P.c), Se = new ve(P.c, M, Y);
      for (P.h = ce.length, M = 0, U = ce.length; M < U; M++)
        ce[M].load(function(Ie, Ne, Le) {
          le(P, Se, Ie, Ne, Le);
        });
    }
    function Oe(P, M) {
      this.c = P, this.a = M;
    }
    Oe.prototype.load = function(P) {
      function M() {
        if (Se["__mti_fntLst" + Y]) {
          var Ie = Se["__mti_fntLst" + Y](), Ne = [], Le;
          if (Ie)
            for (var Ge = 0; Ge < Ie.length; Ge++) {
              var qe = Ie[Ge].fontfamily;
              Ie[Ge].fontStyle != null && Ie[Ge].fontWeight != null ? (Le = Ie[Ge].fontStyle + Ie[Ge].fontWeight, Ne.push(new _(qe, Le))) : Ne.push(new _(qe));
            }
          P(Ne);
        } else
          setTimeout(function() {
            M();
          }, 50);
      }
      var U = this, Y = U.a.projectId, ce = U.a.version;
      if (Y) {
        var Se = U.c.o;
        m(this.c, (U.a.api || "https://fast.fonts.net/jsapi") + "/" + Y + ".js" + (ce ? "?v=" + ce : ""), function(Ie) {
          Ie ? P([]) : (Se["__MonotypeConfiguration__" + Y] = function() {
            return U.a;
          }, M());
        }).id = "__MonotypeAPIScript__" + Y;
      } else
        P([]);
    };
    function te(P, M) {
      this.c = P, this.a = M;
    }
    te.prototype.load = function(P) {
      var M, U, Y = this.a.urls || [], ce = this.a.families || [], Se = this.a.testStrings || {}, Ie = new g();
      for (M = 0, U = Y.length; M < U; M++)
        h(this.c, Y[M], p(Ie));
      var Ne = [];
      for (M = 0, U = ce.length; M < U; M++)
        if (Y = ce[M].split(":"), Y[1])
          for (var Le = Y[1].split(","), Ge = 0; Ge < Le.length; Ge += 1)
            Ne.push(new _(Y[0], Le[Ge]));
        else
          Ne.push(new _(Y[0]));
      y(Ie, function() {
        P(Ne, Se);
      });
    };
    function me(P, M) {
      P ? this.c = P : this.c = Me, this.a = [], this.f = [], this.g = M || "";
    }
    var Me = "https://fonts.googleapis.com/css";
    function Fe(P, M) {
      for (var U = M.length, Y = 0; Y < U; Y++) {
        var ce = M[Y].split(":");
        ce.length == 3 && P.f.push(ce.pop());
        var Se = "";
        ce.length == 2 && ce[1] != "" && (Se = ":"), P.a.push(ce.join(Se));
      }
    }
    function xe(P) {
      if (P.a.length == 0)
        throw Error("No fonts to load!");
      if (P.c.indexOf("kit=") != -1)
        return P.c;
      for (var M = P.a.length, U = [], Y = 0; Y < M; Y++)
        U.push(P.a[Y].replace(/ /g, "+"));
      return M = P.c + "?family=" + U.join("%7C"), 0 < P.f.length && (M += "&subset=" + P.f.join(",")), 0 < P.g.length && (M += "&text=" + encodeURIComponent(P.g)), M;
    }
    function ze(P) {
      this.f = P, this.a = [], this.c = {};
    }
    var Ke = { latin: "BESbswy", "latin-ext": "çöüğş", cyrillic: "йяЖ", greek: "αβΣ", khmer: "កខគ", Hanuman: "កខគ" }, ut = { thin: "1", extralight: "2", "extra-light": "2", ultralight: "2", "ultra-light": "2", light: "3", regular: "4", book: "4", medium: "5", "semi-bold": "6", semibold: "6", "demi-bold": "6", demibold: "6", bold: "7", "extra-bold": "8", extrabold: "8", "ultra-bold": "8", ultrabold: "8", black: "9", heavy: "9", l: "3", r: "4", b: "7" }, vt = { i: "i", italic: "i", n: "n", normal: "n" }, En = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
    function On(P) {
      for (var M = P.f.length, U = 0; U < M; U++) {
        var Y = P.f[U].split(":"), ce = Y[0].replace(/\+/g, " "), Se = ["n4"];
        if (2 <= Y.length) {
          var Ie, Ne = Y[1];
          if (Ie = [], Ne)
            for (var Ne = Ne.split(","), Le = Ne.length, Ge = 0; Ge < Le; Ge++) {
              var qe;
              if (qe = Ne[Ge], qe.match(/^[\w-]+$/)) {
                var Et = En.exec(qe.toLowerCase());
                if (Et == null)
                  qe = "";
                else {
                  if (qe = Et[2], qe = qe == null || qe == "" ? "n" : vt[qe], Et = Et[1], Et == null || Et == "")
                    Et = "4";
                  else
                    var Ot = ut[Et], Et = Ot || (isNaN(Et) ? "4" : Et.substr(0, 1));
                  qe = [qe, Et].join("");
                }
              } else
                qe = "";
              qe && Ie.push(qe);
            }
          0 < Ie.length && (Se = Ie), Y.length == 3 && (Y = Y[2], Ie = [], Y = Y ? Y.split(",") : Ie, 0 < Y.length && (Y = Ke[Y[0]]) && (P.c[ce] = Y));
        }
        for (P.c[ce] || (Y = Ke[ce]) && (P.c[ce] = Y), Y = 0; Y < Se.length; Y += 1)
          P.a.push(new _(ce, Se[Y]));
      }
    }
    function Vr(P, M) {
      this.c = P, this.a = M;
    }
    var ma = { Arimo: !0, Cousine: !0, Tinos: !0 };
    Vr.prototype.load = function(P) {
      var M = new g(), U = this.c, Y = new me(this.a.api, this.a.text), ce = this.a.families;
      Fe(Y, ce);
      var Se = new ze(ce);
      On(Se), h(U, xe(Y), p(M)), y(M, function() {
        P(Se.a, Se.c, ma);
      });
    };
    function li(P, M) {
      this.c = P, this.a = M;
    }
    li.prototype.load = function(P) {
      var M = this.a.id, U = this.c.o;
      M ? m(this.c, (this.a.api || "https://use.typekit.net") + "/" + M + ".js", function(Y) {
        if (Y)
          P([]);
        else if (U.Typekit && U.Typekit.config && U.Typekit.config.fn) {
          Y = U.Typekit.config.fn;
          for (var ce = [], Se = 0; Se < Y.length; Se += 2)
            for (var Ie = Y[Se], Ne = Y[Se + 1], Le = 0; Le < Ne.length; Le++)
              ce.push(new _(Ie, Ne[Le]));
          try {
            U.Typekit.load({ events: !1, classes: !1, async: !0 });
          } catch {
          }
          P(ce);
        }
      }, 2e3) : P([]);
    };
    function q(P, M) {
      this.c = P, this.f = M, this.a = [];
    }
    q.prototype.load = function(P) {
      var M = this.f.id, U = this.c.o, Y = this;
      M ? (U.__webfontfontdeckmodule__ || (U.__webfontfontdeckmodule__ = {}), U.__webfontfontdeckmodule__[M] = function(ce, Se) {
        for (var Ie = 0, Ne = Se.fonts.length; Ie < Ne; ++Ie) {
          var Le = Se.fonts[Ie];
          Y.a.push(new _(Le.name, A("font-weight:" + Le.weight + ";font-style:" + Le.style)));
        }
        P(Y.a);
      }, m(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + f(this.c) + "/" + M + ".js", function(ce) {
        ce && P([]);
      })) : P([]);
    };
    var z = new Pe(window);
    z.a.c.custom = function(P, M) {
      return new te(M, P);
    }, z.a.c.fontdeck = function(P, M) {
      return new q(M, P);
    }, z.a.c.monotype = function(P, M) {
      return new Oe(M, P);
    }, z.a.c.typekit = function(P, M) {
      return new li(M, P);
    }, z.a.c.google = function(P, M) {
      return new Vr(M, P);
    };
    var de = { load: i(z.load, z) };
    e.exports ? e.exports = de : (window.WebFont = de, window.WebFontConfig && z.load(window.WebFontConfig));
  })();
})(Tq);
const $o = xs("Webfontloader"), xq = {
  install: (e, t) => {
    const n = X(!1);
    if (n.value === !1 && t && (t.custom || t.google || t.typekit || t.fontdeck || t.monotype)) {
      const i = () => {
        t && t.loading && typeof t.loading == "function" && t.loading(), e.config.globalProperties.$bus && e.config.globalProperties.$bus.emit("webfonts:loading", { local: !0 }), $o("Webfonts loading");
      }, r = () => {
        t && t.active && typeof t.active == "function" && t.active(), e.config.globalProperties.$bus && e.config.globalProperties.$bus.emit("webfonts:active", { local: !0 }), $o("Webfonts active");
      }, s = () => {
        t && t.inactive && typeof t.inactive == "function" && t.inactive(), e.config.globalProperties.$bus && e.config.globalProperties.$bus.emit("webfonts:inactive", { local: !0 }), $o("Webfonts inactive");
      };
      if (typeof window < "u" && typeof window.WebFont < "u")
        try {
          window.WebFont.load({
            ...t,
            loading: i,
            active: r,
            inactive: s
          }), n.value = !0;
        } catch (a) {
          $o("Error loading webfonts", a);
        }
      else
        typeof window.WebFont > "u" && $o("WebFont not loaded in global scope");
    } else
      n.value === !1 && $o("No webfonts to load");
  }
}, v9 = {
  install: (e, t) => {
    var n;
    e.use(U2, t == null ? void 0 : t.push), e.use(Cq, { sounds: (n = t == null ? void 0 : t.ui) == null ? void 0 : n.sounds }), e.use(xq, t == null ? void 0 : t.webfontloader);
  }
};
const Aq = B({
  ...ke(),
  ...GS({
    fullHeight: !0
  }),
  ...Qe()
}, "VApp"), Iq = J()({
  name: "VApp",
  props: Aq(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = lt(e), {
      layoutClasses: r,
      getLayoutItem: s,
      items: a,
      layoutRef: o
    } = ZS(e), {
      rtlClasses: l
    } = yn();
    return ie(() => v("div", {
      ref: o,
      class: ["v-application", i.themeClasses.value, r.value, l.value, e.class],
      style: [e.style]
    }, [v("div", {
      class: "v-application__wrap"
    }, [v(eS, null, {
      default: () => {
        var u;
        return [v(De, null, [(u = n.default) == null ? void 0 : u.call(n)])];
      }
    })])])), {
      getLayoutItem: s,
      items: a,
      theme: i
    };
  }
});
const Dx = B({
  text: String,
  ...ke(),
  ...je()
}, "VToolbarTitle"), Ky = J()({
  name: "VToolbarTitle",
  props: Dx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ie(() => {
      const i = !!(n.default || n.text || e.text);
      return v(e.tag, {
        class: ["v-toolbar-title", e.class],
        style: e.style
      }, {
        default: () => {
          var r;
          return [i && v("div", {
            class: "v-toolbar-title__placeholder"
          }, [n.text ? n.text() : e.text, (r = n.default) == null ? void 0 : r.call(n)])];
        }
      });
    }), {};
  }
});
function Eq(e) {
  return {
    aspectStyles: w(() => {
      const t = Number(e.aspectRatio);
      return t ? {
        paddingBottom: String(1 / t * 100) + "%"
      } : void 0;
    })
  };
}
const Nx = B({
  aspectRatio: [String, Number],
  contentClass: null,
  inline: Boolean,
  ...ke(),
  ...wn()
}, "VResponsive"), xg = J()({
  name: "VResponsive",
  props: Nx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      aspectStyles: i
    } = Eq(e), {
      dimensionStyles: r
    } = _n(e);
    return ie(() => {
      var s;
      return v("div", {
        class: ["v-responsive", {
          "v-responsive--inline": e.inline
        }, e.class],
        style: [r.value, e.style]
      }, [v("div", {
        class: "v-responsive__sizer",
        style: i.value
      }, null), (s = n.additional) == null ? void 0 : s.call(n), n.default && v("div", {
        class: ["v-responsive__content", e.contentClass]
      }, [n.default()])]);
    }), {};
  }
}), Mx = B({
  alt: String,
  cover: Boolean,
  color: String,
  draggable: {
    type: [Boolean, String],
    default: void 0
  },
  eager: Boolean,
  gradient: String,
  lazySrc: String,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  sizes: String,
  src: {
    type: [String, Object],
    default: ""
  },
  crossorigin: String,
  referrerpolicy: String,
  srcset: String,
  position: String,
  ...Nx(),
  ...ke(),
  ...It(),
  ...Tr()
}, "VImg"), _s = J()({
  name: "VImg",
  directives: {
    intersect: Pc
  },
  props: Mx(),
  emits: {
    loadstart: (e) => !0,
    load: (e) => !0,
    error: (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const {
      backgroundColorClasses: r,
      backgroundColorStyles: s
    } = gt(G(e, "color")), {
      roundedClasses: a
    } = Ht(e), o = Ut("VImg"), l = pe(""), u = X(), c = pe(e.eager ? "loading" : "idle"), d = pe(), f = pe(), h = w(() => e.src && typeof e.src == "object" ? {
      src: e.src.src,
      srcset: e.srcset || e.src.srcset,
      lazySrc: e.lazySrc || e.src.lazySrc,
      aspect: Number(e.aspectRatio || e.src.aspect || 0)
    } : {
      src: e.src,
      srcset: e.srcset,
      lazySrc: e.lazySrc,
      aspect: Number(e.aspectRatio || 0)
    }), m = w(() => h.value.aspect || d.value / f.value || 0);
    fe(() => e.src, () => {
      g(c.value !== "idle");
    }), fe(m, (O, V) => {
      !O && V && u.value && _(u.value);
    }), J_(() => g());
    function g(O) {
      if (!(e.eager && O) && !(tp && !O && !e.eager)) {
        if (c.value = "loading", h.value.lazySrc) {
          const V = new Image();
          V.src = h.value.lazySrc, _(V, null);
        }
        h.value.src && He(() => {
          var V;
          n("loadstart", ((V = u.value) == null ? void 0 : V.currentSrc) || h.value.src), setTimeout(() => {
            var N;
            if (!o.isUnmounted)
              if ((N = u.value) != null && N.complete) {
                if (u.value.naturalWidth || y(), c.value === "error")
                  return;
                m.value || _(u.value, null), c.value === "loading" && p();
              } else
                m.value || _(u.value), k();
          });
        });
      }
    }
    function p() {
      var O;
      o.isUnmounted || (k(), _(u.value), c.value = "loaded", n("load", ((O = u.value) == null ? void 0 : O.currentSrc) || h.value.src));
    }
    function y() {
      var O;
      o.isUnmounted || (c.value = "error", n("error", ((O = u.value) == null ? void 0 : O.currentSrc) || h.value.src));
    }
    function k() {
      const O = u.value;
      O && (l.value = O.currentSrc || O.src);
    }
    let T = -1;
    ai(() => {
      clearTimeout(T);
    });
    function _(O) {
      let V = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
      const N = () => {
        if (clearTimeout(T), o.isUnmounted)
          return;
        const {
          naturalHeight: F,
          naturalWidth: $
        } = O;
        F || $ ? (d.value = $, f.value = F) : !O.complete && c.value === "loading" && V != null ? T = window.setTimeout(N, V) : (O.currentSrc.endsWith(".svg") || O.currentSrc.startsWith("data:image/svg+xml")) && (d.value = 1, f.value = 1);
      };
      N();
    }
    const b = w(() => ({
      "v-img__img--cover": e.cover,
      "v-img__img--contain": !e.cover
    })), S = () => {
      var N;
      if (!h.value.src || c.value === "idle")
        return null;
      const O = v("img", {
        class: ["v-img__img", b.value],
        style: {
          objectPosition: e.position
        },
        src: h.value.src,
        srcset: h.value.srcset,
        alt: e.alt,
        crossorigin: e.crossorigin,
        referrerpolicy: e.referrerpolicy,
        draggable: e.draggable,
        sizes: e.sizes,
        ref: u,
        onLoad: p,
        onError: y
      }, null), V = (N = i.sources) == null ? void 0 : N.call(i);
      return v(Gn, {
        transition: e.transition,
        appear: !0
      }, {
        default: () => [Rt(V ? v("picture", {
          class: "v-img__picture"
        }, [V, O]) : O, [[Cr, c.value === "loaded"]])]
      });
    }, C = () => v(Gn, {
      transition: e.transition
    }, {
      default: () => [h.value.lazySrc && c.value !== "loaded" && v("img", {
        class: ["v-img__img", "v-img__img--preload", b.value],
        style: {
          objectPosition: e.position
        },
        src: h.value.lazySrc,
        alt: e.alt,
        crossorigin: e.crossorigin,
        referrerpolicy: e.referrerpolicy,
        draggable: e.draggable
      }, null)]
    }), x = () => i.placeholder ? v(Gn, {
      transition: e.transition,
      appear: !0
    }, {
      default: () => [(c.value === "loading" || c.value === "error" && !i.error) && v("div", {
        class: "v-img__placeholder"
      }, [i.placeholder()])]
    }) : null, A = () => i.error ? v(Gn, {
      transition: e.transition,
      appear: !0
    }, {
      default: () => [c.value === "error" && v("div", {
        class: "v-img__error"
      }, [i.error()])]
    }) : null, I = () => e.gradient ? v("div", {
      class: "v-img__gradient",
      style: {
        backgroundImage: `linear-gradient(${e.gradient})`
      }
    }, null) : null, E = pe(!1);
    {
      const O = fe(m, (V) => {
        V && (requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            E.value = !0;
          });
        }), O());
      });
    }
    return ie(() => {
      const O = xg.filterProps(e);
      return Rt(v(xg, se({
        class: ["v-img", {
          "v-img--booting": !E.value
        }, r.value, a.value, e.class],
        style: [{
          width: _e(e.width === "auto" ? d.value : e.width)
        }, s.value, e.style]
      }, O, {
        aspectRatio: m.value,
        "aria-label": e.alt,
        role: e.alt ? "img" : void 0
      }), {
        additional: () => v(De, null, [v(S, null, null), v(C, null, null), v(I, null, null), v(x, null, null), v(A, null, null)]),
        default: i.default
      }), [[Ei("intersect"), {
        handler: g,
        options: e.options
      }, null, {
        once: !0
      }]]);
    }), {
      currentSrc: l,
      image: u,
      state: c,
      naturalWidth: d,
      naturalHeight: f
    };
  }
}), Ni = B({
  border: [Boolean, Number, String]
}, "border");
function er(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zr();
  return {
    borderClasses: w(() => {
      const i = ia(e) ? e.value : e.border, r = [];
      if (i === !0 || i === "")
        r.push(`${t}--border`);
      else if (typeof i == "string" || i === 0)
        for (const s of String(i).split(" "))
          r.push(`border-${s}`);
      return r;
    })
  };
}
const mn = B({
  elevation: {
    type: [Number, String],
    validator(e) {
      const t = parseInt(e);
      return !isNaN(t) && t >= 0 && // Material Design has a maximum elevation of 24
      // https://material.io/design/environment/elevation.html#default-elevations
      t <= 24;
    }
  }
}, "elevation");
function In(e) {
  return {
    elevationClasses: w(() => {
      const n = ia(e) ? e.value : e.elevation, i = [];
      return n == null || i.push(`elevation-${n}`), i;
    })
  };
}
const Oq = [null, "prominent", "default", "comfortable", "compact"], Rx = B({
  absolute: Boolean,
  collapse: Boolean,
  color: String,
  density: {
    type: String,
    default: "default",
    validator: (e) => Oq.includes(e)
  },
  extended: Boolean,
  extensionHeight: {
    type: [Number, String],
    default: 48
  },
  flat: Boolean,
  floating: Boolean,
  height: {
    type: [Number, String],
    default: 64
  },
  image: String,
  title: String,
  ...Ni(),
  ...ke(),
  ...mn(),
  ...It(),
  ...je({
    tag: "header"
  }),
  ...Qe()
}, "VToolbar"), Ag = J()({
  name: "VToolbar",
  props: Rx(),
  setup(e, t) {
    var h;
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: r
    } = gt(G(e, "color")), {
      borderClasses: s
    } = er(e), {
      elevationClasses: a
    } = In(e), {
      roundedClasses: o
    } = Ht(e), {
      themeClasses: l
    } = lt(e), {
      rtlClasses: u
    } = yn(), c = pe(!!(e.extended || (h = n.extension) != null && h.call(n))), d = w(() => parseInt(Number(e.height) + (e.density === "prominent" ? Number(e.height) : 0) - (e.density === "comfortable" ? 8 : 0) - (e.density === "compact" ? 16 : 0), 10)), f = w(() => c.value ? parseInt(Number(e.extensionHeight) + (e.density === "prominent" ? Number(e.extensionHeight) : 0) - (e.density === "comfortable" ? 4 : 0) - (e.density === "compact" ? 8 : 0), 10) : 0);
    return jt({
      VBtn: {
        variant: "text"
      }
    }), ie(() => {
      var y;
      const m = !!(e.title || n.title), g = !!(n.image || e.image), p = (y = n.extension) == null ? void 0 : y.call(n);
      return c.value = !!(e.extended || p), v(e.tag, {
        class: ["v-toolbar", {
          "v-toolbar--absolute": e.absolute,
          "v-toolbar--collapse": e.collapse,
          "v-toolbar--flat": e.flat,
          "v-toolbar--floating": e.floating,
          [`v-toolbar--density-${e.density}`]: !0
        }, i.value, s.value, a.value, o.value, l.value, u.value, e.class],
        style: [r.value, e.style]
      }, {
        default: () => [g && v("div", {
          key: "image",
          class: "v-toolbar__image"
        }, [n.image ? v(Ze, {
          key: "image-defaults",
          disabled: !e.image,
          defaults: {
            VImg: {
              cover: !0,
              src: e.image
            }
          }
        }, n.image) : v(_s, {
          key: "image-img",
          cover: !0,
          src: e.image
        }, null)]), v(Ze, {
          defaults: {
            VTabs: {
              height: _e(d.value)
            }
          }
        }, {
          default: () => {
            var k, T, _;
            return [v("div", {
              class: "v-toolbar__content",
              style: {
                height: _e(d.value)
              }
            }, [n.prepend && v("div", {
              class: "v-toolbar__prepend"
            }, [(k = n.prepend) == null ? void 0 : k.call(n)]), m && v(Ky, {
              key: "title",
              text: e.title
            }, {
              text: n.title
            }), (T = n.default) == null ? void 0 : T.call(n), n.append && v("div", {
              class: "v-toolbar__append"
            }, [(_ = n.append) == null ? void 0 : _.call(n)])])];
          }
        }), v(Ze, {
          defaults: {
            VTabs: {
              height: _e(f.value)
            }
          }
        }, {
          default: () => [v(fh, null, {
            default: () => [c.value && v("div", {
              class: "v-toolbar__extension",
              style: {
                height: _e(f.value)
              }
            }, [p])]
          })]
        })]
      });
    }), {
      contentHeight: d,
      extensionHeight: f
    };
  }
}), Pq = B({
  scrollTarget: {
    type: String
  },
  scrollThreshold: {
    type: [String, Number],
    default: 300
  }
}, "scroll");
function Vq(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    canScroll: n
  } = t;
  let i = 0;
  const r = X(null), s = pe(0), a = pe(0), o = pe(0), l = pe(!1), u = pe(!1), c = w(() => Number(e.scrollThreshold)), d = w(() => Xt((c.value - s.value) / c.value || 0)), f = () => {
    const h = r.value;
    !h || n && !n.value || (i = s.value, s.value = "window" in h ? h.pageYOffset : h.scrollTop, u.value = s.value < i, o.value = Math.abs(s.value - c.value));
  };
  return fe(u, () => {
    a.value = a.value || s.value;
  }), fe(l, () => {
    a.value = 0;
  }), jn(() => {
    fe(() => e.scrollTarget, (h) => {
      var g;
      const m = h ? document.querySelector(h) : window;
      if (!m) {
        gr(`Unable to locate element with identifier ${h}`);
        return;
      }
      m !== r.value && ((g = r.value) == null || g.removeEventListener("scroll", f), r.value = m, r.value.addEventListener("scroll", f, {
        passive: !0
      }));
    }, {
      immediate: !0
    });
  }), ai(() => {
    var h;
    (h = r.value) == null || h.removeEventListener("scroll", f);
  }), n && fe(n, f, {
    immediate: !0
  }), {
    scrollThreshold: c,
    currentScroll: s,
    currentThreshold: o,
    isScrollActive: l,
    scrollRatio: d,
    // required only for testing
    // probably can be removed
    // later (2 chars chlng)
    isScrollingUp: u,
    savedScroll: a
  };
}
function Ao() {
  const e = pe(!1);
  return jn(() => {
    window.requestAnimationFrame(() => {
      e.value = !0;
    });
  }), {
    ssrBootStyles: w(() => e.value ? void 0 : {
      transition: "none !important"
    }),
    isBooted: Ml(e)
  };
}
const Dq = B({
  scrollBehavior: String,
  modelValue: {
    type: Boolean,
    default: !0
  },
  location: {
    type: String,
    default: "top",
    validator: (e) => ["top", "bottom"].includes(e)
  },
  ...Rx(),
  ...yo(),
  ...Pq(),
  height: {
    type: [Number, String],
    default: 64
  }
}, "VAppBar"), Nq = J()({
  name: "VAppBar",
  props: Dq(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = X(), r = Ee(e, "modelValue"), s = w(() => {
      var _;
      const T = new Set(((_ = e.scrollBehavior) == null ? void 0 : _.split(" ")) ?? []);
      return {
        hide: T.has("hide"),
        fullyHide: T.has("fully-hide"),
        inverted: T.has("inverted"),
        collapse: T.has("collapse"),
        elevate: T.has("elevate"),
        fadeImage: T.has("fade-image")
        // shrink: behavior.has('shrink'),
      };
    }), a = w(() => {
      const T = s.value;
      return T.hide || T.fullyHide || T.inverted || T.collapse || T.elevate || T.fadeImage || // behavior.shrink ||
      !r.value;
    }), {
      currentScroll: o,
      scrollThreshold: l,
      isScrollingUp: u,
      scrollRatio: c
    } = Vq(e, {
      canScroll: a
    }), d = w(() => s.value.hide || s.value.fullyHide), f = w(() => e.collapse || s.value.collapse && (s.value.inverted ? c.value > 0 : c.value === 0)), h = w(() => e.flat || s.value.fullyHide && !r.value || s.value.elevate && (s.value.inverted ? o.value > 0 : o.value === 0)), m = w(() => s.value.fadeImage ? s.value.inverted ? 1 - c.value : c.value : void 0), g = w(() => {
      var b, S;
      const T = Number(((b = i.value) == null ? void 0 : b.contentHeight) ?? e.height), _ = Number(((S = i.value) == null ? void 0 : S.extensionHeight) ?? 0);
      return d.value ? o.value < l.value || s.value.fullyHide ? T + _ : T : T + _;
    });
    vi(w(() => !!e.scrollBehavior), () => {
      Wt(() => {
        d.value ? s.value.inverted ? r.value = o.value > l.value : r.value = u.value || o.value < l.value : r.value = !0;
      });
    });
    const {
      ssrBootStyles: p
    } = Ao(), {
      layoutItemStyles: y,
      layoutIsReady: k
    } = bo({
      id: e.name,
      order: w(() => parseInt(e.order, 10)),
      position: G(e, "location"),
      layoutSize: g,
      elementSize: pe(void 0),
      active: r,
      absolute: G(e, "absolute")
    });
    return ie(() => {
      const T = Ag.filterProps(e);
      return v(Ag, se({
        ref: i,
        class: ["v-app-bar", {
          "v-app-bar--bottom": e.location === "bottom"
        }, e.class],
        style: [{
          ...y.value,
          "--v-toolbar-image-opacity": m.value,
          height: void 0,
          ...p.value
        }, e.style]
      }, T, {
        collapse: f.value,
        flat: h.value
      }), n);
    }), k;
  }
});
const Mq = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
function fa(e, t) {
  return v(De, null, [e && v("span", {
    key: "overlay",
    class: `${t}__overlay`
  }, null), v("span", {
    key: "underlay",
    class: `${t}__underlay`
  }, null)]);
}
const tr = B({
  color: String,
  variant: {
    type: String,
    default: "elevated",
    validator: (e) => Mq.includes(e)
  }
}, "variant");
function Io(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zr();
  const n = w(() => {
    const {
      variant: s
    } = Ct(e);
    return `${t}--variant-${s}`;
  }), {
    colorClasses: i,
    colorStyles: r
  } = vp(w(() => {
    const {
      variant: s,
      color: a
    } = Ct(e);
    return {
      [["elevated", "flat"].includes(s) ? "background" : "text"]: a
    };
  }));
  return {
    colorClasses: i,
    colorStyles: r,
    variantClasses: n
  };
}
const Fx = B({
  baseColor: String,
  divided: Boolean,
  ...Ni(),
  ...ke(),
  ...bn(),
  ...mn(),
  ...It(),
  ...je(),
  ...Qe(),
  ...tr()
}, "VBtnGroup"), Ig = J()({
  name: "VBtnGroup",
  props: Fx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      densityClasses: r
    } = Kn(e), {
      borderClasses: s
    } = er(e), {
      elevationClasses: a
    } = In(e), {
      roundedClasses: o
    } = Ht(e);
    jt({
      VBtn: {
        height: "auto",
        baseColor: G(e, "baseColor"),
        color: G(e, "color"),
        density: G(e, "density"),
        flat: !0,
        variant: G(e, "variant")
      }
    }), ie(() => v(e.tag, {
      class: ["v-btn-group", {
        "v-btn-group--divided": e.divided
      }, i.value, s.value, r.value, a.value, o.value, e.class],
      style: e.style
    }, n));
  }
}), Eo = B({
  modelValue: {
    type: null,
    default: void 0
  },
  multiple: Boolean,
  mandatory: [Boolean, String],
  max: Number,
  selectedClass: String,
  disabled: Boolean
}, "group"), Oo = B({
  value: null,
  disabled: Boolean,
  selectedClass: String
}, "group-item");
function Po(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  const i = Ut("useGroupItem");
  if (!i)
    throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
  const r = An();
  Tt(Symbol.for(`${t.description}:id`), r);
  const s = tt(t, null);
  if (!s) {
    if (!n)
      return s;
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${t.description}`);
  }
  const a = G(e, "value"), o = w(() => !!(s.disabled.value || e.disabled));
  s.register({
    id: r,
    value: a,
    disabled: o
  }, i), ai(() => {
    s.unregister(r);
  });
  const l = w(() => s.isSelected(r)), u = w(() => s.items.value[0].id === r), c = w(() => s.items.value[s.items.value.length - 1].id === r), d = w(() => l.value && [s.selectedClass.value, e.selectedClass]);
  return fe(l, (f) => {
    i.emit("group:selected", {
      value: f
    });
  }, {
    flush: "sync"
  }), {
    id: r,
    isSelected: l,
    isFirst: u,
    isLast: c,
    toggle: () => s.select(r, !l.value),
    select: (f) => s.select(r, f),
    selectedClass: d,
    value: a,
    disabled: o,
    group: s
  };
}
function ha(e, t) {
  let n = !1;
  const i = ti([]), r = Ee(e, "modelValue", [], (f) => f == null ? [] : Bx(i, Nt(f)), (f) => {
    const h = Fq(i, f);
    return e.multiple ? h : h[0];
  }), s = Ut("useGroup");
  function a(f, h) {
    const m = f, g = Symbol.for(`${t.description}:id`), y = Zo(g, s == null ? void 0 : s.vnode).indexOf(h);
    Ct(m.value) == null && (m.value = y, m.useIndexAsValue = !0), y > -1 ? i.splice(y, 0, m) : i.push(m);
  }
  function o(f) {
    if (n)
      return;
    l();
    const h = i.findIndex((m) => m.id === f);
    i.splice(h, 1);
  }
  function l() {
    const f = i.find((h) => !h.disabled);
    f && e.mandatory === "force" && !r.value.length && (r.value = [f.id]);
  }
  jn(() => {
    l();
  }), ai(() => {
    n = !0;
  }), XE(() => {
    for (let f = 0; f < i.length; f++)
      i[f].useIndexAsValue && (i[f].value = f);
  });
  function u(f, h) {
    const m = i.find((g) => g.id === f);
    if (!(h && (m != null && m.disabled)))
      if (e.multiple) {
        const g = r.value.slice(), p = g.findIndex((k) => k === f), y = ~p;
        if (h = h ?? !y, y && e.mandatory && g.length <= 1 || !y && e.max != null && g.length + 1 > e.max)
          return;
        p < 0 && h ? g.push(f) : p >= 0 && !h && g.splice(p, 1), r.value = g;
      } else {
        const g = r.value.includes(f);
        if (e.mandatory && g)
          return;
        r.value = h ?? !g ? [f] : [];
      }
  }
  function c(f) {
    if (e.multiple && gr('This method is not supported when using "multiple" prop'), r.value.length) {
      const h = r.value[0], m = i.findIndex((y) => y.id === h);
      let g = (m + f) % i.length, p = i[g];
      for (; p.disabled && g !== m; )
        g = (g + f) % i.length, p = i[g];
      if (p.disabled)
        return;
      r.value = [i[g].id];
    } else {
      const h = i.find((m) => !m.disabled);
      h && (r.value = [h.id]);
    }
  }
  const d = {
    register: a,
    unregister: o,
    selected: r,
    select: u,
    disabled: G(e, "disabled"),
    prev: () => c(i.length - 1),
    next: () => c(1),
    isSelected: (f) => r.value.includes(f),
    selectedClass: w(() => e.selectedClass),
    items: w(() => i),
    getItemIndex: (f) => Rq(i, f)
  };
  return Tt(t, d), d;
}
function Rq(e, t) {
  const n = Bx(e, [t]);
  return n.length ? e.findIndex((i) => i.id === n[0]) : -1;
}
function Bx(e, t) {
  const n = [];
  return t.forEach((i) => {
    const r = e.find((a) => Gr(i, a.value)), s = e[i];
    (r == null ? void 0 : r.value) != null ? n.push(r.id) : s != null && n.push(s.id);
  }), n;
}
function Fq(e, t) {
  const n = [];
  return t.forEach((i) => {
    const r = e.findIndex((s) => s.id === i);
    if (~r) {
      const s = e[r];
      n.push(s.value != null ? s.value : r);
    }
  }), n;
}
const Xy = Symbol.for("vuetify:v-btn-toggle"), Bq = B({
  ...Fx(),
  ...Eo()
}, "VBtnToggle"), Lq = J()({
  name: "VBtnToggle",
  props: Bq(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isSelected: i,
      next: r,
      prev: s,
      select: a,
      selected: o
    } = ha(e, Xy);
    return ie(() => {
      const l = Ig.filterProps(e);
      return v(Ig, se({
        class: ["v-btn-toggle", e.class]
      }, l, {
        style: e.style
      }), {
        default: () => {
          var u;
          return [(u = n.default) == null ? void 0 : u.call(n, {
            isSelected: i,
            next: r,
            prev: s,
            select: a,
            selected: o
          })];
        }
      });
    }), {
      next: r,
      prev: s,
      select: a
    };
  }
});
const $q = B({
  bgColor: String,
  color: String,
  indeterminate: [Boolean, String],
  modelValue: {
    type: [Number, String],
    default: 0
  },
  rotate: {
    type: [Number, String],
    default: 0
  },
  width: {
    type: [Number, String],
    default: 4
  },
  ...ke(),
  ...Kr(),
  ...je({
    tag: "div"
  }),
  ...Qe()
}, "VProgressCircular"), Vl = J()({
  name: "VProgressCircular",
  props: $q(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = 20, r = 2 * Math.PI * i, s = X(), {
      themeClasses: a
    } = lt(e), {
      sizeClasses: o,
      sizeStyles: l
    } = Fl(e), {
      textColorClasses: u,
      textColorStyles: c
    } = Ln(G(e, "color")), {
      textColorClasses: d,
      textColorStyles: f
    } = Ln(G(e, "bgColor")), {
      intersectionRef: h,
      isIntersecting: m
    } = vh(), {
      resizeRef: g,
      contentRect: p
    } = _r(), y = w(() => Math.max(0, Math.min(100, parseFloat(e.modelValue)))), k = w(() => Number(e.width)), T = w(() => l.value ? Number(e.size) : p.value ? p.value.width : Math.max(k.value, 32)), _ = w(() => i / (1 - k.value / T.value) * 2), b = w(() => k.value / T.value * _.value), S = w(() => _e((100 - y.value) / 100 * r));
    return Wt(() => {
      h.value = s.value, g.value = s.value;
    }), ie(() => v(e.tag, {
      ref: s,
      class: ["v-progress-circular", {
        "v-progress-circular--indeterminate": !!e.indeterminate,
        "v-progress-circular--visible": m.value,
        "v-progress-circular--disable-shrink": e.indeterminate === "disable-shrink"
      }, a.value, o.value, u.value, e.class],
      style: [l.value, c.value, e.style],
      role: "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": e.indeterminate ? void 0 : y.value
    }, {
      default: () => [v("svg", {
        style: {
          transform: `rotate(calc(-90deg + ${Number(e.rotate)}deg))`
        },
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${_.value} ${_.value}`
      }, [v("circle", {
        class: ["v-progress-circular__underlay", d.value],
        style: f.value,
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r: i,
        "stroke-width": b.value,
        "stroke-dasharray": r,
        "stroke-dashoffset": 0
      }, null), v("circle", {
        class: "v-progress-circular__overlay",
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r: i,
        "stroke-width": b.value,
        "stroke-dasharray": r,
        "stroke-dashoffset": S.value
      }, null)]), n.default && v("div", {
        class: "v-progress-circular__content"
      }, [n.default({
        value: y.value
      })])]
    })), {};
  }
}), Wq = ["static", "relative", "fixed", "absolute", "sticky"], nu = B({
  position: {
    type: String,
    validator: (
      /* istanbul ignore next */
      (e) => Wq.includes(e)
    )
  }
}, "position");
function iu(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zr();
  return {
    positionClasses: w(() => e.position ? `${t}--${e.position}` : void 0)
  };
}
function jq() {
  const e = Ut("useRoute");
  return w(() => {
    var t;
    return (t = e == null ? void 0 : e.proxy) == null ? void 0 : t.$route;
  });
}
function Lx() {
  var e, t;
  return (t = (e = Ut("useRouter")) == null ? void 0 : e.proxy) == null ? void 0 : t.$router;
}
function nd(e, t) {
  var u, c;
  const n = JE("RouterLink"), i = w(() => !!(e.href || e.to)), r = w(() => (i == null ? void 0 : i.value) || Gb(t, "click") || Gb(e, "click"));
  if (typeof n == "string" || !("useLink" in n))
    return {
      isLink: i,
      isClickable: r,
      href: G(e, "href")
    };
  const s = w(() => ({
    ...e,
    to: G(() => e.to || "")
  })), a = n.useLink(s.value), o = w(() => e.to ? a : void 0), l = jq();
  return {
    isLink: i,
    isClickable: r,
    route: (u = o.value) == null ? void 0 : u.route,
    navigate: (c = o.value) == null ? void 0 : c.navigate,
    isActive: w(() => {
      var d, f, h;
      return o.value ? e.exact ? l.value ? ((h = o.value.isExactActive) == null ? void 0 : h.value) && Gr(o.value.route.value.query, l.value.query) : ((f = o.value.isExactActive) == null ? void 0 : f.value) ?? !1 : ((d = o.value.isActive) == null ? void 0 : d.value) ?? !1 : !1;
    }),
    href: w(() => {
      var d;
      return e.to ? (d = o.value) == null ? void 0 : d.route.value.href : e.href;
    })
  };
}
const id = B({
  href: String,
  replace: Boolean,
  to: [String, Object],
  exact: Boolean
}, "router");
let wv = !1;
function Hq(e, t) {
  let n = !1, i, r;
  ft && (He(() => {
    window.addEventListener("popstate", s), i = e == null ? void 0 : e.beforeEach((a, o, l) => {
      wv ? n ? t(l) : l() : setTimeout(() => n ? t(l) : l()), wv = !0;
    }), r = e == null ? void 0 : e.afterEach(() => {
      wv = !1;
    });
  }), Wn(() => {
    window.removeEventListener("popstate", s), i == null || i(), r == null || r();
  }));
  function s(a) {
    var o;
    (o = a.state) != null && o.replaced || (n = !0, setTimeout(() => n = !1));
  }
}
function zq(e, t) {
  fe(() => {
    var n;
    return (n = e.isActive) == null ? void 0 : n.value;
  }, (n) => {
    e.isLink.value && n && t && He(() => {
      t(!0);
    });
  }, {
    immediate: !0
  });
}
const Eg = Symbol("rippleStop"), Uq = 80;
function O_(e, t) {
  e.style.transform = t, e.style.webkitTransform = t;
}
function Og(e) {
  return e.constructor.name === "TouchEvent";
}
function $x(e) {
  return e.constructor.name === "KeyboardEvent";
}
const qq = function(e, t) {
  var d;
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = 0, r = 0;
  if (!$x(e)) {
    const f = t.getBoundingClientRect(), h = Og(e) ? e.touches[e.touches.length - 1] : e;
    i = h.clientX - f.left, r = h.clientY - f.top;
  }
  let s = 0, a = 0.3;
  (d = t._ripple) != null && d.circle ? (a = 0.15, s = t.clientWidth / 2, s = n.center ? s : s + Math.sqrt((i - s) ** 2 + (r - s) ** 2) / 4) : s = Math.sqrt(t.clientWidth ** 2 + t.clientHeight ** 2) / 2;
  const o = `${(t.clientWidth - s * 2) / 2}px`, l = `${(t.clientHeight - s * 2) / 2}px`, u = n.center ? o : `${i - s}px`, c = n.center ? l : `${r - s}px`;
  return {
    radius: s,
    scale: a,
    x: u,
    y: c,
    centerX: o,
    centerY: l
  };
}, nh = {
  /* eslint-disable max-statements */
  show(e, t) {
    var h;
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!((h = t == null ? void 0 : t._ripple) != null && h.enabled))
      return;
    const i = document.createElement("span"), r = document.createElement("span");
    i.appendChild(r), i.className = "v-ripple__container", n.class && (i.className += ` ${n.class}`);
    const {
      radius: s,
      scale: a,
      x: o,
      y: l,
      centerX: u,
      centerY: c
    } = qq(e, t, n), d = `${s * 2}px`;
    r.className = "v-ripple__animation", r.style.width = d, r.style.height = d, t.appendChild(i);
    const f = window.getComputedStyle(t);
    f && f.position === "static" && (t.style.position = "relative", t.dataset.previousPosition = "static"), r.classList.add("v-ripple__animation--enter"), r.classList.add("v-ripple__animation--visible"), O_(r, `translate(${o}, ${l}) scale3d(${a},${a},${a})`), r.dataset.activated = String(performance.now()), setTimeout(() => {
      r.classList.remove("v-ripple__animation--enter"), r.classList.add("v-ripple__animation--in"), O_(r, `translate(${u}, ${c}) scale3d(1,1,1)`);
    }, 0);
  },
  hide(e) {
    var s;
    if (!((s = e == null ? void 0 : e._ripple) != null && s.enabled))
      return;
    const t = e.getElementsByClassName("v-ripple__animation");
    if (t.length === 0)
      return;
    const n = t[t.length - 1];
    if (n.dataset.isHiding)
      return;
    n.dataset.isHiding = "true";
    const i = performance.now() - Number(n.dataset.activated), r = Math.max(250 - i, 0);
    setTimeout(() => {
      n.classList.remove("v-ripple__animation--in"), n.classList.add("v-ripple__animation--out"), setTimeout(() => {
        var o;
        e.getElementsByClassName("v-ripple__animation").length === 1 && e.dataset.previousPosition && (e.style.position = e.dataset.previousPosition, delete e.dataset.previousPosition), ((o = n.parentNode) == null ? void 0 : o.parentNode) === e && e.removeChild(n.parentNode);
      }, 300);
    }, r);
  }
};
function Wx(e) {
  return typeof e > "u" || !!e;
}
function bc(e) {
  const t = {}, n = e.currentTarget;
  if (!(!(n != null && n._ripple) || n._ripple.touched || e[Eg])) {
    if (e[Eg] = !0, Og(e))
      n._ripple.touched = !0, n._ripple.isTouch = !0;
    else if (n._ripple.isTouch)
      return;
    if (t.center = n._ripple.centered || $x(e), n._ripple.class && (t.class = n._ripple.class), Og(e)) {
      if (n._ripple.showTimerCommit)
        return;
      n._ripple.showTimerCommit = () => {
        nh.show(e, n, t);
      }, n._ripple.showTimer = window.setTimeout(() => {
        var i;
        (i = n == null ? void 0 : n._ripple) != null && i.showTimerCommit && (n._ripple.showTimerCommit(), n._ripple.showTimerCommit = null);
      }, Uq);
    } else
      nh.show(e, n, t);
  }
}
function P_(e) {
  e[Eg] = !0;
}
function Ti(e) {
  const t = e.currentTarget;
  if (t != null && t._ripple) {
    if (window.clearTimeout(t._ripple.showTimer), e.type === "touchend" && t._ripple.showTimerCommit) {
      t._ripple.showTimerCommit(), t._ripple.showTimerCommit = null, t._ripple.showTimer = window.setTimeout(() => {
        Ti(e);
      });
      return;
    }
    window.setTimeout(() => {
      t._ripple && (t._ripple.touched = !1);
    }), nh.hide(t);
  }
}
function jx(e) {
  const t = e.currentTarget;
  t != null && t._ripple && (t._ripple.showTimerCommit && (t._ripple.showTimerCommit = null), window.clearTimeout(t._ripple.showTimer));
}
let wc = !1;
function Hx(e) {
  !wc && (e.keyCode === jb.enter || e.keyCode === jb.space) && (wc = !0, bc(e));
}
function zx(e) {
  wc = !1, Ti(e);
}
function Ux(e) {
  wc && (wc = !1, Ti(e));
}
function qx(e, t, n) {
  const {
    value: i,
    modifiers: r
  } = t, s = Wx(i);
  if (s || nh.hide(e), e._ripple = e._ripple ?? {}, e._ripple.enabled = s, e._ripple.centered = r.center, e._ripple.circle = r.circle, Wu(i) && i.class && (e._ripple.class = i.class), s && !n) {
    if (r.stop) {
      e.addEventListener("touchstart", P_, {
        passive: !0
      }), e.addEventListener("mousedown", P_);
      return;
    }
    e.addEventListener("touchstart", bc, {
      passive: !0
    }), e.addEventListener("touchend", Ti, {
      passive: !0
    }), e.addEventListener("touchmove", jx, {
      passive: !0
    }), e.addEventListener("touchcancel", Ti), e.addEventListener("mousedown", bc), e.addEventListener("mouseup", Ti), e.addEventListener("mouseleave", Ti), e.addEventListener("keydown", Hx), e.addEventListener("keyup", zx), e.addEventListener("blur", Ux), e.addEventListener("dragstart", Ti, {
      passive: !0
    });
  } else
    !s && n && Gx(e);
}
function Gx(e) {
  e.removeEventListener("mousedown", bc), e.removeEventListener("touchstart", bc), e.removeEventListener("touchend", Ti), e.removeEventListener("touchmove", jx), e.removeEventListener("touchcancel", Ti), e.removeEventListener("mouseup", Ti), e.removeEventListener("mouseleave", Ti), e.removeEventListener("keydown", Hx), e.removeEventListener("keyup", zx), e.removeEventListener("dragstart", Ti), e.removeEventListener("blur", Ux);
}
function Gq(e, t) {
  qx(e, t, !1);
}
function Yq(e) {
  delete e._ripple, Gx(e);
}
function Zq(e, t) {
  if (t.value === t.oldValue)
    return;
  const n = Wx(t.oldValue);
  qx(e, t, n);
}
const Os = {
  mounted: Gq,
  unmounted: Yq,
  updated: Zq
}, sm = B({
  active: {
    type: Boolean,
    default: void 0
  },
  baseColor: String,
  symbol: {
    type: null,
    default: Xy
  },
  flat: Boolean,
  icon: [Boolean, String, Function, Object],
  prependIcon: We,
  appendIcon: We,
  block: Boolean,
  readonly: Boolean,
  slim: Boolean,
  stacked: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  text: String,
  ...Ni(),
  ...ke(),
  ...bn(),
  ...wn(),
  ...mn(),
  ...Oo(),
  ...ph(),
  ...ua(),
  ...nu(),
  ...It(),
  ...id(),
  ...Kr(),
  ...je({
    tag: "button"
  }),
  ...Qe(),
  ...tr({
    variant: "elevated"
  })
}, "VBtn"), st = J()({
  name: "VBtn",
  props: sm(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      themeClasses: r
    } = lt(e), {
      borderClasses: s
    } = er(e), {
      densityClasses: a
    } = Kn(e), {
      dimensionStyles: o
    } = _n(e), {
      elevationClasses: l
    } = In(e), {
      loaderClasses: u
    } = Ic(e), {
      locationStyles: c
    } = po(e), {
      positionClasses: d
    } = iu(e), {
      roundedClasses: f
    } = Ht(e), {
      sizeClasses: h,
      sizeStyles: m
    } = Fl(e), g = Po(e, e.symbol, !1), p = nd(e, n), y = w(() => {
      var I;
      return e.active !== void 0 ? e.active : p.isLink.value ? (I = p.isActive) == null ? void 0 : I.value : g == null ? void 0 : g.isSelected.value;
    }), k = w(() => {
      var E, O;
      return {
        color: (g == null ? void 0 : g.isSelected.value) && (!p.isLink.value || ((E = p.isActive) == null ? void 0 : E.value)) || !g || ((O = p.isActive) == null ? void 0 : O.value) ? e.color ?? e.baseColor : e.baseColor,
        variant: e.variant
      };
    }), {
      colorClasses: T,
      colorStyles: _,
      variantClasses: b
    } = Io(k), S = w(() => (g == null ? void 0 : g.disabled.value) || e.disabled), C = w(() => e.variant === "elevated" && !(e.disabled || e.flat || e.border)), x = w(() => {
      if (!(e.value === void 0 || typeof e.value == "symbol"))
        return Object(e.value) === e.value ? JSON.stringify(e.value, null, 0) : e.value;
    });
    function A(I) {
      var E;
      S.value || p.isLink.value && (I.metaKey || I.ctrlKey || I.shiftKey || I.button !== 0 || n.target === "_blank") || ((E = p.navigate) == null || E.call(p, I), g == null || g.toggle());
    }
    return zq(p, g == null ? void 0 : g.select), ie(() => {
      const I = p.isLink.value ? "a" : e.tag, E = !!(e.prependIcon || i.prepend), O = !!(e.appendIcon || i.append), V = !!(e.icon && e.icon !== !0);
      return Rt(v(I, {
        type: I === "a" ? void 0 : "button",
        class: ["v-btn", g == null ? void 0 : g.selectedClass.value, {
          "v-btn--active": y.value,
          "v-btn--block": e.block,
          "v-btn--disabled": S.value,
          "v-btn--elevated": C.value,
          "v-btn--flat": e.flat,
          "v-btn--icon": !!e.icon,
          "v-btn--loading": e.loading,
          "v-btn--readonly": e.readonly,
          "v-btn--slim": e.slim,
          "v-btn--stacked": e.stacked
        }, r.value, s.value, T.value, a.value, l.value, u.value, d.value, f.value, h.value, b.value, e.class],
        style: [_.value, o.value, c.value, m.value, e.style],
        "aria-busy": e.loading ? !0 : void 0,
        disabled: S.value || void 0,
        href: p.href.value,
        tabindex: e.loading || e.readonly ? -1 : void 0,
        onClick: A,
        value: x.value
      }, {
        default: () => {
          var N;
          return [fa(!0, "v-btn"), !e.icon && E && v("span", {
            key: "prepend",
            class: "v-btn__prepend"
          }, [i.prepend ? v(Ze, {
            key: "prepend-defaults",
            disabled: !e.prependIcon,
            defaults: {
              VIcon: {
                icon: e.prependIcon
              }
            }
          }, i.prepend) : v(at, {
            key: "prepend-icon",
            icon: e.prependIcon
          }, null)]), v("span", {
            class: "v-btn__content",
            "data-no-activator": ""
          }, [!i.default && V ? v(at, {
            key: "content-icon",
            icon: e.icon
          }, null) : v(Ze, {
            key: "content-defaults",
            disabled: !V,
            defaults: {
              VIcon: {
                icon: e.icon
              }
            }
          }, {
            default: () => {
              var F;
              return [((F = i.default) == null ? void 0 : F.call(i)) ?? e.text];
            }
          })]), !e.icon && O && v("span", {
            key: "append",
            class: "v-btn__append"
          }, [i.append ? v(Ze, {
            key: "append-defaults",
            disabled: !e.appendIcon,
            defaults: {
              VIcon: {
                icon: e.appendIcon
              }
            }
          }, i.append) : v(at, {
            key: "append-icon",
            icon: e.appendIcon
          }, null)]), !!e.loading && v("span", {
            key: "loader",
            class: "v-btn__loader"
          }, [((N = i.loader) == null ? void 0 : N.call(i)) ?? v(Vl, {
            color: typeof e.loading == "boolean" ? void 0 : e.loading,
            indeterminate: !0,
            width: "2"
          }, null)])];
        }
      }), [[Os, !S.value && !!e.ripple, "", {
        center: !!e.icon
      }]]);
    }), {
      group: g
    };
  }
}), Kq = B({
  ...sm({
    icon: "$menu",
    variant: "text"
  })
}, "VAppBarNavIcon"), Xq = J()({
  name: "VAppBarNavIcon",
  props: Kq(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ie(() => v(st, se(e, {
      class: ["v-app-bar-nav-icon"]
    }), n)), {};
  }
}), Jq = J()({
  name: "VAppBarTitle",
  props: Dx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ie(() => v(Ky, se(e, {
      class: "v-app-bar-title"
    }), n)), {};
  }
});
const Yx = Yr("v-alert-title"), Qq = ["success", "info", "warning", "error"], e6 = B({
  border: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || ["top", "end", "bottom", "start"].includes(e)
  },
  borderColor: String,
  closable: Boolean,
  closeIcon: {
    type: We,
    default: "$close"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  icon: {
    type: [Boolean, String, Function, Object],
    default: null
  },
  modelValue: {
    type: Boolean,
    default: !0
  },
  prominent: Boolean,
  title: String,
  text: String,
  type: {
    type: String,
    validator: (e) => Qq.includes(e)
  },
  ...ke(),
  ...bn(),
  ...wn(),
  ...mn(),
  ...ua(),
  ...nu(),
  ...It(),
  ...je(),
  ...Qe(),
  ...tr({
    variant: "flat"
  })
}, "VAlert"), t6 = J()({
  name: "VAlert",
  props: e6(),
  emits: {
    "click:close": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const r = Ee(e, "modelValue"), s = w(() => {
      if (e.icon !== !1)
        return e.type ? e.icon ?? `$${e.type}` : e.icon;
    }), a = w(() => ({
      color: e.color ?? e.type,
      variant: e.variant
    })), {
      themeClasses: o
    } = lt(e), {
      colorClasses: l,
      colorStyles: u,
      variantClasses: c
    } = Io(a), {
      densityClasses: d
    } = Kn(e), {
      dimensionStyles: f
    } = _n(e), {
      elevationClasses: h
    } = In(e), {
      locationStyles: m
    } = po(e), {
      positionClasses: g
    } = iu(e), {
      roundedClasses: p
    } = Ht(e), {
      textColorClasses: y,
      textColorStyles: k
    } = Ln(G(e, "borderColor")), {
      t: T
    } = qt(), _ = w(() => ({
      "aria-label": T(e.closeLabel),
      onClick(b) {
        r.value = !1, n("click:close", b);
      }
    }));
    return () => {
      const b = !!(i.prepend || s.value), S = !!(i.title || e.title), C = !!(i.close || e.closable);
      return r.value && v(e.tag, {
        class: ["v-alert", e.border && {
          "v-alert--border": !!e.border,
          [`v-alert--border-${e.border === !0 ? "start" : e.border}`]: !0
        }, {
          "v-alert--prominent": e.prominent
        }, o.value, l.value, d.value, h.value, g.value, p.value, c.value, e.class],
        style: [u.value, f.value, m.value, e.style],
        role: "alert"
      }, {
        default: () => {
          var x, A;
          return [fa(!1, "v-alert"), e.border && v("div", {
            key: "border",
            class: ["v-alert__border", y.value],
            style: k.value
          }, null), b && v("div", {
            key: "prepend",
            class: "v-alert__prepend"
          }, [i.prepend ? v(Ze, {
            key: "prepend-defaults",
            disabled: !s.value,
            defaults: {
              VIcon: {
                density: e.density,
                icon: s.value,
                size: e.prominent ? 44 : 28
              }
            }
          }, i.prepend) : v(at, {
            key: "prepend-icon",
            density: e.density,
            icon: s.value,
            size: e.prominent ? 44 : 28
          }, null)]), v("div", {
            class: "v-alert__content"
          }, [S && v(Yx, {
            key: "title"
          }, {
            default: () => {
              var I;
              return [((I = i.title) == null ? void 0 : I.call(i)) ?? e.title];
            }
          }), ((x = i.text) == null ? void 0 : x.call(i)) ?? e.text, (A = i.default) == null ? void 0 : A.call(i)]), i.append && v("div", {
            key: "append",
            class: "v-alert__append"
          }, [i.append()]), C && v("div", {
            key: "close",
            class: "v-alert__close"
          }, [i.close ? v(Ze, {
            key: "close-defaults",
            defaults: {
              VBtn: {
                icon: e.closeIcon,
                size: "x-small",
                variant: "text"
              }
            }
          }, {
            default: () => {
              var I;
              return [(I = i.close) == null ? void 0 : I.call(i, {
                props: _.value
              })];
            }
          }) : v(st, se({
            key: "close-btn",
            icon: e.closeIcon,
            size: "x-small",
            variant: "text"
          }, _.value), null)])];
        }
      });
    };
  }
});
const n6 = B({
  start: Boolean,
  end: Boolean,
  icon: We,
  image: String,
  text: String,
  ...ke(),
  ...bn(),
  ...It(),
  ...Kr(),
  ...je(),
  ...Qe(),
  ...tr({
    variant: "flat"
  })
}, "VAvatar"), Ji = J()({
  name: "VAvatar",
  props: n6(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      colorClasses: r,
      colorStyles: s,
      variantClasses: a
    } = Io(e), {
      densityClasses: o
    } = Kn(e), {
      roundedClasses: l
    } = Ht(e), {
      sizeClasses: u,
      sizeStyles: c
    } = Fl(e);
    return ie(() => v(e.tag, {
      class: ["v-avatar", {
        "v-avatar--start": e.start,
        "v-avatar--end": e.end
      }, i.value, r.value, o.value, l.value, u.value, a.value, e.class],
      style: [s.value, c.value, e.style]
    }, {
      default: () => [n.default ? v(Ze, {
        key: "content-defaults",
        defaults: {
          VImg: {
            cover: !0,
            image: e.image
          },
          VIcon: {
            icon: e.icon
          }
        }
      }, {
        default: () => [n.default()]
      }) : e.image ? v(_s, {
        key: "image",
        src: e.image,
        alt: "",
        cover: !0
      }, null) : e.icon ? v(at, {
        key: "icon",
        icon: e.icon
      }, null) : e.text, fa(!1, "v-avatar")]
    })), {};
  }
});
const Zx = Symbol.for("vuetify:selection-control-group"), Jy = B({
  color: String,
  disabled: {
    type: Boolean,
    default: null
  },
  defaultsTarget: String,
  error: Boolean,
  id: String,
  inline: Boolean,
  falseIcon: We,
  trueIcon: We,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: {
    type: Boolean,
    default: null
  },
  modelValue: null,
  type: String,
  valueComparator: {
    type: Function,
    default: Gr
  },
  ...ke(),
  ...bn(),
  ...Qe()
}, "SelectionControlGroup"), i6 = B({
  ...Jy({
    defaultsTarget: "VSelectionControl"
  })
}, "VSelectionControlGroup"), Kx = J()({
  name: "VSelectionControlGroup",
  props: i6(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), r = An(), s = w(() => e.id || `v-selection-control-group-${r}`), a = w(() => e.name || s.value), o = /* @__PURE__ */ new Set();
    return Tt(Zx, {
      modelValue: i,
      forceUpdate: () => {
        o.forEach((l) => l());
      },
      onForceUpdate: (l) => {
        o.add(l), Wn(() => {
          o.delete(l);
        });
      }
    }), jt({
      [e.defaultsTarget]: {
        color: G(e, "color"),
        disabled: G(e, "disabled"),
        density: G(e, "density"),
        error: G(e, "error"),
        inline: G(e, "inline"),
        modelValue: i,
        multiple: w(() => !!e.multiple || e.multiple == null && Array.isArray(i.value)),
        name: a,
        falseIcon: G(e, "falseIcon"),
        trueIcon: G(e, "trueIcon"),
        readonly: G(e, "readonly"),
        ripple: G(e, "ripple"),
        type: G(e, "type"),
        valueComparator: G(e, "valueComparator")
      }
    }), ie(() => {
      var l;
      return v("div", {
        class: ["v-selection-control-group", {
          "v-selection-control-group--inline": e.inline
        }, e.class],
        style: e.style,
        role: e.type === "radio" ? "radiogroup" : void 0
      }, [(l = n.default) == null ? void 0 : l.call(n)]);
    }), {};
  }
}), am = B({
  label: String,
  baseColor: String,
  trueValue: null,
  falseValue: null,
  value: null,
  ...ke(),
  ...Jy()
}, "VSelectionControl");
function r6(e) {
  const t = tt(Zx, void 0), {
    densityClasses: n
  } = Kn(e), i = Ee(e, "modelValue"), r = w(() => e.trueValue !== void 0 ? e.trueValue : e.value !== void 0 ? e.value : !0), s = w(() => e.falseValue !== void 0 ? e.falseValue : !1), a = w(() => !!e.multiple || e.multiple == null && Array.isArray(i.value)), o = w({
    get() {
      const h = t ? t.modelValue.value : i.value;
      return a.value ? Nt(h).some((m) => e.valueComparator(m, r.value)) : e.valueComparator(h, r.value);
    },
    set(h) {
      if (e.readonly)
        return;
      const m = h ? r.value : s.value;
      let g = m;
      a.value && (g = h ? [...Nt(i.value), m] : Nt(i.value).filter((p) => !e.valueComparator(p, r.value))), t ? t.modelValue.value = g : i.value = g;
    }
  }), {
    textColorClasses: l,
    textColorStyles: u
  } = Ln(w(() => {
    if (!(e.error || e.disabled))
      return o.value ? e.color : e.baseColor;
  })), {
    backgroundColorClasses: c,
    backgroundColorStyles: d
  } = gt(w(() => o.value && !e.error && !e.disabled ? e.color : e.baseColor)), f = w(() => o.value ? e.trueIcon : e.falseIcon);
  return {
    group: t,
    densityClasses: n,
    trueValue: r,
    falseValue: s,
    model: o,
    textColorClasses: l,
    textColorStyles: u,
    backgroundColorClasses: c,
    backgroundColorStyles: d,
    icon: f
  };
}
const uo = J()({
  name: "VSelectionControl",
  directives: {
    Ripple: Os
  },
  inheritAttrs: !1,
  props: am(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      group: r,
      densityClasses: s,
      icon: a,
      model: o,
      textColorClasses: l,
      textColorStyles: u,
      backgroundColorClasses: c,
      backgroundColorStyles: d,
      trueValue: f
    } = r6(e), h = An(), m = pe(!1), g = pe(!1), p = X(), y = w(() => e.id || `input-${h}`), k = w(() => !e.disabled && !e.readonly);
    r == null || r.onForceUpdate(() => {
      p.value && (p.value.checked = o.value);
    });
    function T(C) {
      k.value && (m.value = !0, vl(C.target, ":focus-visible") !== !1 && (g.value = !0));
    }
    function _() {
      m.value = !1, g.value = !1;
    }
    function b(C) {
      C.stopPropagation();
    }
    function S(C) {
      k.value && (e.readonly && r && He(() => r.forceUpdate()), o.value = C.target.checked);
    }
    return ie(() => {
      var E, O;
      const C = i.label ? i.label({
        label: e.label,
        props: {
          for: y.value
        }
      }) : e.label, [x, A] = la(n), I = v("input", se({
        ref: p,
        checked: o.value,
        disabled: !!e.disabled,
        id: y.value,
        onBlur: _,
        onFocus: T,
        onInput: S,
        "aria-disabled": !!e.disabled,
        "aria-label": e.label,
        type: e.type,
        value: f.value,
        name: e.name,
        "aria-checked": e.type === "checkbox" ? o.value : void 0
      }, A), null);
      return v("div", se({
        class: ["v-selection-control", {
          "v-selection-control--dirty": o.value,
          "v-selection-control--disabled": e.disabled,
          "v-selection-control--error": e.error,
          "v-selection-control--focused": m.value,
          "v-selection-control--focus-visible": g.value,
          "v-selection-control--inline": e.inline
        }, s.value, e.class]
      }, x, {
        style: e.style
      }), [v("div", {
        class: ["v-selection-control__wrapper", l.value],
        style: u.value
      }, [(E = i.default) == null ? void 0 : E.call(i, {
        backgroundColorClasses: c,
        backgroundColorStyles: d
      }), Rt(v("div", {
        class: ["v-selection-control__input"]
      }, [((O = i.input) == null ? void 0 : O.call(i, {
        model: o,
        textColorClasses: l,
        textColorStyles: u,
        backgroundColorClasses: c,
        backgroundColorStyles: d,
        inputNode: I,
        icon: a.value,
        props: {
          onFocus: T,
          onBlur: _,
          id: y.value
        }
      })) ?? v(De, null, [a.value && v(at, {
        key: "icon",
        icon: a.value
      }, null), I])]), [[Ei("ripple"), e.ripple && [!e.disabled && !e.readonly, null, ["center", "circle"]]]])]), C && v(Rl, {
        for: y.value,
        onClick: b
      }, {
        default: () => [C]
      })]);
    }), {
      isFocused: m,
      input: p
    };
  }
}), Xx = B({
  indeterminate: Boolean,
  indeterminateIcon: {
    type: We,
    default: "$checkboxIndeterminate"
  },
  ...am({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })
}, "VCheckboxBtn"), Ss = J()({
  name: "VCheckboxBtn",
  props: Xx(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:indeterminate": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "indeterminate"), r = Ee(e, "modelValue");
    function s(l) {
      i.value && (i.value = !1);
    }
    const a = w(() => i.value ? e.indeterminateIcon : e.falseIcon), o = w(() => i.value ? e.indeterminateIcon : e.trueIcon);
    return ie(() => {
      const l = sn(uo.filterProps(e), ["modelValue"]);
      return v(uo, se(l, {
        modelValue: r.value,
        "onUpdate:modelValue": [(u) => r.value = u, s],
        class: ["v-checkbox-btn", e.class],
        style: e.style,
        type: "checkbox",
        falseIcon: a.value,
        trueIcon: o.value,
        "aria-checked": i.value ? "mixed" : void 0
      }), n);
    }), {};
  }
}), s6 = B({
  ...Ts(),
  ...sn(Xx(), ["inline"])
}, "VCheckbox"), a6 = J()({
  name: "VCheckbox",
  inheritAttrs: !1,
  props: s6(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:focused": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const r = Ee(e, "modelValue"), {
      isFocused: s,
      focus: a,
      blur: o
    } = Cs(e), l = An(), u = w(() => e.id || `checkbox-${l}`);
    return ie(() => {
      const [c, d] = la(n), f = $n.filterProps(e), h = Ss.filterProps(e);
      return v($n, se({
        class: ["v-checkbox", e.class]
      }, c, f, {
        modelValue: r.value,
        "onUpdate:modelValue": (m) => r.value = m,
        id: u.value,
        focused: s.value,
        style: e.style
      }), {
        ...i,
        default: (m) => {
          let {
            id: g,
            messagesId: p,
            isDisabled: y,
            isReadonly: k,
            isValid: T
          } = m;
          return v(Ss, se(h, {
            id: g.value,
            "aria-describedby": p.value,
            disabled: y.value,
            readonly: k.value
          }, d, {
            error: T.value === !1,
            modelValue: r.value,
            "onUpdate:modelValue": (_) => r.value = _,
            onFocus: a,
            onBlur: o
          }), i);
        }
      });
    }), {};
  }
});
function o6(e) {
  let {
    selectedElement: t,
    containerElement: n,
    isRtl: i,
    isHorizontal: r
  } = e;
  const s = _c(r, n), a = Jx(r, i, n), o = _c(r, t), l = Qx(r, t), u = o * 0.4;
  return a > l ? l - u : a + s < l + o ? l - s + o + u : a;
}
function l6(e) {
  let {
    selectedElement: t,
    containerElement: n,
    isHorizontal: i
  } = e;
  const r = _c(i, n), s = Qx(i, t), a = _c(i, t);
  return s - r / 2 + a / 2;
}
function V_(e, t) {
  const n = e ? "scrollWidth" : "scrollHeight";
  return (t == null ? void 0 : t[n]) || 0;
}
function u6(e, t) {
  const n = e ? "clientWidth" : "clientHeight";
  return (t == null ? void 0 : t[n]) || 0;
}
function Jx(e, t, n) {
  if (!n)
    return 0;
  const {
    scrollLeft: i,
    offsetWidth: r,
    scrollWidth: s
  } = n;
  return e ? t ? s - r + i : i : n.scrollTop;
}
function _c(e, t) {
  const n = e ? "offsetWidth" : "offsetHeight";
  return (t == null ? void 0 : t[n]) || 0;
}
function Qx(e, t) {
  const n = e ? "offsetLeft" : "offsetTop";
  return (t == null ? void 0 : t[n]) || 0;
}
const eA = Symbol.for("vuetify:v-slide-group"), Qy = B({
  centerActive: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  symbol: {
    type: null,
    default: eA
  },
  nextIcon: {
    type: We,
    default: "$next"
  },
  prevIcon: {
    type: We,
    default: "$prev"
  },
  showArrows: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || ["always", "desktop", "mobile"].includes(e)
  },
  ...ke(),
  ...Ll({
    mobile: null
  }),
  ...je(),
  ...Eo({
    selectedClass: "v-slide-group-item--active"
  })
}, "VSlideGroup"), Sc = J()({
  name: "VSlideGroup",
  props: Qy(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isRtl: i
    } = yn(), {
      displayClasses: r,
      mobile: s
    } = xr(e), a = ha(e, e.symbol), o = pe(!1), l = pe(0), u = pe(0), c = pe(0), d = w(() => e.direction === "horizontal"), {
      resizeRef: f,
      contentRect: h
    } = _r(), {
      resizeRef: m,
      contentRect: g
    } = _r(), p = kV(), y = w(() => ({
      container: f.el,
      duration: 200,
      easing: "easeOutQuart"
    })), k = w(() => a.selected.value.length ? a.items.value.findIndex((R) => R.id === a.selected.value[0]) : -1), T = w(() => a.selected.value.length ? a.items.value.findIndex((R) => R.id === a.selected.value[a.selected.value.length - 1]) : -1);
    if (ft) {
      let R = -1;
      fe(() => [a.selected.value, h.value, g.value, d.value], () => {
        cancelAnimationFrame(R), R = requestAnimationFrame(() => {
          if (h.value && g.value) {
            const L = d.value ? "width" : "height";
            u.value = h.value[L], c.value = g.value[L], o.value = u.value + 1 < c.value;
          }
          if (k.value >= 0 && m.el) {
            const L = m.el.children[T.value];
            b(L, e.centerActive);
          }
        });
      });
    }
    const _ = pe(!1);
    function b(R, L) {
      let ne = 0;
      L ? ne = l6({
        containerElement: f.el,
        isHorizontal: d.value,
        selectedElement: R
      }) : ne = o6({
        containerElement: f.el,
        isHorizontal: d.value,
        isRtl: i.value,
        selectedElement: R
      }), S(ne);
    }
    function S(R) {
      if (!ft || !f.el)
        return;
      const L = _c(d.value, f.el), ne = Jx(d.value, i.value, f.el);
      if (!(V_(d.value, f.el) <= L || // Prevent scrolling by only a couple of pixels, which doesn't look smooth
      Math.abs(R - ne) < 16)) {
        if (d.value && i.value && f.el) {
          const {
            scrollWidth: we,
            offsetWidth: ee
          } = f.el;
          R = we - ee - R;
        }
        d.value ? p.horizontal(R, y.value) : p(R, y.value);
      }
    }
    function C(R) {
      const {
        scrollTop: L,
        scrollLeft: ne
      } = R.target;
      l.value = d.value ? ne : L;
    }
    function x(R) {
      if (_.value = !0, !(!o.value || !m.el)) {
        for (const L of R.composedPath())
          for (const ne of m.el.children)
            if (ne === L) {
              b(ne);
              return;
            }
      }
    }
    function A(R) {
      _.value = !1;
    }
    let I = !1;
    function E(R) {
      var L;
      !I && !_.value && !(R.relatedTarget && ((L = m.el) != null && L.contains(R.relatedTarget))) && N(), I = !1;
    }
    function O() {
      I = !0;
    }
    function V(R) {
      if (!m.el)
        return;
      function L(ne) {
        R.preventDefault(), N(ne);
      }
      d.value ? R.key === "ArrowRight" ? L(i.value ? "prev" : "next") : R.key === "ArrowLeft" && L(i.value ? "next" : "prev") : R.key === "ArrowDown" ? L("next") : R.key === "ArrowUp" && L("prev"), R.key === "Home" ? L("first") : R.key === "End" && L("last");
    }
    function N(R) {
      var ne, oe;
      if (!m.el)
        return;
      let L;
      if (!R)
        L = ju(m.el)[0];
      else if (R === "next") {
        if (L = (ne = m.el.querySelector(":focus")) == null ? void 0 : ne.nextElementSibling, !L)
          return N("first");
      } else if (R === "prev") {
        if (L = (oe = m.el.querySelector(":focus")) == null ? void 0 : oe.previousElementSibling, !L)
          return N("last");
      } else
        R === "first" ? L = m.el.firstElementChild : R === "last" && (L = m.el.lastElementChild);
      L && L.focus({
        preventScroll: !0
      });
    }
    function F(R) {
      const L = d.value && i.value ? -1 : 1, ne = (R === "prev" ? -L : L) * u.value;
      let oe = l.value + ne;
      if (d.value && i.value && f.el) {
        const {
          scrollWidth: we,
          offsetWidth: ee
        } = f.el;
        oe += we - ee;
      }
      S(oe);
    }
    const $ = w(() => ({
      next: a.next,
      prev: a.prev,
      select: a.select,
      isSelected: a.isSelected
    })), Z = w(() => {
      switch (e.showArrows) {
        case "always":
          return !0;
        case "desktop":
          return !s.value;
        case !0:
          return o.value || Math.abs(l.value) > 0;
        case "mobile":
          return s.value || o.value || Math.abs(l.value) > 0;
        default:
          return !s.value && (o.value || Math.abs(l.value) > 0);
      }
    }), j = w(() => Math.abs(l.value) > 1), H = w(() => {
      if (!f.value)
        return !1;
      const R = V_(d.value, f.el), L = u6(d.value, f.el);
      return R - L - Math.abs(l.value) > 1;
    });
    return ie(() => v(e.tag, {
      class: ["v-slide-group", {
        "v-slide-group--vertical": !d.value,
        "v-slide-group--has-affixes": Z.value,
        "v-slide-group--is-overflowing": o.value
      }, r.value, e.class],
      style: e.style,
      tabindex: _.value || a.selected.value.length ? -1 : 0,
      onFocus: E
    }, {
      default: () => {
        var R, L, ne;
        return [Z.value && v("div", {
          key: "prev",
          class: ["v-slide-group__prev", {
            "v-slide-group__prev--disabled": !j.value
          }],
          onMousedown: O,
          onClick: () => j.value && F("prev")
        }, [((R = n.prev) == null ? void 0 : R.call(n, $.value)) ?? v(zu, null, {
          default: () => [v(at, {
            icon: i.value ? e.nextIcon : e.prevIcon
          }, null)]
        })]), v("div", {
          key: "container",
          ref: f,
          class: "v-slide-group__container",
          onScroll: C
        }, [v("div", {
          ref: m,
          class: "v-slide-group__content",
          onFocusin: x,
          onFocusout: A,
          onKeydown: V
        }, [(L = n.default) == null ? void 0 : L.call(n, $.value)])]), Z.value && v("div", {
          key: "next",
          class: ["v-slide-group__next", {
            "v-slide-group__next--disabled": !H.value
          }],
          onMousedown: O,
          onClick: () => H.value && F("next")
        }, [((ne = n.next) == null ? void 0 : ne.call(n, $.value)) ?? v(zu, null, {
          default: () => [v(at, {
            icon: i.value ? e.prevIcon : e.nextIcon
          }, null)]
        })])];
      }
    })), {
      selected: a.selected,
      scrollTo: F,
      scrollOffset: l,
      focus: N
    };
  }
}), tA = Symbol.for("vuetify:v-chip-group"), c6 = B({
  column: Boolean,
  filter: Boolean,
  valueComparator: {
    type: Function,
    default: Gr
  },
  ...Qy(),
  ...ke(),
  ...Eo({
    selectedClass: "v-chip--selected"
  }),
  ...je(),
  ...Qe(),
  ...tr({
    variant: "tonal"
  })
}, "VChipGroup"), d6 = J()({
  name: "VChipGroup",
  props: c6(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      isSelected: r,
      select: s,
      next: a,
      prev: o,
      selected: l
    } = ha(e, tA);
    return jt({
      VChip: {
        color: G(e, "color"),
        disabled: G(e, "disabled"),
        filter: G(e, "filter"),
        variant: G(e, "variant")
      }
    }), ie(() => {
      const u = Sc.filterProps(e);
      return v(Sc, se(u, {
        class: ["v-chip-group", {
          "v-chip-group--column": e.column
        }, i.value, e.class],
        style: e.style
      }), {
        default: () => {
          var c;
          return [(c = n.default) == null ? void 0 : c.call(n, {
            isSelected: r,
            select: s,
            next: a,
            prev: o,
            selected: l.value
          })];
        }
      });
    }), {};
  }
}), f6 = B({
  activeClass: String,
  appendAvatar: String,
  appendIcon: We,
  closable: Boolean,
  closeIcon: {
    type: We,
    default: "$delete"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  draggable: Boolean,
  filter: Boolean,
  filterIcon: {
    type: String,
    default: "$complete"
  },
  label: Boolean,
  link: {
    type: Boolean,
    default: void 0
  },
  pill: Boolean,
  prependAvatar: String,
  prependIcon: We,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  text: String,
  modelValue: {
    type: Boolean,
    default: !0
  },
  onClick: ri(),
  onClickOnce: ri(),
  ...Ni(),
  ...ke(),
  ...bn(),
  ...mn(),
  ...Oo(),
  ...It(),
  ...id(),
  ...Kr(),
  ...je({
    tag: "span"
  }),
  ...Qe(),
  ...tr({
    variant: "tonal"
  })
}, "VChip"), ru = J()({
  name: "VChip",
  directives: {
    Ripple: Os
  },
  props: f6(),
  emits: {
    "click:close": (e) => !0,
    "update:modelValue": (e) => !0,
    "group:selected": (e) => !0,
    click: (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const {
      t: s
    } = qt(), {
      borderClasses: a
    } = er(e), {
      colorClasses: o,
      colorStyles: l,
      variantClasses: u
    } = Io(e), {
      densityClasses: c
    } = Kn(e), {
      elevationClasses: d
    } = In(e), {
      roundedClasses: f
    } = Ht(e), {
      sizeClasses: h
    } = Fl(e), {
      themeClasses: m
    } = lt(e), g = Ee(e, "modelValue"), p = Po(e, tA, !1), y = nd(e, n), k = w(() => e.link !== !1 && y.isLink.value), T = w(() => !e.disabled && e.link !== !1 && (!!p || e.link || y.isClickable.value)), _ = w(() => ({
      "aria-label": s(e.closeLabel),
      onClick(C) {
        C.preventDefault(), C.stopPropagation(), g.value = !1, i("click:close", C);
      }
    }));
    function b(C) {
      var x;
      i("click", C), T.value && ((x = y.navigate) == null || x.call(y, C), p == null || p.toggle());
    }
    function S(C) {
      (C.key === "Enter" || C.key === " ") && (C.preventDefault(), b(C));
    }
    return () => {
      const C = y.isLink.value ? "a" : e.tag, x = !!(e.appendIcon || e.appendAvatar), A = !!(x || r.append), I = !!(r.close || e.closable), E = !!(r.filter || e.filter) && p, O = !!(e.prependIcon || e.prependAvatar), V = !!(O || r.prepend), N = !p || p.isSelected.value;
      return g.value && Rt(v(C, {
        class: ["v-chip", {
          "v-chip--disabled": e.disabled,
          "v-chip--label": e.label,
          "v-chip--link": T.value,
          "v-chip--filter": E,
          "v-chip--pill": e.pill
        }, m.value, a.value, N ? o.value : void 0, c.value, d.value, f.value, h.value, u.value, p == null ? void 0 : p.selectedClass.value, e.class],
        style: [N ? l.value : void 0, e.style],
        disabled: e.disabled || void 0,
        draggable: e.draggable,
        href: y.href.value,
        tabindex: T.value ? 0 : void 0,
        onClick: b,
        onKeydown: T.value && !k.value && S
      }, {
        default: () => {
          var F;
          return [fa(T.value, "v-chip"), E && v(mp, {
            key: "filter"
          }, {
            default: () => [Rt(v("div", {
              class: "v-chip__filter"
            }, [r.filter ? v(Ze, {
              key: "filter-defaults",
              disabled: !e.filterIcon,
              defaults: {
                VIcon: {
                  icon: e.filterIcon
                }
              }
            }, r.filter) : v(at, {
              key: "filter-icon",
              icon: e.filterIcon
            }, null)]), [[Cr, p.isSelected.value]])]
          }), V && v("div", {
            key: "prepend",
            class: "v-chip__prepend"
          }, [r.prepend ? v(Ze, {
            key: "prepend-defaults",
            disabled: !O,
            defaults: {
              VAvatar: {
                image: e.prependAvatar,
                start: !0
              },
              VIcon: {
                icon: e.prependIcon,
                start: !0
              }
            }
          }, r.prepend) : v(De, null, [e.prependIcon && v(at, {
            key: "prepend-icon",
            icon: e.prependIcon,
            start: !0
          }, null), e.prependAvatar && v(Ji, {
            key: "prepend-avatar",
            image: e.prependAvatar,
            start: !0
          }, null)])]), v("div", {
            class: "v-chip__content",
            "data-no-activator": ""
          }, [((F = r.default) == null ? void 0 : F.call(r, {
            isSelected: p == null ? void 0 : p.isSelected.value,
            selectedClass: p == null ? void 0 : p.selectedClass.value,
            select: p == null ? void 0 : p.select,
            toggle: p == null ? void 0 : p.toggle,
            value: p == null ? void 0 : p.value.value,
            disabled: e.disabled
          })) ?? e.text]), A && v("div", {
            key: "append",
            class: "v-chip__append"
          }, [r.append ? v(Ze, {
            key: "append-defaults",
            disabled: !x,
            defaults: {
              VAvatar: {
                end: !0,
                image: e.appendAvatar
              },
              VIcon: {
                end: !0,
                icon: e.appendIcon
              }
            }
          }, r.append) : v(De, null, [e.appendIcon && v(at, {
            key: "append-icon",
            end: !0,
            icon: e.appendIcon
          }, null), e.appendAvatar && v(Ji, {
            key: "append-avatar",
            end: !0,
            image: e.appendAvatar
          }, null)])]), I && v("button", se({
            key: "close",
            class: "v-chip__close",
            type: "button"
          }, _.value), [r.close ? v(Ze, {
            key: "close-defaults",
            defaults: {
              VIcon: {
                icon: e.closeIcon,
                size: "x-small"
              }
            }
          }, r.close) : v(at, {
            key: "close-icon",
            icon: e.closeIcon,
            size: "x-small"
          }, null)])];
        }
      }), [[Ei("ripple"), T.value && e.ripple, null]]);
    };
  }
});
const Pg = Symbol.for("vuetify:list");
function nA() {
  const e = tt(Pg, {
    hasPrepend: pe(!1),
    updateHasPrepend: () => null
  }), t = {
    hasPrepend: pe(!1),
    updateHasPrepend: (n) => {
      n && (t.hasPrepend.value = n);
    }
  };
  return Tt(Pg, t), e;
}
function iA() {
  return tt(Pg, null);
}
const eb = (e) => {
  const t = {
    activate: (n) => {
      let {
        id: i,
        value: r,
        activated: s
      } = n;
      return i = si(i), e && !r && s.size === 1 && s.has(i) || (r ? s.add(i) : s.delete(i)), s;
    },
    in: (n, i, r) => {
      let s = /* @__PURE__ */ new Set();
      if (n != null)
        for (const a of Nt(n))
          s = t.activate({
            id: a,
            value: !0,
            activated: new Set(s),
            children: i,
            parents: r
          });
      return s;
    },
    out: (n) => Array.from(n)
  };
  return t;
}, rA = (e) => {
  const t = eb(e);
  return {
    activate: (i) => {
      let {
        activated: r,
        id: s,
        ...a
      } = i;
      s = si(s);
      const o = r.has(s) ? /* @__PURE__ */ new Set([s]) : /* @__PURE__ */ new Set();
      return t.activate({
        ...a,
        id: s,
        activated: o
      });
    },
    in: (i, r, s) => {
      let a = /* @__PURE__ */ new Set();
      if (i != null) {
        const o = Nt(i);
        o.length && (a = t.in(o.slice(0, 1), r, s));
      }
      return a;
    },
    out: (i, r, s) => t.out(i, r, s)
  };
}, h6 = (e) => {
  const t = eb(e);
  return {
    activate: (i) => {
      let {
        id: r,
        activated: s,
        children: a,
        ...o
      } = i;
      return r = si(r), a.has(r) ? s : t.activate({
        id: r,
        activated: s,
        children: a,
        ...o
      });
    },
    in: t.in,
    out: t.out
  };
}, m6 = (e) => {
  const t = rA(e);
  return {
    activate: (i) => {
      let {
        id: r,
        activated: s,
        children: a,
        ...o
      } = i;
      return r = si(r), a.has(r) ? s : t.activate({
        id: r,
        activated: s,
        children: a,
        ...o
      });
    },
    in: t.in,
    out: t.out
  };
}, v6 = {
  open: (e) => {
    let {
      id: t,
      value: n,
      opened: i,
      parents: r
    } = e;
    if (n) {
      const s = /* @__PURE__ */ new Set();
      s.add(t);
      let a = r.get(t);
      for (; a != null; )
        s.add(a), a = r.get(a);
      return s;
    } else
      return i.delete(t), i;
  },
  select: () => null
}, sA = {
  open: (e) => {
    let {
      id: t,
      value: n,
      opened: i,
      parents: r
    } = e;
    if (n) {
      let s = r.get(t);
      for (i.add(t); s != null && s !== t; )
        i.add(s), s = r.get(s);
      return i;
    } else
      i.delete(t);
    return i;
  },
  select: () => null
}, g6 = {
  open: sA.open,
  select: (e) => {
    let {
      id: t,
      value: n,
      opened: i,
      parents: r
    } = e;
    if (!n)
      return i;
    const s = [];
    let a = r.get(t);
    for (; a != null; )
      s.push(a), a = r.get(a);
    return new Set(s);
  }
}, tb = (e) => {
  const t = {
    select: (n) => {
      let {
        id: i,
        value: r,
        selected: s
      } = n;
      if (i = si(i), e && !r) {
        const a = Array.from(s.entries()).reduce((o, l) => {
          let [u, c] = l;
          return c === "on" && o.push(u), o;
        }, []);
        if (a.length === 1 && a[0] === i)
          return s;
      }
      return s.set(i, r ? "on" : "off"), s;
    },
    in: (n, i, r) => {
      let s = /* @__PURE__ */ new Map();
      for (const a of n || [])
        s = t.select({
          id: a,
          value: !0,
          selected: new Map(s),
          children: i,
          parents: r
        });
      return s;
    },
    out: (n) => {
      const i = [];
      for (const [r, s] of n.entries())
        s === "on" && i.push(r);
      return i;
    }
  };
  return t;
}, aA = (e) => {
  const t = tb(e);
  return {
    select: (i) => {
      let {
        selected: r,
        id: s,
        ...a
      } = i;
      s = si(s);
      const o = r.has(s) ? /* @__PURE__ */ new Map([[s, r.get(s)]]) : /* @__PURE__ */ new Map();
      return t.select({
        ...a,
        id: s,
        selected: o
      });
    },
    in: (i, r, s) => {
      let a = /* @__PURE__ */ new Map();
      return i != null && i.length && (a = t.in(i.slice(0, 1), r, s)), a;
    },
    out: (i, r, s) => t.out(i, r, s)
  };
}, p6 = (e) => {
  const t = tb(e);
  return {
    select: (i) => {
      let {
        id: r,
        selected: s,
        children: a,
        ...o
      } = i;
      return r = si(r), a.has(r) ? s : t.select({
        id: r,
        selected: s,
        children: a,
        ...o
      });
    },
    in: t.in,
    out: t.out
  };
}, y6 = (e) => {
  const t = aA(e);
  return {
    select: (i) => {
      let {
        id: r,
        selected: s,
        children: a,
        ...o
      } = i;
      return r = si(r), a.has(r) ? s : t.select({
        id: r,
        selected: s,
        children: a,
        ...o
      });
    },
    in: t.in,
    out: t.out
  };
}, b6 = (e) => {
  const t = {
    select: (n) => {
      let {
        id: i,
        value: r,
        selected: s,
        children: a,
        parents: o
      } = n;
      i = si(i);
      const l = new Map(s), u = [i];
      for (; u.length; ) {
        const d = u.shift();
        s.set(d, r ? "on" : "off"), a.has(d) && u.push(...a.get(d));
      }
      let c = o.get(i);
      for (; c; ) {
        const d = a.get(c), f = d.every((m) => s.get(m) === "on"), h = d.every((m) => !s.has(m) || s.get(m) === "off");
        s.set(c, f ? "on" : h ? "off" : "indeterminate"), c = o.get(c);
      }
      return e && !r && Array.from(s.entries()).reduce((f, h) => {
        let [m, g] = h;
        return g === "on" && f.push(m), f;
      }, []).length === 0 ? l : s;
    },
    in: (n, i, r) => {
      let s = /* @__PURE__ */ new Map();
      for (const a of n || [])
        s = t.select({
          id: a,
          value: !0,
          selected: new Map(s),
          children: i,
          parents: r
        });
      return s;
    },
    out: (n, i) => {
      const r = [];
      for (const [s, a] of n.entries())
        a === "on" && !i.has(s) && r.push(s);
      return r;
    }
  };
  return t;
}, kc = Symbol.for("vuetify:nested"), oA = {
  id: pe(),
  root: {
    register: () => null,
    unregister: () => null,
    parents: X(/* @__PURE__ */ new Map()),
    children: X(/* @__PURE__ */ new Map()),
    open: () => null,
    openOnSelect: () => null,
    activate: () => null,
    select: () => null,
    activatable: X(!1),
    selectable: X(!1),
    opened: X(/* @__PURE__ */ new Set()),
    activated: X(/* @__PURE__ */ new Set()),
    selected: X(/* @__PURE__ */ new Map()),
    selectedValues: X([])
  }
}, w6 = B({
  activatable: Boolean,
  selectable: Boolean,
  activeStrategy: [String, Function, Object],
  selectStrategy: [String, Function, Object],
  openStrategy: [String, Object],
  opened: null,
  activated: null,
  selected: null,
  mandatory: Boolean
}, "nested"), _6 = (e) => {
  let t = !1;
  const n = X(/* @__PURE__ */ new Map()), i = X(/* @__PURE__ */ new Map()), r = Ee(e, "opened", e.opened, (h) => new Set(h), (h) => [...h.values()]), s = w(() => {
    if (typeof e.activeStrategy == "object")
      return e.activeStrategy;
    if (typeof e.activeStrategy == "function")
      return e.activeStrategy(e.mandatory);
    switch (e.activeStrategy) {
      case "leaf":
        return h6(e.mandatory);
      case "single-leaf":
        return m6(e.mandatory);
      case "independent":
        return eb(e.mandatory);
      case "single-independent":
      default:
        return rA(e.mandatory);
    }
  }), a = w(() => {
    if (typeof e.selectStrategy == "object")
      return e.selectStrategy;
    if (typeof e.selectStrategy == "function")
      return e.selectStrategy(e.mandatory);
    switch (e.selectStrategy) {
      case "single-leaf":
        return y6(e.mandatory);
      case "leaf":
        return p6(e.mandatory);
      case "independent":
        return tb(e.mandatory);
      case "single-independent":
        return aA(e.mandatory);
      case "classic":
      default:
        return b6(e.mandatory);
    }
  }), o = w(() => {
    if (typeof e.openStrategy == "object")
      return e.openStrategy;
    switch (e.openStrategy) {
      case "list":
        return g6;
      case "single":
        return v6;
      case "multiple":
      default:
        return sA;
    }
  }), l = Ee(e, "activated", e.activated, (h) => s.value.in(h, n.value, i.value), (h) => s.value.out(h, n.value, i.value)), u = Ee(e, "selected", e.selected, (h) => a.value.in(h, n.value, i.value), (h) => a.value.out(h, n.value, i.value));
  ai(() => {
    t = !0;
  });
  function c(h) {
    const m = [];
    let g = h;
    for (; g != null; )
      m.unshift(g), g = i.value.get(g);
    return m;
  }
  const d = Ut("nested"), f = {
    id: pe(),
    root: {
      opened: r,
      activatable: G(e, "activatable"),
      selectable: G(e, "selectable"),
      activated: l,
      selected: u,
      selectedValues: w(() => {
        const h = [];
        for (const [m, g] of u.value.entries())
          g === "on" && h.push(m);
        return h;
      }),
      register: (h, m, g) => {
        m && h !== m && i.value.set(h, m), g && n.value.set(h, []), m != null && n.value.set(m, [...n.value.get(m) || [], h]);
      },
      unregister: (h) => {
        if (t)
          return;
        n.value.delete(h);
        const m = i.value.get(h);
        if (m) {
          const g = n.value.get(m) ?? [];
          n.value.set(m, g.filter((p) => p !== h));
        }
        i.value.delete(h), r.value.delete(h);
      },
      open: (h, m, g) => {
        d.emit("click:open", {
          id: h,
          value: m,
          path: c(h),
          event: g
        });
        const p = o.value.open({
          id: h,
          value: m,
          opened: new Set(r.value),
          children: n.value,
          parents: i.value,
          event: g
        });
        p && (r.value = p);
      },
      openOnSelect: (h, m, g) => {
        const p = o.value.select({
          id: h,
          value: m,
          selected: new Map(u.value),
          opened: new Set(r.value),
          children: n.value,
          parents: i.value,
          event: g
        });
        p && (r.value = p);
      },
      select: (h, m, g) => {
        d.emit("click:select", {
          id: h,
          value: m,
          path: c(h),
          event: g
        });
        const p = a.value.select({
          id: h,
          value: m,
          selected: new Map(u.value),
          children: n.value,
          parents: i.value,
          event: g
        });
        p && (u.value = p), f.root.openOnSelect(h, m, g);
      },
      activate: (h, m, g) => {
        if (!e.activatable)
          return f.root.select(h, !0, g);
        d.emit("click:activate", {
          id: h,
          value: m,
          path: c(h),
          event: g
        });
        const p = s.value.activate({
          id: h,
          value: m,
          activated: new Set(l.value),
          children: n.value,
          parents: i.value,
          event: g
        });
        p && (l.value = p);
      },
      children: n,
      parents: i
    }
  };
  return Tt(kc, f), f.root;
}, lA = (e, t) => {
  const n = tt(kc, oA), i = Symbol(An()), r = w(() => e.value !== void 0 ? e.value : i), s = {
    ...n,
    id: r,
    open: (a, o) => n.root.open(r.value, a, o),
    openOnSelect: (a, o) => n.root.openOnSelect(r.value, a, o),
    isOpen: w(() => n.root.opened.value.has(r.value)),
    parent: w(() => n.root.parents.value.get(r.value)),
    activate: (a, o) => n.root.activate(r.value, a, o),
    isActivated: w(() => n.root.activated.value.has(si(r.value))),
    select: (a, o) => n.root.select(r.value, a, o),
    isSelected: w(() => n.root.selected.value.get(si(r.value)) === "on"),
    isIndeterminate: w(() => n.root.selected.value.get(r.value) === "indeterminate"),
    isLeaf: w(() => !n.root.children.value.get(r.value)),
    isGroupActivator: n.isGroupActivator
  };
  return !n.isGroupActivator && n.root.register(r.value, n.id.value, t), ai(() => {
    !n.isGroupActivator && n.root.unregister(r.value);
  }), t && Tt(kc, s), s;
}, S6 = () => {
  const e = tt(kc, oA);
  Tt(kc, {
    ...e,
    isGroupActivator: !0
  });
}, k6 = Oi({
  name: "VListGroupActivator",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return S6(), () => {
      var i;
      return (i = n.default) == null ? void 0 : i.call(n);
    };
  }
}), C6 = B({
  /* @deprecated */
  activeColor: String,
  baseColor: String,
  color: String,
  collapseIcon: {
    type: We,
    default: "$collapse"
  },
  expandIcon: {
    type: We,
    default: "$expand"
  },
  prependIcon: We,
  appendIcon: We,
  fluid: Boolean,
  subgroup: Boolean,
  title: String,
  value: null,
  ...ke(),
  ...je()
}, "VListGroup"), Vg = J()({
  name: "VListGroup",
  props: C6(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isOpen: i,
      open: r,
      id: s
    } = lA(G(e, "value"), !0), a = w(() => `v-list-group--id-${String(s.value)}`), o = iA(), {
      isBooted: l
    } = Ao();
    function u(h) {
      r(!i.value, h);
    }
    const c = w(() => ({
      onClick: u,
      class: "v-list-group__header",
      id: a.value
    })), d = w(() => i.value ? e.collapseIcon : e.expandIcon), f = w(() => ({
      VListItem: {
        active: i.value,
        activeColor: e.activeColor,
        baseColor: e.baseColor,
        color: e.color,
        prependIcon: e.prependIcon || e.subgroup && d.value,
        appendIcon: e.appendIcon || !e.subgroup && d.value,
        title: e.title,
        value: e.value
      }
    }));
    return ie(() => v(e.tag, {
      class: ["v-list-group", {
        "v-list-group--prepend": o == null ? void 0 : o.hasPrepend.value,
        "v-list-group--fluid": e.fluid,
        "v-list-group--subgroup": e.subgroup,
        "v-list-group--open": i.value
      }, e.class],
      style: e.style
    }, {
      default: () => [n.activator && v(Ze, {
        defaults: f.value
      }, {
        default: () => [v(k6, null, {
          default: () => [n.activator({
            props: c.value,
            isOpen: i.value
          })]
        })]
      }), v(Gn, {
        transition: {
          component: fh
        },
        disabled: !l.value
      }, {
        default: () => {
          var h;
          return [Rt(v("div", {
            class: "v-list-group__items",
            role: "group",
            "aria-labelledby": a.value
          }, [(h = n.default) == null ? void 0 : h.call(n)]), [[Cr, i.value]])];
        }
      })]
    })), {
      isOpen: i
    };
  }
});
const T6 = B({
  opacity: [Number, String],
  ...ke(),
  ...je()
}, "VListItemSubtitle"), uA = J()({
  name: "VListItemSubtitle",
  props: T6(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ie(() => v(e.tag, {
      class: ["v-list-item-subtitle", e.class],
      style: [{
        "--v-list-item-subtitle-opacity": e.opacity
      }, e.style]
    }, n)), {};
  }
}), cA = Yr("v-list-item-title"), x6 = B({
  active: {
    type: Boolean,
    default: void 0
  },
  activeClass: String,
  /* @deprecated */
  activeColor: String,
  appendAvatar: String,
  appendIcon: We,
  baseColor: String,
  disabled: Boolean,
  lines: [Boolean, String],
  link: {
    type: Boolean,
    default: void 0
  },
  nav: Boolean,
  prependAvatar: String,
  prependIcon: We,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  slim: Boolean,
  subtitle: [String, Number],
  title: [String, Number],
  value: null,
  onClick: ri(),
  onClickOnce: ri(),
  ...Ni(),
  ...ke(),
  ...bn(),
  ...wn(),
  ...mn(),
  ...It(),
  ...id(),
  ...je(),
  ...Qe(),
  ...tr({
    variant: "text"
  })
}, "VListItem"), ks = J()({
  name: "VListItem",
  directives: {
    Ripple: Os
  },
  props: x6(),
  emits: {
    click: (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i,
      emit: r
    } = t;
    const s = nd(e, n), a = w(() => e.value === void 0 ? s.href.value : e.value), {
      activate: o,
      isActivated: l,
      select: u,
      isSelected: c,
      isIndeterminate: d,
      isGroupActivator: f,
      root: h,
      parent: m,
      openOnSelect: g
    } = lA(a, !1), p = iA(), y = w(() => {
      var R;
      return e.active !== !1 && (e.active || ((R = s.isActive) == null ? void 0 : R.value) || (h.activatable.value ? l.value : c.value));
    }), k = w(() => e.link !== !1 && s.isLink.value), T = w(() => !e.disabled && e.link !== !1 && (e.link || s.isClickable.value || !!p && (h.selectable.value || h.activatable.value || e.value != null))), _ = w(() => e.rounded || e.nav), b = w(() => e.color ?? e.activeColor), S = w(() => ({
      color: y.value ? b.value ?? e.baseColor : e.baseColor,
      variant: e.variant
    }));
    fe(() => {
      var R;
      return (R = s.isActive) == null ? void 0 : R.value;
    }, (R) => {
      R && m.value != null && h.open(m.value, !0), R && g(R);
    }, {
      immediate: !0
    });
    const {
      themeClasses: C
    } = lt(e), {
      borderClasses: x
    } = er(e), {
      colorClasses: A,
      colorStyles: I,
      variantClasses: E
    } = Io(S), {
      densityClasses: O
    } = Kn(e), {
      dimensionStyles: V
    } = _n(e), {
      elevationClasses: N
    } = In(e), {
      roundedClasses: F
    } = Ht(_), $ = w(() => e.lines ? `v-list-item--${e.lines}-line` : void 0), Z = w(() => ({
      isActive: y.value,
      select: u,
      isSelected: c.value,
      isIndeterminate: d.value
    }));
    function j(R) {
      var L;
      r("click", R), T.value && ((L = s.navigate) == null || L.call(s, R), !f && (h.activatable.value ? o(!l.value, R) : (h.selectable.value || e.value != null) && u(!c.value, R)));
    }
    function H(R) {
      (R.key === "Enter" || R.key === " ") && (R.preventDefault(), j(R));
    }
    return ie(() => {
      const R = k.value ? "a" : e.tag, L = i.title || e.title != null, ne = i.subtitle || e.subtitle != null, oe = !!(e.appendAvatar || e.appendIcon), we = !!(oe || i.append), ee = !!(e.prependAvatar || e.prependIcon), K = !!(ee || i.prepend);
      return p == null || p.updateHasPrepend(K), e.activeColor && CO("active-color", ["color", "base-color"]), Rt(v(R, {
        class: ["v-list-item", {
          "v-list-item--active": y.value,
          "v-list-item--disabled": e.disabled,
          "v-list-item--link": T.value,
          "v-list-item--nav": e.nav,
          "v-list-item--prepend": !K && (p == null ? void 0 : p.hasPrepend.value),
          "v-list-item--slim": e.slim,
          [`${e.activeClass}`]: e.activeClass && y.value
        }, C.value, x.value, A.value, O.value, N.value, $.value, F.value, E.value, e.class],
        style: [I.value, V.value, e.style],
        href: s.href.value,
        tabindex: T.value ? p ? -2 : 0 : void 0,
        onClick: j,
        onKeydown: T.value && !k.value && H
      }, {
        default: () => {
          var ue;
          return [fa(T.value || y.value, "v-list-item"), K && v("div", {
            key: "prepend",
            class: "v-list-item__prepend"
          }, [i.prepend ? v(Ze, {
            key: "prepend-defaults",
            disabled: !ee,
            defaults: {
              VAvatar: {
                density: e.density,
                image: e.prependAvatar
              },
              VIcon: {
                density: e.density,
                icon: e.prependIcon
              },
              VListItemAction: {
                start: !0
              }
            }
          }, {
            default: () => {
              var ve;
              return [(ve = i.prepend) == null ? void 0 : ve.call(i, Z.value)];
            }
          }) : v(De, null, [e.prependAvatar && v(Ji, {
            key: "prepend-avatar",
            density: e.density,
            image: e.prependAvatar
          }, null), e.prependIcon && v(at, {
            key: "prepend-icon",
            density: e.density,
            icon: e.prependIcon
          }, null)]), v("div", {
            class: "v-list-item__spacer"
          }, null)]), v("div", {
            class: "v-list-item__content",
            "data-no-activator": ""
          }, [L && v(cA, {
            key: "title"
          }, {
            default: () => {
              var ve;
              return [((ve = i.title) == null ? void 0 : ve.call(i, {
                title: e.title
              })) ?? e.title];
            }
          }), ne && v(uA, {
            key: "subtitle"
          }, {
            default: () => {
              var ve;
              return [((ve = i.subtitle) == null ? void 0 : ve.call(i, {
                subtitle: e.subtitle
              })) ?? e.subtitle];
            }
          }), (ue = i.default) == null ? void 0 : ue.call(i, Z.value)]), we && v("div", {
            key: "append",
            class: "v-list-item__append"
          }, [i.append ? v(Ze, {
            key: "append-defaults",
            disabled: !oe,
            defaults: {
              VAvatar: {
                density: e.density,
                image: e.appendAvatar
              },
              VIcon: {
                density: e.density,
                icon: e.appendIcon
              },
              VListItemAction: {
                end: !0
              }
            }
          }, {
            default: () => {
              var ve;
              return [(ve = i.append) == null ? void 0 : ve.call(i, Z.value)];
            }
          }) : v(De, null, [e.appendIcon && v(at, {
            key: "append-icon",
            density: e.density,
            icon: e.appendIcon
          }, null), e.appendAvatar && v(Ji, {
            key: "append-avatar",
            density: e.density,
            image: e.appendAvatar
          }, null)]), v("div", {
            class: "v-list-item__spacer"
          }, null)])];
        }
      }), [[Ei("ripple"), T.value && e.ripple]]);
    }), {
      isGroupActivator: f,
      isSelected: c,
      list: p,
      select: u
    };
  }
}), A6 = B({
  color: String,
  inset: Boolean,
  sticky: Boolean,
  title: String,
  ...ke(),
  ...je()
}, "VListSubheader"), dA = J()({
  name: "VListSubheader",
  props: A6(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      textColorClasses: i,
      textColorStyles: r
    } = Ln(G(e, "color"));
    return ie(() => {
      const s = !!(n.default || e.title);
      return v(e.tag, {
        class: ["v-list-subheader", {
          "v-list-subheader--inset": e.inset,
          "v-list-subheader--sticky": e.sticky
        }, i.value, e.class],
        style: [{
          textColorStyles: r
        }, e.style]
      }, {
        default: () => {
          var a;
          return [s && v("div", {
            class: "v-list-subheader__text"
          }, [((a = n.default) == null ? void 0 : a.call(n)) ?? e.title])];
        }
      });
    }), {};
  }
});
const I6 = B({
  color: String,
  inset: Boolean,
  length: [Number, String],
  opacity: [Number, String],
  thickness: [Number, String],
  vertical: Boolean,
  ...ke(),
  ...Qe()
}, "VDivider"), rd = J()({
  name: "VDivider",
  props: I6(),
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      themeClasses: r
    } = lt(e), {
      textColorClasses: s,
      textColorStyles: a
    } = Ln(G(e, "color")), o = w(() => {
      const l = {};
      return e.length && (l[e.vertical ? "maxHeight" : "maxWidth"] = _e(e.length)), e.thickness && (l[e.vertical ? "borderRightWidth" : "borderTopWidth"] = _e(e.thickness)), l;
    });
    return ie(() => {
      const l = v("hr", {
        class: [{
          "v-divider": !0,
          "v-divider--inset": e.inset,
          "v-divider--vertical": e.vertical
        }, r.value, s.value, e.class],
        style: [o.value, a.value, {
          "--v-border-opacity": e.opacity
        }, e.style],
        "aria-orientation": !n.role || n.role === "separator" ? e.vertical ? "vertical" : "horizontal" : void 0,
        role: `${n.role || "separator"}`
      }, null);
      return i.default ? v("div", {
        class: ["v-divider__wrapper", {
          "v-divider__wrapper--vertical": e.vertical,
          "v-divider__wrapper--inset": e.inset
        }]
      }, [l, v("div", {
        class: "v-divider__content"
      }, [i.default()]), l]) : l;
    }), {};
  }
}), E6 = B({
  items: Array,
  returnObject: Boolean
}, "VListChildren"), fA = J()({
  name: "VListChildren",
  props: E6(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return nA(), () => {
      var i, r;
      return ((i = n.default) == null ? void 0 : i.call(n)) ?? ((r = e.items) == null ? void 0 : r.map((s) => {
        var f, h;
        let {
          children: a,
          props: o,
          type: l,
          raw: u
        } = s;
        if (l === "divider")
          return ((f = n.divider) == null ? void 0 : f.call(n, {
            props: o
          })) ?? v(rd, o, null);
        if (l === "subheader")
          return ((h = n.subheader) == null ? void 0 : h.call(n, {
            props: o
          })) ?? v(dA, o, null);
        const c = {
          subtitle: n.subtitle ? (m) => {
            var g;
            return (g = n.subtitle) == null ? void 0 : g.call(n, {
              ...m,
              item: u
            });
          } : void 0,
          prepend: n.prepend ? (m) => {
            var g;
            return (g = n.prepend) == null ? void 0 : g.call(n, {
              ...m,
              item: u
            });
          } : void 0,
          append: n.append ? (m) => {
            var g;
            return (g = n.append) == null ? void 0 : g.call(n, {
              ...m,
              item: u
            });
          } : void 0,
          title: n.title ? (m) => {
            var g;
            return (g = n.title) == null ? void 0 : g.call(n, {
              ...m,
              item: u
            });
          } : void 0
        }, d = Vg.filterProps(o);
        return a ? v(Vg, se({
          value: o == null ? void 0 : o.value
        }, d), {
          activator: (m) => {
            let {
              props: g
            } = m;
            const p = {
              ...o,
              ...g,
              value: e.returnObject ? u : o.value
            };
            return n.header ? n.header({
              props: p
            }) : v(ks, p, c);
          },
          default: () => v(fA, {
            items: a,
            returnObject: e.returnObject
          }, n)
        }) : n.item ? n.item({
          props: o
        }) : v(ks, se(o, {
          value: e.returnObject ? u : o.value
        }), c);
      }));
    };
  }
}), hA = B({
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: [String, Array, Function],
    default: "title"
  },
  itemValue: {
    type: [String, Array, Function],
    default: "value"
  },
  itemChildren: {
    type: [Boolean, String, Array, Function],
    default: "children"
  },
  itemProps: {
    type: [Boolean, String, Array, Function],
    default: "props"
  },
  returnObject: Boolean,
  valueComparator: {
    type: Function,
    default: Gr
  }
}, "list-items");
function Gs(e, t) {
  const n = dn(t, e.itemTitle, t), i = dn(t, e.itemValue, n), r = dn(t, e.itemChildren), s = e.itemProps === !0 ? typeof t == "object" && t != null && !Array.isArray(t) ? "children" in t ? sn(t, ["children"]) : t : void 0 : dn(t, e.itemProps), a = {
    title: n,
    value: i,
    ...s
  };
  return {
    title: String(a.title ?? ""),
    value: a.value,
    props: a,
    children: Array.isArray(r) ? mA(e, r) : void 0,
    raw: t
  };
}
function mA(e, t) {
  const n = [];
  for (const i of t)
    n.push(Gs(e, i));
  return n;
}
function nb(e) {
  const t = w(() => mA(e, e.items)), n = w(() => t.value.some((s) => s.value === null));
  function i(s) {
    return n.value || (s = s.filter((a) => a !== null)), s.map((a) => e.returnObject && typeof a == "string" ? Gs(e, a) : t.value.find((o) => e.valueComparator(a, o.value)) || Gs(e, a));
  }
  function r(s) {
    return e.returnObject ? s.map((a) => {
      let {
        raw: o
      } = a;
      return o;
    }) : s.map((a) => {
      let {
        value: o
      } = a;
      return o;
    });
  }
  return {
    items: t,
    transformIn: i,
    transformOut: r
  };
}
function O6(e) {
  return typeof e == "string" || typeof e == "number" || typeof e == "boolean";
}
function P6(e, t) {
  const n = dn(t, e.itemType, "item"), i = O6(t) ? t : dn(t, e.itemTitle), r = dn(t, e.itemValue, void 0), s = dn(t, e.itemChildren), a = e.itemProps === !0 ? sn(t, ["children"]) : dn(t, e.itemProps), o = {
    title: i,
    value: r,
    ...a
  };
  return {
    type: n,
    title: o.title,
    value: o.value,
    props: o,
    children: n === "item" && s ? vA(e, s) : void 0,
    raw: t
  };
}
function vA(e, t) {
  const n = [];
  for (const i of t)
    n.push(P6(e, i));
  return n;
}
function V6(e) {
  return {
    items: w(() => vA(e, e.items))
  };
}
const D6 = B({
  baseColor: String,
  /* @deprecated */
  activeColor: String,
  activeClass: String,
  bgColor: String,
  disabled: Boolean,
  expandIcon: String,
  collapseIcon: String,
  lines: {
    type: [Boolean, String],
    default: "one"
  },
  slim: Boolean,
  nav: Boolean,
  ...w6({
    selectStrategy: "single-leaf",
    openStrategy: "list"
  }),
  ...Ni(),
  ...ke(),
  ...bn(),
  ...wn(),
  ...mn(),
  itemType: {
    type: String,
    default: "type"
  },
  ...hA(),
  ...It(),
  ...je(),
  ...Qe(),
  ...tr({
    variant: "text"
  })
}, "VList"), om = J()({
  name: "VList",
  props: D6(),
  emits: {
    "update:selected": (e) => !0,
    "update:activated": (e) => !0,
    "update:opened": (e) => !0,
    "click:open": (e) => !0,
    "click:activate": (e) => !0,
    "click:select": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      items: i
    } = V6(e), {
      themeClasses: r
    } = lt(e), {
      backgroundColorClasses: s,
      backgroundColorStyles: a
    } = gt(G(e, "bgColor")), {
      borderClasses: o
    } = er(e), {
      densityClasses: l
    } = Kn(e), {
      dimensionStyles: u
    } = _n(e), {
      elevationClasses: c
    } = In(e), {
      roundedClasses: d
    } = Ht(e), {
      children: f,
      open: h,
      parents: m,
      select: g
    } = _6(e), p = w(() => e.lines ? `v-list--${e.lines}-line` : void 0), y = G(e, "activeColor"), k = G(e, "baseColor"), T = G(e, "color");
    nA(), jt({
      VListGroup: {
        activeColor: y,
        baseColor: k,
        color: T,
        expandIcon: G(e, "expandIcon"),
        collapseIcon: G(e, "collapseIcon")
      },
      VListItem: {
        activeClass: G(e, "activeClass"),
        activeColor: y,
        baseColor: k,
        color: T,
        density: G(e, "density"),
        disabled: G(e, "disabled"),
        lines: G(e, "lines"),
        nav: G(e, "nav"),
        slim: G(e, "slim"),
        variant: G(e, "variant")
      }
    });
    const _ = pe(!1), b = X();
    function S(O) {
      _.value = !0;
    }
    function C(O) {
      _.value = !1;
    }
    function x(O) {
      var V;
      !_.value && !(O.relatedTarget && ((V = b.value) != null && V.contains(O.relatedTarget))) && E();
    }
    function A(O) {
      const V = O.target;
      if (!(!b.value || ["INPUT", "TEXTAREA"].includes(V.tagName))) {
        if (O.key === "ArrowDown")
          E("next");
        else if (O.key === "ArrowUp")
          E("prev");
        else if (O.key === "Home")
          E("first");
        else if (O.key === "End")
          E("last");
        else
          return;
        O.preventDefault();
      }
    }
    function I(O) {
      _.value = !0;
    }
    function E(O) {
      if (b.value)
        return ml(b.value, O);
    }
    return ie(() => v(e.tag, {
      ref: b,
      class: ["v-list", {
        "v-list--disabled": e.disabled,
        "v-list--nav": e.nav,
        "v-list--slim": e.slim
      }, r.value, s.value, o.value, l.value, c.value, p.value, d.value, e.class],
      style: [a.value, u.value, e.style],
      tabindex: e.disabled || _.value ? -1 : 0,
      role: "listbox",
      "aria-activedescendant": void 0,
      onFocusin: S,
      onFocusout: C,
      onFocus: x,
      onKeydown: A,
      onMousedown: I
    }, {
      default: () => [v(fA, {
        items: i.value,
        returnObject: e.returnObject
      }, n)]
    })), {
      open: h,
      select: g,
      focus: E,
      children: f,
      parents: m
    };
  }
}), N6 = Yr("v-list-img"), M6 = B({
  start: Boolean,
  end: Boolean,
  ...ke(),
  ...je()
}, "VListItemAction"), R6 = J()({
  name: "VListItemAction",
  props: M6(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ie(() => v(e.tag, {
      class: ["v-list-item-action", {
        "v-list-item-action--start": e.start,
        "v-list-item-action--end": e.end
      }, e.class],
      style: e.style
    }, n)), {};
  }
}), F6 = B({
  start: Boolean,
  end: Boolean,
  ...ke(),
  ...je()
}, "VListItemMedia"), B6 = J()({
  name: "VListItemMedia",
  props: F6(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ie(() => v(e.tag, {
      class: ["v-list-item-media", {
        "v-list-item-media--start": e.start,
        "v-list-item-media--end": e.end
      }, e.class],
      style: e.style
    }, n)), {};
  }
});
function _v(e, t) {
  return {
    x: e.x + t.x,
    y: e.y + t.y
  };
}
function L6(e, t) {
  return {
    x: e.x - t.x,
    y: e.y - t.y
  };
}
function D_(e, t) {
  if (e.side === "top" || e.side === "bottom") {
    const {
      side: n,
      align: i
    } = e, r = i === "left" ? 0 : i === "center" ? t.width / 2 : i === "right" ? t.width : i, s = n === "top" ? 0 : n === "bottom" ? t.height : n;
    return _v({
      x: r,
      y: s
    }, t);
  } else if (e.side === "left" || e.side === "right") {
    const {
      side: n,
      align: i
    } = e, r = n === "left" ? 0 : n === "right" ? t.width : n, s = i === "top" ? 0 : i === "center" ? t.height / 2 : i === "bottom" ? t.height : i;
    return _v({
      x: r,
      y: s
    }, t);
  }
  return _v({
    x: t.width / 2,
    y: t.height / 2
  }, t);
}
const gA = {
  static: j6,
  // specific viewport position, usually centered
  connected: z6
  // connected to a certain element
}, $6 = B({
  locationStrategy: {
    type: [String, Function],
    default: "static",
    validator: (e) => typeof e == "function" || e in gA
  },
  location: {
    type: String,
    default: "bottom"
  },
  origin: {
    type: String,
    default: "auto"
  },
  offset: [Number, String, Array]
}, "VOverlay-location-strategies");
function W6(e, t) {
  const n = X({}), i = X();
  ft && vi(() => !!(t.isActive.value && e.locationStrategy), (s) => {
    var a, o;
    fe(() => e.locationStrategy, s), Wn(() => {
      window.removeEventListener("resize", r), i.value = void 0;
    }), window.addEventListener("resize", r, {
      passive: !0
    }), typeof e.locationStrategy == "function" ? i.value = (a = e.locationStrategy(t, e, n)) == null ? void 0 : a.updateLocation : i.value = (o = gA[e.locationStrategy](t, e, n)) == null ? void 0 : o.updateLocation;
  });
  function r(s) {
    var a;
    (a = i.value) == null || a.call(i, s);
  }
  return {
    contentStyles: n,
    updateLocation: i
  };
}
function j6() {
}
function H6(e, t) {
  t ? e.style.removeProperty("left") : e.style.removeProperty("right");
  const n = sp(e);
  return t ? n.x += parseFloat(e.style.right || 0) : n.x -= parseFloat(e.style.left || 0), n.y -= parseFloat(e.style.top || 0), n;
}
function z6(e, t, n) {
  (Array.isArray(e.target.value) || zO(e.target.value)) && Object.assign(n.value, {
    position: "fixed",
    top: 0,
    [e.isRtl.value ? "right" : "left"]: 0
  });
  const {
    preferredAnchor: r,
    preferredOrigin: s
  } = ip(() => {
    const m = Av(t.location, e.isRtl.value), g = t.origin === "overlap" ? m : t.origin === "auto" ? $m(m) : Av(t.origin, e.isRtl.value);
    return m.side === g.side && m.align === Wm(g).align ? {
      preferredAnchor: Zb(m),
      preferredOrigin: Zb(g)
    } : {
      preferredAnchor: m,
      preferredOrigin: g
    };
  }), [a, o, l, u] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((m) => w(() => {
    const g = parseFloat(t[m]);
    return isNaN(g) ? 1 / 0 : g;
  })), c = w(() => {
    if (Array.isArray(t.offset))
      return t.offset;
    if (typeof t.offset == "string") {
      const m = t.offset.split(" ").map(parseFloat);
      return m.length < 2 && m.push(0), m;
    }
    return typeof t.offset == "number" ? [t.offset, 0] : [0, 0];
  });
  let d = !1;
  const f = new ResizeObserver(() => {
    d && h();
  });
  fe([e.target, e.contentEl], (m, g) => {
    let [p, y] = m, [k, T] = g;
    k && !Array.isArray(k) && f.unobserve(k), p && !Array.isArray(p) && f.observe(p), T && f.unobserve(T), y && f.observe(y);
  }, {
    immediate: !0
  }), Wn(() => {
    f.disconnect();
  });
  function h() {
    if (d = !1, requestAnimationFrame(() => d = !0), !e.target.value || !e.contentEl.value)
      return;
    const m = fS(e.target.value), g = H6(e.contentEl.value, e.isRtl.value), p = ff(e.contentEl.value), y = 12;
    p.length || (p.push(document.documentElement), e.contentEl.value.style.top && e.contentEl.value.style.left || (g.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0), g.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0)));
    const k = p.reduce((E, O) => {
      const V = O.getBoundingClientRect(), N = new Wa({
        x: O === document.documentElement ? 0 : V.x,
        y: O === document.documentElement ? 0 : V.y,
        width: O.clientWidth,
        height: O.clientHeight
      });
      return E ? new Wa({
        x: Math.max(E.left, N.left),
        y: Math.max(E.top, N.top),
        width: Math.min(E.right, N.right) - Math.max(E.left, N.left),
        height: Math.min(E.bottom, N.bottom) - Math.max(E.top, N.top)
      }) : N;
    }, void 0);
    k.x += y, k.y += y, k.width -= y * 2, k.height -= y * 2;
    let T = {
      anchor: r.value,
      origin: s.value
    };
    function _(E) {
      const O = new Wa(g), V = D_(E.anchor, m), N = D_(E.origin, O);
      let {
        x: F,
        y: $
      } = L6(V, N);
      switch (E.anchor.side) {
        case "top":
          $ -= c.value[0];
          break;
        case "bottom":
          $ += c.value[0];
          break;
        case "left":
          F -= c.value[0];
          break;
        case "right":
          F += c.value[0];
          break;
      }
      switch (E.anchor.align) {
        case "top":
          $ -= c.value[1];
          break;
        case "bottom":
          $ += c.value[1];
          break;
        case "left":
          F -= c.value[1];
          break;
        case "right":
          F += c.value[1];
          break;
      }
      return O.x += F, O.y += $, O.width = Math.min(O.width, l.value), O.height = Math.min(O.height, u.value), {
        overflows: Xb(O, k),
        x: F,
        y: $
      };
    }
    let b = 0, S = 0;
    const C = {
      x: 0,
      y: 0
    }, x = {
      x: !1,
      y: !1
    };
    let A = -1;
    for (; ; ) {
      if (A++ > 10) {
        cf("Infinite loop detected in connectedLocationStrategy");
        break;
      }
      const {
        x: E,
        y: O,
        overflows: V
      } = _(T);
      b += E, S += O, g.x += E, g.y += O;
      {
        const N = Kb(T.anchor), F = V.x.before || V.x.after, $ = V.y.before || V.y.after;
        let Z = !1;
        if (["x", "y"].forEach((j) => {
          if (j === "x" && F && !x.x || j === "y" && $ && !x.y) {
            const H = {
              anchor: {
                ...T.anchor
              },
              origin: {
                ...T.origin
              }
            }, R = j === "x" ? N === "y" ? Wm : $m : N === "y" ? $m : Wm;
            H.anchor = R(H.anchor), H.origin = R(H.origin);
            const {
              overflows: L
            } = _(H);
            (L[j].before <= V[j].before && L[j].after <= V[j].after || L[j].before + L[j].after < (V[j].before + V[j].after) / 2) && (T = H, Z = x[j] = !0);
          }
        }), Z)
          continue;
      }
      V.x.before && (b += V.x.before, g.x += V.x.before), V.x.after && (b -= V.x.after, g.x -= V.x.after), V.y.before && (S += V.y.before, g.y += V.y.before), V.y.after && (S -= V.y.after, g.y -= V.y.after);
      {
        const N = Xb(g, k);
        C.x = k.width - N.x.before - N.x.after, C.y = k.height - N.y.before - N.y.after, b += N.x.before, g.x += N.x.before, S += N.y.before, g.y += N.y.before;
      }
      break;
    }
    const I = Kb(T.anchor);
    return Object.assign(n.value, {
      "--v-overlay-anchor-origin": `${T.anchor.side} ${T.anchor.align}`,
      transformOrigin: `${T.origin.side} ${T.origin.align}`,
      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,
      top: _e(Sv(S)),
      left: e.isRtl.value ? void 0 : _e(Sv(b)),
      right: e.isRtl.value ? _e(Sv(-b)) : void 0,
      minWidth: _e(I === "y" ? Math.min(a.value, m.width) : a.value),
      maxWidth: _e(N_(Xt(C.x, a.value === 1 / 0 ? 0 : a.value, l.value))),
      maxHeight: _e(N_(Xt(C.y, o.value === 1 / 0 ? 0 : o.value, u.value)))
    }), {
      available: C,
      contentBox: g
    };
  }
  return fe(() => [r.value, s.value, t.offset, t.minWidth, t.minHeight, t.maxWidth, t.maxHeight], () => h()), He(() => {
    const m = h();
    if (!m)
      return;
    const {
      available: g,
      contentBox: p
    } = m;
    p.height > g.y && requestAnimationFrame(() => {
      h(), requestAnimationFrame(() => {
        h();
      });
    });
  }), {
    updateLocation: h
  };
}
function Sv(e) {
  return Math.round(e * devicePixelRatio) / devicePixelRatio;
}
function N_(e) {
  return Math.ceil(e * devicePixelRatio) / devicePixelRatio;
}
let Dg = !0;
const ih = [];
function U6(e) {
  !Dg || ih.length ? (ih.push(e), Ng()) : (Dg = !1, e(), Ng());
}
let M_ = -1;
function Ng() {
  cancelAnimationFrame(M_), M_ = requestAnimationFrame(() => {
    const e = ih.shift();
    e && e(), ih.length ? Ng() : Dg = !0;
  });
}
const sf = {
  none: null,
  close: Y6,
  block: Z6,
  reposition: K6
}, q6 = B({
  scrollStrategy: {
    type: [String, Function],
    default: "block",
    validator: (e) => typeof e == "function" || e in sf
  }
}, "VOverlay-scroll-strategies");
function G6(e, t) {
  if (!ft)
    return;
  let n;
  Wt(async () => {
    n == null || n.stop(), t.isActive.value && e.scrollStrategy && (n = Qg(), await new Promise((i) => setTimeout(i)), n.active && n.run(() => {
      var i;
      typeof e.scrollStrategy == "function" ? e.scrollStrategy(t, e, n) : (i = sf[e.scrollStrategy]) == null || i.call(sf, t, e, n);
    }));
  }), Wn(() => {
    n == null || n.stop();
  });
}
function Y6(e) {
  function t(n) {
    e.isActive.value = !1;
  }
  pA(e.targetEl.value ?? e.contentEl.value, t);
}
function Z6(e, t) {
  var a;
  const n = (a = e.root.value) == null ? void 0 : a.offsetParent, i = [.../* @__PURE__ */ new Set([...ff(e.targetEl.value, t.contained ? n : void 0), ...ff(e.contentEl.value, t.contained ? n : void 0)])].filter((o) => !o.classList.contains("v-overlay-scroll-blocked")), r = window.innerWidth - document.documentElement.offsetWidth, s = ((o) => dp(o) && o)(n || document.documentElement);
  s && e.root.value.classList.add("v-overlay--scroll-blocked"), i.forEach((o, l) => {
    o.style.setProperty("--v-body-scroll-x", _e(-o.scrollLeft)), o.style.setProperty("--v-body-scroll-y", _e(-o.scrollTop)), o !== document.documentElement && o.style.setProperty("--v-scrollbar-offset", _e(r)), o.classList.add("v-overlay-scroll-blocked");
  }), Wn(() => {
    i.forEach((o, l) => {
      const u = parseFloat(o.style.getPropertyValue("--v-body-scroll-x")), c = parseFloat(o.style.getPropertyValue("--v-body-scroll-y")), d = o.style.scrollBehavior;
      o.style.scrollBehavior = "auto", o.style.removeProperty("--v-body-scroll-x"), o.style.removeProperty("--v-body-scroll-y"), o.style.removeProperty("--v-scrollbar-offset"), o.classList.remove("v-overlay-scroll-blocked"), o.scrollLeft = -u, o.scrollTop = -c, o.style.scrollBehavior = d;
    }), s && e.root.value.classList.remove("v-overlay--scroll-blocked");
  });
}
function K6(e, t, n) {
  let i = !1, r = -1, s = -1;
  function a(o) {
    U6(() => {
      var c, d;
      const l = performance.now();
      (d = (c = e.updateLocation).value) == null || d.call(c, o), i = (performance.now() - l) / (1e3 / 60) > 2;
    });
  }
  s = (typeof requestIdleCallback > "u" ? (o) => o() : requestIdleCallback)(() => {
    n.run(() => {
      pA(e.targetEl.value ?? e.contentEl.value, (o) => {
        i ? (cancelAnimationFrame(r), r = requestAnimationFrame(() => {
          r = requestAnimationFrame(() => {
            a(o);
          });
        })) : a(o);
      });
    });
  }), Wn(() => {
    typeof cancelIdleCallback < "u" && cancelIdleCallback(s), cancelAnimationFrame(r);
  });
}
function pA(e, t) {
  const n = [document, ...ff(e)];
  n.forEach((i) => {
    i.addEventListener("scroll", t, {
      passive: !0
    });
  }), Wn(() => {
    n.forEach((i) => {
      i.removeEventListener("scroll", t);
    });
  });
}
const Mg = Symbol.for("vuetify:v-menu"), ib = B({
  closeDelay: [Number, String],
  openDelay: [Number, String]
}, "delay");
function rb(e, t) {
  let n = () => {
  };
  function i(a) {
    n == null || n();
    const o = Number(a ? e.openDelay : e.closeDelay);
    return new Promise((l) => {
      n = fO(o, () => {
        t == null || t(a), l(a);
      });
    });
  }
  function r() {
    return i(!0);
  }
  function s() {
    return i(!1);
  }
  return {
    clearDelay: n,
    runOpenDelay: r,
    runCloseDelay: s
  };
}
const X6 = B({
  target: [String, Object],
  activator: [String, Object],
  activatorProps: {
    type: Object,
    default: () => ({})
  },
  openOnClick: {
    type: Boolean,
    default: void 0
  },
  openOnHover: Boolean,
  openOnFocus: {
    type: Boolean,
    default: void 0
  },
  closeOnContentClick: Boolean,
  ...ib()
}, "VOverlay-activator");
function J6(e, t) {
  let {
    isActive: n,
    isTop: i
  } = t;
  const r = Ut("useActivator"), s = X();
  let a = !1, o = !1, l = !0;
  const u = w(() => e.openOnFocus || e.openOnFocus == null && e.openOnHover), c = w(() => e.openOnClick || e.openOnClick == null && !e.openOnHover && !u.value), {
    runOpenDelay: d,
    runCloseDelay: f
  } = rb(e, (C) => {
    C === (e.openOnHover && a || u.value && o) && !(e.openOnHover && n.value && !i.value) && (n.value !== C && (l = !0), n.value = C);
  }), h = X(), m = {
    onClick: (C) => {
      C.stopPropagation(), s.value = C.currentTarget || C.target, n.value || (h.value = [C.clientX, C.clientY]), n.value = !n.value;
    },
    onMouseenter: (C) => {
      var x;
      (x = C.sourceCapabilities) != null && x.firesTouchEvents || (a = !0, s.value = C.currentTarget || C.target, d());
    },
    onMouseleave: (C) => {
      a = !1, f();
    },
    onFocus: (C) => {
      vl(C.target, ":focus-visible") !== !1 && (o = !0, C.stopPropagation(), s.value = C.currentTarget || C.target, d());
    },
    onBlur: (C) => {
      o = !1, C.stopPropagation(), f();
    }
  }, g = w(() => {
    const C = {};
    return c.value && (C.onClick = m.onClick), e.openOnHover && (C.onMouseenter = m.onMouseenter, C.onMouseleave = m.onMouseleave), u.value && (C.onFocus = m.onFocus, C.onBlur = m.onBlur), C;
  }), p = w(() => {
    const C = {};
    if (e.openOnHover && (C.onMouseenter = () => {
      a = !0, d();
    }, C.onMouseleave = () => {
      a = !1, f();
    }), u.value && (C.onFocusin = () => {
      o = !0, d();
    }, C.onFocusout = () => {
      o = !1, f();
    }), e.closeOnContentClick) {
      const x = tt(Mg, null);
      C.onClick = () => {
        n.value = !1, x == null || x.closeParents();
      };
    }
    return C;
  }), y = w(() => {
    const C = {};
    return e.openOnHover && (C.onMouseenter = () => {
      l && (a = !0, l = !1, d());
    }, C.onMouseleave = () => {
      a = !1, f();
    }), C;
  });
  fe(i, (C) => {
    C && (e.openOnHover && !a && (!u.value || !o) || u.value && !o && (!e.openOnHover || !a)) && (n.value = !1);
  }), fe(n, (C) => {
    C || setTimeout(() => {
      h.value = void 0;
    });
  }, {
    flush: "post"
  });
  const k = uf();
  Wt(() => {
    k.value && He(() => {
      s.value = k.el;
    });
  });
  const T = uf(), _ = w(() => e.target === "cursor" && h.value ? h.value : T.value ? T.el : yA(e.target, r) || s.value), b = w(() => Array.isArray(_.value) ? void 0 : _.value);
  let S;
  return fe(() => !!e.activator, (C) => {
    C && ft ? (S = Qg(), S.run(() => {
      Q6(e, r, {
        activatorEl: s,
        activatorEvents: g
      });
    })) : S && S.stop();
  }, {
    flush: "post",
    immediate: !0
  }), Wn(() => {
    S == null || S.stop();
  }), {
    activatorEl: s,
    activatorRef: k,
    target: _,
    targetEl: b,
    targetRef: T,
    activatorEvents: g,
    contentEvents: p,
    scrimEvents: y
  };
}
function Q6(e, t, n) {
  let {
    activatorEl: i,
    activatorEvents: r
  } = n;
  fe(() => e.activator, (l, u) => {
    if (u && l !== u) {
      const c = o(u);
      c && a(c);
    }
    l && He(() => s());
  }, {
    immediate: !0
  }), fe(() => e.activatorProps, () => {
    s();
  }), Wn(() => {
    a();
  });
  function s() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : o(), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
    l && vO(l, se(r.value, u));
  }
  function a() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : o(), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
    l && gO(l, se(r.value, u));
  }
  function o() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.activator;
    const u = yA(l, t);
    return i.value = (u == null ? void 0 : u.nodeType) === Node.ELEMENT_NODE ? u : void 0, i.value;
  }
}
function yA(e, t) {
  var i, r;
  if (!e)
    return;
  let n;
  if (e === "parent") {
    let s = (r = (i = t == null ? void 0 : t.proxy) == null ? void 0 : i.$el) == null ? void 0 : r.parentNode;
    for (; s != null && s.hasAttribute("data-no-activator"); )
      s = s.parentNode;
    n = s;
  } else
    typeof e == "string" ? n = document.querySelector(e) : "$el" in e ? n = e.$el : n = e;
  return n;
}
function bA() {
  if (!ft)
    return pe(!1);
  const {
    ssr: e
  } = xr();
  if (e) {
    const t = pe(!1);
    return jn(() => {
      t.value = !0;
    }), t;
  } else
    return pe(!0);
}
const sb = B({
  eager: Boolean
}, "lazy");
function ab(e, t) {
  const n = pe(!1), i = w(() => n.value || e.eager || t.value);
  fe(t, () => n.value = !0);
  function r() {
    e.eager || (n.value = !1);
  }
  return {
    isBooted: n,
    hasContent: i,
    onAfterLeave: r
  };
}
function Vo() {
  const t = Ut("useScopeId").vnode.scopeId;
  return {
    scopeId: t ? {
      [t]: ""
    } : void 0
  };
}
const R_ = Symbol.for("vuetify:stack"), du = ti([]);
function e5(e, t, n) {
  const i = Ut("useStack"), r = !n, s = tt(R_, void 0), a = ti({
    activeChildren: /* @__PURE__ */ new Set()
  });
  Tt(R_, a);
  const o = pe(+t.value);
  vi(e, () => {
    var d;
    const c = (d = du.at(-1)) == null ? void 0 : d[1];
    o.value = c ? c + 10 : +t.value, r && du.push([i.uid, o.value]), s == null || s.activeChildren.add(i.uid), Wn(() => {
      if (r) {
        const f = si(du).findIndex((h) => h[0] === i.uid);
        du.splice(f, 1);
      }
      s == null || s.activeChildren.delete(i.uid);
    });
  });
  const l = pe(!0);
  r && Wt(() => {
    var d;
    const c = ((d = du.at(-1)) == null ? void 0 : d[0]) === i.uid;
    setTimeout(() => l.value = c);
  });
  const u = w(() => !a.activeChildren.size);
  return {
    globalTop: Ml(l),
    localTop: u,
    stackStyles: w(() => ({
      zIndex: o.value
    }))
  };
}
function t5(e) {
  return {
    teleportTarget: w(() => {
      const n = e.value;
      if (n === !0 || !ft)
        return;
      const i = n === !1 ? document.body : typeof n == "string" ? document.querySelector(n) : n;
      if (i == null) {
        xc(`Unable to locate target ${n}`);
        return;
      }
      let r = i.querySelector(":scope > .v-overlay-container");
      return r || (r = document.createElement("div"), r.className = "v-overlay-container", i.appendChild(r)), r;
    })
  };
}
function n5() {
  return !0;
}
function wA(e, t, n) {
  if (!e || _A(e, n) === !1)
    return !1;
  const i = TS(t);
  if (typeof ShadowRoot < "u" && i instanceof ShadowRoot && i.host === e.target)
    return !1;
  const r = (typeof n.value == "object" && n.value.include || (() => []))();
  return r.push(t), !r.some((s) => s == null ? void 0 : s.contains(e.target));
}
function _A(e, t) {
  return (typeof t.value == "object" && t.value.closeConditional || n5)(e);
}
function i5(e, t, n) {
  const i = typeof n.value == "function" ? n.value : n.value.handler;
  t._clickOutside.lastMousedownWasOutside && wA(e, t, n) && setTimeout(() => {
    _A(e, n) && i && i(e);
  }, 0);
}
function F_(e, t) {
  const n = TS(e);
  t(document), typeof ShadowRoot < "u" && n instanceof ShadowRoot && t(n);
}
const SA = {
  // [data-app] may not be found
  // if using bind, inserted makes
  // sure that the root element is
  // available, iOS does not support
  // clicks on body
  mounted(e, t) {
    const n = (r) => i5(r, e, t), i = (r) => {
      e._clickOutside.lastMousedownWasOutside = wA(r, e, t);
    };
    F_(e, (r) => {
      r.addEventListener("click", n, !0), r.addEventListener("mousedown", i, !0);
    }), e._clickOutside || (e._clickOutside = {
      lastMousedownWasOutside: !1
    }), e._clickOutside[t.instance.$.uid] = {
      onClick: n,
      onMousedown: i
    };
  },
  unmounted(e, t) {
    e._clickOutside && (F_(e, (n) => {
      var s;
      if (!n || !((s = e._clickOutside) != null && s[t.instance.$.uid]))
        return;
      const {
        onClick: i,
        onMousedown: r
      } = e._clickOutside[t.instance.$.uid];
      n.removeEventListener("click", i, !0), n.removeEventListener("mousedown", r, !0);
    }), delete e._clickOutside[t.instance.$.uid]);
  }
};
function r5(e) {
  const {
    modelValue: t,
    color: n,
    ...i
  } = e;
  return v(na, {
    name: "fade-transition",
    appear: !0
  }, {
    default: () => [e.modelValue && v("div", se({
      class: ["v-overlay__scrim", e.color.backgroundColorClasses.value],
      style: e.color.backgroundColorStyles.value
    }, i), null)]
  });
}
const sd = B({
  absolute: Boolean,
  attach: [Boolean, String, Object],
  closeOnBack: {
    type: Boolean,
    default: !0
  },
  contained: Boolean,
  contentClass: null,
  contentProps: null,
  disabled: Boolean,
  opacity: [Number, String],
  noClickAnimation: Boolean,
  modelValue: Boolean,
  persistent: Boolean,
  scrim: {
    type: [Boolean, String],
    default: !0
  },
  zIndex: {
    type: [Number, String],
    default: 2e3
  },
  ...X6(),
  ...ke(),
  ...wn(),
  ...sb(),
  ...$6(),
  ...q6(),
  ...Qe(),
  ...Tr()
}, "VOverlay"), qr = J()({
  name: "VOverlay",
  directives: {
    ClickOutside: SA
  },
  inheritAttrs: !1,
  props: {
    _disableGlobalStack: Boolean,
    ...sd()
  },
  emits: {
    "click:outside": (e) => !0,
    "update:modelValue": (e) => !0,
    afterEnter: () => !0,
    afterLeave: () => !0
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: i,
      emit: r
    } = t;
    const s = Ee(e, "modelValue"), a = w({
      get: () => s.value,
      set: (ee) => {
        ee && e.disabled || (s.value = ee);
      }
    }), {
      teleportTarget: o
    } = t5(w(() => e.attach || e.contained)), {
      themeClasses: l
    } = lt(e), {
      rtlClasses: u,
      isRtl: c
    } = yn(), {
      hasContent: d,
      onAfterLeave: f
    } = ab(e, a), h = gt(w(() => typeof e.scrim == "string" ? e.scrim : null)), {
      globalTop: m,
      localTop: g,
      stackStyles: p
    } = e5(a, G(e, "zIndex"), e._disableGlobalStack), {
      activatorEl: y,
      activatorRef: k,
      target: T,
      targetEl: _,
      targetRef: b,
      activatorEvents: S,
      contentEvents: C,
      scrimEvents: x
    } = J6(e, {
      isActive: a,
      isTop: g
    }), {
      dimensionStyles: A
    } = _n(e), I = bA(), {
      scopeId: E
    } = Vo();
    fe(() => e.disabled, (ee) => {
      ee && (a.value = !1);
    });
    const O = X(), V = X(), N = X(), {
      contentStyles: F,
      updateLocation: $
    } = W6(e, {
      isRtl: c,
      contentEl: N,
      target: T,
      isActive: a
    });
    G6(e, {
      root: O,
      contentEl: N,
      targetEl: _,
      isActive: a,
      updateLocation: $
    });
    function Z(ee) {
      r("click:outside", ee), e.persistent ? ne() : a.value = !1;
    }
    function j(ee) {
      return a.value && m.value && // If using scrim, only close if clicking on it rather than anything opened on top
      (!e.scrim || ee.target === V.value);
    }
    ft && fe(a, (ee) => {
      ee ? window.addEventListener("keydown", H) : window.removeEventListener("keydown", H);
    }, {
      immediate: !0
    }), ai(() => {
      ft && window.removeEventListener("keydown", H);
    });
    function H(ee) {
      var K, ue;
      ee.key === "Escape" && m.value && (e.persistent ? ne() : (a.value = !1, (K = N.value) != null && K.contains(document.activeElement) && ((ue = y.value) == null || ue.focus())));
    }
    const R = Lx();
    vi(() => e.closeOnBack, () => {
      Hq(R, (ee) => {
        m.value && a.value ? (ee(!1), e.persistent ? ne() : a.value = !1) : ee();
      });
    });
    const L = X();
    fe(() => a.value && (e.absolute || e.contained) && o.value == null, (ee) => {
      if (ee) {
        const K = cp(O.value);
        K && K !== document.scrollingElement && (L.value = K.scrollTop);
      }
    });
    function ne() {
      e.noClickAnimation || N.value && Na(N.value, [{
        transformOrigin: "center"
      }, {
        transform: "scale(1.03)"
      }, {
        transformOrigin: "center"
      }], {
        duration: 150,
        easing: Hu
      });
    }
    function oe() {
      r("afterEnter");
    }
    function we() {
      f(), r("afterLeave");
    }
    return ie(() => {
      var ee;
      return v(De, null, [(ee = n.activator) == null ? void 0 : ee.call(n, {
        isActive: a.value,
        targetRef: b,
        props: se({
          ref: k
        }, S.value, e.activatorProps)
      }), I.value && d.value && v(QE, {
        disabled: !o.value,
        to: o.value
      }, {
        default: () => [v("div", se({
          class: ["v-overlay", {
            "v-overlay--absolute": e.absolute || e.contained,
            "v-overlay--active": a.value,
            "v-overlay--contained": e.contained
          }, l.value, u.value, e.class],
          style: [p.value, {
            "--v-overlay-opacity": e.opacity,
            top: _e(L.value)
          }, e.style],
          ref: O
        }, E, i), [v(r5, se({
          color: h,
          modelValue: a.value && !!e.scrim,
          ref: V
        }, x.value), null), v(Gn, {
          appear: !0,
          persisted: !0,
          transition: e.transition,
          target: T.value,
          onAfterEnter: oe,
          onAfterLeave: we
        }, {
          default: () => {
            var K;
            return [Rt(v("div", se({
              ref: N,
              class: ["v-overlay__content", e.contentClass],
              style: [A.value, F.value]
            }, C.value, e.contentProps), [(K = n.default) == null ? void 0 : K.call(n, {
              isActive: a
            })]), [[Cr, a.value], [Ei("click-outside"), {
              handler: Z,
              closeConditional: j,
              include: () => [y.value]
            }]])];
          }
        })])]
      })]);
    }), {
      activatorEl: y,
      scrimEl: V,
      target: T,
      animateClick: ne,
      contentEl: N,
      globalTop: m,
      localTop: g,
      updateLocation: $
    };
  }
}), kA = B({
  // TODO
  // disableKeys: Boolean,
  id: String,
  ...sn(sd({
    closeDelay: 250,
    closeOnContentClick: !0,
    locationStrategy: "connected",
    openDelay: 300,
    scrim: !1,
    scrollStrategy: "reposition",
    transition: {
      component: dh
    }
  }), ["absolute"])
}, "VMenu"), Dl = J()({
  name: "VMenu",
  props: kA(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), {
      scopeId: r
    } = Vo(), s = An(), a = w(() => e.id || `v-menu-${s}`), o = X(), l = tt(Mg, null), u = pe(0);
    Tt(Mg, {
      register() {
        ++u.value;
      },
      unregister() {
        --u.value;
      },
      closeParents(g) {
        setTimeout(() => {
          !u.value && !e.persistent && (g == null || g && !hO(g, o.value.contentEl)) && (i.value = !1, l == null || l.closeParents());
        }, 40);
      }
    });
    async function c(g) {
      var k, T, _;
      const p = g.relatedTarget, y = g.target;
      await He(), i.value && p !== y && ((k = o.value) != null && k.contentEl) && // We're the topmost menu
      ((T = o.value) != null && T.globalTop) && // It isn't the document or the menu body
      ![document, o.value.contentEl].includes(y) && // It isn't inside the menu body
      !o.value.contentEl.contains(y) && ((_ = ju(o.value.contentEl)[0]) == null || _.focus());
    }
    fe(i, (g) => {
      g ? (l == null || l.register(), document.addEventListener("focusin", c, {
        once: !0
      })) : (l == null || l.unregister(), document.removeEventListener("focusin", c));
    });
    function d(g) {
      l == null || l.closeParents(g);
    }
    function f(g) {
      var p, y, k;
      if (!e.disabled)
        if (g.key === "Tab" || g.key === "Enter" && !e.closeOnContentClick) {
          if (g.key === "Enter" && g.target instanceof HTMLTextAreaElement)
            return;
          g.key === "Enter" && g.preventDefault(), uS(ju((p = o.value) == null ? void 0 : p.contentEl, !1), g.shiftKey ? "prev" : "next", (_) => _.tabIndex >= 0) || (i.value = !1, (k = (y = o.value) == null ? void 0 : y.activatorEl) == null || k.focus());
        } else
          ["Enter", " "].includes(g.key) && e.closeOnContentClick && (i.value = !1, l == null || l.closeParents());
    }
    function h(g) {
      var y;
      if (e.disabled)
        return;
      const p = (y = o.value) == null ? void 0 : y.contentEl;
      p && i.value ? g.key === "ArrowDown" ? (g.preventDefault(), ml(p, "next")) : g.key === "ArrowUp" && (g.preventDefault(), ml(p, "prev")) : ["ArrowDown", "ArrowUp"].includes(g.key) && (i.value = !0, g.preventDefault(), setTimeout(() => setTimeout(() => h(g))));
    }
    const m = w(() => se({
      "aria-haspopup": "menu",
      "aria-expanded": String(i.value),
      "aria-owns": a.value,
      onKeydown: h
    }, e.activatorProps));
    return ie(() => {
      const g = qr.filterProps(e);
      return v(qr, se({
        ref: o,
        id: a.value,
        class: ["v-menu", e.class],
        style: e.style
      }, g, {
        modelValue: i.value,
        "onUpdate:modelValue": (p) => i.value = p,
        absolute: !0,
        activatorProps: m.value,
        "onClick:outside": d,
        onKeydown: f
      }, r), {
        activator: n.activator,
        default: function() {
          for (var p = arguments.length, y = new Array(p), k = 0; k < p; k++)
            y[k] = arguments[k];
          return v(Ze, {
            root: "VMenu"
          }, {
            default: () => {
              var T;
              return [(T = n.default) == null ? void 0 : T.call(n, ...y)];
            }
          });
        }
      });
    }), Qi({
      id: a,
      ΨopenChildren: u
    }, o);
  }
});
const s5 = B({
  renderless: Boolean,
  ...ke()
}, "VVirtualScrollItem"), CA = J()({
  name: "VVirtualScrollItem",
  inheritAttrs: !1,
  props: s5(),
  emits: {
    "update:height": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const {
      resizeRef: s,
      contentRect: a
    } = _r(void 0, "border");
    fe(() => {
      var o;
      return (o = a.value) == null ? void 0 : o.height;
    }, (o) => {
      o != null && i("update:height", o);
    }), ie(() => {
      var o, l;
      return e.renderless ? v(De, null, [(o = r.default) == null ? void 0 : o.call(r, {
        itemRef: s
      })]) : v("div", se({
        ref: s,
        class: ["v-virtual-scroll__item", e.class],
        style: e.style
      }, n), [(l = r.default) == null ? void 0 : l.call(r)]);
    });
  }
}), a5 = -1, o5 = 1, kv = 100, TA = B({
  itemHeight: {
    type: [Number, String],
    default: null
  },
  height: [Number, String]
}, "virtual");
function xA(e, t) {
  const n = xr(), i = pe(0);
  Wt(() => {
    i.value = parseFloat(e.itemHeight || 0);
  });
  const r = pe(0), s = pe(Math.ceil(
    // Assume 16px items filling the entire screen height if
    // not provided. This is probably incorrect but it minimises
    // the chance of ending up with empty space at the bottom.
    // The default value is set here to avoid poisoning getSize()
    (parseInt(e.height) || n.height.value) / (i.value || 16)
  ) || 1), a = pe(0), o = pe(0), l = X(), u = X();
  let c = 0;
  const {
    resizeRef: d,
    contentRect: f
  } = _r();
  Wt(() => {
    d.value = l.value;
  });
  const h = w(() => {
    var H;
    return l.value === document.documentElement ? n.height.value : ((H = f.value) == null ? void 0 : H.height) || parseInt(e.height) || 0;
  }), m = w(() => !!(l.value && u.value && h.value && i.value));
  let g = Array.from({
    length: t.value.length
  }), p = Array.from({
    length: t.value.length
  });
  const y = pe(0);
  let k = -1;
  function T(H) {
    return g[H] || i.value;
  }
  const _ = lO(() => {
    const H = performance.now();
    p[0] = 0;
    const R = t.value.length;
    for (let L = 1; L <= R - 1; L++)
      p[L] = (p[L - 1] || 0) + T(L - 1);
    y.value = Math.max(y.value, performance.now() - H);
  }, y), b = fe(m, (H) => {
    H && (b(), c = u.value.offsetTop, _.immediate(), F(), ~k && He(() => {
      ft && window.requestAnimationFrame(() => {
        Z(k), k = -1;
      });
    }));
  });
  Wn(() => {
    _.clear();
  });
  function S(H, R) {
    const L = g[H], ne = i.value;
    i.value = ne ? Math.min(i.value, R) : R, (L !== R || ne !== i.value) && (g[H] = R, _());
  }
  function C(H) {
    return H = Xt(H, 0, t.value.length - 1), p[H] || 0;
  }
  function x(H) {
    return l5(p, H);
  }
  let A = 0, I = 0, E = 0;
  fe(h, (H, R) => {
    R && (F(), H < R && requestAnimationFrame(() => {
      I = 0, F();
    }));
  });
  function O() {
    if (!l.value || !u.value)
      return;
    const H = l.value.scrollTop, R = performance.now();
    R - E > 500 ? (I = Math.sign(H - A), c = u.value.offsetTop) : I = H - A, A = H, E = R, F();
  }
  function V() {
    !l.value || !u.value || (I = 0, E = 0, F());
  }
  let N = -1;
  function F() {
    cancelAnimationFrame(N), N = requestAnimationFrame($);
  }
  function $() {
    if (!l.value || !h.value)
      return;
    const H = A - c, R = Math.sign(I), L = Math.max(0, H - kv), ne = Xt(x(L), 0, t.value.length), oe = H + h.value + kv, we = Xt(x(oe) + 1, ne + 1, t.value.length);
    if (
      // Only update the side we're scrolling towards,
      // the other side will be updated incidentally
      (R !== a5 || ne < r.value) && (R !== o5 || we > s.value)
    ) {
      const ee = C(r.value) - C(ne), K = C(we) - C(s.value);
      Math.max(ee, K) > kv ? (r.value = ne, s.value = we) : (ne <= 0 && (r.value = ne), we >= t.value.length && (s.value = we));
    }
    a.value = C(r.value), o.value = C(t.value.length) - C(s.value);
  }
  function Z(H) {
    const R = C(H);
    !l.value || H && !R ? k = H : l.value.scrollTop = R;
  }
  const j = w(() => t.value.slice(r.value, s.value).map((H, R) => ({
    raw: H,
    index: R + r.value
  })));
  return fe(t, () => {
    g = Array.from({
      length: t.value.length
    }), p = Array.from({
      length: t.value.length
    }), _.immediate(), F();
  }, {
    deep: !0
  }), {
    containerRef: l,
    markerRef: u,
    computedItems: j,
    paddingTop: a,
    paddingBottom: o,
    scrollToIndex: Z,
    handleScroll: O,
    handleScrollend: V,
    handleItemResize: S
  };
}
function l5(e, t) {
  let n = e.length - 1, i = 0, r = 0, s = null, a = -1;
  if (e[n] < t)
    return n;
  for (; i <= n; )
    if (r = i + n >> 1, s = e[r], s > t)
      n = r - 1;
    else if (s < t)
      a = r, i = r + 1;
    else
      return s === t ? r : i;
  return a;
}
const u5 = B({
  items: {
    type: Array,
    default: () => []
  },
  renderless: Boolean,
  ...TA(),
  ...ke(),
  ...wn()
}, "VVirtualScroll"), lm = J()({
  name: "VVirtualScroll",
  props: u5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ut("VVirtualScroll"), {
      dimensionStyles: r
    } = _n(e), {
      containerRef: s,
      markerRef: a,
      handleScroll: o,
      handleScrollend: l,
      handleItemResize: u,
      scrollToIndex: c,
      paddingTop: d,
      paddingBottom: f,
      computedItems: h
    } = xA(e, G(e, "items"));
    return vi(() => e.renderless, () => {
      function m() {
        var y, k;
        const p = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) ? "addEventListener" : "removeEventListener";
        s.value === document.documentElement ? (document[p]("scroll", o, {
          passive: !0
        }), document[p]("scrollend", l)) : ((y = s.value) == null || y[p]("scroll", o, {
          passive: !0
        }), (k = s.value) == null || k[p]("scrollend", l));
      }
      jn(() => {
        s.value = cp(i.vnode.el, !0), m(!0);
      }), Wn(m);
    }), ie(() => {
      const m = h.value.map((g) => v(CA, {
        key: g.index,
        renderless: e.renderless,
        "onUpdate:height": (p) => u(g.index, p)
      }, {
        default: (p) => {
          var y;
          return (y = n.default) == null ? void 0 : y.call(n, {
            item: g.raw,
            index: g.index,
            ...p
          });
        }
      }));
      return e.renderless ? v(De, null, [v("div", {
        ref: a,
        class: "v-virtual-scroll__spacer",
        style: {
          paddingTop: _e(d.value)
        }
      }, null), m, v("div", {
        class: "v-virtual-scroll__spacer",
        style: {
          paddingBottom: _e(f.value)
        }
      }, null)]) : v("div", {
        ref: s,
        class: ["v-virtual-scroll", e.class],
        onScrollPassive: o,
        onScrollend: l,
        style: [r.value, e.style]
      }, [v("div", {
        ref: a,
        class: "v-virtual-scroll__container",
        style: {
          paddingTop: _e(d.value),
          paddingBottom: _e(f.value)
        }
      }, [m])]);
    }), {
      scrollToIndex: c
    };
  }
});
function ob(e, t) {
  const n = pe(!1);
  let i;
  function r(o) {
    cancelAnimationFrame(i), n.value = !0, i = requestAnimationFrame(() => {
      i = requestAnimationFrame(() => {
        n.value = !1;
      });
    });
  }
  async function s() {
    await new Promise((o) => requestAnimationFrame(o)), await new Promise((o) => requestAnimationFrame(o)), await new Promise((o) => requestAnimationFrame(o)), await new Promise((o) => {
      if (n.value) {
        const l = fe(n, () => {
          l(), o();
        });
      } else
        o();
    });
  }
  async function a(o) {
    var c, d;
    if (o.key === "Tab" && ((c = t.value) == null || c.focus()), !["PageDown", "PageUp", "Home", "End"].includes(o.key))
      return;
    const l = (d = e.value) == null ? void 0 : d.$el;
    if (!l)
      return;
    (o.key === "Home" || o.key === "End") && l.scrollTo({
      top: o.key === "Home" ? 0 : l.scrollHeight,
      behavior: "smooth"
    }), await s();
    const u = l.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
    if (o.key === "PageDown" || o.key === "Home") {
      const f = l.getBoundingClientRect().top;
      for (const h of u)
        if (h.getBoundingClientRect().top >= f) {
          h.focus();
          break;
        }
    } else {
      const f = l.getBoundingClientRect().bottom;
      for (const h of [...u].reverse())
        if (h.getBoundingClientRect().bottom <= f) {
          h.focus();
          break;
        }
    }
  }
  return {
    onListScroll: r,
    onListKeydown: a
  };
}
const lb = B({
  chips: Boolean,
  closableChips: Boolean,
  closeText: {
    type: String,
    default: "$vuetify.close"
  },
  openText: {
    type: String,
    default: "$vuetify.open"
  },
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  listProps: {
    type: Object
  },
  menu: Boolean,
  menuIcon: {
    type: We,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  itemColor: String,
  ...hA({
    itemChildren: !1
  })
}, "Select"), c5 = B({
  ...lb(),
  ...sn(bh({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...Tr({
    transition: {
      component: dh
    }
  })
}, "VSelect"), ub = J()({
  name: "VSelect",
  props: c5(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: i
    } = qt(), r = X(), s = X(), a = X(), o = Ee(e, "menu"), l = w({
      get: () => o.value,
      set: (j) => {
        var H;
        o.value && !j && ((H = s.value) != null && H.ΨopenChildren) || (o.value = j);
      }
    }), {
      items: u,
      transformIn: c,
      transformOut: d
    } = nb(e), f = Ee(e, "modelValue", [], (j) => c(j === null ? [null] : Nt(j)), (j) => {
      const H = d(j);
      return e.multiple ? H : H[0] ?? null;
    }), h = w(() => typeof e.counterValue == "function" ? e.counterValue(f.value) : typeof e.counterValue == "number" ? e.counterValue : f.value.length), m = yh(), g = w(() => f.value.map((j) => j.value)), p = pe(!1), y = w(() => l.value ? e.closeText : e.openText);
    let k = "", T;
    const _ = w(() => e.hideSelected ? u.value.filter((j) => !f.value.some((H) => e.valueComparator(H, j))) : u.value), b = w(() => e.hideNoData && !_.value.length || e.readonly || (m == null ? void 0 : m.isReadonly.value)), S = w(() => {
      var j;
      return {
        ...e.menuProps,
        activatorProps: {
          ...((j = e.menuProps) == null ? void 0 : j.activatorProps) || {},
          "aria-haspopup": "listbox"
          // Set aria-haspopup to 'listbox'
        }
      };
    }), C = X(), {
      onListScroll: x,
      onListKeydown: A
    } = ob(C, r);
    function I(j) {
      e.openOnClear && (l.value = !0);
    }
    function E() {
      b.value || (l.value = !l.value);
    }
    function O(j) {
      var oe, we;
      if (!j.key || e.readonly || m != null && m.isReadonly.value)
        return;
      ["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(j.key) && j.preventDefault(), ["Enter", "ArrowDown", " "].includes(j.key) && (l.value = !0), ["Escape", "Tab"].includes(j.key) && (l.value = !1), j.key === "Home" ? (oe = C.value) == null || oe.focus("first") : j.key === "End" && ((we = C.value) == null || we.focus("last"));
      const H = 1e3;
      function R(ee) {
        const K = ee.key.length === 1, ue = !ee.ctrlKey && !ee.metaKey && !ee.altKey;
        return K && ue;
      }
      if (e.multiple || !R(j))
        return;
      const L = performance.now();
      L - T > H && (k = ""), k += j.key.toLowerCase(), T = L;
      const ne = u.value.find((ee) => ee.title.toLowerCase().startsWith(k));
      if (ne !== void 0) {
        f.value = [ne];
        const ee = _.value.indexOf(ne);
        ft && window.requestAnimationFrame(() => {
          var K;
          ee >= 0 && ((K = a.value) == null || K.scrollToIndex(ee));
        });
      }
    }
    function V(j) {
      let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!j.props.disabled)
        if (e.multiple) {
          const R = f.value.findIndex((ne) => e.valueComparator(ne.value, j.value)), L = H ?? !~R;
          if (~R) {
            const ne = L ? [...f.value, j] : [...f.value];
            ne.splice(R, 1), f.value = ne;
          } else
            L && (f.value = [...f.value, j]);
        } else {
          const R = H !== !1;
          f.value = R ? [j] : [], He(() => {
            l.value = !1;
          });
        }
    }
    function N(j) {
      var H;
      (H = C.value) != null && H.$el.contains(j.relatedTarget) || (l.value = !1);
    }
    function F() {
      var j;
      p.value && ((j = r.value) == null || j.focus());
    }
    function $(j) {
      p.value = !0;
    }
    function Z(j) {
      if (j == null)
        f.value = [];
      else if (vl(r.value, ":autofill") || vl(r.value, ":-webkit-autofill")) {
        const H = u.value.find((R) => R.title === j);
        H && V(H);
      } else
        r.value && (r.value.value = "");
    }
    return fe(l, () => {
      if (!e.hideSelected && l.value && f.value.length) {
        const j = _.value.findIndex((H) => f.value.some((R) => e.valueComparator(R.value, H.value)));
        ft && window.requestAnimationFrame(() => {
          var H;
          j >= 0 && ((H = a.value) == null || H.scrollToIndex(j));
        });
      }
    }), fe(() => e.items, (j, H) => {
      l.value || p.value && !H.length && j.length && (l.value = !0);
    }), ie(() => {
      const j = !!(e.chips || n.chip), H = !!(!e.hideNoData || _.value.length || n["prepend-item"] || n["append-item"] || n["no-data"]), R = f.value.length > 0, L = gi.filterProps(e), ne = R || !p.value && e.label && !e.persistentPlaceholder ? void 0 : e.placeholder;
      return v(gi, se({
        ref: r
      }, L, {
        modelValue: f.value.map((oe) => oe.props.value).join(", "),
        "onUpdate:modelValue": Z,
        focused: p.value,
        "onUpdate:focused": (oe) => p.value = oe,
        validationValue: f.externalValue,
        counterValue: h.value,
        dirty: R,
        class: ["v-select", {
          "v-select--active-menu": l.value,
          "v-select--chips": !!e.chips,
          [`v-select--${e.multiple ? "multiple" : "single"}`]: !0,
          "v-select--selected": f.value.length,
          "v-select--selection-slot": !!n.selection
        }, e.class],
        style: e.style,
        inputmode: "none",
        placeholder: ne,
        "onClick:clear": I,
        "onMousedown:control": E,
        onBlur: N,
        onKeydown: O,
        "aria-label": i(y.value),
        title: i(y.value)
      }), {
        ...n,
        default: () => v(De, null, [v(Dl, se({
          ref: s,
          modelValue: l.value,
          "onUpdate:modelValue": (oe) => l.value = oe,
          activator: "parent",
          contentClass: "v-select__content",
          disabled: b.value,
          eager: e.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: e.transition,
          onAfterLeave: F
        }, S.value), {
          default: () => [H && v(om, se({
            ref: C,
            selected: g.value,
            selectStrategy: e.multiple ? "independent" : "single-independent",
            onMousedown: (oe) => oe.preventDefault(),
            onKeydown: A,
            onFocusin: $,
            onScrollPassive: x,
            tabindex: "-1",
            "aria-live": "polite",
            color: e.itemColor ?? e.color
          }, e.listProps), {
            default: () => {
              var oe, we, ee;
              return [(oe = n["prepend-item"]) == null ? void 0 : oe.call(n), !_.value.length && !e.hideNoData && (((we = n["no-data"]) == null ? void 0 : we.call(n)) ?? v(ks, {
                title: i(e.noDataText)
              }, null)), v(lm, {
                ref: a,
                renderless: !0,
                items: _.value
              }, {
                default: (K) => {
                  var Pe;
                  let {
                    item: ue,
                    index: ve,
                    itemRef: Re
                  } = K;
                  const he = se(ue.props, {
                    ref: Re,
                    key: ve,
                    onClick: () => V(ue, null)
                  });
                  return ((Pe = n.item) == null ? void 0 : Pe.call(n, {
                    item: ue,
                    index: ve,
                    props: he
                  })) ?? v(ks, se(he, {
                    role: "option"
                  }), {
                    prepend: (le) => {
                      let {
                        isSelected: be
                      } = le;
                      return v(De, null, [e.multiple && !e.hideSelected ? v(Ss, {
                        key: ue.value,
                        modelValue: be,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, ue.props.prependAvatar && v(Ji, {
                        image: ue.props.prependAvatar
                      }, null), ue.props.prependIcon && v(at, {
                        icon: ue.props.prependIcon
                      }, null)]);
                    }
                  });
                }
              }), (ee = n["append-item"]) == null ? void 0 : ee.call(n)];
            }
          })]
        }), f.value.map((oe, we) => {
          function ee(Re) {
            Re.stopPropagation(), Re.preventDefault(), V(oe, !1);
          }
          const K = {
            "onClick:close": ee,
            onKeydown(Re) {
              Re.key !== "Enter" && Re.key !== " " || (Re.preventDefault(), Re.stopPropagation(), ee(Re));
            },
            onMousedown(Re) {
              Re.preventDefault(), Re.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, ue = j ? !!n.chip : !!n.selection, ve = ue ? uh(j ? n.chip({
            item: oe,
            index: we,
            props: K
          }) : n.selection({
            item: oe,
            index: we
          })) : void 0;
          if (!(ue && !ve))
            return v("div", {
              key: oe.value,
              class: "v-select__selection"
            }, [j ? n.chip ? v(Ze, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: e.closableChips,
                  size: "small",
                  text: oe.title
                }
              }
            }, {
              default: () => [ve]
            }) : v(ru, se({
              key: "chip",
              closable: e.closableChips,
              size: "small",
              text: oe.title,
              disabled: oe.props.disabled
            }, K), null) : ve ?? v("span", {
              class: "v-select__selection-text"
            }, [oe.title, e.multiple && we < f.value.length - 1 && v("span", {
              class: "v-select__selection-comma"
            }, [wr(",")])])]);
        })]),
        "append-inner": function() {
          var K;
          for (var oe = arguments.length, we = new Array(oe), ee = 0; ee < oe; ee++)
            we[ee] = arguments[ee];
          return v(De, null, [(K = n["append-inner"]) == null ? void 0 : K.call(n, ...we), e.menuIcon ? v(at, {
            class: "v-select__menu-icon",
            icon: e.menuIcon
          }, null) : void 0]);
        }
      });
    }), Qi({
      isFocused: p,
      menu: l,
      select: V
    }, r);
  }
}), d5 = (e, t, n) => e == null || t == null ? -1 : e.toString().toLocaleLowerCase().indexOf(t.toString().toLocaleLowerCase()), ad = B({
  customFilter: Function,
  customKeyFilter: Object,
  filterKeys: [Array, String],
  filterMode: {
    type: String,
    default: "intersection"
  },
  noFilter: Boolean
}, "filter");
function f5(e, t, n) {
  var o;
  const i = [], r = (n == null ? void 0 : n.default) ?? d5, s = n != null && n.filterKeys ? Nt(n.filterKeys) : !1, a = Object.keys((n == null ? void 0 : n.customKeyFilter) ?? {}).length;
  if (!(e != null && e.length))
    return i;
  e:
    for (let l = 0; l < e.length; l++) {
      const [u, c = u] = Nt(e[l]), d = {}, f = {};
      let h = -1;
      if (t && !(n != null && n.noFilter)) {
        if (typeof u == "object") {
          const p = s || Object.keys(c);
          for (const y of p) {
            const k = dn(c, y), T = (o = n == null ? void 0 : n.customKeyFilter) == null ? void 0 : o[y];
            if (h = T ? T(k, t, u) : r(k, t, u), h !== -1 && h !== !1)
              T ? d[y] = h : f[y] = h;
            else if ((n == null ? void 0 : n.filterMode) === "every")
              continue e;
          }
        } else
          h = r(u, t, u), h !== -1 && h !== !1 && (f.title = h);
        const m = Object.keys(f).length, g = Object.keys(d).length;
        if (!m && !g || (n == null ? void 0 : n.filterMode) === "union" && g !== a && !m || (n == null ? void 0 : n.filterMode) === "intersection" && (g !== a || !m))
          continue;
      }
      i.push({
        index: l,
        matches: {
          ...f,
          ...d
        }
      });
    }
  return i;
}
function od(e, t, n, i) {
  const r = X([]), s = X(/* @__PURE__ */ new Map()), a = w(() => i != null && i.transform ? Ct(t).map((l) => [l, i.transform(l)]) : Ct(t));
  Wt(() => {
    const l = typeof n == "function" ? n() : Ct(n), u = typeof l != "string" && typeof l != "number" ? "" : String(l), c = f5(a.value, u, {
      customKeyFilter: {
        ...e.customKeyFilter,
        ...Ct(i == null ? void 0 : i.customKeyFilter)
      },
      default: e.customFilter,
      filterKeys: e.filterKeys,
      filterMode: e.filterMode,
      noFilter: e.noFilter
    }), d = Ct(t), f = [], h = /* @__PURE__ */ new Map();
    c.forEach((m) => {
      let {
        index: g,
        matches: p
      } = m;
      const y = d[g];
      f.push(y), h.set(y.value, p);
    }), r.value = f, s.value = h;
  });
  function o(l) {
    return s.value.get(l.value);
  }
  return {
    filteredItems: r,
    filteredMatches: s,
    getMatches: o
  };
}
function h5(e, t, n) {
  if (t == null)
    return e;
  if (Array.isArray(t))
    throw new Error("Multiple matches is not implemented");
  return typeof t == "number" && ~t ? v(De, null, [v("span", {
    class: "v-autocomplete__unmask"
  }, [e.substr(0, t)]), v("span", {
    class: "v-autocomplete__mask"
  }, [e.substr(t, n)]), v("span", {
    class: "v-autocomplete__unmask"
  }, [e.substr(t + n)])]) : e;
}
const m5 = B({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: Boolean,
  search: String,
  ...ad({
    filterKeys: ["title"]
  }),
  ...lb(),
  ...sn(bh({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...Tr({
    transition: !1
  })
}, "VAutocomplete"), v5 = J()({
  name: "VAutocomplete",
  props: m5(),
  emits: {
    "update:focused": (e) => !0,
    "update:search": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: i
    } = qt(), r = X(), s = pe(!1), a = pe(!0), o = pe(!1), l = X(), u = X(), c = Ee(e, "menu"), d = w({
      get: () => c.value,
      set: (he) => {
        var Pe;
        c.value && !he && ((Pe = l.value) != null && Pe.ΨopenChildren) || (c.value = he);
      }
    }), f = pe(-1), h = w(() => {
      var he;
      return (he = r.value) == null ? void 0 : he.color;
    }), m = w(() => d.value ? e.closeText : e.openText), {
      items: g,
      transformIn: p,
      transformOut: y
    } = nb(e), {
      textColorClasses: k,
      textColorStyles: T
    } = Ln(h), _ = Ee(e, "search", ""), b = Ee(e, "modelValue", [], (he) => p(he === null ? [null] : Nt(he)), (he) => {
      const Pe = y(he);
      return e.multiple ? Pe : Pe[0] ?? null;
    }), S = w(() => typeof e.counterValue == "function" ? e.counterValue(b.value) : typeof e.counterValue == "number" ? e.counterValue : b.value.length), C = yh(), {
      filteredItems: x,
      getMatches: A
    } = od(e, g, () => a.value ? "" : _.value), I = w(() => e.hideSelected ? x.value.filter((he) => !b.value.some((Pe) => Pe.value === he.value)) : x.value), E = w(() => !!(e.chips || n.chip)), O = w(() => E.value || !!n.selection), V = w(() => b.value.map((he) => he.props.value)), N = w(() => {
      var Pe;
      return (e.autoSelectFirst === !0 || e.autoSelectFirst === "exact" && _.value === ((Pe = I.value[0]) == null ? void 0 : Pe.title)) && I.value.length > 0 && !a.value && !o.value;
    }), F = w(() => e.hideNoData && !I.value.length || e.readonly || (C == null ? void 0 : C.isReadonly.value)), $ = X(), {
      onListScroll: Z,
      onListKeydown: j
    } = ob($, r);
    function H(he) {
      e.openOnClear && (d.value = !0), _.value = "";
    }
    function R() {
      F.value || (d.value = !0);
    }
    function L(he) {
      F.value || (s.value && (he.preventDefault(), he.stopPropagation()), d.value = !d.value);
    }
    function ne(he) {
      var be, Oe, te;
      if (e.readonly || C != null && C.isReadonly.value)
        return;
      const Pe = r.value.selectionStart, le = b.value.length;
      if ((f.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(he.key)) && he.preventDefault(), ["Enter", "ArrowDown"].includes(he.key) && (d.value = !0), ["Escape"].includes(he.key) && (d.value = !1), N.value && he.key === "Enter" && Re(I.value[0]), he.key === "ArrowDown" && N.value && ((be = $.value) == null || be.focus("next")), ["Backspace", "Delete"].includes(he.key)) {
        if (!e.multiple && O.value && b.value.length > 0 && !_.value)
          return Re(b.value[0], !1);
        if (~f.value) {
          const me = f.value;
          Re(b.value[f.value], !1), f.value = me >= le - 1 ? le - 2 : me;
        } else
          he.key === "Backspace" && !_.value && (f.value = le - 1);
      }
      if (e.multiple) {
        if (he.key === "ArrowLeft") {
          if (f.value < 0 && Pe > 0)
            return;
          const me = f.value > -1 ? f.value - 1 : le - 1;
          b.value[me] ? f.value = me : (f.value = -1, r.value.setSelectionRange((Oe = _.value) == null ? void 0 : Oe.length, (te = _.value) == null ? void 0 : te.length));
        }
        if (he.key === "ArrowRight") {
          if (f.value < 0)
            return;
          const me = f.value + 1;
          b.value[me] ? f.value = me : (f.value = -1, r.value.setSelectionRange(0, 0));
        }
      }
    }
    function oe(he) {
      if (vl(r.value, ":autofill") || vl(r.value, ":-webkit-autofill")) {
        const Pe = g.value.find((le) => le.title === he.target.value);
        Pe && Re(Pe);
      }
    }
    function we() {
      var he;
      s.value && (a.value = !0, (he = r.value) == null || he.focus());
    }
    function ee(he) {
      s.value = !0, setTimeout(() => {
        o.value = !0;
      });
    }
    function K(he) {
      o.value = !1;
    }
    function ue(he) {
      (he == null || he === "" && !e.multiple && !O.value) && (b.value = []);
    }
    const ve = pe(!1);
    function Re(he) {
      let Pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!(!he || he.props.disabled))
        if (e.multiple) {
          const le = b.value.findIndex((Oe) => e.valueComparator(Oe.value, he.value)), be = Pe ?? !~le;
          if (~le) {
            const Oe = be ? [...b.value, he] : [...b.value];
            Oe.splice(le, 1), b.value = Oe;
          } else
            be && (b.value = [...b.value, he]);
          e.clearOnSelect && (_.value = "");
        } else {
          const le = Pe !== !1;
          b.value = le ? [he] : [], _.value = le && !O.value ? he.title : "", He(() => {
            d.value = !1, a.value = !0;
          });
        }
    }
    return fe(s, (he, Pe) => {
      var le;
      he !== Pe && (he ? (ve.value = !0, _.value = e.multiple || O.value ? "" : String(((le = b.value.at(-1)) == null ? void 0 : le.props.title) ?? ""), a.value = !0, He(() => ve.value = !1)) : (!e.multiple && _.value == null ? b.value = [] : N.value && !o.value && !b.value.some((be) => {
        let {
          value: Oe
        } = be;
        return Oe === I.value[0].value;
      }) && Re(I.value[0]), d.value = !1, (e.multiple || O.value) && (_.value = ""), f.value = -1));
    }), fe(_, (he) => {
      !s.value || ve.value || (he && (d.value = !0), a.value = !he);
    }), fe(d, () => {
      if (!e.hideSelected && d.value && b.value.length) {
        const he = I.value.findIndex((Pe) => b.value.some((le) => Pe.value === le.value));
        ft && window.requestAnimationFrame(() => {
          var Pe;
          he >= 0 && ((Pe = u.value) == null || Pe.scrollToIndex(he));
        });
      }
    }), fe(() => e.items, (he, Pe) => {
      d.value || s.value && !Pe.length && he.length && (d.value = !0);
    }), ie(() => {
      const he = !!(!e.hideNoData || I.value.length || n["prepend-item"] || n["append-item"] || n["no-data"]), Pe = b.value.length > 0, le = gi.filterProps(e);
      return v(gi, se({
        ref: r
      }, le, {
        modelValue: _.value,
        "onUpdate:modelValue": [(be) => _.value = be, ue],
        focused: s.value,
        "onUpdate:focused": (be) => s.value = be,
        validationValue: b.externalValue,
        counterValue: S.value,
        dirty: Pe,
        onChange: oe,
        class: ["v-autocomplete", `v-autocomplete--${e.multiple ? "multiple" : "single"}`, {
          "v-autocomplete--active-menu": d.value,
          "v-autocomplete--chips": !!e.chips,
          "v-autocomplete--selection-slot": !!O.value,
          "v-autocomplete--selecting-index": f.value > -1
        }, e.class],
        style: e.style,
        readonly: e.readonly,
        placeholder: Pe ? void 0 : e.placeholder,
        "onClick:clear": H,
        "onMousedown:control": R,
        onKeydown: ne
      }), {
        ...n,
        default: () => v(De, null, [v(Dl, se({
          ref: l,
          modelValue: d.value,
          "onUpdate:modelValue": (be) => d.value = be,
          activator: "parent",
          contentClass: "v-autocomplete__content",
          disabled: F.value,
          eager: e.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: e.transition,
          onAfterLeave: we
        }, e.menuProps), {
          default: () => [he && v(om, se({
            ref: $,
            selected: V.value,
            selectStrategy: e.multiple ? "independent" : "single-independent",
            onMousedown: (be) => be.preventDefault(),
            onKeydown: j,
            onFocusin: ee,
            onFocusout: K,
            onScrollPassive: Z,
            tabindex: "-1",
            "aria-live": "polite",
            color: e.itemColor ?? e.color
          }, e.listProps), {
            default: () => {
              var be, Oe, te;
              return [(be = n["prepend-item"]) == null ? void 0 : be.call(n), !I.value.length && !e.hideNoData && (((Oe = n["no-data"]) == null ? void 0 : Oe.call(n)) ?? v(ks, {
                title: i(e.noDataText)
              }, null)), v(lm, {
                ref: u,
                renderless: !0,
                items: I.value
              }, {
                default: (me) => {
                  var Ke;
                  let {
                    item: Me,
                    index: Fe,
                    itemRef: xe
                  } = me;
                  const ze = se(Me.props, {
                    ref: xe,
                    key: Fe,
                    active: N.value && Fe === 0 ? !0 : void 0,
                    onClick: () => Re(Me, null)
                  });
                  return ((Ke = n.item) == null ? void 0 : Ke.call(n, {
                    item: Me,
                    index: Fe,
                    props: ze
                  })) ?? v(ks, se(ze, {
                    role: "option"
                  }), {
                    prepend: (ut) => {
                      let {
                        isSelected: vt
                      } = ut;
                      return v(De, null, [e.multiple && !e.hideSelected ? v(Ss, {
                        key: Me.value,
                        modelValue: vt,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, Me.props.prependAvatar && v(Ji, {
                        image: Me.props.prependAvatar
                      }, null), Me.props.prependIcon && v(at, {
                        icon: Me.props.prependIcon
                      }, null)]);
                    },
                    title: () => {
                      var ut, vt;
                      return a.value ? Me.title : h5(Me.title, (ut = A(Me)) == null ? void 0 : ut.title, ((vt = _.value) == null ? void 0 : vt.length) ?? 0);
                    }
                  });
                }
              }), (te = n["append-item"]) == null ? void 0 : te.call(n)];
            }
          })]
        }), b.value.map((be, Oe) => {
          function te(xe) {
            xe.stopPropagation(), xe.preventDefault(), Re(be, !1);
          }
          const me = {
            "onClick:close": te,
            onKeydown(xe) {
              xe.key !== "Enter" && xe.key !== " " || (xe.preventDefault(), xe.stopPropagation(), te(xe));
            },
            onMousedown(xe) {
              xe.preventDefault(), xe.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, Me = E.value ? !!n.chip : !!n.selection, Fe = Me ? uh(E.value ? n.chip({
            item: be,
            index: Oe,
            props: me
          }) : n.selection({
            item: be,
            index: Oe
          })) : void 0;
          if (!(Me && !Fe))
            return v("div", {
              key: be.value,
              class: ["v-autocomplete__selection", Oe === f.value && ["v-autocomplete__selection--selected", k.value]],
              style: Oe === f.value ? T.value : {}
            }, [E.value ? n.chip ? v(Ze, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: e.closableChips,
                  size: "small",
                  text: be.title
                }
              }
            }, {
              default: () => [Fe]
            }) : v(ru, se({
              key: "chip",
              closable: e.closableChips,
              size: "small",
              text: be.title,
              disabled: be.props.disabled
            }, me), null) : Fe ?? v("span", {
              class: "v-autocomplete__selection-text"
            }, [be.title, e.multiple && Oe < b.value.length - 1 && v("span", {
              class: "v-autocomplete__selection-comma"
            }, [wr(",")])])]);
        })]),
        "append-inner": function() {
          var me;
          for (var be = arguments.length, Oe = new Array(be), te = 0; te < be; te++)
            Oe[te] = arguments[te];
          return v(De, null, [(me = n["append-inner"]) == null ? void 0 : me.call(n, ...Oe), e.menuIcon ? v(at, {
            class: "v-autocomplete__menu-icon",
            icon: e.menuIcon,
            onMousedown: L,
            onClick: cS,
            "aria-label": i(m.value),
            title: i(m.value),
            tabindex: "-1"
          }, null) : void 0]);
        }
      });
    }), Qi({
      isFocused: s,
      isPristine: a,
      menu: d,
      search: _,
      filteredItems: x,
      select: Re
    }, r);
  }
});
const g5 = B({
  bordered: Boolean,
  color: String,
  content: [Number, String],
  dot: Boolean,
  floating: Boolean,
  icon: We,
  inline: Boolean,
  label: {
    type: String,
    default: "$vuetify.badge"
  },
  max: [Number, String],
  modelValue: {
    type: Boolean,
    default: !0
  },
  offsetX: [Number, String],
  offsetY: [Number, String],
  textColor: String,
  ...ke(),
  ...ua({
    location: "top end"
  }),
  ...It(),
  ...je(),
  ...Qe(),
  ...Tr({
    transition: "scale-rotate-transition"
  })
}, "VBadge"), p5 = J()({
  name: "VBadge",
  inheritAttrs: !1,
  props: g5(),
  setup(e, t) {
    const {
      backgroundColorClasses: n,
      backgroundColorStyles: i
    } = gt(G(e, "color")), {
      roundedClasses: r
    } = Ht(e), {
      t: s
    } = qt(), {
      textColorClasses: a,
      textColorStyles: o
    } = Ln(G(e, "textColor")), {
      themeClasses: l
    } = ES(), {
      locationStyles: u
    } = po(e, !0, (c) => (e.floating ? e.dot ? 2 : 4 : e.dot ? 8 : 12) + (["top", "bottom"].includes(c) ? +(e.offsetY ?? 0) : ["left", "right"].includes(c) ? +(e.offsetX ?? 0) : 0));
    return ie(() => {
      const c = Number(e.content), d = !e.max || isNaN(c) ? e.content : c <= +e.max ? c : `${e.max}+`, [f, h] = xv(t.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
      return v(e.tag, se({
        class: ["v-badge", {
          "v-badge--bordered": e.bordered,
          "v-badge--dot": e.dot,
          "v-badge--floating": e.floating,
          "v-badge--inline": e.inline
        }, e.class]
      }, h, {
        style: e.style
      }), {
        default: () => {
          var m, g;
          return [v("div", {
            class: "v-badge__wrapper"
          }, [(g = (m = t.slots).default) == null ? void 0 : g.call(m), v(Gn, {
            transition: e.transition
          }, {
            default: () => {
              var p, y;
              return [Rt(v("span", se({
                class: ["v-badge__badge", l.value, n.value, r.value, a.value],
                style: [i.value, o.value, e.inline ? {} : u.value],
                "aria-atomic": "true",
                "aria-label": s(e.label, c),
                "aria-live": "polite",
                role: "status"
              }, f), [e.dot ? void 0 : t.slots.badge ? (y = (p = t.slots).badge) == null ? void 0 : y.call(p) : e.icon ? v(at, {
                icon: e.icon
              }, null) : d]), [[Cr, e.modelValue]])];
            }
          })])];
        }
      });
    }), {};
  }
});
const y5 = B({
  color: String,
  density: String,
  ...ke()
}, "VBannerActions"), AA = J()({
  name: "VBannerActions",
  props: y5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return jt({
      VBtn: {
        color: e.color,
        density: e.density,
        slim: !0,
        variant: "text"
      }
    }), ie(() => {
      var i;
      return v("div", {
        class: ["v-banner-actions", e.class],
        style: e.style
      }, [(i = n.default) == null ? void 0 : i.call(n)]);
    }), {};
  }
}), IA = Yr("v-banner-text"), b5 = B({
  avatar: String,
  bgColor: String,
  color: String,
  icon: We,
  lines: String,
  stacked: Boolean,
  sticky: Boolean,
  text: String,
  ...Ni(),
  ...ke(),
  ...bn(),
  ...wn(),
  ...Ll({
    mobile: null
  }),
  ...mn(),
  ...ua(),
  ...nu(),
  ...It(),
  ...je(),
  ...Qe()
}, "VBanner"), w5 = J()({
  name: "VBanner",
  props: b5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: r
    } = gt(e, "bgColor"), {
      borderClasses: s
    } = er(e), {
      densityClasses: a
    } = Kn(e), {
      displayClasses: o,
      mobile: l
    } = xr(e), {
      dimensionStyles: u
    } = _n(e), {
      elevationClasses: c
    } = In(e), {
      locationStyles: d
    } = po(e), {
      positionClasses: f
    } = iu(e), {
      roundedClasses: h
    } = Ht(e), {
      themeClasses: m
    } = lt(e), g = G(e, "color"), p = G(e, "density");
    jt({
      VBannerActions: {
        color: g,
        density: p
      }
    }), ie(() => {
      const y = !!(e.text || n.text), k = !!(e.avatar || e.icon), T = !!(k || n.prepend);
      return v(e.tag, {
        class: ["v-banner", {
          "v-banner--stacked": e.stacked || l.value,
          "v-banner--sticky": e.sticky,
          [`v-banner--${e.lines}-line`]: !!e.lines
        }, m.value, i.value, s.value, a.value, o.value, c.value, f.value, h.value, e.class],
        style: [r.value, u.value, d.value, e.style],
        role: "banner"
      }, {
        default: () => {
          var _;
          return [T && v("div", {
            key: "prepend",
            class: "v-banner__prepend"
          }, [n.prepend ? v(Ze, {
            key: "prepend-defaults",
            disabled: !k,
            defaults: {
              VAvatar: {
                color: g.value,
                density: p.value,
                icon: e.icon,
                image: e.avatar
              }
            }
          }, n.prepend) : v(Ji, {
            key: "prepend-avatar",
            color: g.value,
            density: p.value,
            icon: e.icon,
            image: e.avatar
          }, null)]), v("div", {
            class: "v-banner__content"
          }, [y && v(IA, {
            key: "text"
          }, {
            default: () => {
              var b;
              return [((b = n.text) == null ? void 0 : b.call(n)) ?? e.text];
            }
          }), (_ = n.default) == null ? void 0 : _.call(n)]), n.actions && v(AA, {
            key: "actions"
          }, n.actions)];
        }
      });
    });
  }
});
const _5 = B({
  baseColor: String,
  bgColor: String,
  color: String,
  grow: Boolean,
  mode: {
    type: String,
    validator: (e) => !e || ["horizontal", "shift"].includes(e)
  },
  height: {
    type: [Number, String],
    default: 56
  },
  active: {
    type: Boolean,
    default: !0
  },
  ...Ni(),
  ...ke(),
  ...bn(),
  ...mn(),
  ...It(),
  ...yo({
    name: "bottom-navigation"
  }),
  ...je({
    tag: "header"
  }),
  ...Eo({
    selectedClass: "v-btn--selected"
  }),
  ...Qe()
}, "VBottomNavigation"), S5 = J()({
  name: "VBottomNavigation",
  props: _5(),
  emits: {
    "update:active": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = ES(), {
      borderClasses: r
    } = er(e), {
      backgroundColorClasses: s,
      backgroundColorStyles: a
    } = gt(G(e, "bgColor")), {
      densityClasses: o
    } = Kn(e), {
      elevationClasses: l
    } = In(e), {
      roundedClasses: u
    } = Ht(e), {
      ssrBootStyles: c
    } = Ao(), d = w(() => Number(e.height) - (e.density === "comfortable" ? 8 : 0) - (e.density === "compact" ? 16 : 0)), f = Ee(e, "active", e.active), {
      layoutItemStyles: h,
      layoutIsReady: m
    } = bo({
      id: e.name,
      order: w(() => parseInt(e.order, 10)),
      position: w(() => "bottom"),
      layoutSize: w(() => f.value ? d.value : 0),
      elementSize: d,
      active: f,
      absolute: G(e, "absolute")
    });
    return ha(e, Xy), jt({
      VBtn: {
        baseColor: G(e, "baseColor"),
        color: G(e, "color"),
        density: G(e, "density"),
        stacked: w(() => e.mode !== "horizontal"),
        variant: "text"
      }
    }, {
      scoped: !0
    }), ie(() => v(e.tag, {
      class: ["v-bottom-navigation", {
        "v-bottom-navigation--active": f.value,
        "v-bottom-navigation--grow": e.grow,
        "v-bottom-navigation--shift": e.mode === "shift"
      }, i.value, s.value, r.value, o.value, l.value, u.value, e.class],
      style: [a.value, h.value, {
        height: _e(d.value)
      }, c.value, e.style]
    }, {
      default: () => [n.default && v("div", {
        class: "v-bottom-navigation__content"
      }, [n.default()])]
    })), m;
  }
});
const EA = B({
  fullscreen: Boolean,
  retainFocus: {
    type: Boolean,
    default: !0
  },
  scrollable: Boolean,
  ...sd({
    origin: "center center",
    scrollStrategy: "block",
    transition: {
      component: dh
    },
    zIndex: 2400
  })
}, "VDialog"), Rg = J()({
  name: "VDialog",
  props: EA(),
  emits: {
    "update:modelValue": (e) => !0,
    afterLeave: () => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const r = Ee(e, "modelValue"), {
      scopeId: s
    } = Vo(), a = X();
    function o(c) {
      var h, m;
      const d = c.relatedTarget, f = c.target;
      if (d !== f && ((h = a.value) != null && h.contentEl) && // We're the topmost dialog
      ((m = a.value) != null && m.globalTop) && // It isn't the document or the dialog body
      ![document, a.value.contentEl].includes(f) && // It isn't inside the dialog body
      !a.value.contentEl.contains(f)) {
        const g = ju(a.value.contentEl);
        if (!g.length)
          return;
        const p = g[0], y = g[g.length - 1];
        d === p ? y.focus() : p.focus();
      }
    }
    ft && fe(() => r.value && e.retainFocus, (c) => {
      c ? document.addEventListener("focusin", o) : document.removeEventListener("focusin", o);
    }, {
      immediate: !0
    });
    function l() {
      var c;
      (c = a.value) != null && c.contentEl && !a.value.contentEl.contains(document.activeElement) && a.value.contentEl.focus({
        preventScroll: !0
      });
    }
    function u() {
      n("afterLeave");
    }
    return fe(r, async (c) => {
      var d;
      c || (await He(), (d = a.value.activatorEl) == null || d.focus({
        preventScroll: !0
      }));
    }), ie(() => {
      const c = qr.filterProps(e), d = se({
        "aria-haspopup": "dialog",
        "aria-expanded": String(r.value)
      }, e.activatorProps), f = se({
        tabindex: -1
      }, e.contentProps);
      return v(qr, se({
        ref: a,
        class: ["v-dialog", {
          "v-dialog--fullscreen": e.fullscreen,
          "v-dialog--scrollable": e.scrollable
        }, e.class],
        style: e.style
      }, c, {
        modelValue: r.value,
        "onUpdate:modelValue": (h) => r.value = h,
        "aria-modal": "true",
        activatorProps: d,
        contentProps: f,
        role: "dialog",
        onAfterEnter: l,
        onAfterLeave: u
      }, s), {
        activator: i.activator,
        default: function() {
          for (var h = arguments.length, m = new Array(h), g = 0; g < h; g++)
            m[g] = arguments[g];
          return v(Ze, {
            root: "VDialog"
          }, {
            default: () => {
              var p;
              return [(p = i.default) == null ? void 0 : p.call(i, ...m)];
            }
          });
        }
      });
    }), Qi({}, a);
  }
}), k5 = B({
  inset: Boolean,
  ...EA({
    transition: "bottom-sheet-transition"
  })
}, "VBottomSheet"), C5 = J()({
  name: "VBottomSheet",
  props: k5(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue");
    return ie(() => {
      const r = Rg.filterProps(e);
      return v(Rg, se(r, {
        contentClass: ["v-bottom-sheet__content", e.contentClass],
        modelValue: i.value,
        "onUpdate:modelValue": (s) => i.value = s,
        class: ["v-bottom-sheet", {
          "v-bottom-sheet--inset": e.inset
        }, e.class],
        style: e.style
      }), n);
    }), {};
  }
});
const T5 = B({
  divider: [Number, String],
  ...ke()
}, "VBreadcrumbsDivider"), OA = J()({
  name: "VBreadcrumbsDivider",
  props: T5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ie(() => {
      var i;
      return v("li", {
        class: ["v-breadcrumbs-divider", e.class],
        style: e.style
      }, [((i = n == null ? void 0 : n.default) == null ? void 0 : i.call(n)) ?? e.divider]);
    }), {};
  }
}), x5 = B({
  active: Boolean,
  activeClass: String,
  activeColor: String,
  color: String,
  disabled: Boolean,
  title: String,
  ...ke(),
  ...id(),
  ...je({
    tag: "li"
  })
}, "VBreadcrumbsItem"), PA = J()({
  name: "VBreadcrumbsItem",
  props: x5(),
  setup(e, t) {
    let {
      slots: n,
      attrs: i
    } = t;
    const r = nd(e, i), s = w(() => {
      var u;
      return e.active || ((u = r.isActive) == null ? void 0 : u.value);
    }), a = w(() => s.value ? e.activeColor : e.color), {
      textColorClasses: o,
      textColorStyles: l
    } = Ln(a);
    return ie(() => v(e.tag, {
      class: ["v-breadcrumbs-item", {
        "v-breadcrumbs-item--active": s.value,
        "v-breadcrumbs-item--disabled": e.disabled,
        [`${e.activeClass}`]: s.value && e.activeClass
      }, o.value, e.class],
      style: [l.value, e.style],
      "aria-current": s.value ? "page" : void 0
    }, {
      default: () => {
        var u, c;
        return [r.isLink.value ? v("a", {
          class: "v-breadcrumbs-item--link",
          href: r.href.value,
          "aria-current": s.value ? "page" : void 0,
          onClick: r.navigate
        }, [((c = n.default) == null ? void 0 : c.call(n)) ?? e.title]) : ((u = n.default) == null ? void 0 : u.call(n)) ?? e.title];
      }
    })), {};
  }
}), A5 = B({
  activeClass: String,
  activeColor: String,
  bgColor: String,
  color: String,
  disabled: Boolean,
  divider: {
    type: String,
    default: "/"
  },
  icon: We,
  items: {
    type: Array,
    default: () => []
  },
  ...ke(),
  ...bn(),
  ...It(),
  ...je({
    tag: "ul"
  })
}, "VBreadcrumbs"), I5 = J()({
  name: "VBreadcrumbs",
  props: A5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: r
    } = gt(G(e, "bgColor")), {
      densityClasses: s
    } = Kn(e), {
      roundedClasses: a
    } = Ht(e);
    jt({
      VBreadcrumbsDivider: {
        divider: G(e, "divider")
      },
      VBreadcrumbsItem: {
        activeClass: G(e, "activeClass"),
        activeColor: G(e, "activeColor"),
        color: G(e, "color"),
        disabled: G(e, "disabled")
      }
    });
    const o = w(() => e.items.map((l) => typeof l == "string" ? {
      item: {
        title: l
      },
      raw: l
    } : {
      item: l,
      raw: l
    }));
    return ie(() => {
      const l = !!(n.prepend || e.icon);
      return v(e.tag, {
        class: ["v-breadcrumbs", i.value, s.value, a.value, e.class],
        style: [r.value, e.style]
      }, {
        default: () => {
          var u;
          return [l && v("li", {
            key: "prepend",
            class: "v-breadcrumbs__prepend"
          }, [n.prepend ? v(Ze, {
            key: "prepend-defaults",
            disabled: !e.icon,
            defaults: {
              VIcon: {
                icon: e.icon,
                start: !0
              }
            }
          }, n.prepend) : v(at, {
            key: "prepend-icon",
            start: !0,
            icon: e.icon
          }, null)]), o.value.map((c, d, f) => {
            var g;
            let {
              item: h,
              raw: m
            } = c;
            return v(De, null, [((g = n.item) == null ? void 0 : g.call(n, {
              item: h,
              index: d
            })) ?? v(PA, se({
              key: d,
              disabled: d >= f.length - 1
            }, typeof h == "string" ? {
              title: h
            } : h), {
              default: n.title ? () => {
                var p;
                return (p = n.title) == null ? void 0 : p.call(n, {
                  item: h,
                  index: d
                });
              } : void 0
            }), d < f.length - 1 && v(OA, null, {
              default: n.divider ? () => {
                var p;
                return (p = n.divider) == null ? void 0 : p.call(n, {
                  item: m,
                  index: d
                });
              } : void 0
            })]);
          }), (u = n.default) == null ? void 0 : u.call(n)];
        }
      });
    }), {};
  }
});
const VA = J()({
  name: "VCardActions",
  props: ke(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return jt({
      VBtn: {
        slim: !0,
        variant: "text"
      }
    }), ie(() => {
      var i;
      return v("div", {
        class: ["v-card-actions", e.class],
        style: e.style
      }, [(i = n.default) == null ? void 0 : i.call(n)]);
    }), {};
  }
}), E5 = B({
  opacity: [Number, String],
  ...ke(),
  ...je()
}, "VCardSubtitle"), DA = J()({
  name: "VCardSubtitle",
  props: E5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ie(() => v(e.tag, {
      class: ["v-card-subtitle", e.class],
      style: [{
        "--v-card-subtitle-opacity": e.opacity
      }, e.style]
    }, n)), {};
  }
}), NA = Yr("v-card-title"), O5 = B({
  appendAvatar: String,
  appendIcon: We,
  prependAvatar: String,
  prependIcon: We,
  subtitle: [String, Number],
  title: [String, Number],
  ...ke(),
  ...bn()
}, "VCardItem"), MA = J()({
  name: "VCardItem",
  props: O5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ie(() => {
      var u;
      const i = !!(e.prependAvatar || e.prependIcon), r = !!(i || n.prepend), s = !!(e.appendAvatar || e.appendIcon), a = !!(s || n.append), o = !!(e.title != null || n.title), l = !!(e.subtitle != null || n.subtitle);
      return v("div", {
        class: ["v-card-item", e.class],
        style: e.style
      }, [r && v("div", {
        key: "prepend",
        class: "v-card-item__prepend"
      }, [n.prepend ? v(Ze, {
        key: "prepend-defaults",
        disabled: !i,
        defaults: {
          VAvatar: {
            density: e.density,
            image: e.prependAvatar
          },
          VIcon: {
            density: e.density,
            icon: e.prependIcon
          }
        }
      }, n.prepend) : v(De, null, [e.prependAvatar && v(Ji, {
        key: "prepend-avatar",
        density: e.density,
        image: e.prependAvatar
      }, null), e.prependIcon && v(at, {
        key: "prepend-icon",
        density: e.density,
        icon: e.prependIcon
      }, null)])]), v("div", {
        class: "v-card-item__content"
      }, [o && v(NA, {
        key: "title"
      }, {
        default: () => {
          var c;
          return [((c = n.title) == null ? void 0 : c.call(n)) ?? e.title];
        }
      }), l && v(DA, {
        key: "subtitle"
      }, {
        default: () => {
          var c;
          return [((c = n.subtitle) == null ? void 0 : c.call(n)) ?? e.subtitle];
        }
      }), (u = n.default) == null ? void 0 : u.call(n)]), a && v("div", {
        key: "append",
        class: "v-card-item__append"
      }, [n.append ? v(Ze, {
        key: "append-defaults",
        disabled: !s,
        defaults: {
          VAvatar: {
            density: e.density,
            image: e.appendAvatar
          },
          VIcon: {
            density: e.density,
            icon: e.appendIcon
          }
        }
      }, n.append) : v(De, null, [e.appendIcon && v(at, {
        key: "append-icon",
        density: e.density,
        icon: e.appendIcon
      }, null), e.appendAvatar && v(Ji, {
        key: "append-avatar",
        density: e.density,
        image: e.appendAvatar
      }, null)])])]);
    }), {};
  }
}), P5 = B({
  opacity: [Number, String],
  ...ke(),
  ...je()
}, "VCardText"), RA = J()({
  name: "VCardText",
  props: P5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ie(() => v(e.tag, {
      class: ["v-card-text", e.class],
      style: [{
        "--v-card-text-opacity": e.opacity
      }, e.style]
    }, n)), {};
  }
}), V5 = B({
  appendAvatar: String,
  appendIcon: We,
  disabled: Boolean,
  flat: Boolean,
  hover: Boolean,
  image: String,
  link: {
    type: Boolean,
    default: void 0
  },
  prependAvatar: String,
  prependIcon: We,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  subtitle: [String, Number],
  text: [String, Number],
  title: [String, Number],
  ...Ni(),
  ...ke(),
  ...bn(),
  ...wn(),
  ...mn(),
  ...ph(),
  ...ua(),
  ...nu(),
  ...It(),
  ...id(),
  ...je(),
  ...Qe(),
  ...tr({
    variant: "elevated"
  })
}, "VCard"), D5 = J()({
  name: "VCard",
  directives: {
    Ripple: Os
  },
  props: V5(),
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      themeClasses: r
    } = lt(e), {
      borderClasses: s
    } = er(e), {
      colorClasses: a,
      colorStyles: o,
      variantClasses: l
    } = Io(e), {
      densityClasses: u
    } = Kn(e), {
      dimensionStyles: c
    } = _n(e), {
      elevationClasses: d
    } = In(e), {
      loaderClasses: f
    } = Ic(e), {
      locationStyles: h
    } = po(e), {
      positionClasses: m
    } = iu(e), {
      roundedClasses: g
    } = Ht(e), p = nd(e, n), y = w(() => e.link !== !1 && p.isLink.value), k = w(() => !e.disabled && e.link !== !1 && (e.link || p.isClickable.value));
    return ie(() => {
      const T = y.value ? "a" : e.tag, _ = !!(i.title || e.title != null), b = !!(i.subtitle || e.subtitle != null), S = _ || b, C = !!(i.append || e.appendAvatar || e.appendIcon), x = !!(i.prepend || e.prependAvatar || e.prependIcon), A = !!(i.image || e.image), I = S || x || C, E = !!(i.text || e.text != null);
      return Rt(v(T, {
        class: ["v-card", {
          "v-card--disabled": e.disabled,
          "v-card--flat": e.flat,
          "v-card--hover": e.hover && !(e.disabled || e.flat),
          "v-card--link": k.value
        }, r.value, s.value, a.value, u.value, d.value, f.value, m.value, g.value, l.value, e.class],
        style: [o.value, c.value, h.value, e.style],
        href: p.href.value,
        onClick: k.value && p.navigate,
        tabindex: e.disabled ? -1 : void 0
      }, {
        default: () => {
          var O;
          return [A && v("div", {
            key: "image",
            class: "v-card__image"
          }, [i.image ? v(Ze, {
            key: "image-defaults",
            disabled: !e.image,
            defaults: {
              VImg: {
                cover: !0,
                src: e.image
              }
            }
          }, i.image) : v(_s, {
            key: "image-img",
            cover: !0,
            src: e.image
          }, null)]), v(Ec, {
            name: "v-card",
            active: !!e.loading,
            color: typeof e.loading == "boolean" ? void 0 : e.loading
          }, {
            default: i.loader
          }), I && v(MA, {
            key: "item",
            prependAvatar: e.prependAvatar,
            prependIcon: e.prependIcon,
            title: e.title,
            subtitle: e.subtitle,
            appendAvatar: e.appendAvatar,
            appendIcon: e.appendIcon
          }, {
            default: i.item,
            prepend: i.prepend,
            title: i.title,
            subtitle: i.subtitle,
            append: i.append
          }), E && v(RA, {
            key: "text"
          }, {
            default: () => {
              var V;
              return [((V = i.text) == null ? void 0 : V.call(i)) ?? e.text];
            }
          }), (O = i.default) == null ? void 0 : O.call(i), i.actions && v(VA, null, {
            default: i.actions
          }), fa(k.value, "v-card")];
        }
      }), [[Ei("ripple"), k.value && e.ripple]]);
    }), {};
  }
});
const N5 = (e) => {
  const {
    touchstartX: t,
    touchendX: n,
    touchstartY: i,
    touchendY: r
  } = e, s = 0.5, a = 16;
  e.offsetX = n - t, e.offsetY = r - i, Math.abs(e.offsetY) < s * Math.abs(e.offsetX) && (e.left && n < t - a && e.left(e), e.right && n > t + a && e.right(e)), Math.abs(e.offsetX) < s * Math.abs(e.offsetY) && (e.up && r < i - a && e.up(e), e.down && r > i + a && e.down(e));
};
function M5(e, t) {
  var i;
  const n = e.changedTouches[0];
  t.touchstartX = n.clientX, t.touchstartY = n.clientY, (i = t.start) == null || i.call(t, {
    originalEvent: e,
    ...t
  });
}
function R5(e, t) {
  var i;
  const n = e.changedTouches[0];
  t.touchendX = n.clientX, t.touchendY = n.clientY, (i = t.end) == null || i.call(t, {
    originalEvent: e,
    ...t
  }), N5(t);
}
function F5(e, t) {
  var i;
  const n = e.changedTouches[0];
  t.touchmoveX = n.clientX, t.touchmoveY = n.clientY, (i = t.move) == null || i.call(t, {
    originalEvent: e,
    ...t
  });
}
function B5() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const t = {
    touchstartX: 0,
    touchstartY: 0,
    touchendX: 0,
    touchendY: 0,
    touchmoveX: 0,
    touchmoveY: 0,
    offsetX: 0,
    offsetY: 0,
    left: e.left,
    right: e.right,
    up: e.up,
    down: e.down,
    start: e.start,
    move: e.move,
    end: e.end
  };
  return {
    touchstart: (n) => M5(n, t),
    touchend: (n) => R5(n, t),
    touchmove: (n) => F5(n, t)
  };
}
function L5(e, t) {
  var o;
  const n = t.value, i = n != null && n.parent ? e.parentElement : e, r = (n == null ? void 0 : n.options) ?? {
    passive: !0
  }, s = (o = t.instance) == null ? void 0 : o.$.uid;
  if (!i || !s)
    return;
  const a = B5(t.value);
  i._touchHandlers = i._touchHandlers ?? /* @__PURE__ */ Object.create(null), i._touchHandlers[s] = a, rS(a).forEach((l) => {
    i.addEventListener(l, a[l], r);
  });
}
function $5(e, t) {
  var s, a;
  const n = (s = t.value) != null && s.parent ? e.parentElement : e, i = (a = t.instance) == null ? void 0 : a.$.uid;
  if (!(n != null && n._touchHandlers) || !i)
    return;
  const r = n._touchHandlers[i];
  rS(r).forEach((o) => {
    n.removeEventListener(o, r[o]);
  }), delete n._touchHandlers[i];
}
const cb = {
  mounted: L5,
  unmounted: $5
}, FA = Symbol.for("vuetify:v-window"), BA = Symbol.for("vuetify:v-window-group"), um = B({
  continuous: Boolean,
  nextIcon: {
    type: [Boolean, String, Function, Object],
    default: "$next"
  },
  prevIcon: {
    type: [Boolean, String, Function, Object],
    default: "$prev"
  },
  reverse: Boolean,
  showArrows: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || e === "hover"
  },
  touch: {
    type: [Object, Boolean],
    default: void 0
  },
  direction: {
    type: String,
    default: "horizontal"
  },
  modelValue: null,
  disabled: Boolean,
  selectedClass: {
    type: String,
    default: "v-window-item--active"
  },
  // TODO: mandatory should probably not be exposed but do this for now
  mandatory: {
    type: [Boolean, String],
    default: "force"
  },
  ...ke(),
  ...je(),
  ...Qe()
}, "VWindow"), co = J()({
  name: "VWindow",
  directives: {
    Touch: cb
  },
  props: um(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      isRtl: r
    } = yn(), {
      t: s
    } = qt(), a = ha(e, BA), o = X(), l = w(() => r.value ? !e.reverse : e.reverse), u = pe(!1), c = w(() => {
      const _ = e.direction === "vertical" ? "y" : "x", S = (l.value ? !u.value : u.value) ? "-reverse" : "";
      return `v-window-${_}${S}-transition`;
    }), d = pe(0), f = X(void 0), h = w(() => a.items.value.findIndex((_) => a.selected.value.includes(_.id)));
    fe(h, (_, b) => {
      const S = a.items.value.length, C = S - 1;
      S <= 2 ? u.value = _ < b : _ === C && b === 0 ? u.value = !0 : _ === 0 && b === C ? u.value = !1 : u.value = _ < b;
    }), Tt(FA, {
      transition: c,
      isReversed: u,
      transitionCount: d,
      transitionHeight: f,
      rootRef: o
    });
    const m = w(() => e.continuous || h.value !== 0), g = w(() => e.continuous || h.value !== a.items.value.length - 1);
    function p() {
      m.value && a.prev();
    }
    function y() {
      g.value && a.next();
    }
    const k = w(() => {
      const _ = [], b = {
        icon: r.value ? e.nextIcon : e.prevIcon,
        class: `v-window__${l.value ? "right" : "left"}`,
        onClick: a.prev,
        "aria-label": s("$vuetify.carousel.prev")
      };
      _.push(m.value ? n.prev ? n.prev({
        props: b
      }) : v(st, b, null) : v("div", null, null));
      const S = {
        icon: r.value ? e.prevIcon : e.nextIcon,
        class: `v-window__${l.value ? "left" : "right"}`,
        onClick: a.next,
        "aria-label": s("$vuetify.carousel.next")
      };
      return _.push(g.value ? n.next ? n.next({
        props: S
      }) : v(st, S, null) : v("div", null, null)), _;
    }), T = w(() => e.touch === !1 ? e.touch : {
      ...{
        left: () => {
          l.value ? p() : y();
        },
        right: () => {
          l.value ? y() : p();
        },
        start: (b) => {
          let {
            originalEvent: S
          } = b;
          S.stopPropagation();
        }
      },
      ...e.touch === !0 ? {} : e.touch
    });
    return ie(() => Rt(v(e.tag, {
      ref: o,
      class: ["v-window", {
        "v-window--show-arrows-on-hover": e.showArrows === "hover"
      }, i.value, e.class],
      style: e.style
    }, {
      default: () => {
        var _, b;
        return [v("div", {
          class: "v-window__container",
          style: {
            height: f.value
          }
        }, [(_ = n.default) == null ? void 0 : _.call(n, {
          group: a
        }), e.showArrows !== !1 && v("div", {
          class: "v-window__controls"
        }, [k.value])]), (b = n.additional) == null ? void 0 : b.call(n, {
          group: a
        })];
      }
    }), [[Ei("touch"), T.value]])), {
      group: a
    };
  }
}), W5 = B({
  color: String,
  cycle: Boolean,
  delimiterIcon: {
    type: We,
    default: "$delimiter"
  },
  height: {
    type: [Number, String],
    default: 500
  },
  hideDelimiters: Boolean,
  hideDelimiterBackground: Boolean,
  interval: {
    type: [Number, String],
    default: 6e3,
    validator: (e) => Number(e) > 0
  },
  progress: [Boolean, String],
  verticalDelimiters: [Boolean, String],
  ...um({
    continuous: !0,
    mandatory: "force",
    showArrows: !0
  })
}, "VCarousel"), j5 = J()({
  name: "VCarousel",
  props: W5(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), {
      t: r
    } = qt(), s = X();
    let a = -1;
    fe(i, l), fe(() => e.interval, l), fe(() => e.cycle, (u) => {
      u ? l() : window.clearTimeout(a);
    }), jn(o);
    function o() {
      !e.cycle || !s.value || (a = window.setTimeout(s.value.group.next, +e.interval > 0 ? +e.interval : 6e3));
    }
    function l() {
      window.clearTimeout(a), window.requestAnimationFrame(o);
    }
    return ie(() => {
      const u = co.filterProps(e);
      return v(co, se({
        ref: s
      }, u, {
        modelValue: i.value,
        "onUpdate:modelValue": (c) => i.value = c,
        class: ["v-carousel", {
          "v-carousel--hide-delimiter-background": e.hideDelimiterBackground,
          "v-carousel--vertical-delimiters": e.verticalDelimiters
        }, e.class],
        style: [{
          height: _e(e.height)
        }, e.style]
      }), {
        default: n.default,
        additional: (c) => {
          let {
            group: d
          } = c;
          return v(De, null, [!e.hideDelimiters && v("div", {
            class: "v-carousel__controls",
            style: {
              left: e.verticalDelimiters === "left" && e.verticalDelimiters ? 0 : "auto",
              right: e.verticalDelimiters === "right" ? 0 : "auto"
            }
          }, [d.items.value.length > 0 && v(Ze, {
            defaults: {
              VBtn: {
                color: e.color,
                icon: e.delimiterIcon,
                size: "x-small",
                variant: "text"
              }
            },
            scoped: !0
          }, {
            default: () => [d.items.value.map((f, h) => {
              const m = {
                id: `carousel-item-${f.id}`,
                "aria-label": r("$vuetify.carousel.ariaLabel.delimiter", h + 1, d.items.value.length),
                class: ["v-carousel__controls__item", d.isSelected(f.id) && "v-btn--active"],
                onClick: () => d.select(f.id, !0)
              };
              return n.item ? n.item({
                props: m,
                item: f
              }) : v(st, se(f, m), null);
            })]
          })]), e.progress && v(gh, {
            class: "v-carousel__progress",
            color: typeof e.progress == "string" ? e.progress : void 0,
            modelValue: (d.getItemIndex(i.value) + 1) / d.items.value.length * 100
          }, null)]);
        },
        prev: n.prev,
        next: n.next
      });
    }), {};
  }
}), cm = B({
  reverseTransition: {
    type: [Boolean, String],
    default: void 0
  },
  transition: {
    type: [Boolean, String],
    default: void 0
  },
  ...ke(),
  ...Oo(),
  ...sb()
}, "VWindowItem"), fo = J()({
  name: "VWindowItem",
  directives: {
    Touch: cb
  },
  props: cm(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = tt(FA), r = Po(e, BA), {
      isBooted: s
    } = Ao();
    if (!i || !r)
      throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
    const a = pe(!1), o = w(() => s.value && (i.isReversed.value ? e.reverseTransition !== !1 : e.transition !== !1));
    function l() {
      !a.value || !i || (a.value = !1, i.transitionCount.value > 0 && (i.transitionCount.value -= 1, i.transitionCount.value === 0 && (i.transitionHeight.value = void 0)));
    }
    function u() {
      var m;
      a.value || !i || (a.value = !0, i.transitionCount.value === 0 && (i.transitionHeight.value = _e((m = i.rootRef.value) == null ? void 0 : m.clientHeight)), i.transitionCount.value += 1);
    }
    function c() {
      l();
    }
    function d(m) {
      a.value && He(() => {
        !o.value || !a.value || !i || (i.transitionHeight.value = _e(m.clientHeight));
      });
    }
    const f = w(() => {
      const m = i.isReversed.value ? e.reverseTransition : e.transition;
      return o.value ? {
        name: typeof m != "string" ? i.transition.value : m,
        onBeforeEnter: u,
        onAfterEnter: l,
        onEnterCancelled: c,
        onBeforeLeave: u,
        onAfterLeave: l,
        onLeaveCancelled: c,
        onEnter: d
      } : !1;
    }), {
      hasContent: h
    } = ab(e, r.isSelected);
    return ie(() => v(Gn, {
      transition: f.value,
      disabled: !s.value
    }, {
      default: () => {
        var m;
        return [Rt(v("div", {
          class: ["v-window-item", r.selectedClass.value, e.class],
          style: e.style
        }, [h.value && ((m = n.default) == null ? void 0 : m.call(n))]), [[Cr, r.isSelected.value]])];
      }
    })), {
      groupItem: r
    };
  }
}), H5 = B({
  ...Mx(),
  ...cm()
}, "VCarouselItem"), z5 = J()({
  name: "VCarouselItem",
  inheritAttrs: !1,
  props: H5(),
  setup(e, t) {
    let {
      slots: n,
      attrs: i
    } = t;
    ie(() => {
      const r = _s.filterProps(e), s = fo.filterProps(e);
      return v(fo, se({
        class: ["v-carousel-item", e.class]
      }, s), {
        default: () => [v(_s, se(i, r), n)]
      });
    });
  }
});
const U5 = Yr("v-code");
const q5 = B({
  color: {
    type: Object
  },
  disabled: Boolean,
  dotSize: {
    type: [Number, String],
    default: 10
  },
  height: {
    type: [Number, String],
    default: 150
  },
  width: {
    type: [Number, String],
    default: 300
  },
  ...ke()
}, "VColorPickerCanvas"), G5 = Oi({
  name: "VColorPickerCanvas",
  props: q5(),
  emits: {
    "update:color": (e) => !0,
    "update:position": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const i = pe(!1), r = X(), s = pe(parseFloat(e.width)), a = pe(parseFloat(e.height)), o = X({
      x: 0,
      y: 0
    }), l = w({
      get: () => o.value,
      set(p) {
        var T, _;
        if (!r.value)
          return;
        const {
          x: y,
          y: k
        } = p;
        o.value = p, n("update:color", {
          h: ((T = e.color) == null ? void 0 : T.h) ?? 0,
          s: Xt(y, 0, s.value) / s.value,
          v: 1 - Xt(k, 0, a.value) / a.value,
          a: ((_ = e.color) == null ? void 0 : _.a) ?? 1
        });
      }
    }), u = w(() => {
      const {
        x: p,
        y
      } = l.value, k = parseInt(e.dotSize, 10) / 2;
      return {
        width: _e(e.dotSize),
        height: _e(e.dotSize),
        transform: `translate(${_e(p - k)}, ${_e(y - k)})`
      };
    }), {
      resizeRef: c
    } = _r((p) => {
      var T;
      if (!((T = c.el) != null && T.offsetParent))
        return;
      const {
        width: y,
        height: k
      } = p[0].contentRect;
      s.value = y, a.value = k;
    });
    function d(p, y, k) {
      const {
        left: T,
        top: _,
        width: b,
        height: S
      } = k;
      l.value = {
        x: Xt(p - T, 0, b),
        y: Xt(y - _, 0, S)
      };
    }
    function f(p) {
      p.type === "mousedown" && p.preventDefault(), !e.disabled && (h(p), window.addEventListener("mousemove", h), window.addEventListener("mouseup", m), window.addEventListener("touchmove", h), window.addEventListener("touchend", m));
    }
    function h(p) {
      if (e.disabled || !r.value)
        return;
      i.value = !0;
      const y = dO(p);
      d(y.clientX, y.clientY, r.value.getBoundingClientRect());
    }
    function m() {
      window.removeEventListener("mousemove", h), window.removeEventListener("mouseup", m), window.removeEventListener("touchmove", h), window.removeEventListener("touchend", m);
    }
    function g() {
      var _;
      if (!r.value)
        return;
      const p = r.value, y = p.getContext("2d");
      if (!y)
        return;
      const k = y.createLinearGradient(0, 0, p.width, 0);
      k.addColorStop(0, "hsla(0, 0%, 100%, 1)"), k.addColorStop(1, `hsla(${((_ = e.color) == null ? void 0 : _.h) ?? 0}, 100%, 50%, 1)`), y.fillStyle = k, y.fillRect(0, 0, p.width, p.height);
      const T = y.createLinearGradient(0, 0, 0, p.height);
      T.addColorStop(0, "hsla(0, 0%, 0%, 0)"), T.addColorStop(1, "hsla(0, 0%, 0%, 1)"), y.fillStyle = T, y.fillRect(0, 0, p.width, p.height);
    }
    return fe(() => {
      var p;
      return (p = e.color) == null ? void 0 : p.h;
    }, g, {
      immediate: !0
    }), fe(() => [s.value, a.value], (p, y) => {
      g(), o.value = {
        x: l.value.x * p[0] / y[0],
        y: l.value.y * p[1] / y[1]
      };
    }, {
      flush: "post"
    }), fe(() => e.color, () => {
      if (i.value) {
        i.value = !1;
        return;
      }
      o.value = e.color ? {
        x: e.color.s * s.value,
        y: (1 - e.color.v) * a.value
      } : {
        x: 0,
        y: 0
      };
    }, {
      deep: !0,
      immediate: !0
    }), jn(() => g()), ie(() => v("div", {
      ref: c,
      class: ["v-color-picker-canvas", e.class],
      style: e.style,
      onMousedown: f,
      onTouchstartPassive: f
    }, [v("canvas", {
      ref: r,
      width: s.value,
      height: a.value
    }, null), e.color && v("div", {
      class: ["v-color-picker-canvas__dot", {
        "v-color-picker-canvas__dot--disabled": e.disabled
      }],
      style: u.value
    }, null)])), {};
  }
});
function Y5(e, t) {
  if (t) {
    const {
      a: n,
      ...i
    } = e;
    return i;
  }
  return e;
}
function Z5(e, t) {
  if (t == null || typeof t == "string") {
    const n = SS(e);
    return e.a === 1 ? n.slice(0, 7) : n;
  }
  if (typeof t == "object") {
    let n;
    return Da(t, ["r", "g", "b"]) ? n = ps(e) : Da(t, ["h", "s", "l"]) ? n = gS(e) : Da(t, ["h", "s", "v"]) && (n = e), Y5(n, !Da(t, ["a"]) && e.a === 1);
  }
  return e;
}
const sl = {
  h: 0,
  s: 0,
  v: 0,
  a: 1
}, Fg = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "R",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.r),
    getColor: (e, t) => ({
      ...e,
      r: Number(t)
    })
  }, {
    label: "G",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.g),
    getColor: (e, t) => ({
      ...e,
      g: Number(t)
    })
  }, {
    label: "B",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.b),
    getColor: (e, t) => ({
      ...e,
      b: Number(t)
    })
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (e) => {
      let {
        a: t
      } = e;
      return t != null ? Math.round(t * 100) / 100 : 1;
    },
    getColor: (e, t) => ({
      ...e,
      a: Number(t)
    })
  }],
  to: ps,
  from: ch
};
var K_;
const K5 = {
  ...Fg,
  inputs: (K_ = Fg.inputs) == null ? void 0 : K_.slice(0, 3)
}, Bg = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "H",
    max: 360,
    step: 1,
    getValue: (e) => Math.round(e.h),
    getColor: (e, t) => ({
      ...e,
      h: Number(t)
    })
  }, {
    label: "S",
    max: 1,
    step: 0.01,
    getValue: (e) => Math.round(e.s * 100) / 100,
    getColor: (e, t) => ({
      ...e,
      s: Number(t)
    })
  }, {
    label: "L",
    max: 1,
    step: 0.01,
    getValue: (e) => Math.round(e.l * 100) / 100,
    getColor: (e, t) => ({
      ...e,
      l: Number(t)
    })
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (e) => {
      let {
        a: t
      } = e;
      return t != null ? Math.round(t * 100) / 100 : 1;
    },
    getColor: (e, t) => ({
      ...e,
      a: Number(t)
    })
  }],
  to: gS,
  from: op
}, X5 = {
  ...Bg,
  inputs: Bg.inputs.slice(0, 3)
}, LA = {
  inputProps: {
    type: "text"
  },
  inputs: [{
    label: "HEXA",
    getValue: (e) => e,
    getColor: (e, t) => t
  }],
  to: SS,
  from: _S
}, J5 = {
  ...LA,
  inputs: [{
    label: "HEX",
    getValue: (e) => e.slice(0, 7),
    getColor: (e, t) => t
  }]
}, qa = {
  rgb: K5,
  rgba: Fg,
  hsl: X5,
  hsla: Bg,
  hex: J5,
  hexa: LA
}, Q5 = (e) => {
  let {
    label: t,
    ...n
  } = e;
  return v("div", {
    class: "v-color-picker-edit__input"
  }, [v("input", n, null), v("span", null, [t])]);
}, eG = B({
  color: Object,
  disabled: Boolean,
  mode: {
    type: String,
    default: "rgba",
    validator: (e) => Object.keys(qa).includes(e)
  },
  modes: {
    type: Array,
    default: () => Object.keys(qa),
    validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(qa).includes(t))
  },
  ...ke()
}, "VColorPickerEdit"), tG = Oi({
  name: "VColorPickerEdit",
  props: eG(),
  emits: {
    "update:color": (e) => !0,
    "update:mode": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const i = w(() => e.modes.map((s) => ({
      ...qa[s],
      name: s
    }))), r = w(() => {
      var o;
      const s = i.value.find((l) => l.name === e.mode);
      if (!s)
        return [];
      const a = e.color ? s.to(e.color) : null;
      return (o = s.inputs) == null ? void 0 : o.map((l) => {
        let {
          getValue: u,
          getColor: c,
          ...d
        } = l;
        return {
          ...s.inputProps,
          ...d,
          disabled: e.disabled,
          value: a && u(a),
          onChange: (f) => {
            const h = f.target;
            h && n("update:color", s.from(c(a ?? s.to(sl), h.value)));
          }
        };
      });
    });
    return ie(() => {
      var s;
      return v("div", {
        class: ["v-color-picker-edit", e.class],
        style: e.style
      }, [(s = r.value) == null ? void 0 : s.map((a) => v(Q5, a, null)), i.value.length > 1 && v(st, {
        icon: "$unfold",
        size: "x-small",
        variant: "plain",
        onClick: () => {
          const a = i.value.findIndex((o) => o.name === e.mode);
          n("update:mode", i.value[(a + 1) % i.value.length].name);
        }
      }, null)]);
    }), {};
  }
});
const db = Symbol.for("vuetify:v-slider");
function Lg(e, t, n) {
  const i = n === "vertical", r = t.getBoundingClientRect(), s = "touches" in e ? e.touches[0] : e;
  return i ? s.clientY - (r.top + r.height / 2) : s.clientX - (r.left + r.width / 2);
}
function nG(e, t) {
  return "touches" in e && e.touches.length ? e.touches[0][t] : "changedTouches" in e && e.changedTouches.length ? e.changedTouches[0][t] : e[t];
}
const $A = B({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  readonly: {
    type: Boolean,
    default: null
  },
  max: {
    type: [Number, String],
    default: 100
  },
  min: {
    type: [Number, String],
    default: 0
  },
  step: {
    type: [Number, String],
    default: 0
  },
  thumbColor: String,
  thumbLabel: {
    type: [Boolean, String],
    default: void 0,
    validator: (e) => typeof e == "boolean" || e === "always"
  },
  thumbSize: {
    type: [Number, String],
    default: 20
  },
  showTicks: {
    type: [Boolean, String],
    default: !1,
    validator: (e) => typeof e == "boolean" || e === "always"
  },
  ticks: {
    type: [Array, Object]
  },
  tickSize: {
    type: [Number, String],
    default: 2
  },
  color: String,
  trackColor: String,
  trackFillColor: String,
  trackSize: {
    type: [Number, String],
    default: 4
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  reverse: Boolean,
  ...It(),
  ...mn({
    elevation: 2
  }),
  ripple: {
    type: Boolean,
    default: !0
  }
}, "Slider"), WA = (e) => {
  const t = w(() => parseFloat(e.min)), n = w(() => parseFloat(e.max)), i = w(() => +e.step > 0 ? parseFloat(e.step) : 0), r = w(() => Math.max(Hb(i.value), Hb(t.value)));
  function s(a) {
    if (a = parseFloat(a), i.value <= 0)
      return a;
    const o = Xt(a, t.value, n.value), l = t.value % i.value, u = Math.round((o - l) / i.value) * i.value + l;
    return parseFloat(Math.min(u, n.value).toFixed(r.value));
  }
  return {
    min: t,
    max: n,
    step: i,
    decimals: r,
    roundValue: s
  };
}, jA = (e) => {
  let {
    props: t,
    steps: n,
    onSliderStart: i,
    onSliderMove: r,
    onSliderEnd: s,
    getActiveThumb: a
  } = e;
  const {
    isRtl: o
  } = yn(), l = G(t, "reverse"), u = w(() => t.direction === "vertical"), c = w(() => u.value !== l.value), {
    min: d,
    max: f,
    step: h,
    decimals: m,
    roundValue: g
  } = n, p = w(() => parseInt(t.thumbSize, 10)), y = w(() => parseInt(t.tickSize, 10)), k = w(() => parseInt(t.trackSize, 10)), T = w(() => (f.value - d.value) / h.value), _ = G(t, "disabled"), b = w(() => t.error || t.disabled ? void 0 : t.thumbColor ?? t.color), S = w(() => t.error || t.disabled ? void 0 : t.trackColor ?? t.color), C = w(() => t.error || t.disabled ? void 0 : t.trackFillColor ?? t.color), x = pe(!1), A = pe(0), I = X(), E = X();
  function O(K) {
    var te;
    const ue = t.direction === "vertical", ve = ue ? "top" : "left", Re = ue ? "height" : "width", he = ue ? "clientY" : "clientX", {
      [ve]: Pe,
      [Re]: le
    } = (te = I.value) == null ? void 0 : te.$el.getBoundingClientRect(), be = nG(K, he);
    let Oe = Math.min(Math.max((be - Pe - A.value) / le, 0), 1) || 0;
    return (ue ? c.value : c.value !== o.value) && (Oe = 1 - Oe), g(d.value + Oe * (f.value - d.value));
  }
  const V = (K) => {
    s({
      value: O(K)
    }), x.value = !1, A.value = 0;
  }, N = (K) => {
    E.value = a(K), E.value && (E.value.focus(), x.value = !0, E.value.contains(K.target) ? A.value = Lg(K, E.value, t.direction) : (A.value = 0, r({
      value: O(K)
    })), i({
      value: O(K)
    }));
  }, F = {
    passive: !0,
    capture: !0
  };
  function $(K) {
    r({
      value: O(K)
    });
  }
  function Z(K) {
    K.stopPropagation(), K.preventDefault(), V(K), window.removeEventListener("mousemove", $, F), window.removeEventListener("mouseup", Z);
  }
  function j(K) {
    var ue;
    V(K), window.removeEventListener("touchmove", $, F), (ue = K.target) == null || ue.removeEventListener("touchend", j);
  }
  function H(K) {
    var ue;
    N(K), window.addEventListener("touchmove", $, F), (ue = K.target) == null || ue.addEventListener("touchend", j, {
      passive: !1
    });
  }
  function R(K) {
    K.preventDefault(), N(K), window.addEventListener("mousemove", $, F), window.addEventListener("mouseup", Z, {
      passive: !1
    });
  }
  const L = (K) => {
    const ue = (K - d.value) / (f.value - d.value) * 100;
    return Xt(isNaN(ue) ? 0 : ue, 0, 100);
  }, ne = G(t, "showTicks"), oe = w(() => ne.value ? t.ticks ? Array.isArray(t.ticks) ? t.ticks.map((K) => ({
    value: K,
    position: L(K),
    label: K.toString()
  })) : Object.keys(t.ticks).map((K) => ({
    value: parseFloat(K),
    position: L(parseFloat(K)),
    label: t.ticks[K]
  })) : T.value !== 1 / 0 ? jr(T.value + 1).map((K) => {
    const ue = d.value + K * h.value;
    return {
      value: ue,
      position: L(ue)
    };
  }) : [] : []), we = w(() => oe.value.some((K) => {
    let {
      label: ue
    } = K;
    return !!ue;
  })), ee = {
    activeThumbRef: E,
    color: G(t, "color"),
    decimals: m,
    disabled: _,
    direction: G(t, "direction"),
    elevation: G(t, "elevation"),
    hasLabels: we,
    isReversed: l,
    indexFromEnd: c,
    min: d,
    max: f,
    mousePressed: x,
    numTicks: T,
    onSliderMousedown: R,
    onSliderTouchstart: H,
    parsedTicks: oe,
    parseMouseMove: O,
    position: L,
    readonly: G(t, "readonly"),
    rounded: G(t, "rounded"),
    roundValue: g,
    showTicks: ne,
    startOffset: A,
    step: h,
    thumbSize: p,
    thumbColor: b,
    thumbLabel: G(t, "thumbLabel"),
    ticks: G(t, "ticks"),
    tickSize: y,
    trackColor: S,
    trackContainerRef: I,
    trackFillColor: C,
    trackSize: k,
    vertical: u
  };
  return Tt(db, ee), ee;
}, iG = B({
  focused: Boolean,
  max: {
    type: Number,
    required: !0
  },
  min: {
    type: Number,
    required: !0
  },
  modelValue: {
    type: Number,
    required: !0
  },
  position: {
    type: Number,
    required: !0
  },
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  ...ke()
}, "VSliderThumb"), $g = J()({
  name: "VSliderThumb",
  directives: {
    Ripple: Os
  },
  props: iG(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const r = tt(db), {
      isRtl: s,
      rtlClasses: a
    } = yn();
    if (!r)
      throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
    const {
      thumbColor: o,
      step: l,
      disabled: u,
      thumbSize: c,
      thumbLabel: d,
      direction: f,
      isReversed: h,
      vertical: m,
      readonly: g,
      elevation: p,
      mousePressed: y,
      decimals: k,
      indexFromEnd: T
    } = r, _ = w(() => u.value ? void 0 : p.value), {
      elevationClasses: b
    } = In(_), {
      textColorClasses: S,
      textColorStyles: C
    } = Ln(o), {
      pageup: x,
      pagedown: A,
      end: I,
      home: E,
      left: O,
      right: V,
      down: N,
      up: F
    } = Tv, $ = [x, A, I, E, O, V, N, F], Z = w(() => l.value ? [1, 2, 3] : [1, 5, 10]);
    function j(R, L) {
      if (!$.includes(R.key))
        return;
      R.preventDefault();
      const ne = l.value || 0.1, oe = (e.max - e.min) / ne;
      if ([O, V, N, F].includes(R.key)) {
        const ee = (m.value ? [s.value ? O : V, h.value ? N : F] : T.value !== s.value ? [O, F] : [V, F]).includes(R.key) ? 1 : -1, K = R.shiftKey ? 2 : R.ctrlKey ? 1 : 0;
        L = L + ee * ne * Z.value[K];
      } else if (R.key === E)
        L = e.min;
      else if (R.key === I)
        L = e.max;
      else {
        const we = R.key === A ? 1 : -1;
        L = L - we * ne * (oe > 100 ? oe / 10 : 10);
      }
      return Math.max(e.min, Math.min(e.max, L));
    }
    function H(R) {
      const L = j(R, e.modelValue);
      L != null && i("update:modelValue", L);
    }
    return ie(() => {
      const R = _e(T.value ? 100 - e.position : e.position, "%");
      return v("div", {
        class: ["v-slider-thumb", {
          "v-slider-thumb--focused": e.focused,
          "v-slider-thumb--pressed": e.focused && y.value
        }, e.class, a.value],
        style: [{
          "--v-slider-thumb-position": R,
          "--v-slider-thumb-size": _e(c.value)
        }, e.style],
        role: "slider",
        tabindex: u.value ? -1 : 0,
        "aria-valuemin": e.min,
        "aria-valuemax": e.max,
        "aria-valuenow": e.modelValue,
        "aria-readonly": !!g.value,
        "aria-orientation": f.value,
        onKeydown: g.value ? void 0 : H
      }, [v("div", {
        class: ["v-slider-thumb__surface", S.value, b.value],
        style: {
          ...C.value
        }
      }, null), Rt(v("div", {
        class: ["v-slider-thumb__ripple", S.value],
        style: C.value
      }, null), [[Ei("ripple"), e.ripple, null, {
        circle: !0,
        center: !0
      }]]), v(fp, {
        origin: "bottom center"
      }, {
        default: () => {
          var L;
          return [Rt(v("div", {
            class: "v-slider-thumb__label-container"
          }, [v("div", {
            class: ["v-slider-thumb__label"]
          }, [v("div", null, [((L = n["thumb-label"]) == null ? void 0 : L.call(n, {
            modelValue: e.modelValue
          })) ?? e.modelValue.toFixed(l.value ? k.value : 1)])])]), [[Cr, d.value && e.focused || d.value === "always"]])];
        }
      })]);
    }), {};
  }
});
const rG = B({
  start: {
    type: Number,
    required: !0
  },
  stop: {
    type: Number,
    required: !0
  },
  ...ke()
}, "VSliderTrack"), HA = J()({
  name: "VSliderTrack",
  props: rG(),
  emits: {},
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = tt(db);
    if (!i)
      throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
    const {
      color: r,
      parsedTicks: s,
      rounded: a,
      showTicks: o,
      tickSize: l,
      trackColor: u,
      trackFillColor: c,
      trackSize: d,
      vertical: f,
      min: h,
      max: m,
      indexFromEnd: g
    } = i, {
      roundedClasses: p
    } = Ht(a), {
      backgroundColorClasses: y,
      backgroundColorStyles: k
    } = gt(c), {
      backgroundColorClasses: T,
      backgroundColorStyles: _
    } = gt(u), b = w(() => `inset-${f.value ? "block" : "inline"}-${g.value ? "end" : "start"}`), S = w(() => f.value ? "height" : "width"), C = w(() => ({
      [b.value]: "0%",
      [S.value]: "100%"
    })), x = w(() => e.stop - e.start), A = w(() => ({
      [b.value]: _e(e.start, "%"),
      [S.value]: _e(x.value, "%")
    })), I = w(() => o.value ? (f.value ? s.value.slice().reverse() : s.value).map((O, V) => {
      var F;
      const N = O.value !== h.value && O.value !== m.value ? _e(O.position, "%") : void 0;
      return v("div", {
        key: O.value,
        class: ["v-slider-track__tick", {
          "v-slider-track__tick--filled": O.position >= e.start && O.position <= e.stop,
          "v-slider-track__tick--first": O.value === h.value,
          "v-slider-track__tick--last": O.value === m.value
        }],
        style: {
          [b.value]: N
        }
      }, [(O.label || n["tick-label"]) && v("div", {
        class: "v-slider-track__tick-label"
      }, [((F = n["tick-label"]) == null ? void 0 : F.call(n, {
        tick: O,
        index: V
      })) ?? O.label])]);
    }) : []);
    return ie(() => v("div", {
      class: ["v-slider-track", p.value, e.class],
      style: [{
        "--v-slider-track-size": _e(d.value),
        "--v-slider-tick-size": _e(l.value)
      }, e.style]
    }, [v("div", {
      class: ["v-slider-track__background", T.value, {
        "v-slider-track__background--opacity": !!r.value || !c.value
      }],
      style: {
        ...C.value,
        ..._.value
      }
    }, null), v("div", {
      class: ["v-slider-track__fill", y.value],
      style: {
        ...A.value,
        ...k.value
      }
    }, null), o.value && v("div", {
      class: ["v-slider-track__ticks", {
        "v-slider-track__ticks--always-show": o.value === "always"
      }]
    }, [I.value])])), {};
  }
}), sG = B({
  ...Ac(),
  ...$A(),
  ...Ts(),
  modelValue: {
    type: [Number, String],
    default: 0
  }
}, "VSlider"), Wg = J()({
  name: "VSlider",
  props: sG(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    start: (e) => !0,
    end: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const r = X(), {
      rtlClasses: s
    } = yn(), a = WA(e), o = Ee(e, "modelValue", void 0, (S) => a.roundValue(S ?? a.min.value)), {
      min: l,
      max: u,
      mousePressed: c,
      roundValue: d,
      onSliderMousedown: f,
      onSliderTouchstart: h,
      trackContainerRef: m,
      position: g,
      hasLabels: p,
      readonly: y
    } = jA({
      props: e,
      steps: a,
      onSliderStart: () => {
        i("start", o.value);
      },
      onSliderEnd: (S) => {
        let {
          value: C
        } = S;
        const x = d(C);
        o.value = x, i("end", x);
      },
      onSliderMove: (S) => {
        let {
          value: C
        } = S;
        return o.value = d(C);
      },
      getActiveThumb: () => {
        var S;
        return (S = r.value) == null ? void 0 : S.$el;
      }
    }), {
      isFocused: k,
      focus: T,
      blur: _
    } = Cs(e), b = w(() => g(o.value));
    return ie(() => {
      const S = $n.filterProps(e), C = !!(e.label || n.label || n.prepend);
      return v($n, se({
        class: ["v-slider", {
          "v-slider--has-labels": !!n["tick-label"] || p.value,
          "v-slider--focused": k.value,
          "v-slider--pressed": c.value,
          "v-slider--disabled": e.disabled
        }, s.value, e.class],
        style: e.style
      }, S, {
        focused: k.value
      }), {
        ...n,
        prepend: C ? (x) => {
          var A, I;
          return v(De, null, [((A = n.label) == null ? void 0 : A.call(n, x)) ?? (e.label ? v(Rl, {
            id: x.id.value,
            class: "v-slider__label",
            text: e.label
          }, null) : void 0), (I = n.prepend) == null ? void 0 : I.call(n, x)]);
        } : void 0,
        default: (x) => {
          let {
            id: A,
            messagesId: I
          } = x;
          return v("div", {
            class: "v-slider__container",
            onMousedown: y.value ? void 0 : f,
            onTouchstartPassive: y.value ? void 0 : h
          }, [v("input", {
            id: A.value,
            name: e.name || A.value,
            disabled: !!e.disabled,
            readonly: !!e.readonly,
            tabindex: "-1",
            value: o.value
          }, null), v(HA, {
            ref: m,
            start: 0,
            stop: b.value
          }, {
            "tick-label": n["tick-label"]
          }), v($g, {
            ref: r,
            "aria-describedby": I.value,
            focused: k.value,
            min: l.value,
            max: u.value,
            modelValue: o.value,
            "onUpdate:modelValue": (E) => o.value = E,
            position: b.value,
            elevation: e.elevation,
            onFocus: T,
            onBlur: _,
            ripple: e.ripple
          }, {
            "thumb-label": n["thumb-label"]
          })]);
        }
      });
    }), {};
  }
}), aG = B({
  color: {
    type: Object
  },
  disabled: Boolean,
  hideAlpha: Boolean,
  ...ke()
}, "VColorPickerPreview"), oG = Oi({
  name: "VColorPickerPreview",
  props: aG(),
  emits: {
    "update:color": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const i = new AbortController();
    Q_(() => i.abort());
    async function r() {
      if (!$b)
        return;
      const s = new window.EyeDropper();
      try {
        const a = await s.open({
          signal: i.signal
        }), o = _S(a.sRGBHex);
        n("update:color", {
          ...e.color ?? sl,
          ...o
        });
      } catch {
      }
    }
    return ie(() => {
      var s, a;
      return v("div", {
        class: ["v-color-picker-preview", {
          "v-color-picker-preview--hide-alpha": e.hideAlpha
        }, e.class],
        style: e.style
      }, [$b && v("div", {
        class: "v-color-picker-preview__eye-dropper",
        key: "eyeDropper"
      }, [v(st, {
        onClick: r,
        icon: "$eyeDropper",
        variant: "plain",
        density: "comfortable"
      }, null)]), v("div", {
        class: "v-color-picker-preview__dot"
      }, [v("div", {
        style: {
          background: yS(e.color ?? sl)
        }
      }, null)]), v("div", {
        class: "v-color-picker-preview__sliders"
      }, [v(Wg, {
        class: "v-color-picker-preview__track v-color-picker-preview__hue",
        modelValue: (s = e.color) == null ? void 0 : s.h,
        "onUpdate:modelValue": (o) => n("update:color", {
          ...e.color ?? sl,
          h: o
        }),
        step: 0,
        min: 0,
        max: 360,
        disabled: e.disabled,
        thumbSize: 14,
        trackSize: 8,
        trackFillColor: "white",
        hideDetails: !0
      }, null), !e.hideAlpha && v(Wg, {
        class: "v-color-picker-preview__track v-color-picker-preview__alpha",
        modelValue: ((a = e.color) == null ? void 0 : a.a) ?? 1,
        "onUpdate:modelValue": (o) => n("update:color", {
          ...e.color ?? sl,
          a: o
        }),
        step: 1 / 256,
        min: 0,
        max: 1,
        disabled: e.disabled,
        thumbSize: 14,
        trackSize: 8,
        trackFillColor: "white",
        hideDetails: !0
      }, null)])]);
    }), {};
  }
});
const lG = {
  base: "#f44336",
  lighten5: "#ffebee",
  lighten4: "#ffcdd2",
  lighten3: "#ef9a9a",
  lighten2: "#e57373",
  lighten1: "#ef5350",
  darken1: "#e53935",
  darken2: "#d32f2f",
  darken3: "#c62828",
  darken4: "#b71c1c",
  accent1: "#ff8a80",
  accent2: "#ff5252",
  accent3: "#ff1744",
  accent4: "#d50000"
}, uG = {
  base: "#e91e63",
  lighten5: "#fce4ec",
  lighten4: "#f8bbd0",
  lighten3: "#f48fb1",
  lighten2: "#f06292",
  lighten1: "#ec407a",
  darken1: "#d81b60",
  darken2: "#c2185b",
  darken3: "#ad1457",
  darken4: "#880e4f",
  accent1: "#ff80ab",
  accent2: "#ff4081",
  accent3: "#f50057",
  accent4: "#c51162"
}, cG = {
  base: "#9c27b0",
  lighten5: "#f3e5f5",
  lighten4: "#e1bee7",
  lighten3: "#ce93d8",
  lighten2: "#ba68c8",
  lighten1: "#ab47bc",
  darken1: "#8e24aa",
  darken2: "#7b1fa2",
  darken3: "#6a1b9a",
  darken4: "#4a148c",
  accent1: "#ea80fc",
  accent2: "#e040fb",
  accent3: "#d500f9",
  accent4: "#aa00ff"
}, dG = {
  base: "#673ab7",
  lighten5: "#ede7f6",
  lighten4: "#d1c4e9",
  lighten3: "#b39ddb",
  lighten2: "#9575cd",
  lighten1: "#7e57c2",
  darken1: "#5e35b1",
  darken2: "#512da8",
  darken3: "#4527a0",
  darken4: "#311b92",
  accent1: "#b388ff",
  accent2: "#7c4dff",
  accent3: "#651fff",
  accent4: "#6200ea"
}, fG = {
  base: "#3f51b5",
  lighten5: "#e8eaf6",
  lighten4: "#c5cae9",
  lighten3: "#9fa8da",
  lighten2: "#7986cb",
  lighten1: "#5c6bc0",
  darken1: "#3949ab",
  darken2: "#303f9f",
  darken3: "#283593",
  darken4: "#1a237e",
  accent1: "#8c9eff",
  accent2: "#536dfe",
  accent3: "#3d5afe",
  accent4: "#304ffe"
}, hG = {
  base: "#2196f3",
  lighten5: "#e3f2fd",
  lighten4: "#bbdefb",
  lighten3: "#90caf9",
  lighten2: "#64b5f6",
  lighten1: "#42a5f5",
  darken1: "#1e88e5",
  darken2: "#1976d2",
  darken3: "#1565c0",
  darken4: "#0d47a1",
  accent1: "#82b1ff",
  accent2: "#448aff",
  accent3: "#2979ff",
  accent4: "#2962ff"
}, mG = {
  base: "#03a9f4",
  lighten5: "#e1f5fe",
  lighten4: "#b3e5fc",
  lighten3: "#81d4fa",
  lighten2: "#4fc3f7",
  lighten1: "#29b6f6",
  darken1: "#039be5",
  darken2: "#0288d1",
  darken3: "#0277bd",
  darken4: "#01579b",
  accent1: "#80d8ff",
  accent2: "#40c4ff",
  accent3: "#00b0ff",
  accent4: "#0091ea"
}, vG = {
  base: "#00bcd4",
  lighten5: "#e0f7fa",
  lighten4: "#b2ebf2",
  lighten3: "#80deea",
  lighten2: "#4dd0e1",
  lighten1: "#26c6da",
  darken1: "#00acc1",
  darken2: "#0097a7",
  darken3: "#00838f",
  darken4: "#006064",
  accent1: "#84ffff",
  accent2: "#18ffff",
  accent3: "#00e5ff",
  accent4: "#00b8d4"
}, gG = {
  base: "#009688",
  lighten5: "#e0f2f1",
  lighten4: "#b2dfdb",
  lighten3: "#80cbc4",
  lighten2: "#4db6ac",
  lighten1: "#26a69a",
  darken1: "#00897b",
  darken2: "#00796b",
  darken3: "#00695c",
  darken4: "#004d40",
  accent1: "#a7ffeb",
  accent2: "#64ffda",
  accent3: "#1de9b6",
  accent4: "#00bfa5"
}, pG = {
  base: "#4caf50",
  lighten5: "#e8f5e9",
  lighten4: "#c8e6c9",
  lighten3: "#a5d6a7",
  lighten2: "#81c784",
  lighten1: "#66bb6a",
  darken1: "#43a047",
  darken2: "#388e3c",
  darken3: "#2e7d32",
  darken4: "#1b5e20",
  accent1: "#b9f6ca",
  accent2: "#69f0ae",
  accent3: "#00e676",
  accent4: "#00c853"
}, yG = {
  base: "#8bc34a",
  lighten5: "#f1f8e9",
  lighten4: "#dcedc8",
  lighten3: "#c5e1a5",
  lighten2: "#aed581",
  lighten1: "#9ccc65",
  darken1: "#7cb342",
  darken2: "#689f38",
  darken3: "#558b2f",
  darken4: "#33691e",
  accent1: "#ccff90",
  accent2: "#b2ff59",
  accent3: "#76ff03",
  accent4: "#64dd17"
}, bG = {
  base: "#cddc39",
  lighten5: "#f9fbe7",
  lighten4: "#f0f4c3",
  lighten3: "#e6ee9c",
  lighten2: "#dce775",
  lighten1: "#d4e157",
  darken1: "#c0ca33",
  darken2: "#afb42b",
  darken3: "#9e9d24",
  darken4: "#827717",
  accent1: "#f4ff81",
  accent2: "#eeff41",
  accent3: "#c6ff00",
  accent4: "#aeea00"
}, wG = {
  base: "#ffeb3b",
  lighten5: "#fffde7",
  lighten4: "#fff9c4",
  lighten3: "#fff59d",
  lighten2: "#fff176",
  lighten1: "#ffee58",
  darken1: "#fdd835",
  darken2: "#fbc02d",
  darken3: "#f9a825",
  darken4: "#f57f17",
  accent1: "#ffff8d",
  accent2: "#ffff00",
  accent3: "#ffea00",
  accent4: "#ffd600"
}, _G = {
  base: "#ffc107",
  lighten5: "#fff8e1",
  lighten4: "#ffecb3",
  lighten3: "#ffe082",
  lighten2: "#ffd54f",
  lighten1: "#ffca28",
  darken1: "#ffb300",
  darken2: "#ffa000",
  darken3: "#ff8f00",
  darken4: "#ff6f00",
  accent1: "#ffe57f",
  accent2: "#ffd740",
  accent3: "#ffc400",
  accent4: "#ffab00"
}, SG = {
  base: "#ff9800",
  lighten5: "#fff3e0",
  lighten4: "#ffe0b2",
  lighten3: "#ffcc80",
  lighten2: "#ffb74d",
  lighten1: "#ffa726",
  darken1: "#fb8c00",
  darken2: "#f57c00",
  darken3: "#ef6c00",
  darken4: "#e65100",
  accent1: "#ffd180",
  accent2: "#ffab40",
  accent3: "#ff9100",
  accent4: "#ff6d00"
}, kG = {
  base: "#ff5722",
  lighten5: "#fbe9e7",
  lighten4: "#ffccbc",
  lighten3: "#ffab91",
  lighten2: "#ff8a65",
  lighten1: "#ff7043",
  darken1: "#f4511e",
  darken2: "#e64a19",
  darken3: "#d84315",
  darken4: "#bf360c",
  accent1: "#ff9e80",
  accent2: "#ff6e40",
  accent3: "#ff3d00",
  accent4: "#dd2c00"
}, CG = {
  base: "#795548",
  lighten5: "#efebe9",
  lighten4: "#d7ccc8",
  lighten3: "#bcaaa4",
  lighten2: "#a1887f",
  lighten1: "#8d6e63",
  darken1: "#6d4c41",
  darken2: "#5d4037",
  darken3: "#4e342e",
  darken4: "#3e2723"
}, TG = {
  base: "#607d8b",
  lighten5: "#eceff1",
  lighten4: "#cfd8dc",
  lighten3: "#b0bec5",
  lighten2: "#90a4ae",
  lighten1: "#78909c",
  darken1: "#546e7a",
  darken2: "#455a64",
  darken3: "#37474f",
  darken4: "#263238"
}, xG = {
  base: "#9e9e9e",
  lighten5: "#fafafa",
  lighten4: "#f5f5f5",
  lighten3: "#eeeeee",
  lighten2: "#e0e0e0",
  lighten1: "#bdbdbd",
  darken1: "#757575",
  darken2: "#616161",
  darken3: "#424242",
  darken4: "#212121"
}, AG = {
  black: "#000000",
  white: "#ffffff",
  transparent: "#ffffff00"
}, IG = {
  red: lG,
  pink: uG,
  purple: cG,
  deepPurple: dG,
  indigo: fG,
  blue: hG,
  lightBlue: mG,
  cyan: vG,
  teal: gG,
  green: pG,
  lightGreen: yG,
  lime: bG,
  yellow: wG,
  amber: _G,
  orange: SG,
  deepOrange: kG,
  brown: CG,
  blueGrey: TG,
  grey: xG,
  shades: AG
}, EG = B({
  swatches: {
    type: Array,
    default: () => OG(IG)
  },
  disabled: Boolean,
  color: Object,
  maxHeight: [Number, String],
  ...ke()
}, "VColorPickerSwatches");
function OG(e) {
  return Object.keys(e).map((t) => {
    const n = e[t];
    return n.base ? [n.base, n.darken4, n.darken3, n.darken2, n.darken1, n.lighten1, n.lighten2, n.lighten3, n.lighten4, n.lighten5] : [n.black, n.white, n.transparent];
  });
}
const PG = Oi({
  name: "VColorPickerSwatches",
  props: EG(),
  emits: {
    "update:color": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    return ie(() => v("div", {
      class: ["v-color-picker-swatches", e.class],
      style: [{
        maxHeight: _e(e.maxHeight)
      }, e.style]
    }, [v("div", null, [e.swatches.map((i) => v("div", {
      class: "v-color-picker-swatches__swatch"
    }, [i.map((r) => {
      const s = Hi(r), a = ch(s), o = pS(s);
      return v("div", {
        class: "v-color-picker-swatches__color",
        onClick: () => a && n("update:color", a)
      }, [v("div", {
        style: {
          background: o
        }
      }, [e.color && Gr(e.color, a) ? v(at, {
        size: "x-small",
        icon: "$success",
        color: RO(r, "#FFFFFF") > 2 ? "white" : "black"
      }, null) : void 0])]);
    })]))])])), {};
  }
});
const dm = B({
  color: String,
  ...Ni(),
  ...ke(),
  ...wn(),
  ...mn(),
  ...ua(),
  ...nu(),
  ...It(),
  ...je(),
  ...Qe()
}, "VSheet"), ho = J()({
  name: "VSheet",
  props: dm(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      backgroundColorClasses: r,
      backgroundColorStyles: s
    } = gt(G(e, "color")), {
      borderClasses: a
    } = er(e), {
      dimensionStyles: o
    } = _n(e), {
      elevationClasses: l
    } = In(e), {
      locationStyles: u
    } = po(e), {
      positionClasses: c
    } = iu(e), {
      roundedClasses: d
    } = Ht(e);
    return ie(() => v(e.tag, {
      class: ["v-sheet", i.value, r.value, a.value, l.value, c.value, d.value, e.class],
      style: [s.value, o.value, u.value, e.style]
    }, n)), {};
  }
}), VG = B({
  canvasHeight: {
    type: [String, Number],
    default: 150
  },
  disabled: Boolean,
  dotSize: {
    type: [Number, String],
    default: 10
  },
  hideCanvas: Boolean,
  hideSliders: Boolean,
  hideInputs: Boolean,
  mode: {
    type: String,
    default: "rgba",
    validator: (e) => Object.keys(qa).includes(e)
  },
  modes: {
    type: Array,
    default: () => Object.keys(qa),
    validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(qa).includes(t))
  },
  showSwatches: Boolean,
  swatches: Array,
  swatchesMaxHeight: {
    type: [Number, String],
    default: 150
  },
  modelValue: {
    type: [Object, String]
  },
  ...sn(dm({
    width: 300
  }), ["height", "location", "minHeight", "maxHeight", "minWidth", "maxWidth"])
}, "VColorPicker"), DG = Oi({
  name: "VColorPicker",
  props: VG(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:mode": (e) => !0
  },
  setup(e) {
    const t = Ee(e, "mode"), n = X(null), i = Ee(e, "modelValue", void 0, (l) => {
      if (l == null || l === "")
        return null;
      let u;
      try {
        u = ch(Hi(l));
      } catch (c) {
        return gr(c), null;
      }
      return u;
    }, (l) => l ? Z5(l, e.modelValue) : null), r = w(() => i.value ? {
      ...i.value,
      h: n.value ?? i.value.h
    } : null), {
      rtlClasses: s
    } = yn();
    let a = !0;
    fe(i, (l) => {
      if (!a) {
        a = !0;
        return;
      }
      l && (n.value = l.h);
    }, {
      immediate: !0
    });
    const o = (l) => {
      a = !1, n.value = l.h, i.value = l;
    };
    return jn(() => {
      e.modes.includes(t.value) || (t.value = e.modes[0]);
    }), jt({
      VSlider: {
        color: void 0,
        trackColor: void 0,
        trackFillColor: void 0
      }
    }), ie(() => {
      const l = ho.filterProps(e);
      return v(ho, se({
        rounded: e.rounded,
        elevation: e.elevation,
        theme: e.theme,
        class: ["v-color-picker", s.value, e.class],
        style: [{
          "--v-color-picker-color-hsv": yS({
            ...r.value ?? sl,
            a: 1
          })
        }, e.style]
      }, l, {
        maxWidth: e.width
      }), {
        default: () => [!e.hideCanvas && v(G5, {
          key: "canvas",
          color: r.value,
          "onUpdate:color": o,
          disabled: e.disabled,
          dotSize: e.dotSize,
          width: e.width,
          height: e.canvasHeight
        }, null), (!e.hideSliders || !e.hideInputs) && v("div", {
          key: "controls",
          class: "v-color-picker__controls"
        }, [!e.hideSliders && v(oG, {
          key: "preview",
          color: r.value,
          "onUpdate:color": o,
          hideAlpha: !t.value.endsWith("a"),
          disabled: e.disabled
        }, null), !e.hideInputs && v(tG, {
          key: "edit",
          modes: e.modes,
          mode: t.value,
          "onUpdate:mode": (u) => t.value = u,
          color: r.value,
          "onUpdate:color": o,
          disabled: e.disabled
        }, null)]), e.showSwatches && v(PG, {
          key: "swatches",
          color: r.value,
          "onUpdate:color": o,
          maxHeight: e.swatchesMaxHeight,
          swatches: e.swatches,
          disabled: e.disabled
        }, null)]
      });
    }), {};
  }
});
function NG(e, t, n) {
  if (t == null)
    return e;
  if (Array.isArray(t))
    throw new Error("Multiple matches is not implemented");
  return typeof t == "number" && ~t ? v(De, null, [v("span", {
    class: "v-combobox__unmask"
  }, [e.substr(0, t)]), v("span", {
    class: "v-combobox__mask"
  }, [e.substr(t, n)]), v("span", {
    class: "v-combobox__unmask"
  }, [e.substr(t + n)])]) : e;
}
const MG = B({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: {
    type: Boolean,
    default: !0
  },
  delimiters: Array,
  ...ad({
    filterKeys: ["title"]
  }),
  ...lb({
    hideNoData: !0,
    returnObject: !0
  }),
  ...sn(bh({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...Tr({
    transition: !1
  })
}, "VCombobox"), RG = J()({
  name: "VCombobox",
  props: MG(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:search": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, t) {
    var Pe;
    let {
      emit: n,
      slots: i
    } = t;
    const {
      t: r
    } = qt(), s = X(), a = pe(!1), o = pe(!0), l = pe(!1), u = X(), c = X(), d = Ee(e, "menu"), f = w({
      get: () => d.value,
      set: (le) => {
        var be;
        d.value && !le && ((be = u.value) != null && be.ΨopenChildren) || (d.value = le);
      }
    }), h = pe(-1);
    let m = !1;
    const g = w(() => {
      var le;
      return (le = s.value) == null ? void 0 : le.color;
    }), p = w(() => f.value ? e.closeText : e.openText), {
      items: y,
      transformIn: k,
      transformOut: T
    } = nb(e), {
      textColorClasses: _,
      textColorStyles: b
    } = Ln(g), S = Ee(e, "modelValue", [], (le) => k(Nt(le)), (le) => {
      const be = T(le);
      return e.multiple ? be : be[0] ?? null;
    }), C = yh(), x = w(() => !!(e.chips || i.chip)), A = w(() => x.value || !!i.selection), I = pe(!e.multiple && !A.value ? ((Pe = S.value[0]) == null ? void 0 : Pe.title) ?? "" : ""), E = w({
      get: () => I.value,
      set: (le) => {
        var be;
        if (I.value = le ?? "", !e.multiple && !A.value && (S.value = [Gs(e, le)]), le && e.multiple && ((be = e.delimiters) != null && be.length)) {
          const Oe = le.split(new RegExp(`(?:${e.delimiters.join("|")})+`));
          Oe.length > 1 && (Oe.forEach((te) => {
            te = te.trim(), te && ue(Gs(e, te));
          }), I.value = "");
        }
        le || (h.value = -1), o.value = !le;
      }
    }), O = w(() => typeof e.counterValue == "function" ? e.counterValue(S.value) : typeof e.counterValue == "number" ? e.counterValue : e.multiple ? S.value.length : E.value.length);
    fe(I, (le) => {
      m ? He(() => m = !1) : a.value && !f.value && (f.value = !0), n("update:search", le);
    }), fe(S, (le) => {
      var be;
      !e.multiple && !A.value && (I.value = ((be = le[0]) == null ? void 0 : be.title) ?? "");
    });
    const {
      filteredItems: V,
      getMatches: N
    } = od(e, y, () => o.value ? "" : E.value), F = w(() => e.hideSelected ? V.value.filter((le) => !S.value.some((be) => be.value === le.value)) : V.value), $ = w(() => S.value.map((le) => le.value)), Z = w(() => {
      var be;
      return (e.autoSelectFirst === !0 || e.autoSelectFirst === "exact" && E.value === ((be = F.value[0]) == null ? void 0 : be.title)) && F.value.length > 0 && !o.value && !l.value;
    }), j = w(() => e.hideNoData && !F.value.length || e.readonly || (C == null ? void 0 : C.isReadonly.value)), H = X(), {
      onListScroll: R,
      onListKeydown: L
    } = ob(H, s);
    function ne(le) {
      m = !0, e.openOnClear && (f.value = !0);
    }
    function oe() {
      j.value || (f.value = !0);
    }
    function we(le) {
      j.value || (a.value && (le.preventDefault(), le.stopPropagation()), f.value = !f.value);
    }
    function ee(le) {
      var te;
      if (oO(le) || e.readonly || C != null && C.isReadonly.value)
        return;
      const be = s.value.selectionStart, Oe = S.value.length;
      if ((h.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(le.key)) && le.preventDefault(), ["Enter", "ArrowDown"].includes(le.key) && (f.value = !0), ["Escape"].includes(le.key) && (f.value = !1), ["Enter", "Escape"].includes(le.key) && (Z.value && le.key === "Enter" && ue(V.value[0]), o.value = !0), le.key === "ArrowDown" && Z.value && ((te = H.value) == null || te.focus("next")), le.key === "Enter" && E.value && (ue(Gs(e, E.value)), A.value && (I.value = "")), ["Backspace", "Delete"].includes(le.key)) {
        if (!e.multiple && A.value && S.value.length > 0 && !E.value)
          return ue(S.value[0], !1);
        if (~h.value) {
          const me = h.value;
          ue(S.value[h.value], !1), h.value = me >= Oe - 1 ? Oe - 2 : me;
        } else
          le.key === "Backspace" && !E.value && (h.value = Oe - 1);
      }
      if (e.multiple) {
        if (le.key === "ArrowLeft") {
          if (h.value < 0 && be > 0)
            return;
          const me = h.value > -1 ? h.value - 1 : Oe - 1;
          S.value[me] ? h.value = me : (h.value = -1, s.value.setSelectionRange(E.value.length, E.value.length));
        }
        if (le.key === "ArrowRight") {
          if (h.value < 0)
            return;
          const me = h.value + 1;
          S.value[me] ? h.value = me : (h.value = -1, s.value.setSelectionRange(0, 0));
        }
      }
    }
    function K() {
      var le;
      a.value && (o.value = !0, (le = s.value) == null || le.focus());
    }
    function ue(le) {
      let be = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!(!le || le.props.disabled))
        if (e.multiple) {
          const Oe = S.value.findIndex((me) => e.valueComparator(me.value, le.value)), te = be ?? !~Oe;
          if (~Oe) {
            const me = te ? [...S.value, le] : [...S.value];
            me.splice(Oe, 1), S.value = me;
          } else
            te && (S.value = [...S.value, le]);
          e.clearOnSelect && (E.value = "");
        } else {
          const Oe = be !== !1;
          S.value = Oe ? [le] : [], I.value = Oe && !A.value ? le.title : "", He(() => {
            f.value = !1, o.value = !0;
          });
        }
    }
    function ve(le) {
      a.value = !0, setTimeout(() => {
        l.value = !0;
      });
    }
    function Re(le) {
      l.value = !1;
    }
    function he(le) {
      (le == null || le === "" && !e.multiple && !A.value) && (S.value = []);
    }
    return fe(a, (le, be) => {
      if (!(le || le === be)) {
        if (h.value = -1, f.value = !1, Z.value && !l.value && !S.value.some((Oe) => {
          let {
            value: te
          } = Oe;
          return te === F.value[0].value;
        })) {
          ue(F.value[0]);
          return;
        }
        if (E.value) {
          if (e.multiple) {
            ue(Gs(e, E.value));
            return;
          }
          if (!A.value)
            return;
          S.value.some((Oe) => {
            let {
              title: te
            } = Oe;
            return te === E.value;
          }) ? I.value = "" : ue(Gs(e, E.value));
        }
      }
    }), fe(f, () => {
      if (!e.hideSelected && f.value && S.value.length) {
        const le = F.value.findIndex((be) => S.value.some((Oe) => e.valueComparator(Oe.value, be.value)));
        ft && window.requestAnimationFrame(() => {
          var be;
          le >= 0 && ((be = c.value) == null || be.scrollToIndex(le));
        });
      }
    }), fe(() => e.items, (le, be) => {
      f.value || a.value && !be.length && le.length && (f.value = !0);
    }), ie(() => {
      const le = !!(!e.hideNoData || F.value.length || i["prepend-item"] || i["append-item"] || i["no-data"]), be = S.value.length > 0, Oe = gi.filterProps(e);
      return v(gi, se({
        ref: s
      }, Oe, {
        modelValue: E.value,
        "onUpdate:modelValue": [(te) => E.value = te, he],
        focused: a.value,
        "onUpdate:focused": (te) => a.value = te,
        validationValue: S.externalValue,
        counterValue: O.value,
        dirty: be,
        class: ["v-combobox", {
          "v-combobox--active-menu": f.value,
          "v-combobox--chips": !!e.chips,
          "v-combobox--selection-slot": !!A.value,
          "v-combobox--selecting-index": h.value > -1,
          [`v-combobox--${e.multiple ? "multiple" : "single"}`]: !0
        }, e.class],
        style: e.style,
        readonly: e.readonly,
        placeholder: be ? void 0 : e.placeholder,
        "onClick:clear": ne,
        "onMousedown:control": oe,
        onKeydown: ee
      }), {
        ...i,
        default: () => v(De, null, [v(Dl, se({
          ref: u,
          modelValue: f.value,
          "onUpdate:modelValue": (te) => f.value = te,
          activator: "parent",
          contentClass: "v-combobox__content",
          disabled: j.value,
          eager: e.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: e.transition,
          onAfterLeave: K
        }, e.menuProps), {
          default: () => [le && v(om, se({
            ref: H,
            selected: $.value,
            selectStrategy: e.multiple ? "independent" : "single-independent",
            onMousedown: (te) => te.preventDefault(),
            onKeydown: L,
            onFocusin: ve,
            onFocusout: Re,
            onScrollPassive: R,
            tabindex: "-1",
            "aria-live": "polite",
            color: e.itemColor ?? e.color
          }, e.listProps), {
            default: () => {
              var te, me, Me;
              return [(te = i["prepend-item"]) == null ? void 0 : te.call(i), !F.value.length && !e.hideNoData && (((me = i["no-data"]) == null ? void 0 : me.call(i)) ?? v(ks, {
                title: r(e.noDataText)
              }, null)), v(lm, {
                ref: c,
                renderless: !0,
                items: F.value
              }, {
                default: (Fe) => {
                  var vt;
                  let {
                    item: xe,
                    index: ze,
                    itemRef: Ke
                  } = Fe;
                  const ut = se(xe.props, {
                    ref: Ke,
                    key: ze,
                    active: Z.value && ze === 0 ? !0 : void 0,
                    onClick: () => ue(xe, null)
                  });
                  return ((vt = i.item) == null ? void 0 : vt.call(i, {
                    item: xe,
                    index: ze,
                    props: ut
                  })) ?? v(ks, se(ut, {
                    role: "option"
                  }), {
                    prepend: (En) => {
                      let {
                        isSelected: On
                      } = En;
                      return v(De, null, [e.multiple && !e.hideSelected ? v(Ss, {
                        key: xe.value,
                        modelValue: On,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, xe.props.prependAvatar && v(Ji, {
                        image: xe.props.prependAvatar
                      }, null), xe.props.prependIcon && v(at, {
                        icon: xe.props.prependIcon
                      }, null)]);
                    },
                    title: () => {
                      var En, On;
                      return o.value ? xe.title : NG(xe.title, (En = N(xe)) == null ? void 0 : En.title, ((On = E.value) == null ? void 0 : On.length) ?? 0);
                    }
                  });
                }
              }), (Me = i["append-item"]) == null ? void 0 : Me.call(i)];
            }
          })]
        }), S.value.map((te, me) => {
          function Me(Ke) {
            Ke.stopPropagation(), Ke.preventDefault(), ue(te, !1);
          }
          const Fe = {
            "onClick:close": Me,
            onKeydown(Ke) {
              Ke.key !== "Enter" && Ke.key !== " " || (Ke.preventDefault(), Ke.stopPropagation(), Me(Ke));
            },
            onMousedown(Ke) {
              Ke.preventDefault(), Ke.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, xe = x.value ? !!i.chip : !!i.selection, ze = xe ? uh(x.value ? i.chip({
            item: te,
            index: me,
            props: Fe
          }) : i.selection({
            item: te,
            index: me
          })) : void 0;
          if (!(xe && !ze))
            return v("div", {
              key: te.value,
              class: ["v-combobox__selection", me === h.value && ["v-combobox__selection--selected", _.value]],
              style: me === h.value ? b.value : {}
            }, [x.value ? i.chip ? v(Ze, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: e.closableChips,
                  size: "small",
                  text: te.title
                }
              }
            }, {
              default: () => [ze]
            }) : v(ru, se({
              key: "chip",
              closable: e.closableChips,
              size: "small",
              text: te.title,
              disabled: te.props.disabled
            }, Fe), null) : ze ?? v("span", {
              class: "v-combobox__selection-text"
            }, [te.title, e.multiple && me < S.value.length - 1 && v("span", {
              class: "v-combobox__selection-comma"
            }, [wr(",")])])]);
        })]),
        "append-inner": function() {
          var Fe;
          for (var te = arguments.length, me = new Array(te), Me = 0; Me < te; Me++)
            me[Me] = arguments[Me];
          return v(De, null, [(Fe = i["append-inner"]) == null ? void 0 : Fe.call(i, ...me), (!e.hideNoData || e.items.length) && e.menuIcon ? v(at, {
            class: "v-combobox__menu-icon",
            icon: e.menuIcon,
            onMousedown: we,
            onClick: cS,
            "aria-label": r(p.value),
            title: r(p.value),
            tabindex: "-1"
          }, null) : void 0]);
        }
      });
    }), Qi({
      isFocused: a,
      isPristine: o,
      menu: f,
      search: E,
      selectionIndex: h,
      filteredItems: V,
      select: ue
    }, s);
  }
}), FG = B({
  modelValue: null,
  color: String,
  cancelText: {
    type: String,
    default: "$vuetify.confirmEdit.cancel"
  },
  okText: {
    type: String,
    default: "$vuetify.confirmEdit.ok"
  }
}, "VConfirmEdit"), BG = J()({
  name: "VConfirmEdit",
  props: FG(),
  emits: {
    cancel: () => !0,
    save: (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const r = Ee(e, "modelValue"), s = X();
    Wt(() => {
      s.value = structuredClone(si(r.value));
    });
    const {
      t: a
    } = qt(), o = w(() => Gr(r.value, s.value));
    function l() {
      r.value = s.value, n("save", s.value);
    }
    function u() {
      s.value = structuredClone(si(r.value)), n("cancel");
    }
    let c = !1;
    return ie(() => {
      var f;
      const d = v(De, null, [v(st, {
        disabled: o.value,
        variant: "text",
        color: e.color,
        onClick: u,
        text: a(e.cancelText)
      }, null), v(st, {
        disabled: o.value,
        variant: "text",
        color: e.color,
        onClick: l,
        text: a(e.okText)
      }, null)]);
      return v(De, null, [(f = i.default) == null ? void 0 : f.call(i, {
        model: s,
        save: l,
        cancel: u,
        isPristine: o.value,
        get actions() {
          return c = !0, d;
        }
      }), !c && d]);
    }), {
      save: l,
      cancel: u,
      isPristine: o
    };
  }
}), zA = B({
  expandOnClick: Boolean,
  showExpand: Boolean,
  expanded: {
    type: Array,
    default: () => []
  }
}, "DataTable-expand"), UA = Symbol.for("vuetify:datatable:expanded");
function fm(e) {
  const t = G(e, "expandOnClick"), n = Ee(e, "expanded", e.expanded, (o) => new Set(o), (o) => [...o.values()]);
  function i(o, l) {
    const u = new Set(n.value);
    l ? u.add(o.value) : u.delete(o.value), n.value = u;
  }
  function r(o) {
    return n.value.has(o.value);
  }
  function s(o) {
    i(o, !r(o));
  }
  const a = {
    expand: i,
    expanded: n,
    expandOnClick: t,
    isExpanded: r,
    toggleExpand: s
  };
  return Tt(UA, a), a;
}
function qA() {
  const e = tt(UA);
  if (!e)
    throw new Error("foo");
  return e;
}
const fb = B({
  groupBy: {
    type: Array,
    default: () => []
  }
}, "DataTable-group"), GA = Symbol.for("vuetify:data-table-group");
function hb(e) {
  return {
    groupBy: Ee(e, "groupBy")
  };
}
function hm(e) {
  const {
    groupBy: t,
    sortBy: n
  } = e, i = X(/* @__PURE__ */ new Set()), r = w(() => t.value.map((u) => ({
    ...u,
    order: u.order ?? !1
  })).concat(n.value));
  function s(u) {
    return i.value.has(u.id);
  }
  function a(u) {
    const c = new Set(i.value);
    s(u) ? c.delete(u.id) : c.add(u.id), i.value = c;
  }
  function o(u) {
    function c(d) {
      const f = [];
      for (const h of d.items)
        "type" in h && h.type === "group" ? f.push(...c(h)) : f.push(h);
      return f;
    }
    return c({
      type: "group",
      items: u,
      id: "dummy",
      key: "dummy",
      value: "dummy",
      depth: 0
    });
  }
  const l = {
    sortByWithGroups: r,
    toggleGroup: a,
    opened: i,
    groupBy: t,
    extractRows: o,
    isGroupOpen: s
  };
  return Tt(GA, l), l;
}
function YA() {
  const e = tt(GA);
  if (!e)
    throw new Error("Missing group!");
  return e;
}
function LG(e, t) {
  if (!e.length)
    return [];
  const n = /* @__PURE__ */ new Map();
  for (const i of e) {
    const r = $u(i.raw, t);
    n.has(r) || n.set(r, []), n.get(r).push(i);
  }
  return n;
}
function ZA(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "root";
  if (!t.length)
    return [];
  const r = LG(e, t[0]), s = [], a = t.slice(1);
  return r.forEach((o, l) => {
    const u = t[0], c = `${i}_${u}_${l}`;
    s.push({
      depth: n,
      id: c,
      key: u,
      value: l,
      items: a.length ? ZA(o, a, n + 1, c) : o,
      type: "group"
    });
  }), s;
}
function KA(e, t) {
  const n = [];
  for (const i of e)
    "type" in i && i.type === "group" ? (i.value != null && n.push(i), (t.has(i.id) || i.value == null) && n.push(...KA(i.items, t))) : n.push(i);
  return n;
}
function mm(e, t, n) {
  return {
    flatItems: w(() => {
      if (!t.value.length)
        return e.value;
      const r = ZA(e.value, t.value.map((s) => s.key));
      return KA(r, n.value);
    })
  };
}
function vm(e) {
  let {
    page: t,
    itemsPerPage: n,
    sortBy: i,
    groupBy: r,
    search: s
  } = e;
  const a = Ut("VDataTable"), o = w(() => ({
    page: t.value,
    itemsPerPage: n.value,
    sortBy: i.value,
    groupBy: r.value,
    search: s.value
  }));
  let l = null;
  fe(o, () => {
    Gr(l, o.value) || (l && l.search !== o.value.search && (t.value = 1), a.emit("update:options", o.value), l = o.value);
  }, {
    deep: !0,
    immediate: !0
  });
}
const mb = B({
  page: {
    type: [Number, String],
    default: 1
  },
  itemsPerPage: {
    type: [Number, String],
    default: 10
  }
}, "DataTable-paginate"), XA = Symbol.for("vuetify:data-table-pagination");
function vb(e) {
  const t = Ee(e, "page", void 0, (i) => +(i ?? 1)), n = Ee(e, "itemsPerPage", void 0, (i) => +(i ?? 10));
  return {
    page: t,
    itemsPerPage: n
  };
}
function gb(e) {
  const {
    page: t,
    itemsPerPage: n,
    itemsLength: i
  } = e, r = w(() => n.value === -1 ? 0 : n.value * (t.value - 1)), s = w(() => n.value === -1 ? i.value : Math.min(i.value, r.value + n.value)), a = w(() => n.value === -1 || i.value === 0 ? 1 : Math.ceil(i.value / n.value));
  Wt(() => {
    t.value > a.value && (t.value = a.value);
  });
  function o(f) {
    n.value = f, t.value = 1;
  }
  function l() {
    t.value = Xt(t.value + 1, 1, a.value);
  }
  function u() {
    t.value = Xt(t.value - 1, 1, a.value);
  }
  function c(f) {
    t.value = Xt(f, 1, a.value);
  }
  const d = {
    page: t,
    itemsPerPage: n,
    startIndex: r,
    stopIndex: s,
    pageCount: a,
    itemsLength: i,
    nextPage: l,
    prevPage: u,
    setPage: c,
    setItemsPerPage: o
  };
  return Tt(XA, d), d;
}
function $G() {
  const e = tt(XA);
  if (!e)
    throw new Error("Missing pagination!");
  return e;
}
function JA(e) {
  const t = Ut("usePaginatedItems"), {
    items: n,
    startIndex: i,
    stopIndex: r,
    itemsPerPage: s
  } = e, a = w(() => s.value <= 0 ? n.value : n.value.slice(i.value, r.value));
  return fe(a, (o) => {
    t.emit("update:currentItems", o);
  }), {
    paginatedItems: a
  };
}
const WG = {
  showSelectAll: !1,
  allSelected: () => [],
  select: (e) => {
    var i;
    let {
      items: t,
      value: n
    } = e;
    return new Set(n ? [(i = t[0]) == null ? void 0 : i.value] : []);
  },
  selectAll: (e) => {
    let {
      selected: t
    } = e;
    return t;
  }
}, QA = {
  showSelectAll: !0,
  allSelected: (e) => {
    let {
      currentPage: t
    } = e;
    return t;
  },
  select: (e) => {
    let {
      items: t,
      value: n,
      selected: i
    } = e;
    for (const r of t)
      n ? i.add(r.value) : i.delete(r.value);
    return i;
  },
  selectAll: (e) => {
    let {
      value: t,
      currentPage: n,
      selected: i
    } = e;
    return QA.select({
      items: n,
      value: t,
      selected: i
    });
  }
}, eI = {
  showSelectAll: !0,
  allSelected: (e) => {
    let {
      allItems: t
    } = e;
    return t;
  },
  select: (e) => {
    let {
      items: t,
      value: n,
      selected: i
    } = e;
    for (const r of t)
      n ? i.add(r.value) : i.delete(r.value);
    return i;
  },
  selectAll: (e) => {
    let {
      value: t,
      allItems: n,
      selected: i
    } = e;
    return eI.select({
      items: n,
      value: t,
      selected: i
    });
  }
}, tI = B({
  showSelect: Boolean,
  selectStrategy: {
    type: [String, Object],
    default: "page"
  },
  modelValue: {
    type: Array,
    default: () => []
  },
  valueComparator: {
    type: Function,
    default: Gr
  }
}, "DataTable-select"), nI = Symbol.for("vuetify:data-table-selection");
function gm(e, t) {
  let {
    allItems: n,
    currentPage: i
  } = t;
  const r = Ee(e, "modelValue", e.modelValue, (y) => new Set(Nt(y).map((k) => {
    var T;
    return ((T = n.value.find((_) => e.valueComparator(k, _.value))) == null ? void 0 : T.value) ?? k;
  })), (y) => [...y.values()]), s = w(() => n.value.filter((y) => y.selectable)), a = w(() => i.value.filter((y) => y.selectable)), o = w(() => {
    if (typeof e.selectStrategy == "object")
      return e.selectStrategy;
    switch (e.selectStrategy) {
      case "single":
        return WG;
      case "all":
        return eI;
      case "page":
      default:
        return QA;
    }
  });
  function l(y) {
    return Nt(y).every((k) => r.value.has(k.value));
  }
  function u(y) {
    return Nt(y).some((k) => r.value.has(k.value));
  }
  function c(y, k) {
    const T = o.value.select({
      items: y,
      value: k,
      selected: new Set(r.value)
    });
    r.value = T;
  }
  function d(y) {
    c([y], !l([y]));
  }
  function f(y) {
    const k = o.value.selectAll({
      value: y,
      allItems: s.value,
      currentPage: a.value,
      selected: new Set(r.value)
    });
    r.value = k;
  }
  const h = w(() => r.value.size > 0), m = w(() => {
    const y = o.value.allSelected({
      allItems: s.value,
      currentPage: a.value
    });
    return !!y.length && l(y);
  }), g = w(() => o.value.showSelectAll), p = {
    toggleSelect: d,
    select: c,
    selectAll: f,
    isSelected: l,
    isSomeSelected: u,
    someSelected: h,
    allSelected: m,
    showSelectAll: g
  };
  return Tt(nI, p), p;
}
function pm() {
  const e = tt(nI);
  if (!e)
    throw new Error("Missing selection!");
  return e;
}
const iI = B({
  sortBy: {
    type: Array,
    default: () => []
  },
  customKeySort: Object,
  multiSort: Boolean,
  mustSort: Boolean
}, "DataTable-sort"), rI = Symbol.for("vuetify:data-table-sort");
function ym(e) {
  const t = Ee(e, "sortBy"), n = G(e, "mustSort"), i = G(e, "multiSort");
  return {
    sortBy: t,
    mustSort: n,
    multiSort: i
  };
}
function bm(e) {
  const {
    sortBy: t,
    mustSort: n,
    multiSort: i,
    page: r
  } = e, s = (l) => {
    if (l.key == null)
      return;
    let u = t.value.map((d) => ({
      ...d
    })) ?? [];
    const c = u.find((d) => d.key === l.key);
    c ? c.order === "desc" ? n.value ? c.order = "asc" : u = u.filter((d) => d.key !== l.key) : c.order = "desc" : i.value ? u = [...u, {
      key: l.key,
      order: "asc"
    }] : u = [{
      key: l.key,
      order: "asc"
    }], t.value = u, r && (r.value = 1);
  };
  function a(l) {
    return !!t.value.find((u) => u.key === l.key);
  }
  const o = {
    sortBy: t,
    toggleSort: s,
    isSorted: a
  };
  return Tt(rI, o), o;
}
function sI() {
  const e = tt(rI);
  if (!e)
    throw new Error("Missing sort!");
  return e;
}
function pb(e, t, n, i) {
  const r = qt();
  return {
    sortedItems: w(() => {
      var a, o;
      return !n.value.length || e.disableSort ? t.value : jG(t.value, n.value, r.current.value, {
        transform: i == null ? void 0 : i.transform,
        sortFunctions: {
          ...e.customKeySort,
          ...(a = i == null ? void 0 : i.sortFunctions) == null ? void 0 : a.value
        },
        sortRawFunctions: (o = i == null ? void 0 : i.sortRawFunctions) == null ? void 0 : o.value
      });
    })
  };
}
function jG(e, t, n, i) {
  const r = new Intl.Collator(n, {
    sensitivity: "accent",
    usage: "sort"
  });
  return e.map((a) => [a, i != null && i.transform ? i.transform(a) : a]).sort((a, o) => {
    var l, u;
    for (let c = 0; c < t.length; c++) {
      let d = !1;
      const f = t[c].key, h = t[c].order ?? "asc";
      if (h === !1)
        continue;
      let m = a[1][f], g = o[1][f], p = a[0].raw, y = o[0].raw;
      if (h === "desc" && ([m, g] = [g, m], [p, y] = [y, p]), (l = i == null ? void 0 : i.sortRawFunctions) != null && l[f]) {
        const k = i.sortRawFunctions[f](p, y);
        if (k == null)
          continue;
        if (d = !0, k)
          return k;
      }
      if ((u = i == null ? void 0 : i.sortFunctions) != null && u[f]) {
        const k = i.sortFunctions[f](m, g);
        if (k == null)
          continue;
        if (d = !0, k)
          return k;
      }
      if (!d) {
        if (m instanceof Date && g instanceof Date)
          return m.getTime() - g.getTime();
        if ([m, g] = [m, g].map((k) => k != null ? k.toString().toLocaleLowerCase() : k), m !== g)
          return hd(m) && hd(g) ? 0 : hd(m) ? -1 : hd(g) ? 1 : !isNaN(m) && !isNaN(g) ? Number(m) - Number(g) : r.compare(m, g);
      }
    }
    return 0;
  }).map((a) => {
    let [o] = a;
    return o;
  });
}
const HG = B({
  items: {
    type: Array,
    default: () => []
  },
  itemValue: {
    type: [String, Array, Function],
    default: "id"
  },
  itemSelectable: {
    type: [String, Array, Function],
    default: null
  },
  returnObject: Boolean
}, "DataIterator-items");
function zG(e, t) {
  const n = e.returnObject ? t : dn(t, e.itemValue), i = dn(t, e.itemSelectable, !0);
  return {
    type: "item",
    value: n,
    selectable: i,
    raw: t
  };
}
function UG(e, t) {
  const n = [];
  for (const i of t)
    n.push(zG(e, i));
  return n;
}
function qG(e) {
  return {
    items: w(() => UG(e, e.items))
  };
}
const GG = B({
  search: String,
  loading: Boolean,
  ...ke(),
  ...HG(),
  ...tI(),
  ...iI(),
  ...mb({
    itemsPerPage: 5
  }),
  ...zA(),
  ...fb(),
  ...ad(),
  ...je(),
  ...Tr({
    transition: {
      component: zu,
      hideOnLeave: !0
    }
  })
}, "VDataIterator"), YG = J()({
  name: "VDataIterator",
  props: GG(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:groupBy": (e) => !0,
    "update:page": (e) => !0,
    "update:itemsPerPage": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:expanded": (e) => !0,
    "update:currentItems": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "groupBy"), r = G(e, "search"), {
      items: s
    } = qG(e), {
      filteredItems: a
    } = od(e, s, r, {
      transform: (L) => L.raw
    }), {
      sortBy: o,
      multiSort: l,
      mustSort: u
    } = ym(e), {
      page: c,
      itemsPerPage: d
    } = vb(e), {
      toggleSort: f
    } = bm({
      sortBy: o,
      multiSort: l,
      mustSort: u,
      page: c
    }), {
      sortByWithGroups: h,
      opened: m,
      extractRows: g,
      isGroupOpen: p,
      toggleGroup: y
    } = hm({
      groupBy: i,
      sortBy: o
    }), {
      sortedItems: k
    } = pb(e, a, h, {
      transform: (L) => L.raw
    }), {
      flatItems: T
    } = mm(k, i, m), _ = w(() => T.value.length), {
      startIndex: b,
      stopIndex: S,
      pageCount: C,
      prevPage: x,
      nextPage: A,
      setItemsPerPage: I,
      setPage: E
    } = gb({
      page: c,
      itemsPerPage: d,
      itemsLength: _
    }), {
      paginatedItems: O
    } = JA({
      items: T,
      startIndex: b,
      stopIndex: S,
      itemsPerPage: d
    }), V = w(() => g(O.value)), {
      isSelected: N,
      select: F,
      selectAll: $,
      toggleSelect: Z
    } = gm(e, {
      allItems: s,
      currentPage: V
    }), {
      isExpanded: j,
      toggleExpand: H
    } = fm(e);
    vm({
      page: c,
      itemsPerPage: d,
      sortBy: o,
      groupBy: i,
      search: r
    });
    const R = w(() => ({
      page: c.value,
      itemsPerPage: d.value,
      sortBy: o.value,
      pageCount: C.value,
      toggleSort: f,
      prevPage: x,
      nextPage: A,
      setPage: E,
      setItemsPerPage: I,
      isSelected: N,
      select: F,
      selectAll: $,
      toggleSelect: Z,
      isExpanded: j,
      toggleExpand: H,
      isGroupOpen: p,
      toggleGroup: y,
      items: V.value,
      groupedItems: O.value
    }));
    return ie(() => v(e.tag, {
      class: ["v-data-iterator", {
        "v-data-iterator--loading": e.loading
      }, e.class],
      style: e.style
    }, {
      default: () => {
        var L, ne;
        return [(L = n.header) == null ? void 0 : L.call(n, R.value), v(Gn, {
          transition: e.transition
        }, {
          default: () => {
            var oe, we;
            return [e.loading ? v(Ec, {
              key: "loader",
              name: "v-data-iterator",
              active: !0
            }, {
              default: (ee) => {
                var K;
                return (K = n.loader) == null ? void 0 : K.call(n, ee);
              }
            }) : v("div", {
              key: "items"
            }, [O.value.length ? (we = n.default) == null ? void 0 : we.call(n, R.value) : (oe = n["no-data"]) == null ? void 0 : oe.call(n)])];
          }
        }), (ne = n.footer) == null ? void 0 : ne.call(n, R.value)];
      }
    })), {};
  }
});
function ZG() {
  const e = X([]);
  eO(() => e.value = []);
  function t(n, i) {
    e.value[i] = n;
  }
  return {
    refs: e,
    updateRef: t
  };
}
const KG = B({
  activeColor: String,
  start: {
    type: [Number, String],
    default: 1
  },
  modelValue: {
    type: Number,
    default: (e) => e.start
  },
  disabled: Boolean,
  length: {
    type: [Number, String],
    default: 1,
    validator: (e) => e % 1 === 0
  },
  totalVisible: [Number, String],
  firstIcon: {
    type: We,
    default: "$first"
  },
  prevIcon: {
    type: We,
    default: "$prev"
  },
  nextIcon: {
    type: We,
    default: "$next"
  },
  lastIcon: {
    type: We,
    default: "$last"
  },
  ariaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.root"
  },
  pageAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.page"
  },
  currentPageAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.currentPage"
  },
  firstAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.first"
  },
  previousAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.previous"
  },
  nextAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.next"
  },
  lastAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.last"
  },
  ellipsis: {
    type: String,
    default: "..."
  },
  showFirstLastPage: Boolean,
  ...Ni(),
  ...ke(),
  ...bn(),
  ...mn(),
  ...It(),
  ...Kr(),
  ...je({
    tag: "nav"
  }),
  ...Qe(),
  ...tr({
    variant: "text"
  })
}, "VPagination"), jg = J()({
  name: "VPagination",
  props: KG(),
  emits: {
    "update:modelValue": (e) => !0,
    first: (e) => !0,
    prev: (e) => !0,
    next: (e) => !0,
    last: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const r = Ee(e, "modelValue"), {
      t: s,
      n: a
    } = qt(), {
      isRtl: o
    } = yn(), {
      themeClasses: l
    } = lt(e), {
      width: u
    } = xr(), c = pe(-1);
    jt(void 0, {
      scoped: !0
    });
    const {
      resizeRef: d
    } = _r((x) => {
      if (!x.length)
        return;
      const {
        target: A,
        contentRect: I
      } = x[0], E = A.querySelector(".v-pagination__list > *");
      if (!E)
        return;
      const O = I.width, V = E.offsetWidth + parseFloat(getComputedStyle(E).marginRight) * 2;
      c.value = g(O, V);
    }), f = w(() => parseInt(e.length, 10)), h = w(() => parseInt(e.start, 10)), m = w(() => e.totalVisible != null ? parseInt(e.totalVisible, 10) : c.value >= 0 ? c.value : g(u.value, 58));
    function g(x, A) {
      const I = e.showFirstLastPage ? 5 : 3;
      return Math.max(0, Math.floor(
        // Round to two decimal places to avoid floating point errors
        +((x - A * I) / A).toFixed(2)
      ));
    }
    const p = w(() => {
      if (f.value <= 0 || isNaN(f.value) || f.value > Number.MAX_SAFE_INTEGER)
        return [];
      if (m.value <= 0)
        return [];
      if (m.value === 1)
        return [r.value];
      if (f.value <= m.value)
        return jr(f.value, h.value);
      const x = m.value % 2 === 0, A = x ? m.value / 2 : Math.floor(m.value / 2), I = x ? A : A + 1, E = f.value - A;
      if (I - r.value >= 0)
        return [...jr(Math.max(1, m.value - 1), h.value), e.ellipsis, f.value];
      if (r.value - E >= (x ? 1 : 0)) {
        const O = m.value - 1, V = f.value - O + h.value;
        return [h.value, e.ellipsis, ...jr(O, V)];
      } else {
        const O = Math.max(1, m.value - 3), V = O === 1 ? r.value : r.value - Math.ceil(O / 2) + h.value;
        return [h.value, e.ellipsis, ...jr(O, V), e.ellipsis, f.value];
      }
    });
    function y(x, A, I) {
      x.preventDefault(), r.value = A, I && i(I, A);
    }
    const {
      refs: k,
      updateRef: T
    } = ZG();
    jt({
      VPaginationBtn: {
        color: G(e, "color"),
        border: G(e, "border"),
        density: G(e, "density"),
        size: G(e, "size"),
        variant: G(e, "variant"),
        rounded: G(e, "rounded"),
        elevation: G(e, "elevation")
      }
    });
    const _ = w(() => p.value.map((x, A) => {
      const I = (E) => T(E, A);
      if (typeof x == "string")
        return {
          isActive: !1,
          key: `ellipsis-${A}`,
          page: x,
          props: {
            ref: I,
            ellipsis: !0,
            icon: !0,
            disabled: !0
          }
        };
      {
        const E = x === r.value;
        return {
          isActive: E,
          key: x,
          page: a(x),
          props: {
            ref: I,
            ellipsis: !1,
            icon: !0,
            disabled: !!e.disabled || +e.length < 2,
            color: E ? e.activeColor : e.color,
            "aria-current": E,
            "aria-label": s(E ? e.currentPageAriaLabel : e.pageAriaLabel, x),
            onClick: (O) => y(O, x)
          }
        };
      }
    })), b = w(() => {
      const x = !!e.disabled || r.value <= h.value, A = !!e.disabled || r.value >= h.value + f.value - 1;
      return {
        first: e.showFirstLastPage ? {
          icon: o.value ? e.lastIcon : e.firstIcon,
          onClick: (I) => y(I, h.value, "first"),
          disabled: x,
          "aria-label": s(e.firstAriaLabel),
          "aria-disabled": x
        } : void 0,
        prev: {
          icon: o.value ? e.nextIcon : e.prevIcon,
          onClick: (I) => y(I, r.value - 1, "prev"),
          disabled: x,
          "aria-label": s(e.previousAriaLabel),
          "aria-disabled": x
        },
        next: {
          icon: o.value ? e.prevIcon : e.nextIcon,
          onClick: (I) => y(I, r.value + 1, "next"),
          disabled: A,
          "aria-label": s(e.nextAriaLabel),
          "aria-disabled": A
        },
        last: e.showFirstLastPage ? {
          icon: o.value ? e.firstIcon : e.lastIcon,
          onClick: (I) => y(I, h.value + f.value - 1, "last"),
          disabled: A,
          "aria-label": s(e.lastAriaLabel),
          "aria-disabled": A
        } : void 0
      };
    });
    function S() {
      var A;
      const x = r.value - h.value;
      (A = k.value[x]) == null || A.$el.focus();
    }
    function C(x) {
      x.key === Tv.left && !e.disabled && r.value > +e.start ? (r.value = r.value - 1, He(S)) : x.key === Tv.right && !e.disabled && r.value < h.value + f.value - 1 && (r.value = r.value + 1, He(S));
    }
    return ie(() => v(e.tag, {
      ref: d,
      class: ["v-pagination", l.value, e.class],
      style: e.style,
      role: "navigation",
      "aria-label": s(e.ariaLabel),
      onKeydown: C,
      "data-test": "v-pagination-root"
    }, {
      default: () => [v("ul", {
        class: "v-pagination__list"
      }, [e.showFirstLastPage && v("li", {
        key: "first",
        class: "v-pagination__first",
        "data-test": "v-pagination-first"
      }, [n.first ? n.first(b.value.first) : v(st, se({
        _as: "VPaginationBtn"
      }, b.value.first), null)]), v("li", {
        key: "prev",
        class: "v-pagination__prev",
        "data-test": "v-pagination-prev"
      }, [n.prev ? n.prev(b.value.prev) : v(st, se({
        _as: "VPaginationBtn"
      }, b.value.prev), null)]), _.value.map((x, A) => v("li", {
        key: x.key,
        class: ["v-pagination__item", {
          "v-pagination__item--is-active": x.isActive
        }],
        "data-test": "v-pagination-item"
      }, [n.item ? n.item(x) : v(st, se({
        _as: "VPaginationBtn"
      }, x.props), {
        default: () => [x.page]
      })])), v("li", {
        key: "next",
        class: "v-pagination__next",
        "data-test": "v-pagination-next"
      }, [n.next ? n.next(b.value.next) : v(st, se({
        _as: "VPaginationBtn"
      }, b.value.next), null)]), e.showFirstLastPage && v("li", {
        key: "last",
        class: "v-pagination__last",
        "data-test": "v-pagination-last"
      }, [n.last ? n.last(b.value.last) : v(st, se({
        _as: "VPaginationBtn"
      }, b.value.last), null)])])]
    })), {};
  }
}), yb = B({
  prevIcon: {
    type: String,
    default: "$prev"
  },
  nextIcon: {
    type: String,
    default: "$next"
  },
  firstIcon: {
    type: String,
    default: "$first"
  },
  lastIcon: {
    type: String,
    default: "$last"
  },
  itemsPerPageText: {
    type: String,
    default: "$vuetify.dataFooter.itemsPerPageText"
  },
  pageText: {
    type: String,
    default: "$vuetify.dataFooter.pageText"
  },
  firstPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.firstPage"
  },
  prevPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.prevPage"
  },
  nextPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.nextPage"
  },
  lastPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.lastPage"
  },
  itemsPerPageOptions: {
    type: Array,
    default: () => [{
      value: 10,
      title: "10"
    }, {
      value: 25,
      title: "25"
    }, {
      value: 50,
      title: "50"
    }, {
      value: 100,
      title: "100"
    }, {
      value: -1,
      title: "$vuetify.dataFooter.itemsPerPageAll"
    }]
  },
  showCurrentPage: Boolean
}, "VDataTableFooter"), Cc = J()({
  name: "VDataTableFooter",
  props: yb(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: i
    } = qt(), {
      page: r,
      pageCount: s,
      startIndex: a,
      stopIndex: o,
      itemsLength: l,
      itemsPerPage: u,
      setItemsPerPage: c
    } = $G(), d = w(() => e.itemsPerPageOptions.map((f) => typeof f == "number" ? {
      value: f,
      title: f === -1 ? i("$vuetify.dataFooter.itemsPerPageAll") : String(f)
    } : {
      ...f,
      title: isNaN(Number(f.title)) ? i(f.title) : f.title
    }));
    return ie(() => {
      var h;
      const f = jg.filterProps(e);
      return v("div", {
        class: "v-data-table-footer"
      }, [(h = n.prepend) == null ? void 0 : h.call(n), v("div", {
        class: "v-data-table-footer__items-per-page"
      }, [v("span", null, [i(e.itemsPerPageText)]), v(ub, {
        items: d.value,
        modelValue: u.value,
        "onUpdate:modelValue": (m) => c(Number(m)),
        density: "compact",
        variant: "outlined",
        "hide-details": !0
      }, null)]), v("div", {
        class: "v-data-table-footer__info"
      }, [v("div", null, [i(e.pageText, l.value ? a.value + 1 : 0, o.value, l.value)])]), v("div", {
        class: "v-data-table-footer__pagination"
      }, [v(jg, se({
        modelValue: r.value,
        "onUpdate:modelValue": (m) => r.value = m,
        density: "comfortable",
        "first-aria-label": e.firstPageLabel,
        "last-aria-label": e.lastPageLabel,
        length: s.value,
        "next-aria-label": e.nextPageLabel,
        "previous-aria-label": e.prevPageLabel,
        rounded: !0,
        "show-first-last-page": !0,
        "total-visible": e.showCurrentPage ? 1 : 0,
        variant: "plain"
      }, f), null)])]);
    }), {};
  }
}), rh = LO({
  align: {
    type: String,
    default: "start"
  },
  fixed: Boolean,
  fixedOffset: [Number, String],
  height: [Number, String],
  lastFixed: Boolean,
  noPadding: Boolean,
  tag: String,
  width: [Number, String],
  maxWidth: [Number, String],
  nowrap: Boolean
}, (e, t) => {
  let {
    slots: n
  } = t;
  const i = e.tag ?? "td";
  return v(i, {
    class: ["v-data-table__td", {
      "v-data-table-column--fixed": e.fixed,
      "v-data-table-column--last-fixed": e.lastFixed,
      "v-data-table-column--no-padding": e.noPadding,
      "v-data-table-column--nowrap": e.nowrap
    }, `v-data-table-column--align-${e.align}`],
    style: {
      height: _e(e.height),
      width: _e(e.width),
      maxWidth: _e(e.maxWidth),
      left: _e(e.fixedOffset || null)
    }
  }, {
    default: () => {
      var r;
      return [(r = n.default) == null ? void 0 : r.call(n)];
    }
  });
}), XG = B({
  headers: Array
}, "DataTable-header"), aI = Symbol.for("vuetify:data-table-headers"), oI = {
  title: "",
  sortable: !1
}, JG = {
  ...oI,
  width: 48
};
function QG() {
  const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).map((n) => ({
    element: n,
    priority: 0
  }));
  return {
    enqueue: (n, i) => {
      let r = !1;
      for (let s = 0; s < t.length; s++)
        if (t[s].priority > i) {
          t.splice(s, 0, {
            element: n,
            priority: i
          }), r = !0;
          break;
        }
      r || t.push({
        element: n,
        priority: i
      });
    },
    size: () => t.length,
    count: () => {
      let n = 0;
      if (!t.length)
        return 0;
      const i = Math.floor(t[0].priority);
      for (let r = 0; r < t.length; r++)
        Math.floor(t[r].priority) === i && (n += 1);
      return n;
    },
    dequeue: () => t.shift()
  };
}
function Hg(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  if (!e.children)
    t.push(e);
  else
    for (const n of e.children)
      Hg(n, t);
  return t;
}
function lI(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
  for (const n of e)
    n.key && t.add(n.key), n.children && lI(n.children, t);
  return t;
}
function e8(e) {
  if (e.key) {
    if (e.key === "data-table-group")
      return oI;
    if (["data-table-expand", "data-table-select"].includes(e.key))
      return JG;
  }
}
function bb(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return e.children ? Math.max(t, ...e.children.map((n) => bb(n, t + 1))) : t;
}
function t8(e) {
  let t = !1;
  function n(s) {
    let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (s)
      if (a && (s.fixed = !0), s.fixed)
        if (s.children)
          for (let o = s.children.length - 1; o >= 0; o--)
            n(s.children[o], !0);
        else
          t ? isNaN(+s.width) && cf(`Multiple fixed columns should have a static width (key: ${s.key})`) : s.lastFixed = !0, t = !0;
      else if (s.children)
        for (let o = s.children.length - 1; o >= 0; o--)
          n(s.children[o]);
      else
        t = !1;
  }
  for (let s = e.length - 1; s >= 0; s--)
    n(e[s]);
  function i(s) {
    let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!s)
      return a;
    if (s.children) {
      s.fixedOffset = a;
      for (const o of s.children)
        a = i(o, a);
    } else
      s.fixed && (s.fixedOffset = a, a += parseFloat(s.width || "0") || 0);
    return a;
  }
  let r = 0;
  for (const s of e)
    r = i(s, r);
}
function n8(e, t) {
  const n = [];
  let i = 0;
  const r = QG(e);
  for (; r.size() > 0; ) {
    let a = r.count();
    const o = [];
    let l = 1;
    for (; a > 0; ) {
      const {
        element: u,
        priority: c
      } = r.dequeue(), d = t - i - bb(u);
      if (o.push({
        ...u,
        rowspan: d ?? 1,
        colspan: u.children ? Hg(u).length : 1
      }), u.children)
        for (const f of u.children) {
          const h = c % 1 + l / Math.pow(10, i + 2);
          r.enqueue(f, i + d + h);
        }
      l += 1, a -= 1;
    }
    i += 1, n.push(o);
  }
  return {
    columns: e.map((a) => Hg(a)).flat(),
    headers: n
  };
}
function uI(e) {
  const t = [];
  for (const n of e) {
    const i = {
      ...e8(n),
      ...n
    }, r = i.key ?? (typeof i.value == "string" ? i.value : null), s = i.value ?? r ?? null, a = {
      ...i,
      key: r,
      value: s,
      sortable: i.sortable ?? (i.key != null || !!i.sort),
      children: i.children ? uI(i.children) : void 0
    };
    t.push(a);
  }
  return t;
}
function wb(e, t) {
  const n = X([]), i = X([]), r = X({}), s = X({}), a = X({});
  Wt(() => {
    var g, p, y;
    const u = (e.headers || Object.keys(e.items[0] ?? {}).map((k) => ({
      key: k,
      title: Nl(k)
    }))).slice(), c = lI(u);
    (g = t == null ? void 0 : t.groupBy) != null && g.value.length && !c.has("data-table-group") && u.unshift({
      key: "data-table-group",
      title: "Group"
    }), (p = t == null ? void 0 : t.showSelect) != null && p.value && !c.has("data-table-select") && u.unshift({
      key: "data-table-select"
    }), (y = t == null ? void 0 : t.showExpand) != null && y.value && !c.has("data-table-expand") && u.push({
      key: "data-table-expand"
    });
    const d = uI(u);
    t8(d);
    const f = Math.max(...d.map((k) => bb(k))) + 1, h = n8(d, f);
    n.value = h.headers, i.value = h.columns;
    const m = h.headers.flat(1);
    for (const k of m)
      k.key && (k.sortable && (k.sort && (r.value[k.key] = k.sort), k.sortRaw && (s.value[k.key] = k.sortRaw)), k.filter && (a.value[k.key] = k.filter));
  });
  const o = {
    headers: n,
    columns: i,
    sortFunctions: r,
    sortRawFunctions: s,
    filterFunctions: a
  };
  return Tt(aI, o), o;
}
function wm() {
  const e = tt(aI);
  if (!e)
    throw new Error("Missing headers!");
  return e;
}
const cI = B({
  color: String,
  sticky: Boolean,
  disableSort: Boolean,
  multiSort: Boolean,
  sortAscIcon: {
    type: We,
    default: "$sortAsc"
  },
  sortDescIcon: {
    type: We,
    default: "$sortDesc"
  },
  headerProps: {
    type: Object
  },
  ...Ll(),
  ...ph()
}, "VDataTableHeaders"), mo = J()({
  name: "VDataTableHeaders",
  props: cI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: i
    } = qt(), {
      toggleSort: r,
      sortBy: s,
      isSorted: a
    } = sI(), {
      someSelected: o,
      allSelected: l,
      selectAll: u,
      showSelectAll: c
    } = pm(), {
      columns: d,
      headers: f
    } = wm(), {
      loaderClasses: h
    } = Ic(e);
    function m(x, A) {
      if (!(!e.sticky && !x.fixed))
        return {
          position: "sticky",
          left: x.fixed ? _e(x.fixedOffset) : void 0,
          top: e.sticky ? `calc(var(--v-table-header-height) * ${A})` : void 0
        };
    }
    function g(x) {
      const A = s.value.find((I) => I.key === x.key);
      return A ? A.order === "asc" ? e.sortAscIcon : e.sortDescIcon : e.sortAscIcon;
    }
    const {
      backgroundColorClasses: p,
      backgroundColorStyles: y
    } = gt(e, "color"), {
      displayClasses: k,
      mobile: T
    } = xr(e), _ = w(() => ({
      headers: f.value,
      columns: d.value,
      toggleSort: r,
      isSorted: a,
      sortBy: s.value,
      someSelected: o.value,
      allSelected: l.value,
      selectAll: u,
      getSortIcon: g
    })), b = w(() => ["v-data-table__th", {
      "v-data-table__th--sticky": e.sticky
    }, k.value, h.value]), S = (x) => {
      let {
        column: A,
        x: I,
        y: E
      } = x;
      const O = A.key === "data-table-select" || A.key === "data-table-expand", V = se(e.headerProps ?? {}, A.headerProps ?? {});
      return v(rh, se({
        tag: "th",
        align: A.align,
        class: [{
          "v-data-table__th--sortable": A.sortable && !e.disableSort,
          "v-data-table__th--sorted": a(A),
          "v-data-table__th--fixed": A.fixed
        }, ...b.value],
        style: {
          width: _e(A.width),
          minWidth: _e(A.minWidth),
          maxWidth: _e(A.maxWidth),
          ...m(A, E)
        },
        colspan: A.colspan,
        rowspan: A.rowspan,
        onClick: A.sortable ? () => r(A) : void 0,
        fixed: A.fixed,
        nowrap: A.nowrap,
        lastFixed: A.lastFixed,
        noPadding: O
      }, V), {
        default: () => {
          var $;
          const N = `header.${A.key}`, F = {
            column: A,
            selectAll: u,
            isSorted: a,
            toggleSort: r,
            sortBy: s.value,
            someSelected: o.value,
            allSelected: l.value,
            getSortIcon: g
          };
          return n[N] ? n[N](F) : A.key === "data-table-select" ? (($ = n["header.data-table-select"]) == null ? void 0 : $.call(n, F)) ?? (c.value && v(Ss, {
            modelValue: l.value,
            indeterminate: o.value && !l.value,
            "onUpdate:modelValue": u
          }, null)) : v("div", {
            class: "v-data-table-header__content"
          }, [v("span", null, [A.title]), A.sortable && !e.disableSort && v(at, {
            key: "icon",
            class: "v-data-table-header__sort-icon",
            icon: g(A)
          }, null), e.multiSort && a(A) && v("div", {
            key: "badge",
            class: ["v-data-table-header__sort-badge", ...p.value],
            style: y.value
          }, [s.value.findIndex((Z) => Z.key === A.key) + 1])]);
        }
      });
    }, C = () => {
      const x = se(e.headerProps ?? {} ?? {}), A = w(() => d.value.filter((E) => (E == null ? void 0 : E.sortable) && !e.disableSort)), I = w(() => {
        if (d.value.find((O) => O.key === "data-table-select") != null)
          return l.value ? "$checkboxOn" : o.value ? "$checkboxIndeterminate" : "$checkboxOff";
      });
      return v(rh, se({
        tag: "th",
        class: [...b.value],
        colspan: f.value.length + 1
      }, x), {
        default: () => [v("div", {
          class: "v-data-table-header__content"
        }, [v(ub, {
          chips: !0,
          class: "v-data-table__td-sort-select",
          clearable: !0,
          density: "default",
          items: A.value,
          label: i("$vuetify.dataTable.sortBy"),
          multiple: e.multiSort,
          variant: "underlined",
          "onClick:clear": () => s.value = [],
          appendIcon: I.value,
          "onClick:append": () => u(!l.value)
        }, {
          ...n,
          chip: (E) => {
            var O;
            return v(ru, {
              onClick: (O = E.item.raw) != null && O.sortable ? () => r(E.item.raw) : void 0,
              onMousedown: (V) => {
                V.preventDefault(), V.stopPropagation();
              }
            }, {
              default: () => [E.item.title, v(at, {
                class: ["v-data-table__td-sort-icon", a(E.item.raw) && "v-data-table__td-sort-icon-active"],
                icon: g(E.item.raw),
                size: "small"
              }, null)]
            });
          }
        })])]
      });
    };
    ie(() => T.value ? v("tr", null, [v(C, null, null)]) : v(De, null, [n.headers ? n.headers(_.value) : f.value.map((x, A) => v("tr", null, [x.map((I, E) => v(S, {
      column: I,
      x: E,
      y: A
    }, null))])), e.loading && v("tr", {
      class: "v-data-table-progress"
    }, [v("th", {
      colspan: d.value.length
    }, [v(Ec, {
      name: "v-data-table-progress",
      absolute: !0,
      active: !0,
      color: typeof e.loading == "boolean" ? void 0 : e.loading,
      indeterminate: !0
    }, {
      default: n.loader
    })])])]));
  }
}), i8 = B({
  item: {
    type: Object,
    required: !0
  }
}, "VDataTableGroupHeaderRow"), r8 = J()({
  name: "VDataTableGroupHeaderRow",
  props: i8(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isGroupOpen: i,
      toggleGroup: r,
      extractRows: s
    } = YA(), {
      isSelected: a,
      isSomeSelected: o,
      select: l
    } = pm(), {
      columns: u
    } = wm(), c = w(() => s([e.item]));
    return () => v("tr", {
      class: "v-data-table-group-header-row",
      style: {
        "--v-data-table-group-header-row-depth": e.item.depth
      }
    }, [u.value.map((d) => {
      var f, h;
      if (d.key === "data-table-group") {
        const m = i(e.item) ? "$expand" : "$next", g = () => r(e.item);
        return ((f = n["data-table-group"]) == null ? void 0 : f.call(n, {
          item: e.item,
          count: c.value.length,
          props: {
            icon: m,
            onClick: g
          }
        })) ?? v(rh, {
          class: "v-data-table-group-header-row__column"
        }, {
          default: () => [v(st, {
            size: "small",
            variant: "text",
            icon: m,
            onClick: g
          }, null), v("span", null, [e.item.value]), v("span", null, [wr("("), c.value.length, wr(")")])]
        });
      }
      if (d.key === "data-table-select") {
        const m = a(c.value), g = o(c.value) && !m, p = (y) => l(c.value, y);
        return ((h = n["data-table-select"]) == null ? void 0 : h.call(n, {
          props: {
            modelValue: m,
            indeterminate: g,
            "onUpdate:modelValue": p
          }
        })) ?? v("td", null, [v(Ss, {
          modelValue: m,
          indeterminate: g,
          "onUpdate:modelValue": p
        }, null)]);
      }
      return v("td", null, null);
    })]);
  }
}), s8 = B({
  index: Number,
  item: Object,
  cellProps: [Object, Function],
  onClick: ri(),
  onContextmenu: ri(),
  onDblclick: ri(),
  ...Ll()
}, "VDataTableRow"), _b = J()({
  name: "VDataTableRow",
  props: s8(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      displayClasses: i,
      mobile: r
    } = xr(e, "v-data-table__tr"), {
      isSelected: s,
      toggleSelect: a,
      someSelected: o,
      allSelected: l,
      selectAll: u
    } = pm(), {
      isExpanded: c,
      toggleExpand: d
    } = qA(), {
      toggleSort: f,
      sortBy: h,
      isSorted: m
    } = sI(), {
      columns: g
    } = wm();
    ie(() => v("tr", {
      class: ["v-data-table__tr", {
        "v-data-table__tr--clickable": !!(e.onClick || e.onContextmenu || e.onDblclick)
      }, i.value],
      onClick: e.onClick,
      onContextmenu: e.onContextmenu,
      onDblclick: e.onDblclick
    }, [e.item && g.value.map((p, y) => {
      const k = e.item, T = `item.${p.key}`, _ = `header.${p.key}`, b = {
        index: e.index,
        item: k.raw,
        internalItem: k,
        value: $u(k.columns, p.key),
        column: p,
        isSelected: s,
        toggleSelect: a,
        isExpanded: c,
        toggleExpand: d
      }, S = {
        column: p,
        selectAll: u,
        isSorted: m,
        toggleSort: f,
        sortBy: h.value,
        someSelected: o.value,
        allSelected: l.value,
        getSortIcon: () => ""
      }, C = typeof e.cellProps == "function" ? e.cellProps({
        index: b.index,
        item: b.item,
        internalItem: b.internalItem,
        value: b.value,
        column: p
      }) : e.cellProps, x = typeof p.cellProps == "function" ? p.cellProps({
        index: b.index,
        item: b.item,
        internalItem: b.internalItem,
        value: b.value
      }) : p.cellProps;
      return v(rh, se({
        align: p.align,
        class: {
          "v-data-table__td--expanded-row": p.key === "data-table-expand",
          "v-data-table__td--select-row": p.key === "data-table-select"
        },
        fixed: p.fixed,
        fixedOffset: p.fixedOffset,
        lastFixed: p.lastFixed,
        maxWidth: r.value ? void 0 : p.maxWidth,
        noPadding: p.key === "data-table-select" || p.key === "data-table-expand",
        nowrap: p.nowrap,
        width: r.value ? void 0 : p.width
      }, C, x), {
        default: () => {
          var I, E, O, V, N;
          if (n[T] && !r.value)
            return (I = n[T]) == null ? void 0 : I.call(n, b);
          if (p.key === "data-table-select")
            return ((E = n["item.data-table-select"]) == null ? void 0 : E.call(n, b)) ?? v(Ss, {
              disabled: !k.selectable,
              modelValue: s([k]),
              onClick: Cv(() => a(k), ["stop"])
            }, null);
          if (p.key === "data-table-expand")
            return ((O = n["item.data-table-expand"]) == null ? void 0 : O.call(n, b)) ?? v(st, {
              icon: c(k) ? "$collapse" : "$expand",
              size: "small",
              variant: "text",
              onClick: Cv(() => d(k), ["stop"])
            }, null);
          const A = ep(b.value);
          return r.value ? v(De, null, [v("div", {
            class: "v-data-table__td-title"
          }, [((V = n[_]) == null ? void 0 : V.call(n, S)) ?? p.title]), v("div", {
            class: "v-data-table__td-value"
          }, [((N = n[T]) == null ? void 0 : N.call(n, b)) ?? A])]) : A;
        }
      });
    })]));
  }
}), dI = B({
  loading: [Boolean, String],
  loadingText: {
    type: String,
    default: "$vuetify.dataIterator.loadingText"
  },
  hideNoData: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  rowProps: [Object, Function],
  cellProps: [Object, Function],
  ...Ll()
}, "VDataTableRows"), vo = J()({
  name: "VDataTableRows",
  inheritAttrs: !1,
  props: dI(),
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      columns: r
    } = wm(), {
      expandOnClick: s,
      toggleExpand: a,
      isExpanded: o
    } = qA(), {
      isSelected: l,
      toggleSelect: u
    } = pm(), {
      toggleGroup: c,
      isGroupOpen: d
    } = YA(), {
      t: f
    } = qt(), {
      mobile: h
    } = xr(e);
    return ie(() => {
      var m, g;
      return e.loading && (!e.items.length || i.loading) ? v("tr", {
        class: "v-data-table-rows-loading",
        key: "loading"
      }, [v("td", {
        colspan: r.value.length
      }, [((m = i.loading) == null ? void 0 : m.call(i)) ?? f(e.loadingText)])]) : !e.loading && !e.items.length && !e.hideNoData ? v("tr", {
        class: "v-data-table-rows-no-data",
        key: "no-data"
      }, [v("td", {
        colspan: r.value.length
      }, [((g = i["no-data"]) == null ? void 0 : g.call(i)) ?? f(e.noDataText)])]) : v(De, null, [e.items.map((p, y) => {
        var _;
        if (p.type === "group") {
          const b = {
            index: y,
            item: p,
            columns: r.value,
            isExpanded: o,
            toggleExpand: a,
            isSelected: l,
            toggleSelect: u,
            toggleGroup: c,
            isGroupOpen: d
          };
          return i["group-header"] ? i["group-header"](b) : v(r8, se({
            key: `group-header_${p.id}`,
            item: p
          }, lw(n, ":group-header", () => b)), i);
        }
        const k = {
          index: y,
          item: p.raw,
          internalItem: p,
          columns: r.value,
          isExpanded: o,
          toggleExpand: a,
          isSelected: l,
          toggleSelect: u
        }, T = {
          ...k,
          props: se({
            key: `item_${p.key ?? p.index}`,
            onClick: s.value ? () => {
              a(p);
            } : void 0,
            index: y,
            item: p,
            cellProps: e.cellProps,
            mobile: h.value
          }, lw(n, ":row", () => k), typeof e.rowProps == "function" ? e.rowProps({
            item: k.item,
            index: k.index,
            internalItem: k.internalItem
          }) : e.rowProps)
        };
        return v(De, {
          key: T.props.key
        }, [i.item ? i.item(T) : v(_b, T.props, i), o(p) && ((_ = i["expanded-row"]) == null ? void 0 : _.call(i, k))]);
      })]);
    }), {};
  }
});
const fI = B({
  fixedHeader: Boolean,
  fixedFooter: Boolean,
  height: [Number, String],
  hover: Boolean,
  ...ke(),
  ...bn(),
  ...je(),
  ...Qe()
}, "VTable"), go = J()({
  name: "VTable",
  props: fI(),
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const {
      themeClasses: r
    } = lt(e), {
      densityClasses: s
    } = Kn(e);
    return ie(() => v(e.tag, {
      class: ["v-table", {
        "v-table--fixed-height": !!e.height,
        "v-table--fixed-header": e.fixedHeader,
        "v-table--fixed-footer": e.fixedFooter,
        "v-table--has-top": !!n.top,
        "v-table--has-bottom": !!n.bottom,
        "v-table--hover": e.hover
      }, r.value, s.value, e.class],
      style: e.style
    }, {
      default: () => {
        var a, o, l;
        return [(a = n.top) == null ? void 0 : a.call(n), n.default ? v("div", {
          class: "v-table__wrapper",
          style: {
            height: _e(e.height)
          }
        }, [v("table", null, [n.default()])]) : (o = n.wrapper) == null ? void 0 : o.call(n), (l = n.bottom) == null ? void 0 : l.call(n)];
      }
    })), {};
  }
}), a8 = B({
  items: {
    type: Array,
    default: () => []
  },
  itemValue: {
    type: [String, Array, Function],
    default: "id"
  },
  itemSelectable: {
    type: [String, Array, Function],
    default: null
  },
  rowProps: [Object, Function],
  cellProps: [Object, Function],
  returnObject: Boolean
}, "DataTable-items");
function o8(e, t, n, i) {
  const r = e.returnObject ? t : dn(t, e.itemValue), s = dn(t, e.itemSelectable, !0), a = i.reduce((o, l) => (l.key != null && (o[l.key] = dn(t, l.value)), o), {});
  return {
    type: "item",
    key: e.returnObject ? dn(t, e.itemValue) : r,
    index: n,
    value: r,
    selectable: s,
    columns: a,
    raw: t
  };
}
function l8(e, t, n) {
  return t.map((i, r) => o8(e, i, r, n));
}
function Sb(e, t) {
  return {
    items: w(() => l8(e, e.items, t.value))
  };
}
const kb = B({
  ...dI(),
  hideDefaultBody: Boolean,
  hideDefaultFooter: Boolean,
  hideDefaultHeader: Boolean,
  width: [String, Number],
  search: String,
  ...zA(),
  ...fb(),
  ...XG(),
  ...a8(),
  ...tI(),
  ...iI(),
  ...cI(),
  ...fI()
}, "DataTable"), u8 = B({
  ...mb(),
  ...kb(),
  ...ad(),
  ...yb()
}, "VDataTable"), c8 = J()({
  name: "VDataTable",
  props: u8(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:page": (e) => !0,
    "update:itemsPerPage": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:groupBy": (e) => !0,
    "update:expanded": (e) => !0,
    "update:currentItems": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      groupBy: r
    } = hb(e), {
      sortBy: s,
      multiSort: a,
      mustSort: o
    } = ym(e), {
      page: l,
      itemsPerPage: u
    } = vb(e), {
      columns: c,
      headers: d,
      sortFunctions: f,
      sortRawFunctions: h,
      filterFunctions: m
    } = wb(e, {
      groupBy: r,
      showSelect: G(e, "showSelect"),
      showExpand: G(e, "showExpand")
    }), {
      items: g
    } = Sb(e, c), p = G(e, "search"), {
      filteredItems: y
    } = od(e, g, p, {
      transform: (K) => K.columns,
      customKeyFilter: m
    }), {
      toggleSort: k
    } = bm({
      sortBy: s,
      multiSort: a,
      mustSort: o,
      page: l
    }), {
      sortByWithGroups: T,
      opened: _,
      extractRows: b,
      isGroupOpen: S,
      toggleGroup: C
    } = hm({
      groupBy: r,
      sortBy: s
    }), {
      sortedItems: x
    } = pb(e, y, T, {
      transform: (K) => K.columns,
      sortFunctions: f,
      sortRawFunctions: h
    }), {
      flatItems: A
    } = mm(x, r, _), I = w(() => A.value.length), {
      startIndex: E,
      stopIndex: O,
      pageCount: V,
      setItemsPerPage: N
    } = gb({
      page: l,
      itemsPerPage: u,
      itemsLength: I
    }), {
      paginatedItems: F
    } = JA({
      items: A,
      startIndex: E,
      stopIndex: O,
      itemsPerPage: u
    }), $ = w(() => b(F.value)), {
      isSelected: Z,
      select: j,
      selectAll: H,
      toggleSelect: R,
      someSelected: L,
      allSelected: ne
    } = gm(e, {
      allItems: g,
      currentPage: $
    }), {
      isExpanded: oe,
      toggleExpand: we
    } = fm(e);
    vm({
      page: l,
      itemsPerPage: u,
      sortBy: s,
      groupBy: r,
      search: p
    }), jt({
      VDataTableRows: {
        hideNoData: G(e, "hideNoData"),
        noDataText: G(e, "noDataText"),
        loading: G(e, "loading"),
        loadingText: G(e, "loadingText")
      }
    });
    const ee = w(() => ({
      page: l.value,
      itemsPerPage: u.value,
      sortBy: s.value,
      pageCount: V.value,
      toggleSort: k,
      setItemsPerPage: N,
      someSelected: L.value,
      allSelected: ne.value,
      isSelected: Z,
      select: j,
      selectAll: H,
      toggleSelect: R,
      isExpanded: oe,
      toggleExpand: we,
      isGroupOpen: S,
      toggleGroup: C,
      items: $.value.map((K) => K.raw),
      internalItems: $.value,
      groupedItems: F.value,
      columns: c.value,
      headers: d.value
    }));
    return ie(() => {
      const K = Cc.filterProps(e), ue = mo.filterProps(e), ve = vo.filterProps(e), Re = go.filterProps(e);
      return v(go, se({
        class: ["v-data-table", {
          "v-data-table--show-select": e.showSelect,
          "v-data-table--loading": e.loading
        }, e.class],
        style: e.style
      }, Re), {
        top: () => {
          var he;
          return (he = i.top) == null ? void 0 : he.call(i, ee.value);
        },
        default: () => {
          var he, Pe, le, be, Oe, te;
          return i.default ? i.default(ee.value) : v(De, null, [(he = i.colgroup) == null ? void 0 : he.call(i, ee.value), !e.hideDefaultHeader && v("thead", {
            key: "thead"
          }, [v(mo, ue, i)]), (Pe = i.thead) == null ? void 0 : Pe.call(i, ee.value), !e.hideDefaultBody && v("tbody", null, [(le = i["body.prepend"]) == null ? void 0 : le.call(i, ee.value), i.body ? i.body(ee.value) : v(vo, se(n, ve, {
            items: F.value
          }), i), (be = i["body.append"]) == null ? void 0 : be.call(i, ee.value)]), (Oe = i.tbody) == null ? void 0 : Oe.call(i, ee.value), (te = i.tfoot) == null ? void 0 : te.call(i, ee.value)]);
        },
        bottom: () => i.bottom ? i.bottom(ee.value) : !e.hideDefaultFooter && v(De, null, [v(rd, null, null), v(Cc, K, {
          prepend: i["footer.prepend"]
        })])
      });
    }), {};
  }
}), d8 = B({
  ...kb(),
  ...fb(),
  ...TA(),
  ...ad()
}, "VDataTableVirtual"), f8 = J()({
  name: "VDataTableVirtual",
  props: d8(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:groupBy": (e) => !0,
    "update:expanded": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      groupBy: r
    } = hb(e), {
      sortBy: s,
      multiSort: a,
      mustSort: o
    } = ym(e), {
      columns: l,
      headers: u,
      filterFunctions: c,
      sortFunctions: d,
      sortRawFunctions: f
    } = wb(e, {
      groupBy: r,
      showSelect: G(e, "showSelect"),
      showExpand: G(e, "showExpand")
    }), {
      items: h
    } = Sb(e, l), m = G(e, "search"), {
      filteredItems: g
    } = od(e, h, m, {
      transform: (ue) => ue.columns,
      customKeyFilter: c
    }), {
      toggleSort: p
    } = bm({
      sortBy: s,
      multiSort: a,
      mustSort: o
    }), {
      sortByWithGroups: y,
      opened: k,
      extractRows: T,
      isGroupOpen: _,
      toggleGroup: b
    } = hm({
      groupBy: r,
      sortBy: s
    }), {
      sortedItems: S
    } = pb(e, g, y, {
      transform: (ue) => ue.columns,
      sortFunctions: d,
      sortRawFunctions: f
    }), {
      flatItems: C
    } = mm(S, r, k), x = w(() => T(C.value)), {
      isSelected: A,
      select: I,
      selectAll: E,
      toggleSelect: O,
      someSelected: V,
      allSelected: N
    } = gm(e, {
      allItems: x,
      currentPage: x
    }), {
      isExpanded: F,
      toggleExpand: $
    } = fm(e), {
      containerRef: Z,
      markerRef: j,
      paddingTop: H,
      paddingBottom: R,
      computedItems: L,
      handleItemResize: ne,
      handleScroll: oe,
      handleScrollend: we
    } = xA(e, C), ee = w(() => L.value.map((ue) => ue.raw));
    vm({
      sortBy: s,
      page: pe(1),
      itemsPerPage: pe(-1),
      groupBy: r,
      search: m
    }), jt({
      VDataTableRows: {
        hideNoData: G(e, "hideNoData"),
        noDataText: G(e, "noDataText"),
        loading: G(e, "loading"),
        loadingText: G(e, "loadingText")
      }
    });
    const K = w(() => ({
      sortBy: s.value,
      toggleSort: p,
      someSelected: V.value,
      allSelected: N.value,
      isSelected: A,
      select: I,
      selectAll: E,
      toggleSelect: O,
      isExpanded: F,
      toggleExpand: $,
      isGroupOpen: _,
      toggleGroup: b,
      items: x.value.map((ue) => ue.raw),
      internalItems: x.value,
      groupedItems: C.value,
      columns: l.value,
      headers: u.value
    }));
    ie(() => {
      const ue = mo.filterProps(e), ve = vo.filterProps(e), Re = go.filterProps(e);
      return v(go, se({
        class: ["v-data-table", {
          "v-data-table--loading": e.loading
        }, e.class],
        style: e.style
      }, Re), {
        top: () => {
          var he;
          return (he = i.top) == null ? void 0 : he.call(i, K.value);
        },
        wrapper: () => {
          var he, Pe, le;
          return v("div", {
            ref: Z,
            onScrollPassive: oe,
            onScrollend: we,
            class: "v-table__wrapper",
            style: {
              height: _e(e.height)
            }
          }, [v("table", null, [(he = i.colgroup) == null ? void 0 : he.call(i, K.value), !e.hideDefaultHeader && v("thead", {
            key: "thead"
          }, [v(mo, se(ue, {
            sticky: e.fixedHeader
          }), i)]), !e.hideDefaultBody && v("tbody", null, [v("tr", {
            ref: j,
            style: {
              height: _e(H.value),
              border: 0
            }
          }, [v("td", {
            colspan: l.value.length,
            style: {
              height: 0,
              border: 0
            }
          }, null)]), (Pe = i["body.prepend"]) == null ? void 0 : Pe.call(i, K.value), v(vo, se(n, ve, {
            items: ee.value
          }), {
            ...i,
            item: (be) => v(CA, {
              key: be.internalItem.index,
              renderless: !0,
              "onUpdate:height": (Oe) => ne(be.internalItem.index, Oe)
            }, {
              default: (Oe) => {
                var me;
                let {
                  itemRef: te
                } = Oe;
                return ((me = i.item) == null ? void 0 : me.call(i, {
                  ...be,
                  itemRef: te
                })) ?? v(_b, se(be.props, {
                  ref: te,
                  key: be.internalItem.index,
                  index: be.internalItem.index
                }), i);
              }
            })
          }), (le = i["body.append"]) == null ? void 0 : le.call(i, K.value), v("tr", {
            style: {
              height: _e(R.value),
              border: 0
            }
          }, [v("td", {
            colspan: l.value.length,
            style: {
              height: 0,
              border: 0
            }
          }, null)])])])]);
        },
        bottom: () => {
          var he;
          return (he = i.bottom) == null ? void 0 : he.call(i, K.value);
        }
      });
    });
  }
}), h8 = B({
  itemsLength: {
    type: [Number, String],
    required: !0
  },
  ...mb(),
  ...kb(),
  ...yb()
}, "VDataTableServer"), m8 = J()({
  name: "VDataTableServer",
  props: h8(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:page": (e) => !0,
    "update:itemsPerPage": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:expanded": (e) => !0,
    "update:groupBy": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      groupBy: r
    } = hb(e), {
      sortBy: s,
      multiSort: a,
      mustSort: o
    } = ym(e), {
      page: l,
      itemsPerPage: u
    } = vb(e), c = w(() => parseInt(e.itemsLength, 10)), {
      columns: d,
      headers: f
    } = wb(e, {
      groupBy: r,
      showSelect: G(e, "showSelect"),
      showExpand: G(e, "showExpand")
    }), {
      items: h
    } = Sb(e, d), {
      toggleSort: m
    } = bm({
      sortBy: s,
      multiSort: a,
      mustSort: o,
      page: l
    }), {
      opened: g,
      isGroupOpen: p,
      toggleGroup: y,
      extractRows: k
    } = hm({
      groupBy: r,
      sortBy: s
    }), {
      pageCount: T,
      setItemsPerPage: _
    } = gb({
      page: l,
      itemsPerPage: u,
      itemsLength: c
    }), {
      flatItems: b
    } = mm(h, r, g), {
      isSelected: S,
      select: C,
      selectAll: x,
      toggleSelect: A,
      someSelected: I,
      allSelected: E
    } = gm(e, {
      allItems: h,
      currentPage: h
    }), {
      isExpanded: O,
      toggleExpand: V
    } = fm(e), N = w(() => k(h.value));
    vm({
      page: l,
      itemsPerPage: u,
      sortBy: s,
      groupBy: r,
      search: G(e, "search")
    }), Tt("v-data-table", {
      toggleSort: m,
      sortBy: s
    }), jt({
      VDataTableRows: {
        hideNoData: G(e, "hideNoData"),
        noDataText: G(e, "noDataText"),
        loading: G(e, "loading"),
        loadingText: G(e, "loadingText")
      }
    });
    const F = w(() => ({
      page: l.value,
      itemsPerPage: u.value,
      sortBy: s.value,
      pageCount: T.value,
      toggleSort: m,
      setItemsPerPage: _,
      someSelected: I.value,
      allSelected: E.value,
      isSelected: S,
      select: C,
      selectAll: x,
      toggleSelect: A,
      isExpanded: O,
      toggleExpand: V,
      isGroupOpen: p,
      toggleGroup: y,
      items: N.value.map(($) => $.raw),
      internalItems: N.value,
      groupedItems: b.value,
      columns: d.value,
      headers: f.value
    }));
    ie(() => {
      const $ = Cc.filterProps(e), Z = mo.filterProps(e), j = vo.filterProps(e), H = go.filterProps(e);
      return v(go, se({
        class: ["v-data-table", {
          "v-data-table--loading": e.loading
        }, e.class],
        style: e.style
      }, H), {
        top: () => {
          var R;
          return (R = i.top) == null ? void 0 : R.call(i, F.value);
        },
        default: () => {
          var R, L, ne, oe, we, ee;
          return i.default ? i.default(F.value) : v(De, null, [(R = i.colgroup) == null ? void 0 : R.call(i, F.value), !e.hideDefaultHeader && v("thead", {
            key: "thead",
            class: "v-data-table__thead",
            role: "rowgroup"
          }, [v(mo, se(Z, {
            sticky: e.fixedHeader
          }), i)]), (L = i.thead) == null ? void 0 : L.call(i, F.value), !e.hideDefaultBody && v("tbody", {
            class: "v-data-table__tbody",
            role: "rowgroup"
          }, [(ne = i["body.prepend"]) == null ? void 0 : ne.call(i, F.value), i.body ? i.body(F.value) : v(vo, se(n, j, {
            items: b.value
          }), i), (oe = i["body.append"]) == null ? void 0 : oe.call(i, F.value)]), (we = i.tbody) == null ? void 0 : we.call(i, F.value), (ee = i.tfoot) == null ? void 0 : ee.call(i, F.value)]);
        },
        bottom: () => i.bottom ? i.bottom(F.value) : !e.hideDefaultFooter && v(De, null, [v(rd, null, null), v(Cc, $, {
          prepend: i["footer.prepend"]
        })])
      });
    });
  }
});
const v8 = B({
  fluid: {
    type: Boolean,
    default: !1
  },
  ...ke(),
  ...je()
}, "VContainer"), g8 = J()({
  name: "VContainer",
  props: v8(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      rtlClasses: i
    } = yn();
    return ie(() => v(e.tag, {
      class: ["v-container", {
        "v-container--fluid": e.fluid
      }, i.value, e.class],
      style: e.style
    }, n)), {};
  }
}), hI = (() => wh.reduce((e, t) => (e[t] = {
  type: [Boolean, String, Number],
  default: !1
}, e), {}))(), mI = (() => wh.reduce((e, t) => {
  const n = "offset" + Nl(t);
  return e[n] = {
    type: [String, Number],
    default: null
  }, e;
}, {}))(), vI = (() => wh.reduce((e, t) => {
  const n = "order" + Nl(t);
  return e[n] = {
    type: [String, Number],
    default: null
  }, e;
}, {}))(), B_ = {
  col: Object.keys(hI),
  offset: Object.keys(mI),
  order: Object.keys(vI)
};
function p8(e, t, n) {
  let i = e;
  if (!(n == null || n === !1)) {
    if (t) {
      const r = t.replace(e, "");
      i += `-${r}`;
    }
    return e === "col" && (i = "v-" + i), e === "col" && (n === "" || n === !0) || (i += `-${n}`), i.toLowerCase();
  }
}
const y8 = ["auto", "start", "end", "center", "baseline", "stretch"], b8 = B({
  cols: {
    type: [Boolean, String, Number],
    default: !1
  },
  ...hI,
  offset: {
    type: [String, Number],
    default: null
  },
  ...mI,
  order: {
    type: [String, Number],
    default: null
  },
  ...vI,
  alignSelf: {
    type: String,
    default: null,
    validator: (e) => y8.includes(e)
  },
  ...ke(),
  ...je()
}, "VCol"), w8 = J()({
  name: "VCol",
  props: b8(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = w(() => {
      const r = [];
      let s;
      for (s in B_)
        B_[s].forEach((o) => {
          const l = e[o], u = p8(s, o, l);
          u && r.push(u);
        });
      const a = r.some((o) => o.startsWith("v-col-"));
      return r.push({
        // Default to .v-col if no other col-{bp}-* classes generated nor `cols` specified.
        "v-col": !a || !e.cols,
        [`v-col-${e.cols}`]: e.cols,
        [`offset-${e.offset}`]: e.offset,
        [`order-${e.order}`]: e.order,
        [`align-self-${e.alignSelf}`]: e.alignSelf
      }), r;
    });
    return () => {
      var r;
      return oa(e.tag, {
        class: [i.value, e.class],
        style: e.style
      }, (r = n.default) == null ? void 0 : r.call(n));
    };
  }
}), Cb = ["start", "end", "center"], gI = ["space-between", "space-around", "space-evenly"];
function Tb(e, t) {
  return wh.reduce((n, i) => {
    const r = e + Nl(i);
    return n[r] = t(), n;
  }, {});
}
const _8 = [...Cb, "baseline", "stretch"], pI = (e) => _8.includes(e), yI = Tb("align", () => ({
  type: String,
  default: null,
  validator: pI
})), S8 = [...Cb, ...gI], bI = (e) => S8.includes(e), wI = Tb("justify", () => ({
  type: String,
  default: null,
  validator: bI
})), k8 = [...Cb, ...gI, "stretch"], _I = (e) => k8.includes(e), SI = Tb("alignContent", () => ({
  type: String,
  default: null,
  validator: _I
})), L_ = {
  align: Object.keys(yI),
  justify: Object.keys(wI),
  alignContent: Object.keys(SI)
}, C8 = {
  align: "align",
  justify: "justify",
  alignContent: "align-content"
};
function T8(e, t, n) {
  let i = C8[e];
  if (n != null) {
    if (t) {
      const r = t.replace(e, "");
      i += `-${r}`;
    }
    return i += `-${n}`, i.toLowerCase();
  }
}
const x8 = B({
  dense: Boolean,
  noGutters: Boolean,
  align: {
    type: String,
    default: null,
    validator: pI
  },
  ...yI,
  justify: {
    type: String,
    default: null,
    validator: bI
  },
  ...wI,
  alignContent: {
    type: String,
    default: null,
    validator: _I
  },
  ...SI,
  ...ke(),
  ...je()
}, "VRow"), A8 = J()({
  name: "VRow",
  props: x8(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = w(() => {
      const r = [];
      let s;
      for (s in L_)
        L_[s].forEach((a) => {
          const o = e[a], l = T8(s, a, o);
          l && r.push(l);
        });
      return r.push({
        "v-row--no-gutters": e.noGutters,
        "v-row--dense": e.dense,
        [`align-${e.align}`]: e.align,
        [`justify-${e.justify}`]: e.justify,
        [`align-content-${e.alignContent}`]: e.alignContent
      }), r;
    });
    return () => {
      var r;
      return oa(e.tag, {
        class: ["v-row", i.value, e.class],
        style: e.style
      }, (r = n.default) == null ? void 0 : r.call(n));
    };
  }
}), kI = Yr("v-spacer", "div", "VSpacer"), CI = B({
  active: {
    type: [String, Array],
    default: void 0
  },
  disabled: {
    type: [Boolean, String, Array],
    default: !1
  },
  nextIcon: {
    type: [String],
    default: "$next"
  },
  prevIcon: {
    type: [String],
    default: "$prev"
  },
  modeIcon: {
    type: [String],
    default: "$subgroup"
  },
  text: String,
  viewMode: {
    type: String,
    default: "month"
  }
}, "VDatePickerControls"), zg = J()({
  name: "VDatePickerControls",
  props: CI(),
  emits: {
    "click:year": () => !0,
    "click:month": () => !0,
    "click:prev": () => !0,
    "click:next": () => !0,
    "click:text": () => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const i = w(() => Array.isArray(e.disabled) ? e.disabled.includes("text") : !!e.disabled), r = w(() => Array.isArray(e.disabled) ? e.disabled.includes("mode") : !!e.disabled), s = w(() => Array.isArray(e.disabled) ? e.disabled.includes("prev") : !!e.disabled), a = w(() => Array.isArray(e.disabled) ? e.disabled.includes("next") : !!e.disabled);
    function o() {
      n("click:prev");
    }
    function l() {
      n("click:next");
    }
    function u() {
      n("click:year");
    }
    function c() {
      n("click:month");
    }
    return ie(() => v("div", {
      class: ["v-date-picker-controls"]
    }, [v(st, {
      class: "v-date-picker-controls__month-btn",
      disabled: i.value,
      text: e.text,
      variant: "text",
      rounded: !0,
      onClick: c
    }, null), v(st, {
      key: "mode-btn",
      class: "v-date-picker-controls__mode-btn",
      disabled: r.value,
      density: "comfortable",
      icon: e.modeIcon,
      variant: "text",
      onClick: u
    }, null), v(kI, {
      key: "mode-spacer"
    }, null), v("div", {
      key: "month-buttons",
      class: "v-date-picker-controls__month"
    }, [v(st, {
      disabled: s.value,
      icon: e.prevIcon,
      variant: "text",
      onClick: o
    }, null), v(st, {
      disabled: a.value,
      icon: e.nextIcon,
      variant: "text",
      onClick: l
    }, null)])])), {};
  }
});
const I8 = B({
  appendIcon: String,
  color: String,
  header: String,
  transition: String,
  onClick: ri()
}, "VDatePickerHeader"), Ug = J()({
  name: "VDatePickerHeader",
  props: I8(),
  emits: {
    click: () => !0,
    "click:append": () => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const {
      backgroundColorClasses: r,
      backgroundColorStyles: s
    } = gt(e, "color");
    function a() {
      n("click");
    }
    function o() {
      n("click:append");
    }
    return ie(() => {
      const l = !!(i.default || e.header), u = !!(i.append || e.appendIcon);
      return v("div", {
        class: ["v-date-picker-header", {
          "v-date-picker-header--clickable": !!e.onClick
        }, r.value],
        style: s.value,
        onClick: a
      }, [i.prepend && v("div", {
        key: "prepend",
        class: "v-date-picker-header__prepend"
      }, [i.prepend()]), l && v(Gn, {
        key: "content",
        name: e.transition
      }, {
        default: () => {
          var c;
          return [v("div", {
            key: e.header,
            class: "v-date-picker-header__content"
          }, [((c = i.default) == null ? void 0 : c.call(i)) ?? e.header])];
        }
      }), u && v("div", {
        class: "v-date-picker-header__append"
      }, [i.append ? v(Ze, {
        key: "append-defaults",
        disabled: !e.appendIcon,
        defaults: {
          VBtn: {
            icon: e.appendIcon,
            variant: "text"
          }
        }
      }, {
        default: () => {
          var c;
          return [(c = i.append) == null ? void 0 : c.call(i)];
        }
      }) : v(st, {
        key: "append-btn",
        icon: e.appendIcon,
        variant: "text",
        onClick: o
      }, null)])]);
    }), {};
  }
});
const E8 = B({
  allowedDates: [Array, Function],
  disabled: Boolean,
  displayValue: null,
  modelValue: Array,
  month: [Number, String],
  max: null,
  min: null,
  showAdjacentMonths: Boolean,
  year: [Number, String],
  weekdays: {
    type: Array,
    default: () => [0, 1, 2, 3, 4, 5, 6]
  },
  weeksInMonth: {
    type: String,
    default: "dynamic"
  }
}, "calendar");
function O8(e) {
  const t = Vc(), n = Ee(e, "modelValue", [], (f) => Nt(f)), i = w(() => e.displayValue ? t.date(e.displayValue) : n.value.length > 0 ? t.date(n.value[0]) : e.min ? t.date(e.min) : Array.isArray(e.allowedDates) ? t.date(e.allowedDates[0]) : t.date()), r = Ee(e, "year", void 0, (f) => {
    const h = f != null ? Number(f) : t.getYear(i.value);
    return t.startOfYear(t.setYear(t.date(), h));
  }, (f) => t.getYear(f)), s = Ee(e, "month", void 0, (f) => {
    const h = f != null ? Number(f) : t.getMonth(i.value), m = t.setYear(t.startOfMonth(t.date()), t.getYear(r.value));
    return t.setMonth(m, h);
  }, (f) => t.getMonth(f)), a = w(() => {
    const f = t.getWeekArray(s.value), h = f.flat(), m = 6 * 7;
    if (e.weeksInMonth === "static" && h.length < m) {
      const g = h[h.length - 1];
      let p = [];
      for (let y = 1; y <= m - h.length; y++)
        p.push(t.addDays(g, y)), y % 7 === 0 && (f.push(p), p = []);
    }
    return f;
  });
  function o(f, h) {
    return f.filter((m) => e.weekdays.includes(t.toJsDate(m).getDay())).map((m, g) => {
      const p = t.toISO(m), y = !t.isSameMonth(m, s.value), k = t.isSameDay(m, t.startOfMonth(s.value)), T = t.isSameDay(m, t.endOfMonth(s.value)), _ = t.isSameDay(m, s.value);
      return {
        date: m,
        isoDate: p,
        formatted: t.format(m, "keyboardDate"),
        year: t.getYear(m),
        month: t.getMonth(m),
        isDisabled: d(m),
        isWeekStart: g % 7 === 0,
        isWeekEnd: g % 7 === 6,
        isToday: t.isSameDay(m, h),
        isAdjacent: y,
        isHidden: y && !e.showAdjacentMonths,
        isStart: k,
        isSelected: n.value.some((b) => t.isSameDay(m, b)),
        isEnd: T,
        isSame: _,
        localized: t.format(m, "dayOfMonth")
      };
    });
  }
  const l = w(() => {
    const f = t.startOfWeek(i.value), h = [];
    for (let g = 0; g <= 6; g++)
      h.push(t.addDays(f, g));
    const m = t.date();
    return o(h, m);
  }), u = w(() => {
    const f = a.value.flat(), h = t.date();
    return o(f, h);
  }), c = w(() => a.value.map((f) => f.length ? yV(t, f[0]) : null));
  function d(f) {
    if (e.disabled)
      return !0;
    const h = t.date(f);
    return e.min && t.isAfter(t.date(e.min), h) || e.max && t.isAfter(h, t.date(e.max)) ? !0 : Array.isArray(e.allowedDates) && e.allowedDates.length > 0 ? !e.allowedDates.some((m) => t.isSameDay(t.date(m), h)) : typeof e.allowedDates == "function" ? !e.allowedDates(h) : !1;
  }
  return {
    displayValue: i,
    daysInMonth: u,
    daysInWeek: l,
    genDays: o,
    model: n,
    weeksInMonth: a,
    weekNumbers: c
  };
}
const TI = B({
  color: String,
  hideWeekdays: Boolean,
  multiple: [Boolean, Number, String],
  showWeek: Boolean,
  transition: {
    type: String,
    default: "picker-transition"
  },
  reverseTransition: {
    type: String,
    default: "picker-reverse-transition"
  },
  ...E8()
}, "VDatePickerMonth"), qg = J()({
  name: "VDatePickerMonth",
  props: TI(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:month": (e) => !0,
    "update:year": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const r = X(), {
      daysInMonth: s,
      model: a,
      weekNumbers: o
    } = O8(e), l = Vc(), u = pe(), c = pe(), d = pe(!1), f = w(() => d.value ? e.reverseTransition : e.transition);
    e.multiple === "range" && a.value.length > 0 && (u.value = a.value[0], a.value.length > 1 && (c.value = a.value[a.value.length - 1]));
    const h = w(() => {
      const y = ["number", "string"].includes(typeof e.multiple) ? Number(e.multiple) : 1 / 0;
      return a.value.length >= y;
    });
    fe(s, (y, k) => {
      k && (d.value = l.isBefore(y[0].date, k[0].date));
    });
    function m(y) {
      const k = l.startOfDay(y);
      if (!u.value)
        u.value = k, a.value = [u.value];
      else if (c.value)
        u.value = y, c.value = void 0, a.value = [u.value];
      else {
        if (l.isSameDay(k, u.value)) {
          u.value = void 0, a.value = [];
          return;
        } else
          l.isBefore(k, u.value) ? (c.value = l.endOfDay(u.value), u.value = k) : c.value = l.endOfDay(k);
        const T = l.getDiff(c.value, u.value, "days"), _ = [u.value];
        for (let b = 1; b < T; b++) {
          const S = l.addDays(u.value, b);
          _.push(S);
        }
        _.push(c.value), a.value = _;
      }
    }
    function g(y) {
      const k = a.value.findIndex((T) => l.isSameDay(T, y));
      if (k === -1)
        a.value = [...a.value, y];
      else {
        const T = [...a.value];
        T.splice(k, 1), a.value = T;
      }
    }
    function p(y) {
      e.multiple === "range" ? m(y) : e.multiple ? g(y) : a.value = [y];
    }
    return () => v("div", {
      class: "v-date-picker-month"
    }, [e.showWeek && v("div", {
      key: "weeks",
      class: "v-date-picker-month__weeks"
    }, [!e.hideWeekdays && v("div", {
      key: "hide-week-days",
      class: "v-date-picker-month__day"
    }, [wr(" ")]), o.value.map((y) => v("div", {
      class: ["v-date-picker-month__day", "v-date-picker-month__day--adjacent"]
    }, [y]))]), v(Gn, {
      name: f.value
    }, {
      default: () => {
        var y;
        return [v("div", {
          ref: r,
          key: (y = s.value[0].date) == null ? void 0 : y.toString(),
          class: "v-date-picker-month__days"
        }, [!e.hideWeekdays && l.getWeekdays().map((k) => v("div", {
          class: ["v-date-picker-month__day", "v-date-picker-month__weekday"]
        }, [k])), s.value.map((k, T) => {
          const _ = {
            props: {
              onClick: () => p(k.date)
            },
            item: k,
            i: T
          };
          return h.value && !k.isSelected && (k.isDisabled = !0), v("div", {
            class: ["v-date-picker-month__day", {
              "v-date-picker-month__day--adjacent": k.isAdjacent,
              "v-date-picker-month__day--hide-adjacent": k.isHidden,
              "v-date-picker-month__day--selected": k.isSelected,
              "v-date-picker-month__day--week-end": k.isWeekEnd,
              "v-date-picker-month__day--week-start": k.isWeekStart
            }],
            "data-v-date": k.isDisabled ? void 0 : k.isoDate
          }, [(e.showAdjacentMonths || !k.isAdjacent) && v(Ze, {
            defaults: {
              VBtn: {
                class: "v-date-picker-month__day-btn",
                color: (k.isSelected || k.isToday) && !k.isDisabled ? e.color : void 0,
                disabled: k.isDisabled,
                icon: !0,
                ripple: !1,
                text: k.localized,
                variant: k.isDisabled ? k.isToday ? "outlined" : "text" : k.isToday && !k.isSelected ? "outlined" : "flat",
                onClick: () => p(k.date)
              }
            }
          }, {
            default: () => {
              var b;
              return [((b = i.day) == null ? void 0 : b.call(i, _)) ?? v(st, _.props, null)];
            }
          })]);
        })])];
      }
    })]);
  }
});
const xI = B({
  color: String,
  height: [String, Number],
  min: null,
  max: null,
  modelValue: Number,
  year: Number
}, "VDatePickerMonths"), Gg = J()({
  name: "VDatePickerMonths",
  props: xI(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const r = Vc(), s = Ee(e, "modelValue"), a = w(() => {
      let o = r.startOfYear(r.date());
      return e.year && (o = r.setYear(o, e.year)), jr(12).map((l) => {
        const u = r.format(o, "monthShort"), c = !!(e.min && r.isAfter(r.startOfMonth(r.date(e.min)), o) || e.max && r.isAfter(o, r.startOfMonth(r.date(e.max))));
        return o = r.getNextMonth(o), {
          isDisabled: c,
          text: u,
          value: l
        };
      });
    });
    return Wt(() => {
      s.value = s.value ?? r.getMonth(r.date());
    }), ie(() => v("div", {
      class: "v-date-picker-months",
      style: {
        height: _e(e.height)
      }
    }, [v("div", {
      class: "v-date-picker-months__content"
    }, [a.value.map((o, l) => {
      var d;
      const u = {
        active: s.value === l,
        color: s.value === l ? e.color : void 0,
        disabled: o.isDisabled,
        rounded: !0,
        text: o.text,
        variant: s.value === o.value ? "flat" : "text",
        onClick: () => c(l)
      };
      function c(f) {
        if (s.value === f) {
          n("update:modelValue", s.value);
          return;
        }
        s.value = f;
      }
      return ((d = i.month) == null ? void 0 : d.call(i, {
        month: o,
        i: l,
        props: u
      })) ?? v(st, se({
        key: "month"
      }, u), null);
    })])])), {};
  }
});
const AI = B({
  color: String,
  height: [String, Number],
  min: null,
  max: null,
  modelValue: Number
}, "VDatePickerYears"), Yg = J()({
  name: "VDatePickerYears",
  props: AI(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const r = Vc(), s = Ee(e, "modelValue"), a = w(() => {
      const l = r.getYear(r.date());
      let u = l - 100, c = l + 52;
      e.min && (u = r.getYear(r.date(e.min))), e.max && (c = r.getYear(r.date(e.max)));
      let d = r.startOfYear(r.date());
      return d = r.setYear(d, u), jr(c - u + 1, u).map((f) => {
        const h = r.format(d, "year");
        return d = r.setYear(d, r.getYear(d) + 1), {
          text: h,
          value: f
        };
      });
    });
    Wt(() => {
      s.value = s.value ?? r.getYear(r.date());
    });
    const o = uf();
    return jn(async () => {
      var l;
      await He(), (l = o.el) == null || l.scrollIntoView({
        block: "center"
      });
    }), ie(() => v("div", {
      class: "v-date-picker-years",
      style: {
        height: _e(e.height)
      }
    }, [v("div", {
      class: "v-date-picker-years__content"
    }, [a.value.map((l, u) => {
      var d;
      const c = {
        ref: s.value === l.value ? o : void 0,
        active: s.value === l.value,
        color: s.value === l.value ? e.color : void 0,
        rounded: !0,
        text: l.text,
        variant: s.value === l.value ? "flat" : "text",
        onClick: () => {
          if (s.value === l.value) {
            n("update:modelValue", s.value);
            return;
          }
          s.value = l.value;
        }
      };
      return ((d = i.year) == null ? void 0 : d.call(i, {
        year: l,
        i: u,
        props: c
      })) ?? v(st, se({
        key: "month"
      }, c), null);
    })])])), {};
  }
});
const P8 = Yr("v-picker-title"), II = B({
  bgColor: String,
  landscape: Boolean,
  title: String,
  hideHeader: Boolean,
  ...dm()
}, "VPicker"), $_ = J()({
  name: "VPicker",
  props: II(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: r
    } = gt(G(e, "color"));
    return ie(() => {
      const s = ho.filterProps(e), a = !!(e.title || n.title);
      return v(ho, se(s, {
        color: e.bgColor,
        class: ["v-picker", {
          "v-picker--landscape": e.landscape,
          "v-picker--with-actions": !!n.actions
        }, e.class],
        style: e.style
      }), {
        default: () => {
          var o;
          return [!e.hideHeader && v("div", {
            key: "header",
            class: [i.value],
            style: [r.value]
          }, [a && v(P8, {
            key: "picker-title"
          }, {
            default: () => {
              var l;
              return [((l = n.title) == null ? void 0 : l.call(n)) ?? e.title];
            }
          }), n.header && v("div", {
            class: "v-picker__header"
          }, [n.header()])]), v("div", {
            class: "v-picker__body"
          }, [(o = n.default) == null ? void 0 : o.call(n)]), n.actions && v(Ze, {
            defaults: {
              VBtn: {
                slim: !0,
                variant: "text"
              }
            }
          }, {
            default: () => [v("div", {
              class: "v-picker__actions"
            }, [n.actions()])]
          })];
        }
      });
    }), {};
  }
}), V8 = B({
  // TODO: implement in v3.5
  // calendarIcon: {
  //   type: String,
  //   default: '$calendar',
  // },
  // keyboardIcon: {
  //   type: String,
  //   default: '$edit',
  // },
  // inputMode: {
  //   type: String as PropType<'calendar' | 'keyboard'>,
  //   default: 'calendar',
  // },
  // inputText: {
  //   type: String,
  //   default: '$vuetify.datePicker.input.placeholder',
  // },
  // inputPlaceholder: {
  //   type: String,
  //   default: 'dd/mm/yyyy',
  // },
  header: {
    type: String,
    default: "$vuetify.datePicker.header"
  },
  ...CI(),
  ...TI({
    weeksInMonth: "static"
  }),
  ...sn(xI(), ["modelValue"]),
  ...sn(AI(), ["modelValue"]),
  ...II({
    title: "$vuetify.datePicker.title"
  }),
  modelValue: null
}, "VDatePicker"), D8 = J()({
  name: "VDatePicker",
  props: V8(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:month": (e) => !0,
    "update:year": (e) => !0,
    // 'update:inputMode': (date: any) => true,
    "update:viewMode": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const r = Vc(), {
      t: s
    } = qt(), a = Ee(e, "modelValue", void 0, (A) => Nt(A), (A) => e.multiple ? A : A[0]), o = Ee(e, "viewMode"), l = w(() => {
      var I;
      const A = r.date((I = a.value) == null ? void 0 : I[0]);
      return A && r.isValid(A) ? A : r.date();
    }), u = X(Number(e.month ?? r.getMonth(r.startOfMonth(l.value)))), c = X(Number(e.year ?? r.getYear(r.startOfYear(r.setMonth(l.value, u.value))))), d = pe(!1), f = w(() => e.multiple && a.value.length > 1 ? s("$vuetify.datePicker.itemsSelected", a.value.length) : a.value[0] && r.isValid(a.value[0]) ? r.format(r.date(a.value[0]), "normalDateWithWeekday") : s(e.header)), h = w(() => {
      let A = r.date();
      return A = r.setDate(A, 1), A = r.setMonth(A, u.value), A = r.setYear(A, c.value), r.format(A, "monthAndYear");
    }), m = w(() => `date-picker-header${d.value ? "-reverse" : ""}-transition`), g = w(() => {
      const A = r.date(e.min);
      return e.min && r.isValid(A) ? A : null;
    }), p = w(() => {
      const A = r.date(e.max);
      return e.max && r.isValid(A) ? A : null;
    }), y = w(() => {
      if (e.disabled)
        return !0;
      const A = [];
      if (o.value !== "month")
        A.push("prev", "next");
      else {
        let I = r.date();
        if (I = r.setYear(I, c.value), I = r.setMonth(I, u.value), g.value) {
          const E = r.addDays(r.startOfMonth(I), -1);
          r.isAfter(g.value, E) && A.push("prev");
        }
        if (p.value) {
          const E = r.addDays(r.endOfMonth(I), 1);
          r.isAfter(E, p.value) && A.push("next");
        }
      }
      return A;
    });
    function k() {
      u.value < 11 ? u.value++ : (c.value++, u.value = 0, x(c.value)), C(u.value);
    }
    function T() {
      u.value > 0 ? u.value-- : (c.value--, u.value = 11, x(c.value)), C(u.value);
    }
    function _() {
      o.value = "month";
    }
    function b() {
      o.value = o.value === "months" ? "month" : "months";
    }
    function S() {
      o.value = o.value === "year" ? "month" : "year";
    }
    function C(A) {
      o.value === "months" && b(), n("update:month", A);
    }
    function x(A) {
      o.value === "year" && S(), n("update:year", A);
    }
    return fe(a, (A, I) => {
      const E = r.date(Nt(I)[I.length - 1]), O = r.date(Nt(A)[A.length - 1]), V = r.getMonth(O), N = r.getYear(O);
      V !== u.value && (u.value = V, C(u.value)), N !== c.value && (c.value = N, x(c.value)), d.value = r.isBefore(E, O);
    }), ie(() => {
      const A = $_.filterProps(e), I = zg.filterProps(e), E = Ug.filterProps(e), O = qg.filterProps(e), V = sn(Gg.filterProps(e), ["modelValue"]), N = sn(Yg.filterProps(e), ["modelValue"]), F = {
        header: f.value,
        transition: m.value
      };
      return v($_, se(A, {
        class: ["v-date-picker", `v-date-picker--${o.value}`, {
          "v-date-picker--show-week": e.showWeek
        }, e.class],
        style: e.style
      }), {
        title: () => {
          var $;
          return (($ = i.title) == null ? void 0 : $.call(i)) ?? v("div", {
            class: "v-date-picker__title"
          }, [s(e.title)]);
        },
        header: () => i.header ? v(Ze, {
          defaults: {
            VDatePickerHeader: {
              ...F
            }
          }
        }, {
          default: () => {
            var $;
            return [($ = i.header) == null ? void 0 : $.call(i, F)];
          }
        }) : v(Ug, se({
          key: "header"
        }, E, F, {
          onClick: o.value !== "month" ? _ : void 0
        }), {
          ...i,
          default: void 0
        }),
        default: () => v(De, null, [v(zg, se(I, {
          disabled: y.value,
          text: h.value,
          "onClick:next": k,
          "onClick:prev": T,
          "onClick:month": b,
          "onClick:year": S
        }), null), v(zu, {
          hideOnLeave: !0
        }, {
          default: () => [o.value === "months" ? v(Gg, se({
            key: "date-picker-months"
          }, V, {
            modelValue: u.value,
            "onUpdate:modelValue": [($) => u.value = $, C],
            min: g.value,
            max: p.value,
            year: c.value
          }), null) : o.value === "year" ? v(Yg, se({
            key: "date-picker-years"
          }, N, {
            modelValue: c.value,
            "onUpdate:modelValue": [($) => c.value = $, x],
            min: g.value,
            max: p.value
          }), null) : v(qg, se({
            key: "date-picker-month"
          }, O, {
            modelValue: a.value,
            "onUpdate:modelValue": ($) => a.value = $,
            month: u.value,
            "onUpdate:month": [($) => u.value = $, C],
            year: c.value,
            "onUpdate:year": [($) => c.value = $, x],
            min: g.value,
            max: p.value
          }), null)]
        })]),
        actions: i.actions
      });
    }), {};
  }
});
const N8 = B({
  actionText: String,
  bgColor: String,
  color: String,
  icon: We,
  image: String,
  justify: {
    type: String,
    default: "center"
  },
  headline: String,
  title: String,
  text: String,
  textWidth: {
    type: [Number, String],
    default: 500
  },
  href: String,
  to: String,
  ...ke(),
  ...wn(),
  ...Kr({
    size: void 0
  }),
  ...Qe()
}, "VEmptyState"), M8 = J()({
  name: "VEmptyState",
  props: N8(),
  emits: {
    "click:action": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const {
      themeClasses: r
    } = lt(e), {
      backgroundColorClasses: s,
      backgroundColorStyles: a
    } = gt(G(e, "bgColor")), {
      dimensionStyles: o
    } = _n(e), {
      displayClasses: l
    } = xr();
    function u(c) {
      n("click:action", c);
    }
    return ie(() => {
      var p, y, k;
      const c = !!(i.actions || e.actionText), d = !!(i.headline || e.headline), f = !!(i.title || e.title), h = !!(i.text || e.text), m = !!(i.media || e.image || e.icon), g = e.size || (e.image ? 200 : 96);
      return v("div", {
        class: ["v-empty-state", {
          [`v-empty-state--${e.justify}`]: !0
        }, r.value, s.value, l.value, e.class],
        style: [a.value, o.value, e.style]
      }, [m && v("div", {
        key: "media",
        class: "v-empty-state__media"
      }, [i.media ? v(Ze, {
        key: "media-defaults",
        defaults: {
          VImg: {
            src: e.image,
            height: g
          },
          VIcon: {
            size: g,
            icon: e.icon
          }
        }
      }, {
        default: () => [i.media()]
      }) : v(De, null, [e.image ? v(_s, {
        key: "image",
        src: e.image,
        height: g
      }, null) : e.icon ? v(at, {
        key: "icon",
        color: e.color,
        size: g,
        icon: e.icon
      }, null) : void 0])]), d && v("div", {
        key: "headline",
        class: "v-empty-state__headline"
      }, [((p = i.headline) == null ? void 0 : p.call(i)) ?? e.headline]), f && v("div", {
        key: "title",
        class: "v-empty-state__title"
      }, [((y = i.title) == null ? void 0 : y.call(i)) ?? e.title]), h && v("div", {
        key: "text",
        class: "v-empty-state__text",
        style: {
          maxWidth: _e(e.textWidth)
        }
      }, [((k = i.text) == null ? void 0 : k.call(i)) ?? e.text]), i.default && v("div", {
        key: "content",
        class: "v-empty-state__content"
      }, [i.default()]), c && v("div", {
        key: "actions",
        class: "v-empty-state__actions"
      }, [v(Ze, {
        defaults: {
          VBtn: {
            class: "v-empty-state__action-btn",
            color: e.color,
            text: e.actionText
          }
        }
      }, {
        default: () => {
          var T;
          return [((T = i.actions) == null ? void 0 : T.call(i, {
            props: {
              onClick: u
            }
          })) ?? v(st, {
            onClick: u
          }, null)];
        }
      })])]);
    }), {};
  }
});
const EI = B({
  ...ke(),
  ...sb()
}, "VExpansionPanelText"), Zg = J()({
  name: "VExpansionPanelText",
  props: EI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = tt(Tc);
    if (!i)
      throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
    const {
      hasContent: r,
      onAfterLeave: s
    } = ab(e, i.isSelected);
    return ie(() => v(fh, {
      onAfterLeave: s
    }, {
      default: () => {
        var a;
        return [Rt(v("div", {
          class: ["v-expansion-panel-text", e.class],
          style: e.style
        }, [n.default && r.value && v("div", {
          class: "v-expansion-panel-text__wrapper"
        }, [(a = n.default) == null ? void 0 : a.call(n)])]), [[Cr, i.isSelected.value]])];
      }
    })), {};
  }
}), OI = B({
  color: String,
  expandIcon: {
    type: We,
    default: "$expand"
  },
  collapseIcon: {
    type: We,
    default: "$collapse"
  },
  hideActions: Boolean,
  focusable: Boolean,
  static: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: !1
  },
  readonly: Boolean,
  ...ke()
}, "VExpansionPanelTitle"), Kg = J()({
  name: "VExpansionPanelTitle",
  directives: {
    Ripple: Os
  },
  props: OI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = tt(Tc);
    if (!i)
      throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
    const {
      backgroundColorClasses: r,
      backgroundColorStyles: s
    } = gt(e, "color"), a = w(() => ({
      collapseIcon: e.collapseIcon,
      disabled: i.disabled.value,
      expanded: i.isSelected.value,
      expandIcon: e.expandIcon,
      readonly: e.readonly
    }));
    return ie(() => {
      var o;
      return Rt(v("button", {
        class: ["v-expansion-panel-title", {
          "v-expansion-panel-title--active": i.isSelected.value,
          "v-expansion-panel-title--focusable": e.focusable,
          "v-expansion-panel-title--static": e.static
        }, r.value, e.class],
        style: [s.value, e.style],
        type: "button",
        tabindex: i.disabled.value ? -1 : void 0,
        disabled: i.disabled.value,
        "aria-expanded": i.isSelected.value,
        onClick: e.readonly ? void 0 : i.toggle
      }, [v("span", {
        class: "v-expansion-panel-title__overlay"
      }, null), (o = n.default) == null ? void 0 : o.call(n, a.value), !e.hideActions && v("span", {
        class: "v-expansion-panel-title__icon"
      }, [n.actions ? n.actions(a.value) : v(at, {
        icon: i.isSelected.value ? e.collapseIcon : e.expandIcon
      }, null)])]), [[Ei("ripple"), e.ripple]]);
    }), {};
  }
}), PI = B({
  title: String,
  text: String,
  bgColor: String,
  ...mn(),
  ...Oo(),
  ...It(),
  ...je(),
  ...OI(),
  ...EI()
}, "VExpansionPanel"), R8 = J()({
  name: "VExpansionPanel",
  props: PI(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Po(e, Tc), {
      backgroundColorClasses: r,
      backgroundColorStyles: s
    } = gt(e, "bgColor"), {
      elevationClasses: a
    } = In(e), {
      roundedClasses: o
    } = Ht(e), l = w(() => (i == null ? void 0 : i.disabled.value) || e.disabled), u = w(() => i.group.items.value.reduce((f, h, m) => (i.group.selected.value.includes(h.id) && f.push(m), f), [])), c = w(() => {
      const f = i.group.items.value.findIndex((h) => h.id === i.id);
      return !i.isSelected.value && u.value.some((h) => h - f === 1);
    }), d = w(() => {
      const f = i.group.items.value.findIndex((h) => h.id === i.id);
      return !i.isSelected.value && u.value.some((h) => h - f === -1);
    });
    return Tt(Tc, i), ie(() => {
      const f = !!(n.text || e.text), h = !!(n.title || e.title), m = Kg.filterProps(e), g = Zg.filterProps(e);
      return v(e.tag, {
        class: ["v-expansion-panel", {
          "v-expansion-panel--active": i.isSelected.value,
          "v-expansion-panel--before-active": c.value,
          "v-expansion-panel--after-active": d.value,
          "v-expansion-panel--disabled": l.value
        }, o.value, r.value, e.class],
        style: [s.value, e.style]
      }, {
        default: () => {
          var p;
          return [v("div", {
            class: ["v-expansion-panel__shadow", ...a.value]
          }, null), h && v(Kg, se({
            key: "title"
          }, m), {
            default: () => [n.title ? n.title() : e.title]
          }), f && v(Zg, se({
            key: "text"
          }, g), {
            default: () => [n.text ? n.text() : e.text]
          }), (p = n.default) == null ? void 0 : p.call(n)];
        }
      });
    }), {
      groupItem: i
    };
  }
}), Tc = Symbol.for("vuetify:v-expansion-panel"), F8 = ["default", "accordion", "inset", "popout"], B8 = B({
  flat: Boolean,
  ...Eo(),
  ...PI(),
  ...Qe(),
  variant: {
    type: String,
    default: "default",
    validator: (e) => F8.includes(e)
  }
}, "VExpansionPanels"), L8 = J()({
  name: "VExpansionPanels",
  props: B8(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      next: i,
      prev: r
    } = ha(e, Tc), {
      themeClasses: s
    } = lt(e), a = w(() => e.variant && `v-expansion-panels--variant-${e.variant}`);
    return jt({
      VExpansionPanel: {
        bgColor: G(e, "bgColor"),
        collapseIcon: G(e, "collapseIcon"),
        color: G(e, "color"),
        eager: G(e, "eager"),
        elevation: G(e, "elevation"),
        expandIcon: G(e, "expandIcon"),
        focusable: G(e, "focusable"),
        hideActions: G(e, "hideActions"),
        readonly: G(e, "readonly"),
        ripple: G(e, "ripple"),
        rounded: G(e, "rounded"),
        static: G(e, "static")
      }
    }), ie(() => v(e.tag, {
      class: ["v-expansion-panels", {
        "v-expansion-panels--flat": e.flat,
        "v-expansion-panels--tile": e.tile
      }, s.value, a.value, e.class],
      style: e.style
    }, {
      default: () => {
        var o;
        return [(o = n.default) == null ? void 0 : o.call(n, {
          prev: r,
          next: i
        })];
      }
    })), {
      next: i,
      prev: r
    };
  }
});
const $8 = B({
  app: Boolean,
  appear: Boolean,
  extended: Boolean,
  layout: Boolean,
  location: {
    type: String,
    default: "bottom end"
  },
  offset: Boolean,
  modelValue: {
    type: Boolean,
    default: !0
  },
  ...sn(sm({
    active: !0
  }), ["location"]),
  ...yo(),
  ...Tr({
    transition: "fab-transition"
  })
}, "VFab"), W8 = J()({
  name: "VFab",
  props: $8(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), r = pe(56), s = X(), {
      resizeRef: a
    } = _r((d) => {
      d.length && (r.value = d[0].target.clientHeight);
    }), o = w(() => e.app || e.absolute), l = w(() => o.value ? e.location.split(" ").shift() : !1), u = w(() => o.value ? e.location.split(" ")[1] ?? "end" : !1);
    vi(() => e.app, () => {
      const d = bo({
        id: e.name,
        order: w(() => parseInt(e.order, 10)),
        position: l,
        layoutSize: w(() => e.layout ? r.value + 24 : 0),
        elementSize: w(() => r.value + 24),
        active: w(() => e.app && i.value),
        absolute: G(e, "absolute")
      });
      Wt(() => {
        s.value = d.layoutItemStyles.value;
      });
    });
    const c = X();
    return ie(() => {
      const d = st.filterProps(e);
      return v("div", {
        ref: c,
        class: ["v-fab", {
          "v-fab--absolute": e.absolute,
          "v-fab--app": !!e.app,
          "v-fab--extended": e.extended,
          "v-fab--offset": e.offset,
          [`v-fab--${l.value}`]: o.value,
          [`v-fab--${u.value}`]: o.value
        }, e.class],
        style: [e.app ? {
          ...s.value
        } : {
          height: "inherit",
          width: void 0
        }, e.style]
      }, [v("div", {
        class: "v-fab__container"
      }, [v(Gn, {
        appear: e.appear,
        transition: e.transition
      }, {
        default: () => [Rt(v(st, se({
          ref: a
        }, d, {
          active: void 0,
          location: void 0
        }), n), [[Cr, e.active]])]
      })])]);
    }), {};
  }
});
const j8 = B({
  chips: Boolean,
  counter: Boolean,
  counterSizeString: {
    type: String,
    default: "$vuetify.fileInput.counterSize"
  },
  counterString: {
    type: String,
    default: "$vuetify.fileInput.counter"
  },
  hideInput: Boolean,
  multiple: Boolean,
  showSize: {
    type: [Boolean, Number, String],
    default: !1,
    validator: (e) => typeof e == "boolean" || [1e3, 1024].includes(Number(e))
  },
  ...Ts({
    prependIcon: "$file"
  }),
  modelValue: {
    type: [Array, Object],
    default: (e) => e.multiple ? [] : null,
    validator: (e) => Nt(e).every((t) => t != null && typeof t == "object")
  },
  ...Oc({
    clearable: !0
  })
}, "VFileInput"), H8 = J()({
  name: "VFileInput",
  inheritAttrs: !1,
  props: j8(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const {
      t: s
    } = qt(), a = Ee(e, "modelValue", e.modelValue, (A) => Nt(A), (A) => e.multiple || Array.isArray(e.modelValue) ? A : A[0] ?? null), {
      isFocused: o,
      focus: l,
      blur: u
    } = Cs(e), c = w(() => typeof e.showSize != "boolean" ? e.showSize : void 0), d = w(() => (a.value ?? []).reduce((A, I) => {
      let {
        size: E = 0
      } = I;
      return A + E;
    }, 0)), f = w(() => qb(d.value, c.value)), h = w(() => (a.value ?? []).map((A) => {
      const {
        name: I = "",
        size: E = 0
      } = A;
      return e.showSize ? `${I} (${qb(E, c.value)})` : I;
    })), m = w(() => {
      var I;
      const A = ((I = a.value) == null ? void 0 : I.length) ?? 0;
      return e.showSize ? s(e.counterSizeString, A, f.value) : s(e.counterString, A);
    }), g = X(), p = X(), y = X(), k = w(() => o.value || e.active), T = w(() => ["plain", "underlined"].includes(e.variant));
    function _() {
      var A;
      y.value !== document.activeElement && ((A = y.value) == null || A.focus()), o.value || l();
    }
    function b(A) {
      var I;
      (I = y.value) == null || I.click();
    }
    function S(A) {
      i("mousedown:control", A);
    }
    function C(A) {
      var I;
      (I = y.value) == null || I.click(), i("click:control", A);
    }
    function x(A) {
      A.stopPropagation(), _(), He(() => {
        a.value = [], rp(e["onClick:clear"], A);
      });
    }
    return fe(a, (A) => {
      (!Array.isArray(A) || !A.length) && y.value && (y.value.value = "");
    }), ie(() => {
      const A = !!(r.counter || e.counter), I = !!(A || r.details), [E, O] = la(n), {
        modelValue: V,
        ...N
      } = $n.filterProps(e), F = yp(e);
      return v($n, se({
        ref: g,
        modelValue: a.value,
        "onUpdate:modelValue": ($) => a.value = $,
        class: ["v-file-input", {
          "v-file-input--chips": !!e.chips,
          "v-file-input--hide": e.hideInput,
          "v-input--plain-underlined": T.value
        }, e.class],
        style: e.style,
        "onClick:prepend": b
      }, E, N, {
        centerAffix: !T.value,
        focused: o.value
      }), {
        ...r,
        default: ($) => {
          let {
            id: Z,
            isDisabled: j,
            isDirty: H,
            isReadonly: R,
            isValid: L
          } = $;
          return v(Bl, se({
            ref: p,
            "prepend-icon": e.prependIcon,
            onMousedown: S,
            onClick: C,
            "onClick:clear": x,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"]
          }, F, {
            id: Z.value,
            active: k.value || H.value,
            dirty: H.value || e.dirty,
            disabled: j.value,
            focused: o.value,
            error: L.value === !1
          }), {
            ...r,
            default: (ne) => {
              var ee;
              let {
                props: {
                  class: oe,
                  ...we
                }
              } = ne;
              return v(De, null, [v("input", se({
                ref: y,
                type: "file",
                readonly: R.value,
                disabled: j.value,
                multiple: e.multiple,
                name: e.name,
                onClick: (K) => {
                  K.stopPropagation(), R.value && K.preventDefault(), _();
                },
                onChange: (K) => {
                  if (!K.target)
                    return;
                  const ue = K.target;
                  a.value = [...ue.files ?? []];
                },
                onFocus: _,
                onBlur: u
              }, we, O), null), v("div", {
                class: oe
              }, [!!((ee = a.value) != null && ee.length) && !e.hideInput && (r.selection ? r.selection({
                fileNames: h.value,
                totalBytes: d.value,
                totalBytesReadable: f.value
              }) : e.chips ? h.value.map((K) => v(ru, {
                key: K,
                size: "small",
                text: K
              }, null)) : h.value.join(", "))])]);
            }
          });
        },
        details: I ? ($) => {
          var Z, j;
          return v(De, null, [(Z = r.details) == null ? void 0 : Z.call(r, $), A && v(De, null, [v("span", null, null), v(hh, {
            active: !!((j = a.value) != null && j.length),
            value: m.value,
            disabled: e.disabled
          }, r.counter)])]);
        } : void 0
      });
    }), Qi({}, g, p, y);
  }
});
const z8 = B({
  app: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: "auto"
  },
  ...Ni(),
  ...ke(),
  ...mn(),
  ...yo(),
  ...It(),
  ...je({
    tag: "footer"
  }),
  ...Qe()
}, "VFooter"), U8 = J()({
  name: "VFooter",
  props: z8(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      backgroundColorClasses: r,
      backgroundColorStyles: s
    } = gt(G(e, "color")), {
      borderClasses: a
    } = er(e), {
      elevationClasses: o
    } = In(e), {
      roundedClasses: l
    } = Ht(e), u = pe(32), {
      resizeRef: c
    } = _r((m) => {
      m.length && (u.value = m[0].target.clientHeight);
    }), d = w(() => e.height === "auto" ? u.value : parseInt(e.height, 10)), {
      layoutItemStyles: f,
      layoutIsReady: h
    } = bo({
      id: e.name,
      order: w(() => parseInt(e.order, 10)),
      position: w(() => "bottom"),
      layoutSize: d,
      elementSize: w(() => e.height === "auto" ? void 0 : d.value),
      active: w(() => e.app),
      absolute: G(e, "absolute")
    });
    return ie(() => v(e.tag, {
      ref: c,
      class: ["v-footer", i.value, r.value, a.value, o.value, l.value, e.class],
      style: [s.value, e.app ? f.value : {
        height: _e(e.height)
      }, e.style]
    }, n)), e.app ? h : {};
  }
}), q8 = B({
  ...ke(),
  ...EP()
}, "VForm"), G8 = J()({
  name: "VForm",
  props: q8(),
  emits: {
    "update:modelValue": (e) => !0,
    submit: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const r = OP(e), s = X();
    function a(l) {
      l.preventDefault(), r.reset();
    }
    function o(l) {
      const u = l, c = r.validate();
      u.then = c.then.bind(c), u.catch = c.catch.bind(c), u.finally = c.finally.bind(c), i("submit", u), u.defaultPrevented || c.then((d) => {
        var h;
        let {
          valid: f
        } = d;
        f && ((h = s.value) == null || h.submit());
      }), u.preventDefault();
    }
    return ie(() => {
      var l;
      return v("form", {
        ref: s,
        class: ["v-form", e.class],
        style: e.style,
        novalidate: !0,
        onReset: a,
        onSubmit: o
      }, [(l = n.default) == null ? void 0 : l.call(n, r)]);
    }), Qi(r, s);
  }
}), Y8 = B({
  disabled: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  ...ib()
}, "VHover"), Z8 = J()({
  name: "VHover",
  props: Y8(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), {
      runOpenDelay: r,
      runCloseDelay: s
    } = rb(e, (a) => !e.disabled && (i.value = a));
    return () => {
      var a;
      return (a = n.default) == null ? void 0 : a.call(n, {
        isHovering: i.value,
        props: {
          onMouseenter: r,
          onMouseleave: s
        }
      });
    };
  }
});
const K8 = B({
  color: String,
  direction: {
    type: String,
    default: "vertical",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  side: {
    type: String,
    default: "end",
    validator: (e) => ["start", "end", "both"].includes(e)
  },
  mode: {
    type: String,
    default: "intersect",
    validator: (e) => ["intersect", "manual"].includes(e)
  },
  margin: [Number, String],
  loadMoreText: {
    type: String,
    default: "$vuetify.infiniteScroll.loadMore"
  },
  emptyText: {
    type: String,
    default: "$vuetify.infiniteScroll.empty"
  },
  ...wn(),
  ...je()
}, "VInfiniteScroll"), W_ = Oi({
  name: "VInfiniteScrollIntersect",
  props: {
    side: {
      type: String,
      required: !0
    },
    rootRef: null,
    rootMargin: String
  },
  emits: {
    intersect: (e, t) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const {
      intersectionRef: i,
      isIntersecting: r
    } = vh((s) => {
    }, e.rootMargin ? {
      rootMargin: e.rootMargin
    } : void 0);
    return fe(r, async (s) => {
      n("intersect", e.side, s);
    }), ie(() => v("div", {
      class: "v-infinite-scroll-intersect",
      ref: i
    }, [wr(" ")])), {};
  }
}), X8 = J()({
  name: "VInfiniteScroll",
  props: K8(),
  emits: {
    load: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const r = X(), s = pe("ok"), a = pe("ok"), o = w(() => _e(e.margin)), l = pe(!1);
    function u(b) {
      if (!r.value)
        return;
      const S = e.direction === "vertical" ? "scrollTop" : "scrollLeft";
      r.value[S] = b;
    }
    function c() {
      if (!r.value)
        return 0;
      const b = e.direction === "vertical" ? "scrollTop" : "scrollLeft";
      return r.value[b];
    }
    function d() {
      if (!r.value)
        return 0;
      const b = e.direction === "vertical" ? "scrollHeight" : "scrollWidth";
      return r.value[b];
    }
    function f() {
      if (!r.value)
        return 0;
      const b = e.direction === "vertical" ? "clientHeight" : "clientWidth";
      return r.value[b];
    }
    jn(() => {
      r.value && (e.side === "start" ? u(d()) : e.side === "both" && u(d() / 2 - f() / 2));
    });
    function h(b, S) {
      b === "start" ? s.value = S : b === "end" && (a.value = S);
    }
    function m(b) {
      return b === "start" ? s.value : a.value;
    }
    let g = 0;
    function p(b, S) {
      l.value = S, l.value && y(b);
    }
    function y(b) {
      if (e.mode !== "manual" && !l.value)
        return;
      const S = m(b);
      if (!r.value || ["empty", "loading"].includes(S))
        return;
      g = d(), h(b, "loading");
      function C(x) {
        h(b, x), He(() => {
          x === "empty" || x === "error" || (x === "ok" && b === "start" && u(d() - g + c()), e.mode !== "manual" && He(() => {
            window.requestAnimationFrame(() => {
              window.requestAnimationFrame(() => {
                window.requestAnimationFrame(() => {
                  y(b);
                });
              });
            });
          }));
        });
      }
      i("load", {
        side: b,
        done: C
      });
    }
    const {
      t: k
    } = qt();
    function T(b, S) {
      var A, I, E, O, V;
      if (e.side !== b && e.side !== "both")
        return;
      const C = () => y(b), x = {
        side: b,
        props: {
          onClick: C,
          color: e.color
        }
      };
      return S === "error" ? (A = n.error) == null ? void 0 : A.call(n, x) : S === "empty" ? ((I = n.empty) == null ? void 0 : I.call(n, x)) ?? v("div", null, [k(e.emptyText)]) : e.mode === "manual" ? S === "loading" ? ((E = n.loading) == null ? void 0 : E.call(n, x)) ?? v(Vl, {
        indeterminate: !0,
        color: e.color
      }, null) : ((O = n["load-more"]) == null ? void 0 : O.call(n, x)) ?? v(st, {
        variant: "outlined",
        color: e.color,
        onClick: C
      }, {
        default: () => [k(e.loadMoreText)]
      }) : ((V = n.loading) == null ? void 0 : V.call(n, x)) ?? v(Vl, {
        indeterminate: !0,
        color: e.color
      }, null);
    }
    const {
      dimensionStyles: _
    } = _n(e);
    ie(() => {
      const b = e.tag, S = e.side === "start" || e.side === "both", C = e.side === "end" || e.side === "both", x = e.mode === "intersect";
      return v(b, {
        ref: r,
        class: ["v-infinite-scroll", `v-infinite-scroll--${e.direction}`, {
          "v-infinite-scroll--start": S,
          "v-infinite-scroll--end": C
        }],
        style: _.value
      }, {
        default: () => {
          var A;
          return [v("div", {
            class: "v-infinite-scroll__side"
          }, [T("start", s.value)]), r.value && S && x && v(W_, {
            key: "start",
            side: "start",
            onIntersect: p,
            rootRef: r.value,
            rootMargin: o.value
          }, null), (A = n.default) == null ? void 0 : A.call(n), r.value && C && x && v(W_, {
            key: "end",
            side: "end",
            onIntersect: p,
            rootRef: r.value,
            rootMargin: o.value
          }, null), v("div", {
            class: "v-infinite-scroll__side"
          }, [T("end", a.value)])];
        }
      });
    });
  }
});
const VI = Symbol.for("vuetify:v-item-group"), J8 = B({
  ...ke(),
  ...Eo({
    selectedClass: "v-item--selected"
  }),
  ...je(),
  ...Qe()
}, "VItemGroup"), Q8 = J()({
  name: "VItemGroup",
  props: J8(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      isSelected: r,
      select: s,
      next: a,
      prev: o,
      selected: l
    } = ha(e, VI);
    return () => v(e.tag, {
      class: ["v-item-group", i.value, e.class],
      style: e.style
    }, {
      default: () => {
        var u;
        return [(u = n.default) == null ? void 0 : u.call(n, {
          isSelected: r,
          select: s,
          next: a,
          prev: o,
          selected: l.value
        })];
      }
    });
  }
}), eY = J()({
  name: "VItem",
  props: Oo(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isSelected: i,
      select: r,
      toggle: s,
      selectedClass: a,
      value: o,
      disabled: l
    } = Po(e, VI);
    return () => {
      var u;
      return (u = n.default) == null ? void 0 : u.call(n, {
        isSelected: i.value,
        selectedClass: a.value,
        select: r,
        toggle: s,
        value: o.value,
        disabled: l.value
      });
    };
  }
});
const tY = Yr("v-kbd");
const nY = B({
  ...ke(),
  ...wn(),
  ...GS()
}, "VLayout"), iY = J()({
  name: "VLayout",
  props: nY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      layoutClasses: i,
      layoutStyles: r,
      getLayoutItem: s,
      items: a,
      layoutRef: o
    } = ZS(e), {
      dimensionStyles: l
    } = _n(e);
    return ie(() => v("div", {
      ref: o,
      class: [i.value, e.class],
      style: [l.value, r.value, e.style]
    }, [v(eS, null, {
      default: () => {
        var u;
        return [v(De, null, [(u = n.default) == null ? void 0 : u.call(n)])];
      }
    })])), {
      getLayoutItem: s,
      items: a
    };
  }
});
const rY = B({
  position: {
    type: String,
    required: !0
  },
  size: {
    type: [Number, String],
    default: 300
  },
  modelValue: Boolean,
  ...ke(),
  ...yo()
}, "VLayoutItem"), sY = J()({
  name: "VLayoutItem",
  props: rY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      layoutItemStyles: i,
      layoutIsReady: r
    } = bo({
      id: e.name,
      order: w(() => parseInt(e.order, 10)),
      position: G(e, "position"),
      elementSize: G(e, "size"),
      layoutSize: G(e, "size"),
      active: G(e, "modelValue"),
      absolute: G(e, "absolute")
    });
    return ie(() => {
      var s;
      return v("div", {
        class: ["v-layout-item", e.class],
        style: [i.value, e.style]
      }, [(s = n.default) == null ? void 0 : s.call(n)]);
    }), r;
  }
}), aY = B({
  modelValue: Boolean,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  ...ke(),
  ...wn(),
  ...je(),
  ...Tr({
    transition: "fade-transition"
  })
}, "VLazy"), oY = J()({
  name: "VLazy",
  directives: {
    intersect: Pc
  },
  props: aY(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      dimensionStyles: i
    } = _n(e), r = Ee(e, "modelValue");
    function s(a) {
      r.value || (r.value = a);
    }
    return ie(() => Rt(v(e.tag, {
      class: ["v-lazy", e.class],
      style: [i.value, e.style]
    }, {
      default: () => [r.value && v(Gn, {
        transition: e.transition,
        appear: !0
      }, {
        default: () => {
          var a;
          return [(a = n.default) == null ? void 0 : a.call(n)];
        }
      })]
    }), [[Ei("intersect"), {
      handler: s,
      options: e.options
    }, null]])), {};
  }
});
const lY = B({
  locale: String,
  fallbackLocale: String,
  messages: Object,
  rtl: {
    type: Boolean,
    default: void 0
  },
  ...ke()
}, "VLocaleProvider"), uY = J()({
  name: "VLocaleProvider",
  props: lY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      rtlClasses: i
    } = _P(e);
    return ie(() => {
      var r;
      return v("div", {
        class: ["v-locale-provider", i.value, e.class],
        style: e.style
      }, [(r = n.default) == null ? void 0 : r.call(n)]);
    }), {};
  }
});
const cY = B({
  scrollable: Boolean,
  ...ke(),
  ...wn(),
  ...je({
    tag: "main"
  })
}, "VMain"), dY = J()({
  name: "VMain",
  props: cY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      dimensionStyles: i
    } = _n(e), {
      mainStyles: r,
      layoutIsReady: s
    } = YS(), {
      ssrBootStyles: a
    } = Ao();
    return ie(() => v(e.tag, {
      class: ["v-main", {
        "v-main--scrollable": e.scrollable
      }, e.class],
      style: [r.value, a.value, i.value, e.style]
    }, {
      default: () => {
        var o, l;
        return [e.scrollable ? v("div", {
          class: "v-main__scroller"
        }, [(o = n.default) == null ? void 0 : o.call(n)]) : (l = n.default) == null ? void 0 : l.call(n)];
      }
    })), s;
  }
});
function fY(e) {
  let {
    rootEl: t,
    isSticky: n,
    layoutItemStyles: i
  } = e;
  const r = pe(!1), s = pe(0), a = w(() => {
    const u = typeof r.value == "boolean" ? "top" : r.value;
    return [n.value ? {
      top: "auto",
      bottom: "auto",
      height: void 0
    } : void 0, r.value ? {
      [u]: _e(s.value)
    } : {
      top: i.value.top
    }];
  });
  jn(() => {
    fe(n, (u) => {
      u ? window.addEventListener("scroll", l, {
        passive: !0
      }) : window.removeEventListener("scroll", l);
    }, {
      immediate: !0
    });
  }), ai(() => {
    window.removeEventListener("scroll", l);
  });
  let o = 0;
  function l() {
    const u = o > window.scrollY ? "up" : "down", c = t.value.getBoundingClientRect(), d = parseFloat(i.value.top ?? 0), f = window.scrollY - Math.max(0, s.value - d), h = c.height + Math.max(s.value, d) - window.scrollY - window.innerHeight, m = parseFloat(getComputedStyle(t.value).getPropertyValue("--v-body-scroll-y")) || 0;
    c.height < window.innerHeight - d ? (r.value = "top", s.value = d) : u === "up" && r.value === "bottom" || u === "down" && r.value === "top" ? (s.value = window.scrollY + c.top - m, r.value = !0) : u === "down" && h <= 0 ? (s.value = 0, r.value = "bottom") : u === "up" && f <= 0 && (m ? r.value !== "top" && (s.value = -f + m + d, r.value = "top") : (s.value = c.top + f, r.value = "top")), o = window.scrollY;
  }
  return {
    isStuck: r,
    stickyStyles: a
  };
}
const hY = 100, mY = 20;
function j_(e) {
  const t = 1.41421356237;
  return (e < 0 ? -1 : 1) * Math.sqrt(Math.abs(e)) * t;
}
function H_(e) {
  if (e.length < 2)
    return 0;
  if (e.length === 2)
    return e[1].t === e[0].t ? 0 : (e[1].d - e[0].d) / (e[1].t - e[0].t);
  let t = 0;
  for (let n = e.length - 1; n > 0; n--) {
    if (e[n].t === e[n - 1].t)
      continue;
    const i = j_(t), r = (e[n].d - e[n - 1].d) / (e[n].t - e[n - 1].t);
    t += (r - i) * Math.abs(r), n === e.length - 1 && (t *= 0.5);
  }
  return j_(t) * 1e3;
}
function vY() {
  const e = {};
  function t(r) {
    Array.from(r.changedTouches).forEach((s) => {
      (e[s.identifier] ?? (e[s.identifier] = new cO(mY))).push([r.timeStamp, s]);
    });
  }
  function n(r) {
    Array.from(r.changedTouches).forEach((s) => {
      delete e[s.identifier];
    });
  }
  function i(r) {
    var u;
    const s = (u = e[r]) == null ? void 0 : u.values().reverse();
    if (!s)
      throw new Error(`No samples for touch id ${r}`);
    const a = s[0], o = [], l = [];
    for (const c of s) {
      if (a[0] - c[0] > hY)
        break;
      o.push({
        t: c[0],
        d: c[1].clientX
      }), l.push({
        t: c[0],
        d: c[1].clientY
      });
    }
    return {
      x: H_(o),
      y: H_(l),
      get direction() {
        const {
          x: c,
          y: d
        } = this, [f, h] = [Math.abs(c), Math.abs(d)];
        return f > h && c >= 0 ? "right" : f > h && c <= 0 ? "left" : h > f && d >= 0 ? "down" : h > f && d <= 0 ? "up" : gY();
      }
    };
  }
  return {
    addMovement: t,
    endTouch: n,
    getVelocity: i
  };
}
function gY() {
  throw new Error();
}
function pY(e) {
  let {
    el: t,
    isActive: n,
    isTemporary: i,
    width: r,
    touchless: s,
    position: a
  } = e;
  jn(() => {
    window.addEventListener("touchstart", k, {
      passive: !0
    }), window.addEventListener("touchmove", T, {
      passive: !1
    }), window.addEventListener("touchend", _, {
      passive: !0
    });
  }), ai(() => {
    window.removeEventListener("touchstart", k), window.removeEventListener("touchmove", T), window.removeEventListener("touchend", _);
  });
  const o = w(() => ["left", "right"].includes(a.value)), {
    addMovement: l,
    endTouch: u,
    getVelocity: c
  } = vY();
  let d = !1;
  const f = pe(!1), h = pe(0), m = pe(0);
  let g;
  function p(S, C) {
    return (a.value === "left" ? S : a.value === "right" ? document.documentElement.clientWidth - S : a.value === "top" ? S : a.value === "bottom" ? document.documentElement.clientHeight - S : Wo()) - (C ? r.value : 0);
  }
  function y(S) {
    let C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const x = a.value === "left" ? (S - m.value) / r.value : a.value === "right" ? (document.documentElement.clientWidth - S - m.value) / r.value : a.value === "top" ? (S - m.value) / r.value : a.value === "bottom" ? (document.documentElement.clientHeight - S - m.value) / r.value : Wo();
    return C ? Math.max(0, Math.min(1, x)) : x;
  }
  function k(S) {
    if (s.value)
      return;
    const C = S.changedTouches[0].clientX, x = S.changedTouches[0].clientY, A = 25, I = a.value === "left" ? C < A : a.value === "right" ? C > document.documentElement.clientWidth - A : a.value === "top" ? x < A : a.value === "bottom" ? x > document.documentElement.clientHeight - A : Wo(), E = n.value && (a.value === "left" ? C < r.value : a.value === "right" ? C > document.documentElement.clientWidth - r.value : a.value === "top" ? x < r.value : a.value === "bottom" ? x > document.documentElement.clientHeight - r.value : Wo());
    (I || E || n.value && i.value) && (g = [C, x], m.value = p(o.value ? C : x, n.value), h.value = y(o.value ? C : x), d = m.value > -20 && m.value < 80, u(S), l(S));
  }
  function T(S) {
    const C = S.changedTouches[0].clientX, x = S.changedTouches[0].clientY;
    if (d) {
      if (!S.cancelable) {
        d = !1;
        return;
      }
      const I = Math.abs(C - g[0]), E = Math.abs(x - g[1]);
      (o.value ? I > E && I > 3 : E > I && E > 3) ? (f.value = !0, d = !1) : (o.value ? E : I) > 3 && (d = !1);
    }
    if (!f.value)
      return;
    S.preventDefault(), l(S);
    const A = y(o.value ? C : x, !1);
    h.value = Math.max(0, Math.min(1, A)), A > 1 ? m.value = p(o.value ? C : x, !0) : A < 0 && (m.value = p(o.value ? C : x, !1));
  }
  function _(S) {
    if (d = !1, !f.value)
      return;
    l(S), f.value = !1;
    const C = c(S.changedTouches[0].identifier), x = Math.abs(C.x), A = Math.abs(C.y);
    (o.value ? x > A && x > 400 : A > x && A > 3) ? n.value = C.direction === ({
      left: "right",
      right: "left",
      top: "down",
      bottom: "up"
    }[a.value] || Wo()) : n.value = h.value > 0.5;
  }
  const b = w(() => f.value ? {
    transform: a.value === "left" ? `translateX(calc(-100% + ${h.value * r.value}px))` : a.value === "right" ? `translateX(calc(100% - ${h.value * r.value}px))` : a.value === "top" ? `translateY(calc(-100% + ${h.value * r.value}px))` : a.value === "bottom" ? `translateY(calc(100% - ${h.value * r.value}px))` : Wo(),
    transition: "none"
  } : void 0);
  return vi(f, () => {
    var x, A;
    const S = ((x = t.value) == null ? void 0 : x.style.transform) ?? null, C = ((A = t.value) == null ? void 0 : A.style.transition) ?? null;
    Wt(() => {
      var I, E, O, V;
      (E = t.value) == null || E.style.setProperty("transform", ((I = b.value) == null ? void 0 : I.transform) || "none"), (V = t.value) == null || V.style.setProperty("transition", ((O = b.value) == null ? void 0 : O.transition) || null);
    }), Wn(() => {
      var I, E;
      (I = t.value) == null || I.style.setProperty("transform", S), (E = t.value) == null || E.style.setProperty("transition", C);
    });
  }), {
    isDragging: f,
    dragProgress: h,
    dragStyles: b
  };
}
function Wo() {
  throw new Error();
}
const yY = ["start", "end", "left", "right", "top", "bottom"], bY = B({
  color: String,
  disableResizeWatcher: Boolean,
  disableRouteWatcher: Boolean,
  expandOnHover: Boolean,
  floating: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  permanent: Boolean,
  rail: {
    type: Boolean,
    default: null
  },
  railWidth: {
    type: [Number, String],
    default: 56
  },
  scrim: {
    type: [Boolean, String],
    default: !0
  },
  image: String,
  temporary: Boolean,
  persistent: Boolean,
  touchless: Boolean,
  width: {
    type: [Number, String],
    default: 256
  },
  location: {
    type: String,
    default: "start",
    validator: (e) => yY.includes(e)
  },
  sticky: Boolean,
  ...Ni(),
  ...ke(),
  ...ib(),
  ...Ll({
    mobile: null
  }),
  ...mn(),
  ...yo(),
  ...It(),
  ...je({
    tag: "nav"
  }),
  ...Qe()
}, "VNavigationDrawer"), wY = J()({
  name: "VNavigationDrawer",
  props: bY(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:rail": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const {
      isRtl: s
    } = yn(), {
      themeClasses: a
    } = lt(e), {
      borderClasses: o
    } = er(e), {
      backgroundColorClasses: l,
      backgroundColorStyles: u
    } = gt(G(e, "color")), {
      elevationClasses: c
    } = In(e), {
      displayClasses: d,
      mobile: f
    } = xr(e), {
      roundedClasses: h
    } = Ht(e), m = Lx(), g = Ee(e, "modelValue", null, (ne) => !!ne), {
      ssrBootStyles: p
    } = Ao(), {
      scopeId: y
    } = Vo(), k = X(), T = pe(!1), {
      runOpenDelay: _,
      runCloseDelay: b
    } = rb(e, (ne) => {
      T.value = ne;
    }), S = w(() => e.rail && e.expandOnHover && T.value ? Number(e.width) : Number(e.rail ? e.railWidth : e.width)), C = w(() => Iv(e.location, s.value)), x = w(() => e.persistent), A = w(() => !e.permanent && (f.value || e.temporary)), I = w(() => e.sticky && !A.value && C.value !== "bottom");
    vi(() => e.expandOnHover && e.rail != null, () => {
      fe(T, (ne) => i("update:rail", !ne));
    }), vi(() => !e.disableResizeWatcher, () => {
      fe(A, (ne) => !e.permanent && He(() => g.value = !ne));
    }), vi(() => !e.disableRouteWatcher && !!m, () => {
      fe(m.currentRoute, () => A.value && (g.value = !1));
    }), fe(() => e.permanent, (ne) => {
      ne && (g.value = !0);
    }), e.modelValue == null && !A.value && (g.value = e.permanent || !f.value);
    const {
      isDragging: E,
      dragProgress: O
    } = pY({
      el: k,
      isActive: g,
      isTemporary: A,
      width: S,
      touchless: G(e, "touchless"),
      position: C
    }), V = w(() => {
      const ne = A.value ? 0 : e.rail && e.expandOnHover ? Number(e.railWidth) : S.value;
      return E.value ? ne * O.value : ne;
    }), N = w(() => ["top", "bottom"].includes(e.location) ? 0 : S.value), {
      layoutItemStyles: F,
      layoutItemScrimStyles: $,
      layoutIsReady: Z
    } = bo({
      id: e.name,
      order: w(() => parseInt(e.order, 10)),
      position: C,
      layoutSize: V,
      elementSize: N,
      active: w(() => g.value || E.value),
      disableTransitions: w(() => E.value),
      absolute: w(() => (
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        e.absolute || I.value && typeof j.value != "string"
      ))
    }), {
      isStuck: j,
      stickyStyles: H
    } = fY({
      rootEl: k,
      isSticky: I,
      layoutItemStyles: F
    }), R = gt(w(() => typeof e.scrim == "string" ? e.scrim : null)), L = w(() => ({
      ...E.value ? {
        opacity: O.value * 0.2,
        transition: "none"
      } : void 0,
      ...$.value
    }));
    return jt({
      VList: {
        bgColor: "transparent"
      }
    }), ie(() => {
      const ne = r.image || e.image;
      return v(De, null, [v(e.tag, se({
        ref: k,
        onMouseenter: _,
        onMouseleave: b,
        class: ["v-navigation-drawer", `v-navigation-drawer--${C.value}`, {
          "v-navigation-drawer--expand-on-hover": e.expandOnHover,
          "v-navigation-drawer--floating": e.floating,
          "v-navigation-drawer--is-hovering": T.value,
          "v-navigation-drawer--rail": e.rail,
          "v-navigation-drawer--temporary": A.value,
          "v-navigation-drawer--persistent": x.value,
          "v-navigation-drawer--active": g.value,
          "v-navigation-drawer--sticky": I.value
        }, a.value, l.value, o.value, d.value, c.value, h.value, e.class],
        style: [u.value, F.value, p.value, H.value, e.style, ["top", "bottom"].includes(C.value) ? {
          height: "auto"
        } : {}]
      }, y, n), {
        default: () => {
          var oe, we, ee;
          return [ne && v("div", {
            key: "image",
            class: "v-navigation-drawer__img"
          }, [r.image ? v(Ze, {
            key: "image-defaults",
            disabled: !e.image,
            defaults: {
              VImg: {
                alt: "",
                cover: !0,
                height: "inherit",
                src: e.image
              }
            }
          }, r.image) : v(_s, {
            key: "image-img",
            alt: "",
            cover: !0,
            height: "inherit",
            src: e.image
          }, null)]), r.prepend && v("div", {
            class: "v-navigation-drawer__prepend"
          }, [(oe = r.prepend) == null ? void 0 : oe.call(r)]), v("div", {
            class: "v-navigation-drawer__content"
          }, [(we = r.default) == null ? void 0 : we.call(r)]), r.append && v("div", {
            class: "v-navigation-drawer__append"
          }, [(ee = r.append) == null ? void 0 : ee.call(r)])];
        }
      }), v(na, {
        name: "fade-transition"
      }, {
        default: () => [A.value && (E.value || g.value) && !!e.scrim && v("div", se({
          class: ["v-navigation-drawer__scrim", R.backgroundColorClasses.value],
          style: [L.value, R.backgroundColorStyles.value],
          onClick: () => {
            x.value || (g.value = !1);
          }
        }, y), null)]
      })]);
    }), Z.then(() => ({
      isStuck: j
    }));
  }
}), _Y = Oi({
  name: "VNoSsr",
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = bA();
    return () => {
      var r;
      return i.value && ((r = n.default) == null ? void 0 : r.call(n));
    };
  }
});
const SY = B({
  autofocus: Boolean,
  divider: String,
  focusAll: Boolean,
  label: {
    type: String,
    default: "$vuetify.input.otp"
  },
  length: {
    type: [Number, String],
    default: 6
  },
  modelValue: {
    type: [Number, String],
    default: void 0
  },
  placeholder: String,
  type: {
    type: String,
    default: "number"
  },
  ...wn(),
  ...Ac(),
  ...oh(Oc({
    variant: "outlined"
  }), ["baseColor", "bgColor", "class", "color", "disabled", "error", "loading", "rounded", "style", "theme", "variant"])
}, "VOtpInput"), kY = J()({
  name: "VOtpInput",
  props: SY(),
  emits: {
    finish: (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const {
      dimensionStyles: s
    } = _n(e), {
      isFocused: a,
      focus: o,
      blur: l
    } = Cs(e), u = Ee(e, "modelValue", "", (x) => x == null ? [] : String(x).split(""), (x) => x.join("")), {
      t: c
    } = qt(), d = w(() => Number(e.length)), f = w(() => Array(d.value).fill(0)), h = X(-1), m = X(), g = X([]), p = w(() => g.value[h.value]);
    function y() {
      if (C(p.value.value)) {
        p.value.value = "";
        return;
      }
      const x = u.value.slice(), A = p.value.value;
      x[h.value] = A;
      let I = null;
      h.value > u.value.length ? I = u.value.length + 1 : h.value + 1 !== d.value && (I = "next"), u.value = x, I && ml(m.value, I);
    }
    function k(x) {
      const A = u.value.slice(), I = h.value;
      let E = null;
      ["ArrowLeft", "ArrowRight", "Backspace", "Delete"].includes(x.key) && (x.preventDefault(), x.key === "ArrowLeft" ? E = "prev" : x.key === "ArrowRight" ? E = "next" : ["Backspace", "Delete"].includes(x.key) && (A[h.value] = "", u.value = A, h.value > 0 && x.key === "Backspace" ? E = "prev" : requestAnimationFrame(() => {
        var O;
        (O = g.value[I]) == null || O.select();
      })), requestAnimationFrame(() => {
        E != null && ml(m.value, E);
      }));
    }
    function T(x, A) {
      var E, O;
      A.preventDefault(), A.stopPropagation();
      const I = ((E = A == null ? void 0 : A.clipboardData) == null ? void 0 : E.getData("Text")) ?? "";
      C(I) || (u.value = I.split(""), (O = g.value) == null || O[x].blur());
    }
    function _() {
      u.value = [];
    }
    function b(x, A) {
      o(), h.value = A;
    }
    function S() {
      l(), h.value = -1;
    }
    function C(x) {
      return e.type === "number" && /[^0-9]/g.test(x);
    }
    return jt({
      VField: {
        color: w(() => e.color),
        bgColor: w(() => e.color),
        baseColor: w(() => e.baseColor),
        disabled: w(() => e.disabled),
        error: w(() => e.error),
        variant: w(() => e.variant)
      }
    }, {
      scoped: !0
    }), fe(u, (x) => {
      x.length === d.value && i("finish", x.join(""));
    }, {
      deep: !0
    }), fe(h, (x) => {
      x < 0 || He(() => {
        var A;
        (A = g.value[x]) == null || A.select();
      });
    }), ie(() => {
      var I;
      const [x, A] = la(n);
      return v("div", se({
        class: ["v-otp-input", {
          "v-otp-input--divided": !!e.divider
        }, e.class],
        style: [e.style]
      }, x), [v("div", {
        ref: m,
        class: "v-otp-input__content",
        style: [s.value]
      }, [f.value.map((E, O) => v(De, null, [e.divider && O !== 0 && v("span", {
        class: "v-otp-input__divider"
      }, [e.divider]), v(Bl, {
        focused: a.value && e.focusAll || h.value === O,
        key: O
      }, {
        ...r,
        loader: void 0,
        default: () => v("input", {
          ref: (V) => g.value[O] = V,
          "aria-label": c(e.label, O + 1),
          autofocus: O === 0 && e.autofocus,
          autocomplete: "one-time-code",
          class: ["v-otp-input__field"],
          disabled: e.disabled,
          inputmode: e.type === "number" ? "numeric" : "text",
          min: e.type === "number" ? 0 : void 0,
          maxlength: "1",
          placeholder: e.placeholder,
          type: e.type === "number" ? "text" : e.type,
          value: u.value[O],
          onInput: y,
          onFocus: (V) => b(V, O),
          onBlur: S,
          onKeydown: k,
          onPaste: (V) => T(O, V)
        }, null)
      })])), v("input", se({
        class: "v-otp-input-input",
        type: "hidden"
      }, A, {
        value: u.value.join("")
      }), null), v(qr, {
        contained: !0,
        "content-class": "v-otp-input__loader",
        "model-value": !!e.loading,
        persistent: !0
      }, {
        default: () => {
          var E;
          return [((E = r.loader) == null ? void 0 : E.call(r)) ?? v(Vl, {
            color: typeof e.loading == "boolean" ? void 0 : e.loading,
            indeterminate: !0,
            size: "24",
            width: "2"
          }, null)];
        }
      }), (I = r.default) == null ? void 0 : I.call(r)])]);
    }), {
      blur: () => {
        var x;
        (x = g.value) == null || x.some((A) => A.blur());
      },
      focus: () => {
        var x;
        (x = g.value) == null || x[0].focus();
      },
      reset: _,
      isFocused: a
    };
  }
});
function CY(e) {
  return Math.floor(Math.abs(e)) * Math.sign(e);
}
const TY = B({
  scale: {
    type: [Number, String],
    default: 0.5
  },
  ...ke()
}, "VParallax"), xY = J()({
  name: "VParallax",
  props: TY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      intersectionRef: i,
      isIntersecting: r
    } = vh(), {
      resizeRef: s,
      contentRect: a
    } = _r(), {
      height: o
    } = xr(), l = X();
    Wt(() => {
      var h;
      i.value = s.value = (h = l.value) == null ? void 0 : h.$el;
    });
    let u;
    fe(r, (h) => {
      h ? (u = cp(i.value), u = u === document.scrollingElement ? document : u, u.addEventListener("scroll", f, {
        passive: !0
      }), f()) : u.removeEventListener("scroll", f);
    }), ai(() => {
      u == null || u.removeEventListener("scroll", f);
    }), fe(o, f), fe(() => {
      var h;
      return (h = a.value) == null ? void 0 : h.height;
    }, f);
    const c = w(() => 1 - Xt(+e.scale));
    let d = -1;
    function f() {
      r.value && (cancelAnimationFrame(d), d = requestAnimationFrame(() => {
        var b;
        const h = ((b = l.value) == null ? void 0 : b.$el).querySelector(".v-img__img");
        if (!h)
          return;
        const m = u instanceof Document ? document.documentElement.clientHeight : u.clientHeight, g = u instanceof Document ? window.scrollY : u.scrollTop, p = i.value.getBoundingClientRect().top + g, y = a.value.height, k = p + (y - m) / 2, T = CY((g - k) * c.value), _ = Math.max(1, (c.value * (m - y) + y) / y);
        h.style.setProperty("transform", `translateY(${T}px) scale(${_})`);
      }));
    }
    return ie(() => v(_s, {
      class: ["v-parallax", {
        "v-parallax--active": r.value
      }, e.class],
      style: e.style,
      ref: l,
      cover: !0,
      onLoadstart: f,
      onLoad: f
    }, n)), {};
  }
}), AY = B({
  ...am({
    falseIcon: "$radioOff",
    trueIcon: "$radioOn"
  })
}, "VRadio"), IY = J()({
  name: "VRadio",
  props: AY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ie(() => v(uo, se(e, {
      class: ["v-radio", e.class],
      style: e.style,
      type: "radio"
    }), n)), {};
  }
});
const EY = B({
  height: {
    type: [Number, String],
    default: "auto"
  },
  ...Ts(),
  ...sn(Jy(), ["multiple"]),
  trueIcon: {
    type: We,
    default: "$radioOn"
  },
  falseIcon: {
    type: We,
    default: "$radioOff"
  },
  type: {
    type: String,
    default: "radio"
  }
}, "VRadioGroup"), OY = J()({
  name: "VRadioGroup",
  inheritAttrs: !1,
  props: EY(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const r = An(), s = w(() => e.id || `radio-group-${r}`), a = Ee(e, "modelValue");
    return ie(() => {
      const [o, l] = la(n), u = $n.filterProps(e), c = uo.filterProps(e), d = i.label ? i.label({
        label: e.label,
        props: {
          for: s.value
        }
      }) : e.label;
      return v($n, se({
        class: ["v-radio-group", e.class],
        style: e.style
      }, o, u, {
        modelValue: a.value,
        "onUpdate:modelValue": (f) => a.value = f,
        id: s.value
      }), {
        ...i,
        default: (f) => {
          let {
            id: h,
            messagesId: m,
            isDisabled: g,
            isReadonly: p
          } = f;
          return v(De, null, [d && v(Rl, {
            id: h.value
          }, {
            default: () => [d]
          }), v(Kx, se(c, {
            id: h.value,
            "aria-describedby": m.value,
            defaultsTarget: "VRadio",
            trueIcon: e.trueIcon,
            falseIcon: e.falseIcon,
            type: e.type,
            disabled: g.value,
            readonly: p.value,
            "aria-labelledby": d ? h.value : void 0,
            multiple: !1
          }, l, {
            modelValue: a.value,
            "onUpdate:modelValue": (y) => a.value = y
          }), i)]);
        }
      });
    }), {};
  }
}), PY = B({
  ...Ac(),
  ...Ts(),
  ...$A(),
  strict: Boolean,
  modelValue: {
    type: Array,
    default: () => [0, 0]
  }
}, "VRangeSlider"), VY = J()({
  name: "VRangeSlider",
  props: PY(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    end: (e) => !0,
    start: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const r = X(), s = X(), a = X(), {
      rtlClasses: o
    } = yn();
    function l(I) {
      if (!r.value || !s.value)
        return;
      const E = Lg(I, r.value.$el, e.direction), O = Lg(I, s.value.$el, e.direction), V = Math.abs(E), N = Math.abs(O);
      return V < N || V === N && E < 0 ? r.value.$el : s.value.$el;
    }
    const u = WA(e), c = Ee(e, "modelValue", void 0, (I) => I != null && I.length ? I.map((E) => u.roundValue(E)) : [0, 0]), {
      activeThumbRef: d,
      hasLabels: f,
      max: h,
      min: m,
      mousePressed: g,
      onSliderMousedown: p,
      onSliderTouchstart: y,
      position: k,
      trackContainerRef: T,
      readonly: _
    } = jA({
      props: e,
      steps: u,
      onSliderStart: () => {
        i("start", c.value);
      },
      onSliderEnd: (I) => {
        var V;
        let {
          value: E
        } = I;
        const O = d.value === ((V = r.value) == null ? void 0 : V.$el) ? [E, c.value[1]] : [c.value[0], E];
        !e.strict && O[0] < O[1] && (c.value = O), i("end", c.value);
      },
      onSliderMove: (I) => {
        var N, F, $, Z;
        let {
          value: E
        } = I;
        const [O, V] = c.value;
        !e.strict && O === V && O !== m.value && (d.value = E > O ? (N = s.value) == null ? void 0 : N.$el : (F = r.value) == null ? void 0 : F.$el, ($ = d.value) == null || $.focus()), d.value === ((Z = r.value) == null ? void 0 : Z.$el) ? c.value = [Math.min(E, V), V] : c.value = [O, Math.max(O, E)];
      },
      getActiveThumb: l
    }), {
      isFocused: b,
      focus: S,
      blur: C
    } = Cs(e), x = w(() => k(c.value[0])), A = w(() => k(c.value[1]));
    return ie(() => {
      const I = $n.filterProps(e), E = !!(e.label || n.label || n.prepend);
      return v($n, se({
        class: ["v-slider", "v-range-slider", {
          "v-slider--has-labels": !!n["tick-label"] || f.value,
          "v-slider--focused": b.value,
          "v-slider--pressed": g.value,
          "v-slider--disabled": e.disabled
        }, o.value, e.class],
        style: e.style,
        ref: a
      }, I, {
        focused: b.value
      }), {
        ...n,
        prepend: E ? (O) => {
          var V, N;
          return v(De, null, [((V = n.label) == null ? void 0 : V.call(n, O)) ?? (e.label ? v(Rl, {
            class: "v-slider__label",
            text: e.label
          }, null) : void 0), (N = n.prepend) == null ? void 0 : N.call(n, O)]);
        } : void 0,
        default: (O) => {
          var F, $;
          let {
            id: V,
            messagesId: N
          } = O;
          return v("div", {
            class: "v-slider__container",
            onMousedown: _.value ? void 0 : p,
            onTouchstartPassive: _.value ? void 0 : y
          }, [v("input", {
            id: `${V.value}_start`,
            name: e.name || V.value,
            disabled: !!e.disabled,
            readonly: !!e.readonly,
            tabindex: "-1",
            value: c.value[0]
          }, null), v("input", {
            id: `${V.value}_stop`,
            name: e.name || V.value,
            disabled: !!e.disabled,
            readonly: !!e.readonly,
            tabindex: "-1",
            value: c.value[1]
          }, null), v(HA, {
            ref: T,
            start: x.value,
            stop: A.value
          }, {
            "tick-label": n["tick-label"]
          }), v($g, {
            ref: r,
            "aria-describedby": N.value,
            focused: b && d.value === ((F = r.value) == null ? void 0 : F.$el),
            modelValue: c.value[0],
            "onUpdate:modelValue": (Z) => c.value = [Z, c.value[1]],
            onFocus: (Z) => {
              var j, H, R, L;
              S(), d.value = (j = r.value) == null ? void 0 : j.$el, c.value[0] === c.value[1] && c.value[1] === m.value && Z.relatedTarget !== ((H = s.value) == null ? void 0 : H.$el) && ((R = r.value) == null || R.$el.blur(), (L = s.value) == null || L.$el.focus());
            },
            onBlur: () => {
              C(), d.value = void 0;
            },
            min: m.value,
            max: c.value[1],
            position: x.value,
            ripple: e.ripple
          }, {
            "thumb-label": n["thumb-label"]
          }), v($g, {
            ref: s,
            "aria-describedby": N.value,
            focused: b && d.value === (($ = s.value) == null ? void 0 : $.$el),
            modelValue: c.value[1],
            "onUpdate:modelValue": (Z) => c.value = [c.value[0], Z],
            onFocus: (Z) => {
              var j, H, R, L;
              S(), d.value = (j = s.value) == null ? void 0 : j.$el, c.value[0] === c.value[1] && c.value[0] === h.value && Z.relatedTarget !== ((H = r.value) == null ? void 0 : H.$el) && ((R = s.value) == null || R.$el.blur(), (L = r.value) == null || L.$el.focus());
            },
            onBlur: () => {
              C(), d.value = void 0;
            },
            min: c.value[0],
            max: h.value,
            position: A.value,
            ripple: e.ripple
          }, {
            "thumb-label": n["thumb-label"]
          })]);
        }
      });
    }), {};
  }
});
const DY = B({
  name: String,
  itemAriaLabel: {
    type: String,
    default: "$vuetify.rating.ariaLabel.item"
  },
  activeColor: String,
  color: String,
  clearable: Boolean,
  disabled: Boolean,
  emptyIcon: {
    type: We,
    default: "$ratingEmpty"
  },
  fullIcon: {
    type: We,
    default: "$ratingFull"
  },
  halfIncrements: Boolean,
  hover: Boolean,
  length: {
    type: [Number, String],
    default: 5
  },
  readonly: Boolean,
  modelValue: {
    type: [Number, String],
    default: 0
  },
  itemLabels: Array,
  itemLabelPosition: {
    type: String,
    default: "top",
    validator: (e) => ["top", "bottom"].includes(e)
  },
  ripple: Boolean,
  ...ke(),
  ...bn(),
  ...Kr(),
  ...je(),
  ...Qe()
}, "VRating"), NY = J()({
  name: "VRating",
  props: DY(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: i
    } = qt(), {
      themeClasses: r
    } = lt(e), s = Ee(e, "modelValue"), a = w(() => Xt(parseFloat(s.value), 0, +e.length)), o = w(() => jr(Number(e.length), 1)), l = w(() => o.value.flatMap((g) => e.halfIncrements ? [g - 0.5, g] : [g])), u = pe(-1), c = w(() => l.value.map((g) => {
      const p = e.hover && u.value > -1, y = a.value >= g, k = u.value >= g, _ = (p ? k : y) ? e.fullIcon : e.emptyIcon, b = e.activeColor ?? e.color, S = y || k ? b : e.color;
      return {
        isFilled: y,
        isHovered: k,
        icon: _,
        color: S
      };
    })), d = w(() => [0, ...l.value].map((g) => {
      function p() {
        u.value = g;
      }
      function y() {
        u.value = -1;
      }
      function k() {
        e.disabled || e.readonly || (s.value = a.value === g && e.clearable ? 0 : g);
      }
      return {
        onMouseenter: e.hover ? p : void 0,
        onMouseleave: e.hover ? y : void 0,
        onClick: k
      };
    })), f = w(() => e.name ?? `v-rating-${An()}`);
    function h(g) {
      var x, A;
      let {
        value: p,
        index: y,
        showStar: k = !0
      } = g;
      const {
        onMouseenter: T,
        onMouseleave: _,
        onClick: b
      } = d.value[y + 1], S = `${f.value}-${String(p).replace(".", "-")}`, C = {
        color: (x = c.value[y]) == null ? void 0 : x.color,
        density: e.density,
        disabled: e.disabled,
        icon: (A = c.value[y]) == null ? void 0 : A.icon,
        ripple: e.ripple,
        size: e.size,
        variant: "plain"
      };
      return v(De, null, [v("label", {
        for: S,
        class: {
          "v-rating__item--half": e.halfIncrements && p % 1 > 0,
          "v-rating__item--full": e.halfIncrements && p % 1 === 0
        },
        onMouseenter: T,
        onMouseleave: _,
        onClick: b
      }, [v("span", {
        class: "v-rating__hidden"
      }, [i(e.itemAriaLabel, p, e.length)]), k ? n.item ? n.item({
        ...c.value[y],
        props: C,
        value: p,
        index: y,
        rating: a.value
      }) : v(st, se({
        "aria-label": i(e.itemAriaLabel, p, e.length)
      }, C), null) : void 0]), v("input", {
        class: "v-rating__hidden",
        name: f.value,
        id: S,
        type: "radio",
        value: p,
        checked: a.value === p,
        tabindex: -1,
        readonly: e.readonly,
        disabled: e.disabled
      }, null)]);
    }
    function m(g) {
      return n["item-label"] ? n["item-label"](g) : g.label ? v("span", null, [g.label]) : v("span", null, [wr(" ")]);
    }
    return ie(() => {
      var p;
      const g = !!((p = e.itemLabels) != null && p.length) || n["item-label"];
      return v(e.tag, {
        class: ["v-rating", {
          "v-rating--hover": e.hover,
          "v-rating--readonly": e.readonly
        }, r.value, e.class],
        style: e.style
      }, {
        default: () => [v(h, {
          value: 0,
          index: -1,
          showStar: !1
        }, null), o.value.map((y, k) => {
          var T, _;
          return v("div", {
            class: "v-rating__wrapper"
          }, [g && e.itemLabelPosition === "top" ? m({
            value: y,
            index: k,
            label: (T = e.itemLabels) == null ? void 0 : T[k]
          }) : void 0, v("div", {
            class: "v-rating__item"
          }, [e.halfIncrements ? v(De, null, [v(h, {
            value: y - 0.5,
            index: k * 2
          }, null), v(h, {
            value: y,
            index: k * 2 + 1
          }, null)]) : v(h, {
            value: y,
            index: k
          }, null)]), g && e.itemLabelPosition === "bottom" ? m({
            value: y,
            index: k,
            label: (_ = e.itemLabels) == null ? void 0 : _[k]
          }) : void 0]);
        })]
      });
    }), {};
  }
});
const MY = {
  actions: "button@2",
  article: "heading, paragraph",
  avatar: "avatar",
  button: "button",
  card: "image, heading",
  "card-avatar": "image, list-item-avatar",
  chip: "chip",
  "date-picker": "list-item, heading, divider, date-picker-options, date-picker-days, actions",
  "date-picker-options": "text, avatar@2",
  "date-picker-days": "avatar@28",
  divider: "divider",
  heading: "heading",
  image: "image",
  "list-item": "text",
  "list-item-avatar": "avatar, text",
  "list-item-two-line": "sentences",
  "list-item-avatar-two-line": "avatar, sentences",
  "list-item-three-line": "paragraph",
  "list-item-avatar-three-line": "avatar, paragraph",
  ossein: "ossein",
  paragraph: "text@3",
  sentences: "text@2",
  subtitle: "text",
  table: "table-heading, table-thead, table-tbody, table-tfoot",
  "table-heading": "chip, text",
  "table-thead": "heading@6",
  "table-tbody": "table-row-divider@6",
  "table-row-divider": "table-row, divider",
  "table-row": "text@6",
  "table-tfoot": "text@2, avatar@2",
  text: "text"
};
function RY(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return v("div", {
    class: ["v-skeleton-loader__bone", `v-skeleton-loader__${e}`]
  }, [t]);
}
function z_(e) {
  const [t, n] = e.split("@");
  return Array.from({
    length: n
  }).map(() => _m(t));
}
function _m(e) {
  let t = [];
  if (!e)
    return t;
  const n = MY[e];
  if (e !== n) {
    if (e.includes(","))
      return U_(e);
    if (e.includes("@"))
      return z_(e);
    n.includes(",") ? t = U_(n) : n.includes("@") ? t = z_(n) : n && t.push(_m(n));
  }
  return [RY(e, t)];
}
function U_(e) {
  return e.replace(/\s/g, "").split(",").map(_m);
}
const FY = B({
  boilerplate: Boolean,
  color: String,
  loading: Boolean,
  loadingText: {
    type: String,
    default: "$vuetify.loading"
  },
  type: {
    type: [String, Array],
    default: "ossein"
  },
  ...wn(),
  ...mn(),
  ...Qe()
}, "VSkeletonLoader"), BY = J()({
  name: "VSkeletonLoader",
  props: FY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: r
    } = gt(G(e, "color")), {
      dimensionStyles: s
    } = _n(e), {
      elevationClasses: a
    } = In(e), {
      themeClasses: o
    } = lt(e), {
      t: l
    } = qt(), u = w(() => _m(Nt(e.type).join(",")));
    return ie(() => {
      var d;
      const c = !n.default || e.loading;
      return v("div", {
        class: ["v-skeleton-loader", {
          "v-skeleton-loader--boilerplate": e.boilerplate
        }, o.value, i.value, a.value],
        style: [r.value, c ? s.value : {}],
        "aria-busy": e.boilerplate ? void 0 : c,
        "aria-live": e.boilerplate ? void 0 : "polite",
        "aria-label": e.boilerplate ? void 0 : l(e.loadingText),
        role: e.boilerplate ? void 0 : "alert"
      }, [c ? u.value : (d = n.default) == null ? void 0 : d.call(n)]);
    }), {};
  }
}), LY = J()({
  name: "VSlideGroupItem",
  props: Oo(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Po(e, eA);
    return () => {
      var r;
      return (r = n.default) == null ? void 0 : r.call(n, {
        isSelected: i.isSelected.value,
        select: i.select,
        toggle: i.toggle,
        selectedClass: i.selectedClass.value
      });
    };
  }
});
function $Y(e) {
  const t = pe(e);
  let n = -1;
  function i() {
    clearInterval(n);
  }
  function r() {
    i(), He(() => t.value = e);
  }
  function s(a) {
    const o = a ? getComputedStyle(a) : {
      transitionDuration: 0.2
    }, l = parseFloat(o.transitionDuration) * 1e3 || 200;
    if (i(), t.value <= 0)
      return;
    const u = performance.now();
    n = window.setInterval(() => {
      const c = performance.now() - u + l;
      t.value = Math.max(e - c, 0), t.value <= 0 && i();
    }, l);
  }
  return Wn(i), {
    clear: i,
    time: t,
    start: s,
    reset: r
  };
}
const WY = B({
  multiLine: Boolean,
  text: String,
  timer: [Boolean, String],
  timeout: {
    type: [Number, String],
    default: 5e3
  },
  vertical: Boolean,
  ...ua({
    location: "bottom"
  }),
  ...nu(),
  ...It(),
  ...tr(),
  ...Qe(),
  ...sn(sd({
    transition: "v-snackbar-transition"
  }), ["persistent", "noClickAnimation", "scrim", "scrollStrategy"])
}, "VSnackbar"), jY = J()({
  name: "VSnackbar",
  props: WY(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), {
      positionClasses: r
    } = iu(e), {
      scopeId: s
    } = Vo(), {
      themeClasses: a
    } = lt(e), {
      colorClasses: o,
      colorStyles: l,
      variantClasses: u
    } = Io(e), {
      roundedClasses: c
    } = Ht(e), d = $Y(Number(e.timeout)), f = X(), h = X(), m = pe(!1), g = pe(0), p = X(), y = tt(Gu, void 0);
    vi(() => !!y, () => {
      const I = YS();
      Wt(() => {
        p.value = I.mainStyles.value;
      });
    }), fe(i, T), fe(() => e.timeout, T), jn(() => {
      i.value && T();
    });
    let k = -1;
    function T() {
      d.reset(), window.clearTimeout(k);
      const I = Number(e.timeout);
      if (!i.value || I === -1)
        return;
      const E = np(h.value);
      d.start(E), k = window.setTimeout(() => {
        i.value = !1;
      }, I);
    }
    function _() {
      d.reset(), window.clearTimeout(k);
    }
    function b() {
      m.value = !0, _();
    }
    function S() {
      m.value = !1, T();
    }
    function C(I) {
      g.value = I.touches[0].clientY;
    }
    function x(I) {
      Math.abs(g.value - I.changedTouches[0].clientY) > 50 && (i.value = !1);
    }
    const A = w(() => e.location.split(" ").reduce((I, E) => (I[`v-snackbar--${E}`] = !0, I), {}));
    return ie(() => {
      const I = qr.filterProps(e), E = !!(n.default || n.text || e.text);
      return v(qr, se({
        ref: f,
        class: ["v-snackbar", {
          "v-snackbar--active": i.value,
          "v-snackbar--multi-line": e.multiLine && !e.vertical,
          "v-snackbar--timer": !!e.timer,
          "v-snackbar--vertical": e.vertical
        }, A.value, r.value, e.class],
        style: [p.value, e.style]
      }, I, {
        modelValue: i.value,
        "onUpdate:modelValue": (O) => i.value = O,
        contentProps: se({
          class: ["v-snackbar__wrapper", a.value, o.value, c.value, u.value],
          style: [l.value],
          onPointerenter: b,
          onPointerleave: S
        }, I.contentProps),
        persistent: !0,
        noClickAnimation: !0,
        scrim: !1,
        scrollStrategy: "none",
        _disableGlobalStack: !0,
        onTouchstartPassive: C,
        onTouchend: x
      }, s), {
        default: () => {
          var O, V;
          return [fa(!1, "v-snackbar"), e.timer && !m.value && v("div", {
            key: "timer",
            class: "v-snackbar__timer"
          }, [v(gh, {
            ref: h,
            color: typeof e.timer == "string" ? e.timer : "info",
            max: e.timeout,
            "model-value": d.time.value
          }, null)]), E && v("div", {
            key: "content",
            class: "v-snackbar__content",
            role: "status",
            "aria-live": "polite"
          }, [((O = n.text) == null ? void 0 : O.call(n)) ?? e.text, (V = n.default) == null ? void 0 : V.call(n)]), n.actions && v(Ze, {
            defaults: {
              VBtn: {
                variant: "text",
                ripple: !1,
                slim: !0
              }
            }
          }, {
            default: () => [v("div", {
              class: "v-snackbar__actions"
            }, [n.actions({
              isActive: i
            })])]
          })];
        },
        activator: n.activator
      });
    }), Qi({}, f);
  }
}), DI = B({
  autoDraw: Boolean,
  autoDrawDuration: [Number, String],
  autoDrawEasing: {
    type: String,
    default: "ease"
  },
  color: String,
  gradient: {
    type: Array,
    default: () => []
  },
  gradientDirection: {
    type: String,
    validator: (e) => ["top", "bottom", "left", "right"].includes(e),
    default: "top"
  },
  height: {
    type: [String, Number],
    default: 75
  },
  labels: {
    type: Array,
    default: () => []
  },
  labelSize: {
    type: [Number, String],
    default: 7
  },
  lineWidth: {
    type: [String, Number],
    default: 4
  },
  id: String,
  itemValue: {
    type: String,
    default: "value"
  },
  modelValue: {
    type: Array,
    default: () => []
  },
  min: [String, Number],
  max: [String, Number],
  padding: {
    type: [String, Number],
    default: 8
  },
  showLabels: Boolean,
  smooth: Boolean,
  width: {
    type: [Number, String],
    default: 300
  }
}, "Line"), NI = B({
  autoLineWidth: Boolean,
  ...DI()
}, "VBarline"), q_ = J()({
  name: "VBarline",
  props: NI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = An(), r = w(() => e.id || `barline-${i}`), s = w(() => Number(e.autoDrawDuration) || 500), a = w(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), o = w(() => parseFloat(e.lineWidth) || 4), l = w(() => Math.max(e.modelValue.length * o.value, Number(e.width))), u = w(() => ({
      minX: 0,
      maxX: l.value,
      minY: 0,
      maxY: parseInt(e.height, 10)
    })), c = w(() => e.modelValue.map((g) => dn(g, e.itemValue, g)));
    function d(g, p) {
      const {
        minX: y,
        maxX: k,
        minY: T,
        maxY: _
      } = p, b = g.length;
      let S = e.max != null ? Number(e.max) : Math.max(...g), C = e.min != null ? Number(e.min) : Math.min(...g);
      C > 0 && e.min == null && (C = 0), S < 0 && e.max == null && (S = 0);
      const x = k / b, A = (_ - T) / (S - C || 1), I = _ - Math.abs(C * A);
      return g.map((E, O) => {
        const V = Math.abs(A * E);
        return {
          x: y + O * x,
          y: I - V + +(E < 0) * V,
          height: V,
          value: E
        };
      });
    }
    const f = w(() => {
      const g = [], p = d(c.value, u.value), y = p.length;
      for (let k = 0; g.length < y; k++) {
        const T = p[k];
        let _ = e.labels[k];
        _ || (_ = typeof T == "object" ? T.value : T), g.push({
          x: T.x,
          value: String(_)
        });
      }
      return g;
    }), h = w(() => d(c.value, u.value)), m = w(() => (Math.abs(h.value[0].x - h.value[1].x) - o.value) / 2);
    ie(() => {
      const g = e.gradient.slice().length ? e.gradient.slice().reverse() : [""];
      return v("svg", {
        display: "block"
      }, [v("defs", null, [v("linearGradient", {
        id: r.value,
        gradientUnits: "userSpaceOnUse",
        x1: e.gradientDirection === "left" ? "100%" : "0",
        y1: e.gradientDirection === "top" ? "100%" : "0",
        x2: e.gradientDirection === "right" ? "100%" : "0",
        y2: e.gradientDirection === "bottom" ? "100%" : "0"
      }, [g.map((p, y) => v("stop", {
        offset: y / Math.max(g.length - 1, 1),
        "stop-color": p || "currentColor"
      }, null))])]), v("clipPath", {
        id: `${r.value}-clip`
      }, [h.value.map((p) => v("rect", {
        x: p.x + m.value,
        y: p.y,
        width: o.value,
        height: p.height,
        rx: typeof e.smooth == "number" ? e.smooth : e.smooth ? 2 : 0,
        ry: typeof e.smooth == "number" ? e.smooth : e.smooth ? 2 : 0
      }, [e.autoDraw && v(De, null, [v("animate", {
        attributeName: "y",
        from: p.y + p.height,
        to: p.y,
        dur: `${s.value}ms`,
        fill: "freeze"
      }, null), v("animate", {
        attributeName: "height",
        from: "0",
        to: p.height,
        dur: `${s.value}ms`,
        fill: "freeze"
      }, null)])]))]), a.value && v("g", {
        key: "labels",
        style: {
          textAnchor: "middle",
          dominantBaseline: "mathematical",
          fill: "currentColor"
        }
      }, [f.value.map((p, y) => {
        var k;
        return v("text", {
          x: p.x + m.value + o.value / 2,
          y: parseInt(e.height, 10) - 2 + (parseInt(e.labelSize, 10) || 7 * 0.75),
          "font-size": Number(e.labelSize) || 7
        }, [((k = n.label) == null ? void 0 : k.call(n, {
          index: y,
          value: p.value
        })) ?? p.value]);
      })]), v("g", {
        "clip-path": `url(#${r.value}-clip)`,
        fill: `url(#${r.value})`
      }, [v("rect", {
        x: 0,
        y: 0,
        width: Math.max(e.modelValue.length * o.value, Number(e.width)),
        height: e.height
      }, null)])]);
    });
  }
});
function HY(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 75;
  if (e.length === 0)
    return "";
  const r = e.shift(), s = e[e.length - 1];
  return (n ? `M${r.x} ${i - r.x + 2} L${r.x} ${r.y}` : `M${r.x} ${r.y}`) + e.map((a, o) => {
    const l = e[o + 1], u = e[o - 1] || r, c = l && zY(l, a, u);
    if (!l || c)
      return `L${a.x} ${a.y}`;
    const d = Math.min(G_(u, a), G_(l, a)), h = d / 2 < t ? d / 2 : t, m = Y_(u, a, h), g = Y_(l, a, h);
    return `L${m.x} ${m.y}S${a.x} ${a.y} ${g.x} ${g.y}`;
  }).join("") + (n ? `L${s.x} ${i - r.x + 2} Z` : "");
}
function Vd(e) {
  return parseInt(e, 10);
}
function zY(e, t, n) {
  return Vd(e.x + n.x) === Vd(2 * t.x) && Vd(e.y + n.y) === Vd(2 * t.y);
}
function G_(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function Y_(e, t, n) {
  const i = {
    x: e.x - t.x,
    y: e.y - t.y
  }, r = Math.sqrt(i.x * i.x + i.y * i.y), s = {
    x: i.x / r,
    y: i.y / r
  };
  return {
    x: t.x + s.x * n,
    y: t.y + s.y * n
  };
}
const MI = B({
  fill: Boolean,
  ...DI()
}, "VTrendline"), Z_ = J()({
  name: "VTrendline",
  props: MI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = An(), r = w(() => e.id || `trendline-${i}`), s = w(() => Number(e.autoDrawDuration) || (e.fill ? 500 : 2e3)), a = X(0), o = X(null);
    function l(p, y) {
      const {
        minX: k,
        maxX: T,
        minY: _,
        maxY: b
      } = y, S = p.length, C = e.max != null ? Number(e.max) : Math.max(...p), x = e.min != null ? Number(e.min) : Math.min(...p), A = (T - k) / (S - 1), I = (b - _) / (C - x || 1);
      return p.map((E, O) => ({
        x: k + O * A,
        y: b - (E - x) * I,
        value: E
      }));
    }
    const u = w(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), c = w(() => parseFloat(e.lineWidth) || 4), d = w(() => Number(e.width)), f = w(() => {
      const p = Number(e.padding);
      return {
        minX: p,
        maxX: d.value - p,
        minY: p,
        maxY: parseInt(e.height, 10) - p
      };
    }), h = w(() => e.modelValue.map((p) => dn(p, e.itemValue, p))), m = w(() => {
      const p = [], y = l(h.value, f.value), k = y.length;
      for (let T = 0; p.length < k; T++) {
        const _ = y[T];
        let b = e.labels[T];
        b || (b = typeof _ == "object" ? _.value : _), p.push({
          x: _.x,
          value: String(b)
        });
      }
      return p;
    });
    fe(() => e.modelValue, async () => {
      if (await He(), !e.autoDraw || !o.value)
        return;
      const p = o.value, y = p.getTotalLength();
      e.fill ? (p.style.transformOrigin = "bottom center", p.style.transition = "none", p.style.transform = "scaleY(0)", p.getBoundingClientRect(), p.style.transition = `transform ${s.value}ms ${e.autoDrawEasing}`, p.style.transform = "scaleY(1)") : (p.style.strokeDasharray = `${y}`, p.style.strokeDashoffset = `${y}`, p.getBoundingClientRect(), p.style.transition = `stroke-dashoffset ${s.value}ms ${e.autoDrawEasing}`, p.style.strokeDashoffset = "0"), a.value = y;
    }, {
      immediate: !0
    });
    function g(p) {
      return HY(l(h.value, f.value), e.smooth ? 8 : Number(e.smooth), p, parseInt(e.height, 10));
    }
    ie(() => {
      var y;
      const p = e.gradient.slice().length ? e.gradient.slice().reverse() : [""];
      return v("svg", {
        display: "block",
        "stroke-width": parseFloat(e.lineWidth) ?? 4
      }, [v("defs", null, [v("linearGradient", {
        id: r.value,
        gradientUnits: "userSpaceOnUse",
        x1: e.gradientDirection === "left" ? "100%" : "0",
        y1: e.gradientDirection === "top" ? "100%" : "0",
        x2: e.gradientDirection === "right" ? "100%" : "0",
        y2: e.gradientDirection === "bottom" ? "100%" : "0"
      }, [p.map((k, T) => v("stop", {
        offset: T / Math.max(p.length - 1, 1),
        "stop-color": k || "currentColor"
      }, null))])]), u.value && v("g", {
        key: "labels",
        style: {
          textAnchor: "middle",
          dominantBaseline: "mathematical",
          fill: "currentColor"
        }
      }, [m.value.map((k, T) => {
        var _;
        return v("text", {
          x: k.x + c.value / 2 + c.value / 2,
          y: parseInt(e.height, 10) - 4 + (parseInt(e.labelSize, 10) || 7 * 0.75),
          "font-size": Number(e.labelSize) || 7
        }, [((_ = n.label) == null ? void 0 : _.call(n, {
          index: T,
          value: k.value
        })) ?? k.value]);
      })]), v("path", {
        ref: o,
        d: g(e.fill),
        fill: e.fill ? `url(#${r.value})` : "none",
        stroke: e.fill ? "none" : `url(#${r.value})`
      }, null), e.fill && v("path", {
        d: g(!1),
        fill: "none",
        stroke: e.color ?? ((y = e.gradient) == null ? void 0 : y[0])
      }, null)]);
    });
  }
}), UY = B({
  type: {
    type: String,
    default: "trend"
  },
  ...NI(),
  ...MI()
}, "VSparkline"), qY = J()({
  name: "VSparkline",
  props: UY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      textColorClasses: i,
      textColorStyles: r
    } = Ln(G(e, "color")), s = w(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), a = w(() => {
      let o = parseInt(e.height, 10);
      return s.value && (o += parseInt(e.labelSize, 10) * 1.5), o;
    });
    ie(() => {
      const o = e.type === "trend" ? Z_ : q_, l = e.type === "trend" ? Z_.filterProps(e) : q_.filterProps(e);
      return v(o, se({
        key: e.type,
        class: i.value,
        style: r.value,
        viewBox: `0 0 ${e.width} ${parseInt(a.value, 10)}`
      }, l), n);
    });
  }
});
const GY = B({
  ...ke(),
  ...kA({
    offset: 8,
    minWidth: 0,
    openDelay: 0,
    closeDelay: 100,
    location: "top center",
    transition: "scale-transition"
  })
}, "VSpeedDial"), YY = J()({
  name: "VSpeedDial",
  props: GY(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), r = X(), s = w(() => {
      const [o, l = "center"] = e.location.split(" ");
      return `${o} ${l}`;
    }), a = w(() => ({
      [`v-speed-dial__content--${s.value.replace(" ", "-")}`]: !0
    }));
    return ie(() => {
      const o = Dl.filterProps(e);
      return v(Dl, se(o, {
        modelValue: i.value,
        "onUpdate:modelValue": (l) => i.value = l,
        class: e.class,
        style: e.style,
        contentClass: ["v-speed-dial__content", a.value],
        location: s.value,
        ref: r,
        transition: "fade-transition"
      }), {
        ...n,
        default: (l) => v(Ze, {
          defaults: {
            VBtn: {
              size: "small"
            }
          }
        }, {
          default: () => [v(Gn, {
            appear: !0,
            group: !0,
            transition: e.transition
          }, {
            default: () => {
              var u;
              return [(u = n.default) == null ? void 0 : u.call(n, l)];
            }
          })]
        })
      });
    }), {};
  }
});
const RI = B({
  color: String,
  disabled: {
    type: [Boolean, String],
    default: !1
  },
  prevText: {
    type: String,
    default: "$vuetify.stepper.prev"
  },
  nextText: {
    type: String,
    default: "$vuetify.stepper.next"
  }
}, "VStepperActions"), FI = J()({
  name: "VStepperActions",
  props: RI(),
  emits: {
    "click:prev": () => !0,
    "click:next": () => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const {
      t: r
    } = qt();
    function s() {
      n("click:prev");
    }
    function a() {
      n("click:next");
    }
    return ie(() => {
      const o = {
        onClick: s
      }, l = {
        onClick: a
      };
      return v("div", {
        class: "v-stepper-actions"
      }, [v(Ze, {
        defaults: {
          VBtn: {
            disabled: ["prev", !0].includes(e.disabled),
            text: r(e.prevText),
            variant: "text"
          }
        }
      }, {
        default: () => {
          var u;
          return [((u = i.prev) == null ? void 0 : u.call(i, {
            props: o
          })) ?? v(st, o, null)];
        }
      }), v(Ze, {
        defaults: {
          VBtn: {
            color: e.color,
            disabled: ["next", !0].includes(e.disabled),
            text: r(e.nextText),
            variant: "tonal"
          }
        }
      }, {
        default: () => {
          var u;
          return [((u = i.next) == null ? void 0 : u.call(i, {
            props: l
          })) ?? v(st, l, null)];
        }
      })]);
    }), {};
  }
}), BI = Yr("v-stepper-header");
const ZY = B({
  color: String,
  title: String,
  subtitle: String,
  complete: Boolean,
  completeIcon: {
    type: String,
    default: "$complete"
  },
  editable: Boolean,
  editIcon: {
    type: String,
    default: "$edit"
  },
  error: Boolean,
  errorIcon: {
    type: String,
    default: "$error"
  },
  icon: String,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  rules: {
    type: Array,
    default: () => []
  }
}, "StepperItem"), KY = B({
  ...ZY(),
  ...Oo()
}, "VStepperItem"), LI = J()({
  name: "VStepperItem",
  directives: {
    Ripple: Os
  },
  props: KY(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Po(e, jI, !0), r = w(() => (i == null ? void 0 : i.value.value) ?? e.value), s = w(() => e.rules.every((f) => f() === !0)), a = w(() => !e.disabled && e.editable), o = w(() => !e.disabled && e.editable), l = w(() => e.error || !s.value), u = w(() => e.complete || e.rules.length > 0 && s.value), c = w(() => l.value ? e.errorIcon : u.value ? e.completeIcon : i.isSelected.value && e.editable ? e.editIcon : e.icon), d = w(() => ({
      canEdit: o.value,
      hasError: l.value,
      hasCompleted: u.value,
      title: e.title,
      subtitle: e.subtitle,
      step: r.value,
      value: e.value
    }));
    return ie(() => {
      var p, y, k;
      const f = (!i || i.isSelected.value || u.value || o.value) && !l.value && !e.disabled, h = !!(e.title != null || n.title), m = !!(e.subtitle != null || n.subtitle);
      function g() {
        i == null || i.toggle();
      }
      return Rt(v("button", {
        class: ["v-stepper-item", {
          "v-stepper-item--complete": u.value,
          "v-stepper-item--disabled": e.disabled,
          "v-stepper-item--error": l.value
        }, i == null ? void 0 : i.selectedClass.value],
        disabled: !e.editable,
        onClick: g
      }, [a.value && fa(!0, "v-stepper-item"), v(Ji, {
        key: "stepper-avatar",
        class: "v-stepper-item__avatar",
        color: f ? e.color : void 0,
        size: 24
      }, {
        default: () => {
          var T;
          return [((T = n.icon) == null ? void 0 : T.call(n, d.value)) ?? (c.value ? v(at, {
            icon: c.value
          }, null) : r.value)];
        }
      }), v("div", {
        class: "v-stepper-item__content"
      }, [h && v("div", {
        key: "title",
        class: "v-stepper-item__title"
      }, [((p = n.title) == null ? void 0 : p.call(n, d.value)) ?? e.title]), m && v("div", {
        key: "subtitle",
        class: "v-stepper-item__subtitle"
      }, [((y = n.subtitle) == null ? void 0 : y.call(n, d.value)) ?? e.subtitle]), (k = n.default) == null ? void 0 : k.call(n, d.value)])]), [[Ei("ripple"), e.ripple && e.editable, null]]);
    }), {};
  }
}), XY = Symbol.for("vuetify:v-stepper"), JY = B({
  ...sn(um(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
}, "VStepperWindow"), $I = J()({
  name: "VStepperWindow",
  props: JY(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = tt(XY, null), r = Ee(e, "modelValue"), s = w({
      get() {
        var a;
        return r.value != null || !i ? r.value : (a = i.items.value.find((o) => i.selected.value.includes(o.id))) == null ? void 0 : a.value;
      },
      set(a) {
        r.value = a;
      }
    });
    return ie(() => {
      const a = co.filterProps(e);
      return v(co, se({
        _as: "VStepperWindow"
      }, a, {
        modelValue: s.value,
        "onUpdate:modelValue": (o) => s.value = o,
        class: ["v-stepper-window", e.class],
        style: e.style,
        mandatory: !1,
        touch: !1
      }), n);
    }), {};
  }
}), QY = B({
  ...cm()
}, "VStepperWindowItem"), WI = J()({
  name: "VStepperWindowItem",
  props: QY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ie(() => {
      const i = fo.filterProps(e);
      return v(fo, se({
        _as: "VStepperWindowItem"
      }, i, {
        class: ["v-stepper-window-item", e.class],
        style: e.style
      }), n);
    }), {};
  }
}), jI = Symbol.for("vuetify:v-stepper"), e7 = B({
  altLabels: Boolean,
  bgColor: String,
  editable: Boolean,
  hideActions: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: String,
    default: "title"
  },
  itemValue: {
    type: String,
    default: "value"
  },
  mobile: Boolean,
  nonLinear: Boolean,
  flat: Boolean
}, "Stepper"), t7 = B({
  ...e7(),
  ...Eo({
    mandatory: "force",
    selectedClass: "v-stepper-item--selected"
  }),
  ...dm(),
  ...oh(RI(), ["prevText", "nextText"])
}, "VStepper"), n7 = J()({
  name: "VStepper",
  props: t7(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      items: i,
      next: r,
      prev: s,
      selected: a
    } = ha(e, jI), {
      color: o,
      editable: l,
      prevText: u,
      nextText: c
    } = sh(e), d = w(() => e.items.map((m, g) => {
      const p = dn(m, e.itemTitle, m), y = dn(m, e.itemValue, g + 1);
      return {
        title: p,
        value: y,
        raw: m
      };
    })), f = w(() => i.value.findIndex((m) => a.value.includes(m.id))), h = w(() => e.disabled ? e.disabled : f.value === 0 ? "prev" : f.value === i.value.length - 1 ? "next" : !1);
    return jt({
      VStepperItem: {
        editable: l,
        prevText: u,
        nextText: c
      },
      VStepperActions: {
        color: o,
        disabled: h,
        prevText: u,
        nextText: c
      }
    }), ie(() => {
      const m = ho.filterProps(e), g = !!(n.header || e.items.length), p = e.items.length > 0, y = !e.hideActions && !!(p || n.actions);
      return v(ho, se(m, {
        color: e.bgColor,
        class: ["v-stepper", {
          "v-stepper--alt-labels": e.altLabels,
          "v-stepper--flat": e.flat,
          "v-stepper--non-linear": e.nonLinear,
          "v-stepper--mobile": e.mobile
        }, e.class],
        style: e.style
      }), {
        default: () => {
          var k, T;
          return [g && v(BI, {
            key: "stepper-header"
          }, {
            default: () => [d.value.map((_, b) => {
              let {
                raw: S,
                ...C
              } = _;
              return v(De, null, [!!b && v(rd, null, null), v(LI, C, {
                default: n[`header-item.${C.value}`] ?? n.header,
                icon: n.icon,
                title: n.title,
                subtitle: n.subtitle
              })]);
            })]
          }), p && v($I, {
            key: "stepper-window"
          }, {
            default: () => [d.value.map((_) => v(WI, {
              value: _.value
            }, {
              default: () => {
                var b, S;
                return ((b = n[`item.${_.value}`]) == null ? void 0 : b.call(n, _)) ?? ((S = n.item) == null ? void 0 : S.call(n, _));
              }
            }))]
          }), (k = n.default) == null ? void 0 : k.call(n, {
            prev: s,
            next: r
          }), y && (((T = n.actions) == null ? void 0 : T.call(n, {
            next: r,
            prev: s
          })) ?? v(FI, {
            key: "stepper-actions",
            "onClick:prev": s,
            "onClick:next": r
          }, n))];
        }
      });
    }), {
      prev: s,
      next: r
    };
  }
});
const i7 = B({
  indeterminate: Boolean,
  inset: Boolean,
  flat: Boolean,
  loading: {
    type: [Boolean, String],
    default: !1
  },
  ...Ts(),
  ...am()
}, "VSwitch"), r7 = J()({
  name: "VSwitch",
  inheritAttrs: !1,
  props: i7(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:indeterminate": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const r = Ee(e, "indeterminate"), s = Ee(e, "modelValue"), {
      loaderClasses: a
    } = Ic(e), {
      isFocused: o,
      focus: l,
      blur: u
    } = Cs(e), c = X(), d = ft && window.matchMedia("(forced-colors: active)").matches, f = w(() => typeof e.loading == "string" && e.loading !== "" ? e.loading : e.color), h = An(), m = w(() => e.id || `switch-${h}`);
    function g() {
      r.value && (r.value = !1);
    }
    function p(y) {
      var k, T;
      y.stopPropagation(), y.preventDefault(), (T = (k = c.value) == null ? void 0 : k.input) == null || T.click();
    }
    return ie(() => {
      const [y, k] = la(n), T = $n.filterProps(e), _ = uo.filterProps(e);
      return v($n, se({
        class: ["v-switch", {
          "v-switch--flat": e.flat
        }, {
          "v-switch--inset": e.inset
        }, {
          "v-switch--indeterminate": r.value
        }, a.value, e.class]
      }, y, T, {
        modelValue: s.value,
        "onUpdate:modelValue": (b) => s.value = b,
        id: m.value,
        focused: o.value,
        style: e.style
      }), {
        ...i,
        default: (b) => {
          let {
            id: S,
            messagesId: C,
            isDisabled: x,
            isReadonly: A,
            isValid: I
          } = b;
          const E = {
            model: s,
            isValid: I
          };
          return v(uo, se({
            ref: c
          }, _, {
            modelValue: s.value,
            "onUpdate:modelValue": [(O) => s.value = O, g],
            id: S.value,
            "aria-describedby": C.value,
            type: "checkbox",
            "aria-checked": r.value ? "mixed" : void 0,
            disabled: x.value,
            readonly: A.value,
            onFocus: l,
            onBlur: u
          }, k), {
            ...i,
            default: (O) => {
              let {
                backgroundColorClasses: V,
                backgroundColorStyles: N
              } = O;
              return v("div", {
                class: ["v-switch__track", d ? void 0 : V.value],
                style: N.value,
                onClick: p
              }, [i["track-true"] && v("div", {
                key: "prepend",
                class: "v-switch__track-true"
              }, [i["track-true"](E)]), i["track-false"] && v("div", {
                key: "append",
                class: "v-switch__track-false"
              }, [i["track-false"](E)])]);
            },
            input: (O) => {
              let {
                inputNode: V,
                icon: N,
                backgroundColorClasses: F,
                backgroundColorStyles: $
              } = O;
              return v(De, null, [V, v("div", {
                class: ["v-switch__thumb", {
                  "v-switch__thumb--filled": N || e.loading
                }, e.inset || d ? void 0 : F.value],
                style: e.inset ? void 0 : $.value
              }, [i.thumb ? v(Ze, {
                defaults: {
                  VIcon: {
                    icon: N,
                    size: "x-small"
                  }
                }
              }, {
                default: () => [i.thumb({
                  ...E,
                  icon: N
                })]
              }) : v(fp, null, {
                default: () => [e.loading ? v(Ec, {
                  name: "v-switch",
                  active: !0,
                  color: I.value === !1 ? void 0 : f.value
                }, {
                  default: (Z) => i.loader ? i.loader(Z) : v(Vl, {
                    active: Z.isActive,
                    color: Z.color,
                    indeterminate: !0,
                    size: "16",
                    width: "2"
                  }, null)
                }) : N && v(at, {
                  key: String(N),
                  icon: N,
                  size: "x-small"
                }, null)]
              })])]);
            }
          });
        }
      });
    }), {};
  }
});
const s7 = B({
  color: String,
  height: [Number, String],
  window: Boolean,
  ...ke(),
  ...mn(),
  ...yo(),
  ...It(),
  ...je(),
  ...Qe()
}, "VSystemBar"), a7 = J()({
  name: "VSystemBar",
  props: s7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      backgroundColorClasses: r,
      backgroundColorStyles: s
    } = gt(G(e, "color")), {
      elevationClasses: a
    } = In(e), {
      roundedClasses: o
    } = Ht(e), {
      ssrBootStyles: l
    } = Ao(), u = w(() => e.height ?? (e.window ? 32 : 24)), {
      layoutItemStyles: c
    } = bo({
      id: e.name,
      order: w(() => parseInt(e.order, 10)),
      position: pe("top"),
      layoutSize: u,
      elementSize: u,
      active: w(() => !0),
      absolute: G(e, "absolute")
    });
    return ie(() => v(e.tag, {
      class: ["v-system-bar", {
        "v-system-bar--window": e.window
      }, i.value, r.value, a.value, o.value, e.class],
      style: [s.value, c.value, l.value, e.style]
    }, n)), {};
  }
});
const xb = Symbol.for("vuetify:v-tabs"), o7 = B({
  fixed: Boolean,
  sliderColor: String,
  hideSlider: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  ...sn(sm({
    selectedClass: "v-tab--selected",
    variant: "text"
  }), ["active", "block", "flat", "location", "position", "symbol"])
}, "VTab"), HI = J()({
  name: "VTab",
  props: o7(),
  setup(e, t) {
    let {
      slots: n,
      attrs: i
    } = t;
    const {
      textColorClasses: r,
      textColorStyles: s
    } = Ln(e, "sliderColor"), a = X(), o = X(), l = w(() => e.direction === "horizontal"), u = w(() => {
      var d, f;
      return ((f = (d = a.value) == null ? void 0 : d.group) == null ? void 0 : f.isSelected.value) ?? !1;
    });
    function c(d) {
      var h, m;
      let {
        value: f
      } = d;
      if (f) {
        const g = (m = (h = a.value) == null ? void 0 : h.$el.parentElement) == null ? void 0 : m.querySelector(".v-tab--selected .v-tab__slider"), p = o.value;
        if (!g || !p)
          return;
        const y = getComputedStyle(g).color, k = g.getBoundingClientRect(), T = p.getBoundingClientRect(), _ = l.value ? "x" : "y", b = l.value ? "X" : "Y", S = l.value ? "right" : "bottom", C = l.value ? "width" : "height", x = k[_], A = T[_], I = x > A ? k[S] - T[S] : k[_] - T[_], E = Math.sign(I) > 0 ? l.value ? "right" : "bottom" : Math.sign(I) < 0 ? l.value ? "left" : "top" : "center", V = (Math.abs(I) + (Math.sign(I) < 0 ? k[C] : T[C])) / Math.max(k[C], T[C]) || 0, N = k[C] / T[C] || 0, F = 1.5;
        Na(p, {
          backgroundColor: [y, "currentcolor"],
          transform: [`translate${b}(${I}px) scale${b}(${N})`, `translate${b}(${I / F}px) scale${b}(${(V - 1) / F + 1})`, "none"],
          transformOrigin: Array(3).fill(E)
        }, {
          duration: 225,
          easing: Hu
        });
      }
    }
    return ie(() => {
      const d = st.filterProps(e);
      return v(st, se({
        symbol: xb,
        ref: a,
        class: ["v-tab", e.class],
        style: e.style,
        tabindex: u.value ? 0 : -1,
        role: "tab",
        "aria-selected": String(u.value),
        active: !1
      }, d, i, {
        block: e.fixed,
        maxWidth: e.fixed ? 300 : void 0,
        "onGroup:selected": c
      }), {
        ...n,
        default: () => {
          var f;
          return v(De, null, [((f = n.default) == null ? void 0 : f.call(n)) ?? e.text, !e.hideSlider && v("div", {
            ref: o,
            class: ["v-tab__slider", r.value],
            style: s.value
          }, null)]);
        }
      });
    }), Qi({}, a);
  }
});
const l7 = B({
  ...sn(um(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
}, "VTabsWindow"), zI = J()({
  name: "VTabsWindow",
  props: l7(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = tt(xb, null), r = Ee(e, "modelValue"), s = w({
      get() {
        var a;
        return r.value != null || !i ? r.value : (a = i.items.value.find((o) => i.selected.value.includes(o.id))) == null ? void 0 : a.value;
      },
      set(a) {
        r.value = a;
      }
    });
    return ie(() => {
      const a = co.filterProps(e);
      return v(co, se({
        _as: "VTabsWindow"
      }, a, {
        modelValue: s.value,
        "onUpdate:modelValue": (o) => s.value = o,
        class: ["v-tabs-window", e.class],
        style: e.style,
        mandatory: !1,
        touch: !1
      }), n);
    }), {};
  }
}), u7 = B({
  ...cm()
}, "VTabsWindowItem"), UI = J()({
  name: "VTabsWindowItem",
  props: u7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ie(() => {
      const i = fo.filterProps(e);
      return v(fo, se({
        _as: "VTabsWindowItem"
      }, i, {
        class: ["v-tabs-window-item", e.class],
        style: e.style
      }), n);
    }), {};
  }
});
function c7(e) {
  return e ? e.map((t) => Wu(t) ? t : {
    text: t,
    value: t
  }) : [];
}
const d7 = B({
  alignTabs: {
    type: String,
    default: "start"
  },
  color: String,
  fixedTabs: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  stacked: Boolean,
  bgColor: String,
  grow: Boolean,
  height: {
    type: [Number, String],
    default: void 0
  },
  hideSlider: Boolean,
  sliderColor: String,
  ...Qy({
    mandatory: "force",
    selectedClass: "v-tab-item--selected"
  }),
  ...bn(),
  ...je()
}, "VTabs"), f7 = J()({
  name: "VTabs",
  props: d7(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const r = Ee(e, "modelValue"), s = w(() => c7(e.items)), {
      densityClasses: a
    } = Kn(e), {
      backgroundColorClasses: o,
      backgroundColorStyles: l
    } = gt(G(e, "bgColor")), {
      scopeId: u
    } = Vo();
    return jt({
      VTab: {
        color: G(e, "color"),
        direction: G(e, "direction"),
        stacked: G(e, "stacked"),
        fixed: G(e, "fixedTabs"),
        sliderColor: G(e, "sliderColor"),
        hideSlider: G(e, "hideSlider")
      }
    }), ie(() => {
      const c = Sc.filterProps(e), d = !!(i.window || e.items.length > 0);
      return v(De, null, [v(Sc, se(c, {
        modelValue: r.value,
        "onUpdate:modelValue": (f) => r.value = f,
        class: ["v-tabs", `v-tabs--${e.direction}`, `v-tabs--align-tabs-${e.alignTabs}`, {
          "v-tabs--fixed-tabs": e.fixedTabs,
          "v-tabs--grow": e.grow,
          "v-tabs--stacked": e.stacked
        }, a.value, o.value, e.class],
        style: [{
          "--v-tabs-height": _e(e.height)
        }, l.value, e.style],
        role: "tablist",
        symbol: xb
      }, u, n), {
        default: () => {
          var f;
          return [((f = i.default) == null ? void 0 : f.call(i)) ?? s.value.map((h) => {
            var m;
            return ((m = i.tab) == null ? void 0 : m.call(i, {
              item: h
            })) ?? v(HI, se(h, {
              key: h.text,
              value: h.value
            }), {
              default: () => {
                var g;
                return (g = i[`tab.${h.value}`]) == null ? void 0 : g.call(i, {
                  item: h
                });
              }
            });
          })];
        }
      }), d && v(zI, se({
        modelValue: r.value,
        "onUpdate:modelValue": (f) => r.value = f,
        key: "tabs-window"
      }, u), {
        default: () => {
          var f;
          return [s.value.map((h) => {
            var m;
            return ((m = i.item) == null ? void 0 : m.call(i, {
              item: h
            })) ?? v(UI, {
              value: h.value
            }, {
              default: () => {
                var g;
                return (g = i[`item.${h.value}`]) == null ? void 0 : g.call(i, {
                  item: h
                });
              }
            });
          }), (f = i.window) == null ? void 0 : f.call(i)];
        }
      })]);
    }), {};
  }
});
const h7 = B({
  autoGrow: Boolean,
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: Function,
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  noResize: Boolean,
  rows: {
    type: [Number, String],
    default: 5,
    validator: (e) => !isNaN(parseFloat(e))
  },
  maxRows: {
    type: [Number, String],
    validator: (e) => !isNaN(parseFloat(e))
  },
  suffix: String,
  modelModifiers: Object,
  ...Ts(),
  ...Oc()
}, "VTextarea"), m7 = J()({
  name: "VTextarea",
  directives: {
    Intersect: Pc
  },
  inheritAttrs: !1,
  props: h7(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: r
    } = t;
    const s = Ee(e, "modelValue"), {
      isFocused: a,
      focus: o,
      blur: l
    } = Cs(e), u = w(() => typeof e.counterValue == "function" ? e.counterValue(s.value) : (s.value || "").toString().length), c = w(() => {
      if (n.maxlength)
        return n.maxlength;
      if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string"))
        return e.counter;
    });
    function d(E, O) {
      var V, N;
      !e.autofocus || !E || (N = (V = O[0].target) == null ? void 0 : V.focus) == null || N.call(V);
    }
    const f = X(), h = X(), m = pe(""), g = X(), p = w(() => e.persistentPlaceholder || a.value || e.active);
    function y() {
      var E;
      g.value !== document.activeElement && ((E = g.value) == null || E.focus()), a.value || o();
    }
    function k(E) {
      y(), i("click:control", E);
    }
    function T(E) {
      i("mousedown:control", E);
    }
    function _(E) {
      E.stopPropagation(), y(), He(() => {
        s.value = "", rp(e["onClick:clear"], E);
      });
    }
    function b(E) {
      var V;
      const O = E.target;
      if (s.value = O.value, (V = e.modelModifiers) != null && V.trim) {
        const N = [O.selectionStart, O.selectionEnd];
        He(() => {
          O.selectionStart = N[0], O.selectionEnd = N[1];
        });
      }
    }
    const S = X(), C = X(+e.rows), x = w(() => ["plain", "underlined"].includes(e.variant));
    Wt(() => {
      e.autoGrow || (C.value = +e.rows);
    });
    function A() {
      e.autoGrow && He(() => {
        if (!S.value || !h.value)
          return;
        const E = getComputedStyle(S.value), O = getComputedStyle(h.value.$el), V = parseFloat(E.getPropertyValue("--v-field-padding-top")) + parseFloat(E.getPropertyValue("--v-input-padding-top")) + parseFloat(E.getPropertyValue("--v-field-padding-bottom")), N = S.value.scrollHeight, F = parseFloat(E.lineHeight), $ = Math.max(parseFloat(e.rows) * F + V, parseFloat(O.getPropertyValue("--v-input-control-height"))), Z = parseFloat(e.maxRows) * F + V || 1 / 0, j = Xt(N ?? 0, $, Z);
        C.value = Math.floor((j - V) / F), m.value = _e(j);
      });
    }
    jn(A), fe(s, A), fe(() => e.rows, A), fe(() => e.maxRows, A), fe(() => e.density, A);
    let I;
    return fe(S, (E) => {
      E ? (I = new ResizeObserver(A), I.observe(S.value)) : I == null || I.disconnect();
    }), ai(() => {
      I == null || I.disconnect();
    }), ie(() => {
      const E = !!(r.counter || e.counter || e.counterValue), O = !!(E || r.details), [V, N] = la(n), {
        modelValue: F,
        ...$
      } = $n.filterProps(e), Z = yp(e);
      return v($n, se({
        ref: f,
        modelValue: s.value,
        "onUpdate:modelValue": (j) => s.value = j,
        class: ["v-textarea v-text-field", {
          "v-textarea--prefixed": e.prefix,
          "v-textarea--suffixed": e.suffix,
          "v-text-field--prefixed": e.prefix,
          "v-text-field--suffixed": e.suffix,
          "v-textarea--auto-grow": e.autoGrow,
          "v-textarea--no-resize": e.noResize || e.autoGrow,
          "v-input--plain-underlined": x.value
        }, e.class],
        style: e.style
      }, V, $, {
        centerAffix: C.value === 1 && !x.value,
        focused: a.value
      }), {
        ...r,
        default: (j) => {
          let {
            id: H,
            isDisabled: R,
            isDirty: L,
            isReadonly: ne,
            isValid: oe
          } = j;
          return v(Bl, se({
            ref: h,
            style: {
              "--v-textarea-control-height": m.value
            },
            onClick: k,
            onMousedown: T,
            "onClick:clear": _,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"]
          }, Z, {
            id: H.value,
            active: p.value || L.value,
            centerAffix: C.value === 1 && !x.value,
            dirty: L.value || e.dirty,
            disabled: R.value,
            focused: a.value,
            error: oe.value === !1
          }), {
            ...r,
            default: (we) => {
              let {
                props: {
                  class: ee,
                  ...K
                }
              } = we;
              return v(De, null, [e.prefix && v("span", {
                class: "v-text-field__prefix"
              }, [e.prefix]), Rt(v("textarea", se({
                ref: g,
                class: ee,
                value: s.value,
                onInput: b,
                autofocus: e.autofocus,
                readonly: ne.value,
                disabled: R.value,
                placeholder: e.placeholder,
                rows: e.rows,
                name: e.name,
                onFocus: y,
                onBlur: l
              }, K, N), null), [[Ei("intersect"), {
                handler: d
              }, null, {
                once: !0
              }]]), e.autoGrow && Rt(v("textarea", {
                class: [ee, "v-textarea__sizer"],
                id: `${K.id}-sizer`,
                "onUpdate:modelValue": (ue) => s.value = ue,
                ref: S,
                readonly: !0,
                "aria-hidden": "true"
              }, null), [[tO, s.value]]), e.suffix && v("span", {
                class: "v-text-field__suffix"
              }, [e.suffix])]);
            }
          });
        },
        details: O ? (j) => {
          var H;
          return v(De, null, [(H = r.details) == null ? void 0 : H.call(r, j), E && v(De, null, [v("span", null, null), v(hh, {
            active: e.persistentCounter || a.value,
            value: u.value,
            max: c.value,
            disabled: e.disabled
          }, r.counter)])]);
        } : void 0
      });
    }), Qi({}, f, h, g);
  }
});
const v7 = B({
  withBackground: Boolean,
  ...ke(),
  ...Qe(),
  ...je()
}, "VThemeProvider"), g7 = J()({
  name: "VThemeProvider",
  props: v7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e);
    return () => {
      var r;
      return e.withBackground ? v(e.tag, {
        class: ["v-theme-provider", i.value, e.class],
        style: e.style
      }, {
        default: () => {
          var s;
          return [(s = n.default) == null ? void 0 : s.call(n)];
        }
      }) : (r = n.default) == null ? void 0 : r.call(n);
    };
  }
});
const p7 = B({
  dotColor: String,
  fillDot: Boolean,
  hideDot: Boolean,
  icon: We,
  iconColor: String,
  lineColor: String,
  ...ke(),
  ...It(),
  ...Kr(),
  ...mn()
}, "VTimelineDivider"), y7 = J()({
  name: "VTimelineDivider",
  props: p7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      sizeClasses: i,
      sizeStyles: r
    } = Fl(e, "v-timeline-divider__dot"), {
      backgroundColorStyles: s,
      backgroundColorClasses: a
    } = gt(G(e, "dotColor")), {
      roundedClasses: o
    } = Ht(e, "v-timeline-divider__dot"), {
      elevationClasses: l
    } = In(e), {
      backgroundColorClasses: u,
      backgroundColorStyles: c
    } = gt(G(e, "lineColor"));
    return ie(() => v("div", {
      class: ["v-timeline-divider", {
        "v-timeline-divider--fill-dot": e.fillDot
      }, e.class],
      style: e.style
    }, [v("div", {
      class: ["v-timeline-divider__before", u.value],
      style: c.value
    }, null), !e.hideDot && v("div", {
      key: "dot",
      class: ["v-timeline-divider__dot", l.value, o.value, i.value],
      style: r.value
    }, [v("div", {
      class: ["v-timeline-divider__inner-dot", a.value, o.value],
      style: s.value
    }, [n.default ? v(Ze, {
      key: "icon-defaults",
      disabled: !e.icon,
      defaults: {
        VIcon: {
          color: e.iconColor,
          icon: e.icon,
          size: e.size
        }
      }
    }, n.default) : v(at, {
      key: "icon",
      color: e.iconColor,
      icon: e.icon,
      size: e.size
    }, null)])]), v("div", {
      class: ["v-timeline-divider__after", u.value],
      style: c.value
    }, null)])), {};
  }
}), qI = B({
  density: String,
  dotColor: String,
  fillDot: Boolean,
  hideDot: Boolean,
  hideOpposite: {
    type: Boolean,
    default: void 0
  },
  icon: We,
  iconColor: String,
  lineInset: [Number, String],
  ...ke(),
  ...wn(),
  ...mn(),
  ...It(),
  ...Kr(),
  ...je()
}, "VTimelineItem"), b7 = J()({
  name: "VTimelineItem",
  props: qI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      dimensionStyles: i
    } = _n(e), r = pe(0), s = X();
    return fe(s, (a) => {
      var o;
      a && (r.value = ((o = a.$el.querySelector(".v-timeline-divider__dot")) == null ? void 0 : o.getBoundingClientRect().width) ?? 0);
    }, {
      flush: "post"
    }), ie(() => {
      var a, o;
      return v("div", {
        class: ["v-timeline-item", {
          "v-timeline-item--fill-dot": e.fillDot
        }, e.class],
        style: [{
          "--v-timeline-dot-size": _e(r.value),
          "--v-timeline-line-inset": e.lineInset ? `calc(var(--v-timeline-dot-size) / 2 + ${_e(e.lineInset)})` : _e(0)
        }, e.style]
      }, [v("div", {
        class: "v-timeline-item__body",
        style: i.value
      }, [(a = n.default) == null ? void 0 : a.call(n)]), v(y7, {
        ref: s,
        hideDot: e.hideDot,
        icon: e.icon,
        iconColor: e.iconColor,
        size: e.size,
        elevation: e.elevation,
        dotColor: e.dotColor,
        fillDot: e.fillDot,
        rounded: e.rounded
      }, {
        default: n.icon
      }), e.density !== "compact" && v("div", {
        class: "v-timeline-item__opposite"
      }, [!e.hideOpposite && ((o = n.opposite) == null ? void 0 : o.call(n))])]);
    }), {};
  }
}), w7 = B({
  align: {
    type: String,
    default: "center",
    validator: (e) => ["center", "start"].includes(e)
  },
  direction: {
    type: String,
    default: "vertical",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  justify: {
    type: String,
    default: "auto",
    validator: (e) => ["auto", "center"].includes(e)
  },
  side: {
    type: String,
    validator: (e) => e == null || ["start", "end"].includes(e)
  },
  lineThickness: {
    type: [String, Number],
    default: 2
  },
  lineColor: String,
  truncateLine: {
    type: String,
    validator: (e) => ["start", "end", "both"].includes(e)
  },
  ...oh(qI({
    lineInset: 0
  }), ["dotColor", "fillDot", "hideOpposite", "iconColor", "lineInset", "size"]),
  ...ke(),
  ...bn(),
  ...je(),
  ...Qe()
}, "VTimeline"), _7 = J()({
  name: "VTimeline",
  props: w7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = lt(e), {
      densityClasses: r
    } = Kn(e), {
      rtlClasses: s
    } = yn();
    jt({
      VTimelineDivider: {
        lineColor: G(e, "lineColor")
      },
      VTimelineItem: {
        density: G(e, "density"),
        dotColor: G(e, "dotColor"),
        fillDot: G(e, "fillDot"),
        hideOpposite: G(e, "hideOpposite"),
        iconColor: G(e, "iconColor"),
        lineColor: G(e, "lineColor"),
        lineInset: G(e, "lineInset"),
        size: G(e, "size")
      }
    });
    const a = w(() => {
      const l = e.side ? e.side : e.density !== "default" ? "end" : null;
      return l && `v-timeline--side-${l}`;
    }), o = w(() => {
      const l = ["v-timeline--truncate-line-start", "v-timeline--truncate-line-end"];
      switch (e.truncateLine) {
        case "both":
          return l;
        case "start":
          return l[0];
        case "end":
          return l[1];
        default:
          return null;
      }
    });
    return ie(() => v(e.tag, {
      class: ["v-timeline", `v-timeline--${e.direction}`, `v-timeline--align-${e.align}`, `v-timeline--justify-${e.justify}`, o.value, {
        "v-timeline--inset-line": !!e.lineInset
      }, i.value, r.value, a.value, s.value, e.class],
      style: [{
        "--v-timeline-line-thickness": _e(e.lineThickness)
      }, e.style]
    }, n)), {};
  }
}), S7 = B({
  ...ke(),
  ...tr({
    variant: "text"
  })
}, "VToolbarItems"), k7 = J()({
  name: "VToolbarItems",
  props: S7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return jt({
      VBtn: {
        color: G(e, "color"),
        height: "inherit",
        variant: G(e, "variant")
      }
    }), ie(() => {
      var i;
      return v("div", {
        class: ["v-toolbar-items", e.class],
        style: e.style
      }, [(i = n.default) == null ? void 0 : i.call(n)]);
    }), {};
  }
});
const C7 = B({
  id: String,
  text: String,
  ...sn(sd({
    closeOnBack: !1,
    location: "end",
    locationStrategy: "connected",
    eager: !0,
    minWidth: 0,
    offset: 10,
    openOnClick: !1,
    openOnHover: !0,
    origin: "auto",
    scrim: !1,
    scrollStrategy: "reposition",
    transition: !1
  }), ["absolute", "persistent"])
}, "VTooltip"), GI = J()({
  name: "VTooltip",
  props: C7(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Ee(e, "modelValue"), {
      scopeId: r
    } = Vo(), s = An(), a = w(() => e.id || `v-tooltip-${s}`), o = X(), l = w(() => e.location.split(" ").length > 1 ? e.location : e.location + " center"), u = w(() => e.origin === "auto" || e.origin === "overlap" || e.origin.split(" ").length > 1 || e.location.split(" ").length > 1 ? e.origin : e.origin + " center"), c = w(() => e.transition ? e.transition : i.value ? "scale-transition" : "fade-transition"), d = w(() => se({
      "aria-describedby": a.value
    }, e.activatorProps));
    return ie(() => {
      const f = qr.filterProps(e);
      return v(qr, se({
        ref: o,
        class: ["v-tooltip", e.class],
        style: e.style,
        id: a.value
      }, f, {
        modelValue: i.value,
        "onUpdate:modelValue": (h) => i.value = h,
        transition: c.value,
        absolute: !0,
        location: l.value,
        origin: u.value,
        persistent: !0,
        role: "tooltip",
        activatorProps: d.value,
        _disableGlobalStack: !0
      }, r), {
        activator: n.activator,
        default: function() {
          var p;
          for (var h = arguments.length, m = new Array(h), g = 0; g < h; g++)
            m[g] = arguments[g];
          return ((p = n.default) == null ? void 0 : p.call(n, ...m)) ?? e.text;
        }
      });
    }), Qi({}, o);
  }
}), T7 = J()({
  name: "VValidation",
  props: RS(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = FS(e, "validation");
    return () => {
      var r;
      return (r = n.default) == null ? void 0 : r.call(n, i);
    };
  }
}), g9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VAlert: t6,
  VAlertTitle: Yx,
  VApp: Iq,
  VAppBar: Nq,
  VAppBarNavIcon: Xq,
  VAppBarTitle: Jq,
  VAutocomplete: v5,
  VAvatar: Ji,
  VBadge: p5,
  VBanner: w5,
  VBannerActions: AA,
  VBannerText: IA,
  VBottomNavigation: S5,
  VBottomSheet: C5,
  VBreadcrumbs: I5,
  VBreadcrumbsDivider: OA,
  VBreadcrumbsItem: PA,
  VBtn: st,
  VBtnGroup: Ig,
  VBtnToggle: Lq,
  VCard: D5,
  VCardActions: VA,
  VCardItem: MA,
  VCardSubtitle: DA,
  VCardText: RA,
  VCardTitle: NA,
  VCarousel: j5,
  VCarouselItem: z5,
  VCheckbox: a6,
  VCheckboxBtn: Ss,
  VChip: ru,
  VChipGroup: d6,
  VClassIcon: pp,
  VCode: U5,
  VCol: w8,
  VColorPicker: DG,
  VCombobox: RG,
  VComponentIcon: Vv,
  VConfirmEdit: BG,
  VContainer: g8,
  VCounter: hh,
  VDataIterator: YG,
  VDataTable: c8,
  VDataTableFooter: Cc,
  VDataTableHeaders: mo,
  VDataTableRow: _b,
  VDataTableRows: vo,
  VDataTableServer: m8,
  VDataTableVirtual: f8,
  VDatePicker: D8,
  VDatePickerControls: zg,
  VDatePickerHeader: Ug,
  VDatePickerMonth: qg,
  VDatePickerMonths: Gg,
  VDatePickerYears: Yg,
  VDefaultsProvider: Ze,
  VDialog: Rg,
  VDialogBottomTransition: YO,
  VDialogTopTransition: ZO,
  VDialogTransition: dh,
  VDivider: rd,
  VEmptyState: M8,
  VExpandTransition: fh,
  VExpandXTransition: mp,
  VExpansionPanel: R8,
  VExpansionPanelText: Zg,
  VExpansionPanelTitle: Kg,
  VExpansionPanels: L8,
  VFab: W8,
  VFabTransition: GO,
  VFadeTransition: zu,
  VField: Bl,
  VFieldLabel: fu,
  VFileInput: H8,
  VFooter: U8,
  VForm: G8,
  VHover: Z8,
  VIcon: at,
  VImg: _s,
  VInfiniteScroll: X8,
  VInput: $n,
  VItem: eY,
  VItemGroup: Q8,
  VKbd: tY,
  VLabel: Rl,
  VLayout: iY,
  VLayoutItem: sY,
  VLazy: oY,
  VLigatureIcon: dP,
  VList: om,
  VListGroup: Vg,
  VListImg: N6,
  VListItem: ks,
  VListItemAction: R6,
  VListItemMedia: B6,
  VListItemSubtitle: uA,
  VListItemTitle: cA,
  VListSubheader: dA,
  VLocaleProvider: uY,
  VMain: dY,
  VMenu: Dl,
  VMessages: NS,
  VNavigationDrawer: wY,
  VNoSsr: _Y,
  VOtpInput: kY,
  VOverlay: qr,
  VPagination: jg,
  VParallax: xY,
  VProgressCircular: Vl,
  VProgressLinear: gh,
  VRadio: IY,
  VRadioGroup: OY,
  VRangeSlider: VY,
  VRating: NY,
  VResponsive: xg,
  VRow: A8,
  VScaleTransition: fp,
  VScrollXReverseTransition: XO,
  VScrollXTransition: KO,
  VScrollYReverseTransition: QO,
  VScrollYTransition: JO,
  VSelect: ub,
  VSelectionControl: uo,
  VSelectionControlGroup: Kx,
  VSheet: ho,
  VSkeletonLoader: BY,
  VSlideGroup: Sc,
  VSlideGroupItem: LY,
  VSlideXReverseTransition: tP,
  VSlideXTransition: eP,
  VSlideYReverseTransition: nP,
  VSlideYTransition: hp,
  VSlider: Wg,
  VSnackbar: jY,
  VSpacer: kI,
  VSparkline: qY,
  VSpeedDial: YY,
  VStepper: n7,
  VStepperActions: FI,
  VStepperHeader: BI,
  VStepperItem: LI,
  VStepperWindow: $I,
  VStepperWindowItem: WI,
  VSvgIcon: gp,
  VSwitch: r7,
  VSystemBar: a7,
  VTab: HI,
  VTable: go,
  VTabs: f7,
  VTabsWindow: zI,
  VTabsWindowItem: UI,
  VTextField: gi,
  VTextarea: m7,
  VThemeProvider: g7,
  VTimeline: _7,
  VTimelineItem: b7,
  VToolbar: Ag,
  VToolbarItems: k7,
  VToolbarTitle: Ky,
  VTooltip: GI,
  VValidation: T7,
  VVirtualScroll: lm,
  VWindow: co,
  VWindowItem: fo
}, Symbol.toStringTag, { value: "Module" }));
function x7(e, t) {
  const n = t.modifiers || {}, i = t.value, {
    once: r,
    immediate: s,
    ...a
  } = n, o = !Object.keys(a).length, {
    handler: l,
    options: u
  } = typeof i == "object" ? i : {
    handler: i,
    options: {
      attributes: (a == null ? void 0 : a.attr) ?? o,
      characterData: (a == null ? void 0 : a.char) ?? o,
      childList: (a == null ? void 0 : a.child) ?? o,
      subtree: (a == null ? void 0 : a.sub) ?? o
    }
  }, c = new MutationObserver(function() {
    let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], f = arguments.length > 1 ? arguments[1] : void 0;
    l == null || l(d, f), r && YI(e, t);
  });
  s && (l == null || l([], c)), e._mutate = Object(e._mutate), e._mutate[t.instance.$.uid] = {
    observer: c
  }, c.observe(e, u);
}
function YI(e, t) {
  var n;
  (n = e._mutate) != null && n[t.instance.$.uid] && (e._mutate[t.instance.$.uid].observer.disconnect(), delete e._mutate[t.instance.$.uid]);
}
const A7 = {
  mounted: x7,
  unmounted: YI
};
function I7(e, t) {
  var r, s;
  const n = t.value, i = {
    passive: !((r = t.modifiers) != null && r.active)
  };
  window.addEventListener("resize", n, i), e._onResize = Object(e._onResize), e._onResize[t.instance.$.uid] = {
    handler: n,
    options: i
  }, (s = t.modifiers) != null && s.quiet || n();
}
function E7(e, t) {
  var r;
  if (!((r = e._onResize) != null && r[t.instance.$.uid]))
    return;
  const {
    handler: n,
    options: i
  } = e._onResize[t.instance.$.uid];
  window.removeEventListener("resize", n, i), delete e._onResize[t.instance.$.uid];
}
const O7 = {
  mounted: I7,
  unmounted: E7
};
function ZI(e, t) {
  const {
    self: n = !1
  } = t.modifiers ?? {}, i = t.value, r = typeof i == "object" && i.options || {
    passive: !0
  }, s = typeof i == "function" || "handleEvent" in i ? i : i.handler, a = n ? e : t.arg ? document.querySelector(t.arg) : window;
  a && (a.addEventListener("scroll", s, r), e._onScroll = Object(e._onScroll), e._onScroll[t.instance.$.uid] = {
    handler: s,
    options: r,
    // Don't reference self
    target: n ? void 0 : a
  });
}
function KI(e, t) {
  var s;
  if (!((s = e._onScroll) != null && s[t.instance.$.uid]))
    return;
  const {
    handler: n,
    options: i,
    target: r = e
  } = e._onScroll[t.instance.$.uid];
  r.removeEventListener("scroll", n, i), delete e._onScroll[t.instance.$.uid];
}
function P7(e, t) {
  t.value !== t.oldValue && (KI(e, t), ZI(e, t));
}
const V7 = {
  mounted: ZI,
  unmounted: KI,
  updated: P7
};
function D7(e, t) {
  const n = typeof e == "string" ? Nn(e) : e, i = N7(n, t);
  return {
    mounted: i,
    updated: i,
    unmounted(r) {
      tS(null, r);
    }
  };
}
function N7(e, t) {
  return function(n, i, r) {
    var d, f, h;
    const s = typeof t == "function" ? t(i) : t, a = ((d = i.value) == null ? void 0 : d.text) ?? i.value ?? (s == null ? void 0 : s.text), o = Wu(i.value) ? i.value : {}, l = () => a ?? n.innerHTML, u = (r.ctx === i.instance.$ ? (f = M7(r, i.instance.$)) == null ? void 0 : f.provides : (h = r.ctx) == null ? void 0 : h.provides) ?? i.instance.$.provides, c = oa(e, se(s, o), l);
    c.appContext = Object.assign(/* @__PURE__ */ Object.create(null), i.instance.$.appContext, {
      provides: u
    }), tS(c, n);
  };
}
function M7(e, t) {
  const n = /* @__PURE__ */ new Set(), i = (s) => {
    var a, o;
    for (const l of s) {
      if (!l)
        continue;
      if (l === e)
        return !0;
      n.add(l);
      let u;
      if (l.suspense ? u = i([l.ssContent]) : Array.isArray(l.children) ? u = i(l.children) : (a = l.component) != null && a.vnode && (u = i([(o = l.component) == null ? void 0 : o.subTree])), u)
        return u;
      n.delete(l);
    }
    return !1;
  };
  if (!i([t.subTree]))
    throw new Error("Could not find original vnode");
  const r = Array.from(n).reverse();
  for (const s of r)
    if (s.component)
      return s.component;
  return t;
}
const R7 = D7(GI, (e) => {
  var t;
  return {
    activator: "parent",
    location: ((t = e.arg) == null ? void 0 : t.replace("-", " ")) ?? "top",
    text: typeof e.value == "boolean" ? void 0 : e.value
  };
}), p9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ClickOutside: SA,
  Intersect: Pc,
  Mutate: A7,
  Resize: O7,
  Ripple: Os,
  Scroll: V7,
  Tooltip: R7,
  Touch: cb
}, Symbol.toStringTag, { value: "Module" }));
export {
  $7 as V,
  v9 as a,
  g9 as b,
  tl as c,
  p9 as d,
  Wp as g,
  L7 as i
};
